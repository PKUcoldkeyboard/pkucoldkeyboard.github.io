<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>大数据技术 on Cuterwrite&#39;s Blog</title>
        <link>http://localhost:1313/categories/bigdata/</link>
        <description>Recent content in 大数据技术 on Cuterwrite&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>cuterwrite</copyright>
        <lastBuildDate>Sat, 30 Dec 2023 01:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/categories/bigdata/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>在 HPC 上运行 Apache Spark</title>
        <link>http://localhost:1313/p/run-spark-on-hpc/</link>
        <pubDate>Sat, 30 Dec 2023 01:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/p/run-spark-on-hpc/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/crop_afb480a4096d16305dc5696f8072d0c0195413.jpg@1256w_2094h_!web-article-pic-2023-12-30.webp" alt="Featured image of post 在 HPC 上运行 Apache Spark" /&gt;&lt;h1 id=&#34;在-hpc-上运行-apache-spark&#34;&gt;在 HPC 上运行 Apache Spark&lt;/h1&gt;
&lt;h2 id=&#34;一概述&#34;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://spark.apache.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34; &gt;Apache Spark
    &lt;span style=&#34;white-space: nowrap;&#34;&gt;&lt;svg width=&#34;.8em&#34; height=&#34;.8em&#34; viewBox=&#34;0 0 21 21&#34;
            xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;
            &lt;path d=&#34;m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z&#34; fill=&#34;currentColor&#34; /&gt;
            &lt;path d=&#34;M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z&#34;
                fill=&#34;currentColor&#34;&gt;
        &lt;/svg&gt;&lt;/span&gt;
    
&lt;/a&gt;
 是一个多语言引擎，用于在单节点机器或集群上执行数据工程、数据科学和机器学习任务。本文将为您提供在高性能计算（HPC）集群系统上运行多节点 Spark 集群的指南，并展示一个使用 PySpark 的作业示例。&lt;/p&gt;
&lt;h2 id=&#34;二开始&#34;&gt;二、开始&lt;/h2&gt;
&lt;h3 id=&#34;1-下载-openjdk-1102&#34;&gt;1. 下载 OpenJDK-11.0.2&lt;/h3&gt;
&lt;p&gt;从 &lt;a class=&#34;link&#34; href=&#34;https://jdk.java.net/archive/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34; &gt;OpenJDK 官方网站
    &lt;span style=&#34;white-space: nowrap;&#34;&gt;&lt;svg width=&#34;.8em&#34; height=&#34;.8em&#34; viewBox=&#34;0 0 21 21&#34;
            xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;
            &lt;path d=&#34;m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z&#34; fill=&#34;currentColor&#34; /&gt;
            &lt;path d=&#34;M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z&#34;
                fill=&#34;currentColor&#34;&gt;
        &lt;/svg&gt;&lt;/span&gt;
    
&lt;/a&gt;
 下载 OpenJDK-11.0.2。选择 Linux 的对应版本并下载。解压下载的文件并将其放置在 &lt;code&gt;${HOME}/software/openjdk&lt;/code&gt; 中并重命名为 &lt;code&gt;11.0.2&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;2-下载-spark-342&#34;&gt;2. 下载 Spark-3.4.2&lt;/h3&gt;
&lt;p&gt;从 &lt;a class=&#34;link&#34; href=&#34;https://spark.apache.org/downloads.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34; &gt;Apache Spark 下载页面
    &lt;span style=&#34;white-space: nowrap;&#34;&gt;&lt;svg width=&#34;.8em&#34; height=&#34;.8em&#34; viewBox=&#34;0 0 21 21&#34;
            xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;
            &lt;path d=&#34;m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z&#34; fill=&#34;currentColor&#34; /&gt;
            &lt;path d=&#34;M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z&#34;
                fill=&#34;currentColor&#34;&gt;
        &lt;/svg&gt;&lt;/span&gt;
    
&lt;/a&gt;
 下载 Spark 。本文使用的是 Spark-3.4.2，但本指南应该也适用于更新的版本。解压下载的文件并将目录重命名为 3.4.2，放置在 ${HOME}/software/spark 文件夹中。&lt;/p&gt;
&lt;h3 id=&#34;3-配置-modulefile&#34;&gt;3. 配置 modulefile&lt;/h3&gt;
&lt;p&gt;在自定义目录中安装软件后，需要将软件的可执行文件路径等添加到相应的环境变量中才能使用。&lt;code&gt;module&lt;/code&gt; 是一款环境变量管理工具，通过 &lt;code&gt;module&lt;/code&gt; 实现软件环境变量的管理，快速加载和切换软件环境。集群中安装了一些常用的软件和库，可以通过 &lt;code&gt;module&lt;/code&gt; 进行加载使用。&lt;/p&gt;
&lt;p&gt;在这里，我们需要编写 &lt;code&gt;modulefile&lt;/code&gt; 来管理自己的 JDK 和 Spark 软件环境，以便快速加载 Java 和 Spark 环境。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;${HOME}/modulefiles/openjdk&lt;/code&gt; 中创建名为 &lt;code&gt;11.0.2&lt;/code&gt; 的文本文件，内容为：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#%Module1.0
##
## openjdk modulefile
##

proc ModulesHelp { } {
    puts stderr &amp;quot;This module sets up the environment for OpenJdk 11.0.2 \n&amp;quot;
}

module-whatis &amp;quot;For more information, \$ module help openjdk/11.0.2\n&amp;quot;

conflict openjdk

# 注意！这里需要进行修改
set root &amp;lt;PATH/WHERE/OPENJDK/DIRECTORY/IS&amp;gt;

prepend-path PATH ${root}/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;${HOME}/modulefiles/spark&lt;/code&gt; 中创建名为 &lt;code&gt;3.4.2&lt;/code&gt; 的文本文件， 内容为：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#%Module1.0
##
## spark modulefile
##

proc ModulesHelp { } {
    global version

    puts stderr &amp;quot;This module loads Apache Spark environment variables and updates the PATH.&amp;quot;
    puts stderr &amp;quot; &amp;quot;
    puts stderr &amp;quot;Version: $version&amp;quot;
}


module-whatis &amp;quot;Loads Apache Spark environment variables and updates the PATH. \n For more information, \$ module help spark/3.4.2 .\n&amp;quot;

conflict spark

# Set the version and installation path
set version 3.4.2

# 注意！这里需要进行修改
set root &amp;lt;PATH/WHERE/SPARK/DIRECTORY/IS&amp;gt;

# Set the environment variables
setenv SPARK_HOME ${root}
setenv SPARK_CONF_DIR ${root}/conf
setenv PYSPARK_PYTHON python3

# Update the PATH
prepend-path PATH ${root}/bin
prepend-path PATH ${root}/sbin


# Update the CLASSPATH
prepend-path CLASSPATH ${root}/jars/*

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-使用-pip-安装-pyspark-库&#34;&gt;4. 使用 pip 安装 pyspark 库&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;创建虚拟 Conda 环境 pyspark&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;conda create -n pyspark python=3.10
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;安装 pyspark&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;conda activate pyspark
pip install pyspark
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-编写环境加载脚本-set-spark-envsh&#34;&gt;5. 编写环境加载脚本 set-spark-env.sh&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;${HOME}/scripts&lt;/code&gt; 目录下编写 &lt;code&gt;set-spark-env.sh&lt;/code&gt; 脚本文件：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash

source /etc/profile

# 注意！这里需要修改为你的 Conda 的安装路径
export CONDA_PATH=&amp;lt;PATH/WHERE/CONDA/DIRECTORY/IS&amp;gt;
export PATH=$CONDA_PATH/bin:$PATH

export MODULEPATH=${HOME}/modulefiles:$MODULEPATH

source activate
conda activate pyspark

module load openjdk
module load spark

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-编写-sbatch-脚本&#34;&gt;6. 编写 sbatch 脚本&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为了启动 Spark 集群，我们使用以下 Slurm 脚本来请求计算节点。Slurm 脚本请求四个节点，并生成一个 master 节点和三个 worker 节点的 Spark 集群。可以通过更改 Slurm 脚本中的 &lt;code&gt;-N&lt;/code&gt; 选项的值来增加或减少工作节点的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash
#SBATCH --export=ALL
#SBATCH --mem=0
#SBATCH -p C28M250G
#SBATCH -t 1:00:00
#SBATCH -N 4
#SBATCH -J spark_test
#SBATCH -o o.spark_test
#SBATCH -e e.spark_test

source ~/scripts/set-spark-env.sh
workdir=`pwd`
nodes=($(scontrol show hostnames ${SLURM_JOB_NODELIST} | sort | uniq ))
numnodes=${#nodes[@]}
last=$(( $numnodes - 1 ))

export SCRATCH=${workdir}/scratch

master=${nodes[0]}
masterurl=&amp;quot;spark://${master}:7077&amp;quot;

ssh ${nodes[0]} &amp;quot;source ~/scripts/set-spark-env.sh; start-master.sh&amp;quot;
for i in $( seq 1 $last )
do
    ssh ${nodes[$i]} &amp;quot;source ~/scripts/set-spark-env.sh; start-worker.sh ${masterurl}&amp;quot;
done

ssh ${nodes[0]} &amp;quot;cd ${workdir}; source ~/scripts/set-spark-env.sh; /usr/bin/time -v spark-submit --deploy-mode client --executor-cores 28 --executor-memory 240G --conf spark.standalone.submit.waitAppCompletion=true --master $masterurl spark_test.py&amp;quot;
wait
echo &#39;end&#39;
exit

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;该 Slurm 脚本会提交一个用于测试的 python 脚本（ &lt;code&gt;spark_test.py&lt;/code&gt; ），内容如下。此脚本运行 PySpark 代码来测试 Spark 集群。复制下面的内容，并将其保存在 sbatch 脚本所在目录中的 &lt;code&gt;spark_test.py&lt;/code&gt; 文件。你也可以更改 &lt;code&gt;spark_test.py&lt;/code&gt; 文件的路径，但必须适当地更新 Slurm 脚本。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;#spark_test.py
import random
from pyspark.sql import SparkSession
import pyspark.sql.functions as F


spark = SparkSession.builder.appName(&#39;Test-app&#39;).getOrCreate()

#Generate sample dataset
cola_list = [&#39;2022-01-01&#39;, &#39;2022-01-02&#39;, &#39;2022-01-03&#39; ]
colb_list = [&#39;CSC&#39;, &#39;PHY&#39;, &#39;MAT&#39;, &#39;ENG&#39;, &#39;CHE&#39;, &#39;ENV&#39;, &#39;BIO&#39;, &#39;PHRM&#39;]
colc_list = [100, 200, 300, 400, 500, 600, 700, 800, 900]


# declaring a random.seed value to generate same data in every run
random.seed(1)
sample_data = []
for idx in range(1000):
    sample_data.append([random.choice(cola_list), random.choice(colb_list), random.choice(colc_list)])

columns= [&amp;quot;date&amp;quot;, &amp;quot;org&amp;quot;, &amp;quot;value&amp;quot;]
#creating a Spark dataframe
df = spark.createDataFrame(data = sample_data, schema = columns)

res = (df.groupBy(&#39;date&#39;,&#39;org&#39;)
       .agg(F.count(&#39;value&#39;).alias(&#39;count_value&#39;)))
res.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;如果启动了 Spark 集群并且 &lt;code&gt;spark-test.py&lt;/code&gt; 成功执行，那么日志文件 &lt;code&gt;o.spark_test&lt;/code&gt; 中的输出应该如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-log&#34;&gt;starting org.apache.spark.deploy.master.Master, logging to ...
starting org.apache.spark.deploy.worker.Worker, logging to ...
starting org.apache.spark.deploy.worker.Worker, logging to ...
starting org.apache.spark.deploy.worker.Worker, logging to ...
+----------+----+-----------+
|      date| org|count_value|
+----------+----+-----------+
|2022-01-03| BIO|         37|
|2022-01-02| ENV|         53|
|2022-01-03| CHE|         39|
|2022-01-03| PHY|         46|
|2022-01-01| CSC|         45|
|2022-01-03| CSC|         48|
|2022-01-01| BIO|         39|
|2022-01-01| MAT|         42|
|2022-01-02| CHE|         44|
|2022-01-03| ENV|         33|
|2022-01-01| ENG|         33|
|2022-01-02| ENG|         28|
|2022-01-01| ENV|         33|
|2022-01-02| CSC|         45|
|2022-01-02| MAT|         51|
|2022-01-01| PHY|         38|
|2022-01-01|PHRM|         40|
|2022-01-03|PHRM|         42|
|2022-01-02|PHRM|         43|
|2022-01-03| ENG|         56|
+----------+----+-----------+
only showing top 20 rows

end
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Spark 还提供了一个 web UI 来监控集群，您可以通过将 master 节点端口转发到本地机器来在本地机器上访问它。
&lt;ul&gt;
&lt;li&gt;例如，如果 master 节点在 &lt;code&gt;cpu1&lt;/code&gt; 上运行，则可以在本地计算机终端上运行以下代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;  ssh -t -t  &amp;lt;USERNAME&amp;gt;@&amp;lt;LOGIN_NODE_IP&amp;gt; -L 8080:localhost:8080 \
  -i &amp;lt;PRIVATE_KEY_LOCATION&amp;gt; ssh cpu1  -L 8080:127.0.0.1:8080
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;然后就可以在本地机器上的 Web 浏览器上使用地址 &lt;a class=&#34;link&#34; href=&#34;http://localhost:8080/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34; &gt;http://localhost:8080/
    &lt;span style=&#34;white-space: nowrap;&#34;&gt;&lt;svg width=&#34;.8em&#34; height=&#34;.8em&#34; viewBox=&#34;0 0 21 21&#34;
            xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;
            &lt;path d=&#34;m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z&#34; fill=&#34;currentColor&#34; /&gt;
            &lt;path d=&#34;M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z&#34;
                fill=&#34;currentColor&#34;&gt;
        &lt;/svg&gt;&lt;/span&gt;
    
&lt;/a&gt;
 访问 Spark Web UI。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三总结&#34;&gt;三、总结&lt;/h2&gt;
&lt;p&gt;在本文中，我们介绍了如何在 HPC 集群上部署和运行 Apache Spark 集群。通过遵循本指南中的步骤，你应该能够成功地在 HPC 环境中运行 Spark 作业。请注意，根据你的具体 HPC 环境和配置，可能需要进行一些调整。&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg t=&#34;1705946198814&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 1024 1024&#34; version=&#34;1.1&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34; p-id=&#34;23141&#34; width=&#34;200&#34; height=&#34;200&#34;&gt;&lt;path d=&#34;M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864a149.333333 149.333333 0 0 1-149.333334 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z m426.666667 0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864a149.333333 149.333333 0 0 1-149.333333 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z&#34; p-id=&#34;23142&#34; fill=&#34;#ffffff&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://spark.apache.org/docs/latest/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34; &gt;Spark 官方文档
    &lt;span style=&#34;white-space: nowrap;&#34;&gt;&lt;svg width=&#34;.8em&#34; height=&#34;.8em&#34; viewBox=&#34;0 0 21 21&#34;
            xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;
            &lt;path d=&#34;m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z&#34; fill=&#34;currentColor&#34; /&gt;
            &lt;path d=&#34;M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z&#34;
                fill=&#34;currentColor&#34;&gt;
        &lt;/svg&gt;&lt;/span&gt;
    
&lt;/a&gt;
 是一个非常有用的工具，通过它可以帮助你找到 Spark 的具体说明并解决问题。所以实际遇到问题时要多使用它。&lt;/p&gt;&lt;/div&gt;

</description>
        </item>
        <item>
        <title>SVD 与 NMF：矩阵分解的两种方法</title>
        <link>http://localhost:1313/p/matrix-factorization/</link>
        <pubDate>Tue, 11 Jul 2023 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/p/matrix-factorization/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/65cf6588fa725014c7cd617ccbeb997f27742e49.jpg@1256w_1880h_!web-article-pic.webp" alt="Featured image of post SVD 与 NMF：矩阵分解的两种方法" /&gt;&lt;h1 id=&#34;svd-与-nmf矩阵分解的两种方法&#34;&gt;SVD 与 NMF：矩阵分解的两种方法&lt;/h1&gt;
&lt;p&gt;在数据科学中，矩阵分解技术是一种强大的工具，可以用于各种应用，如推荐系统、图像处理和自然语言处理。在这篇文章中，我们将深入探讨两种流行的矩阵分解技术：奇异值分解（SVD）和非负矩阵分解（NMF）。我们将详细解析它们的理论基础，以及如何在实际问题中应用它们。&lt;/p&gt;
&lt;h2 id=&#34;一奇异值分解svd&#34;&gt;一、奇异值分解（SVD）&lt;/h2&gt;
&lt;p&gt;奇异值分解是一种在线性代数中常用的矩阵分解方法。对于给定的 $m\times n$ 矩阵 A，我们可以将其分解为三个矩阵的乘积：&lt;/p&gt;
&lt;p&gt;$$
A = U\Sigma V^T
$$&lt;/p&gt;
&lt;p&gt;这里，$U$ 是一个 $m\times m$ 的正交矩阵，$V$ 是一个 $n\times n$ 的正交矩阵，$\Sigma$ 是一个 $m\times n$ 的对角矩阵。对角线上的元素称为奇异值，它们是 $A^T A$ 的特征值的平方根。它们是按降序排列的，代表了原始矩阵中的“能量”或信息量。。我们可以将奇异值分解看作是一种特征值分解，其中 $U$ 和 $V$ 是特征向量，$\Sigma$ 是特征值的对角矩阵。&lt;/p&gt;
&lt;p&gt;计算 SVD 的基本步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;构造矩阵 A 的 Gram 矩阵&lt;!-- raw HTML omitted --&gt;：对于给定的 $m\times n$ 矩阵 A，我们可以构造一个 $n\times n$ 的矩阵 $A^T A$，称为 A 的 Gram 矩阵。Gram 矩阵是一个对称半正定矩阵，因此它的特征值都是非负的。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;计算 Gram 矩阵的特征值和特征向量&lt;!-- raw HTML omitted --&gt;：我们可以使用任何标准的特征值分解算法来计算 Gram 矩阵的特征值和特征向量。这些特征值就是 A 的奇异值的平方，特征向量则构成了右奇异向量和左奇异向量。我们将特征值按降序排列，将特征向量按相同的顺序排列。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;构造奇异值矩阵 $\Sigma$ &lt;!-- raw HTML omitted --&gt;：我将特征值的平方根按照从大到小的顺序排列在对角线上，构成 $m\times n $ 的对角矩阵 $\Sigma$ 。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;构造左奇异向量矩阵 $U$ 和右奇异向量矩阵 $V$ &lt;!-- raw HTML omitted --&gt;：将对应于特征值的特征向量按照特征值的顺序排列，构成 $n\times n$ 的矩阵 $V$ 和 $m\times m$ 的矩阵 $U$ 。这些特征向量是标准化的，即它们的长度为 1，并且互相正交。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样，我们就得到了 A 的奇异值分解。在 Python 中，我们可以使用 NumPy 的&lt;code&gt;np.linalg.svd&lt;/code&gt; 函数来计算 SVD，这个函数会自动执行上述步骤，并返回 $ U, \Sigma, V^T $ 。如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np
U, S, Vt = np.linalg.svd(A)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是，虽然理论上 SVD 总是存在的，但在实际计算中可能会遇到数值稳定性的问题。此外，对于非常大的矩阵，计算 SVD 可能会非常耗时。在这些情况下，我们可能需要使用一些更高效的算法或者近似方法，如随机 SVD。&lt;/p&gt;
&lt;p&gt;SVD 的一个重要应用是在推荐系统中进行矩阵补全。在推荐系统中，我们通常有一个用户-商品评分矩阵，但这个矩阵通常是非常稀疏的，因为大多数用户只评价了少数商品。SVD 可以用于预测用户对未评价商品的评分，从而提供个性化的推荐。&lt;/p&gt;
&lt;h2 id=&#34;二非负矩阵分解nmf&#34;&gt;二、非负矩阵分解（NMF）&lt;/h2&gt;
&lt;p&gt;由于维度的复杂性和维度诅咒，直接处理高维数据需要大量的计算资源。非负矩阵分解（NMF）作为一种降维技术被提出，在图像处理中得到了重要的应用。通过采用 NMF，非负的高维矩阵可以被分解成两个非负的低维矩阵，其中一个包括列向量，可以被视为数据空间中的基向量，另一个则包含缩放这些基向量的系数行。此外，NMF 也可用于文本数据处理。我们可以检查系数矩阵中的每一列，并确定具有最大系数的行号，其中行号表示原始矩阵中各列的聚类 ID。这种聚类特性意味着 NMF 可以用于数据聚类。&lt;/p&gt;
&lt;p&gt;NMF 对矩阵的元素有一个额外的非负约束。对于给定的 $K\times N$ 非负矩阵 $M\in R^{K\times N}$ ，我们可以找到两个非负矩阵 $W$ 和 $H$ ，使得 $M\approx WH$ 。其中 $W\in R^{K\times r}$ 和 $H\in R^{r\times N}$ 是两个非负矩阵，即 $W\geq 0$ 和 $H\geq 0$ 。矩阵 $W$ 代表捕捉数据特征的基向量，而矩阵 $H$ 是表示每个基向量对重建原始数据的贡献的权重。NMF 中的非负约束允许学习整体数据的部分表征，而这种约束在 SVD 中是不允许的。为了找到 $M\approx WH$的近似解，定义基于欧氏距离的成本函数来量化近似的质量，即:&lt;/p&gt;
&lt;p&gt;$$
Q=\Vert M-WH\Vert^2_F=\sum_{i,j}(M_{ij}-(WH)_{ij})^2
$$&lt;/p&gt;
&lt;p&gt;由于成本函数 $Q$ 在 $W$ 和 $H$ 中都是非凸的，所以在求解 $Q$ 的最小值过程中找到全局最小值是不现实的。一些数值优化技术，如梯度下降和共轭梯度，可以被用来寻找局部最小值。然而，梯度下降的收敛速度很慢，共轭梯度的实现很复杂。此外，基于梯度的方法对步长的参数设置很敏感，这对现实应用来说并不方便。为此，可以利用 $W$ 和 $H$ 的 multiplicative update rules，作为收敛速度和实现复杂性之间的折中方案，具体如下:&lt;/p&gt;
&lt;p&gt;$$
H_{aj} \leftarrow H_{aj} \frac{W^T M_{aj}}{W^T W H_{aj}}, W_{ia} \leftarrow W_{ia} \frac{M H^T_{ia}}{W H H^T_{ia}}
$$&lt;/p&gt;
&lt;p&gt;其中，矩阵 $W$ 和 $H$ 可以被随机初始化，然后通过迭代更新来优化 $Q$ 。这些更新规则可以保证 $Q$ 在每次迭代中都会减少，因此可以保证收敛到局部最小值。&lt;/p&gt;
&lt;p&gt;在 Python 中，我们可以使用&lt;code&gt;sklearn.decomposition.NMF&lt;/code&gt; 类来计算 NMF。如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sklearn.decomposition import NMF
model = NMF(n_components=2, init=&#39;random&#39;, random_state=0)
W = model.fit_transform(X)
H = model.components_
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;三svd-与-nmf-的比较&#34;&gt;三、SVD 与 NMF 的比较&lt;/h2&gt;
&lt;p&gt;虽然 SVD 和 NMF 都是矩阵分解技术，但它们有一些重要的区别。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;数据类型和约束&lt;!-- raw HTML omitted --&gt;：SVD 可以应用于任何矩阵，而 NMF 只能应用于非负矩阵。其次，SVD 提供了一种最优的低秩近似，而 NMF 则没有这种保证。然而，NMF 的非负约束使得它的分解更具解释性，这在许多应用中是非常有用的。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;分解的解释性&lt;!-- raw HTML omitted --&gt;：虽然 SVD 和 NMF 都可以将原始矩阵分解为一些基本的“构成元素”，但 NMF 的分解通常更具解释性。这是因为 NMF 的非负约束使得分解的结果更容易解释和理解。在许多应用中，如主题模型或社区发现，NMF 的分解可以直接解释为数据的一些基本模式或特征。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;优化和稳定性&lt;!-- raw HTML omitted --&gt;：SVD 的优化问题有闭式解，这意味着我们可以直接计算出最优解。而 NMF 的优化问题通常需要使用迭代方法来求解，如梯度下降或坐标下降。这使得 NMF 的计算过程可能更复杂，而且可能需要更多的时间。而且 SVD 的结果是唯一的（除了奇异向量的符号），而 NMF 的结果可能依赖于初始化和优化算法。这意味着对同一个数据集，NMF 可能会给出不同的结果。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;近似质量&lt;!-- raw HTML omitted --&gt;：SVD 提供了一种最优的低秩近似，即它可以找到最接近原始矩阵的低秩矩阵。而 NMF 则没有这种保证，它的近似质量可能会比 SVD 差。然而，NMF 的非负约束使得它的近似可能更符合实际的需求，尤其是在那些原始数据是非负的情况下。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;计算复杂性&lt;!-- raw HTML omitted --&gt;：SVD 和 NMF 的计算复杂性也有所不同。对于一个 $m\times n$ 的矩阵，SVD 的计算复杂性大约为 $\mathbf{O}(\min {m^2n, mn^2})$ ，而 NMF 的计算复杂性则取决于迭代次数和所选的优化算法。在实践中，NMF 通常比 SVD 更慢，但也有一些高效的 NMF 算法可以缩短计算时间。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总的来说，SVD 和 NMF 各有优势，选择使用哪一种技术取决于具体的应用和需求。&lt;/p&gt;
&lt;h2 id=&#34;四实战图像压缩&#34;&gt;四、实战：图像压缩&lt;/h2&gt;
&lt;p&gt;让我们通过一个实战演示来看看如何使用 SVD 和 NMF 进行图像压缩。我们将使用 Python 的 NumPy 和 scikit-learn 库来执行这些任务。&lt;/p&gt;
&lt;p&gt;首先，我们需要导入必要的库，并加载一张图像：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np
from sklearn.decomposition import NMF
from PIL import Image

# 加载图像
img = Image.open(&#39;image.jpg&#39;)
width, height = img.size
img = np.array(img)
r, g, b = img[:, :, 0], img[:, :, 1], img[:, :, 2]
img_matrix = []
img_matrix.extend([r.flatten(), g.flatten(), b.flatten()])

M = np.array(img_matrix).T
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，我们可以使用 NumPy 的&lt;code&gt;np.linalg.svd&lt;/code&gt; 函数来进行 SVD，得到 $U, S, V^T$ ：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 执行 SVD
U, s, Vt = np.linalg.svd(M, full_matrices=False)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以选择前 $r$ 个奇异值和对应的 $U$ 和 $V^T$ 的列来进行低秩近似：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;d = 16
U_d = U[:, :d]
s_d = s[:d]
Vt_d = Vt[:d, :]
M_d = U_d @ np.diag(s_d) @ Vt_d

r, g, b = M_d[:, 0], M_d[:, 1], M_d[:, 2]
img = np.dstack((r, g, b)).reshape(height, width, 3)
img[img &amp;lt; 0] = 0
img[img &amp;gt; 255] = 255
img = Image.fromarray(np.uint8(img), mode=&#39;RGB&#39;)
img.show()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样，我们也可以使用 scikit-learn 的 NMF 类来进行 NMF：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 执行 NMF
model = NMF(n_components=16, init=&#39;random&#39;, random_state=0)
W = model.fit_transform(M)
H = model.components_

M_d = W @ H
r, g, b = M_d[:, 0], M_d[:, 1], M_d[:, 2]
img = np.dstack((r, g, b)).reshape(height, width, 3)
img[img &amp;lt; 0] = 0
img[img &amp;gt; 255] = 255
img = Image.fromarray(np.uint8(img), mode=&#39;RGB&#39;)
img.show()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，我们可以比较原始图像和重构图像的差异，以及 SVD 和 NMF 的压缩效果。这种压缩方法的优点是可以大大减少存储和传输图像所需的数据量，而且如果选择的秩 r 足够大，压缩后的图像的质量也可以接受。&lt;/p&gt;
&lt;h2 id=&#34;五结论&#34;&gt;五、结论&lt;/h2&gt;
&lt;p&gt;总的来说，SVD 和 NMF 都是强大的矩阵分解技术，它们在许多数据科学应用中都有广泛的用途。虽然 SVD 提供了一种最优的低秩近似，但 NMF 的非负约束使得它的分解更具解释性。在选择使用哪一种技术时，我们需要考虑我们的具体需求，以及我们的数据是否满足这些技术的要求。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1] Lee, Daniel, and H. Sebastian Seung. &amp;ldquo;Unsupervised learning by convex and conic coding. &amp;quot; Advances in neural information processing systems 9 (1996).&lt;/p&gt;
&lt;p&gt;[2] Lee, Daniel D., and H. Sebastian Seung. &amp;ldquo;Learning the parts of objects by non-negative matrix factorization.&amp;rdquo; Nature 401.6755 (1999): 788-791.&lt;/p&gt;
&lt;p&gt;[3] Lee, Daniel, and H. Sebastian Seung. &amp;ldquo;Algorithms for non-negative matrix factorization. &amp;quot; Advances in neural information processing systems 13 (2000).&lt;/p&gt;
</description>
        </item>
        <item>
        <title>基于 Flink Native Kubernetes 的词频统计实验</title>
        <link>http://localhost:1313/p/flink-native-k8s/</link>
        <pubDate>Fri, 23 Dec 2022 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/p/flink-native-k8s/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/YSFD_P2_50.webp" alt="Featured image of post 基于 Flink Native Kubernetes 的词频统计实验" /&gt;&lt;h1 id=&#34;基于-flink-native-kubernetes-的词频统计实验&#34;&gt;基于 Flink Native Kubernetes 的词频统计实验&lt;/h1&gt;
&lt;h2 id=&#34;1-简介&#34;&gt;1 简介&lt;/h2&gt;
&lt;h3 id=&#34;11-实验环境&#34;&gt;1.1 实验环境&lt;/h3&gt;
&lt;p&gt;本实验主要使用 Ubuntu 20.04 64 位作为系统环境，采用 3 台 4 核 8GB 云服务器作为 Kubernetes 集群部署机器，1 台 4 核 8GB 云服务器作为集群管理工具 Kuboard Spary 部署机器，并作为 NFS Server 部署机器。使用的软件如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;kuboard spary&lt;/td&gt;
&lt;td&gt;v1.2.3-amd64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kubernetes&lt;/td&gt;
&lt;td&gt;v1.25.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;calico&lt;/td&gt;
&lt;td&gt;v3.23.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;etcd&lt;/td&gt;
&lt;td&gt;v3.5.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;crictl&lt;/td&gt;
&lt;td&gt;v1.25.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;crun&lt;/td&gt;
&lt;td&gt;1.4.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;krew&lt;/td&gt;
&lt;td&gt;v0.4.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;runc&lt;/td&gt;
&lt;td&gt;v1.1.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cni&lt;/td&gt;
&lt;td&gt;v1.1.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nerdctl&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;coredns&lt;/td&gt;
&lt;td&gt;v1.8.6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dnsautoscaler&lt;/td&gt;
&lt;td&gt;1.8.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pod_infra&lt;/td&gt;
&lt;td&gt;3.7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;flink&lt;/td&gt;
&lt;td&gt;1.16.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hadoop&lt;/td&gt;
&lt;td&gt;3.2.3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;12-集群规划&#34;&gt;1.2 集群规划&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Kuborad Spary&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;kuborad&lt;/td&gt;
&lt;td&gt;192.168.0.15&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;NFS Server&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NFS-server&lt;/td&gt;
&lt;td&gt;192.168.0.15&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes 集群规划&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;th&gt;控制节点&lt;/th&gt;
&lt;th&gt;etcd 节点&lt;/th&gt;
&lt;th&gt;工作节点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;node1&lt;/td&gt;
&lt;td&gt;192.168.0.6&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;node2&lt;/td&gt;
&lt;td&gt;192.168.0.7&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;node3&lt;/td&gt;
&lt;td&gt;192.168.0.14&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2-kubernetes-集群部署&#34;&gt;2 Kubernetes 集群部署&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这部分内容已经在&lt;a class=&#34;link&#34; href=&#34;https://cuterwrite.top/p/spark-on-k8s/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34; &gt;Spark on K8s
    &lt;span style=&#34;white-space: nowrap;&#34;&gt;&lt;svg width=&#34;.8em&#34; height=&#34;.8em&#34; viewBox=&#34;0 0 21 21&#34;
            xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;
            &lt;path d=&#34;m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z&#34; fill=&#34;currentColor&#34; /&gt;
            &lt;path d=&#34;M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z&#34;
                fill=&#34;currentColor&#34;&gt;
        &lt;/svg&gt;&lt;/span&gt;
    
&lt;/a&gt;
实验中给出详细步骤，这里不再重复。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-flink-native-kubernetes-部署&#34;&gt;3 Flink Native Kubernetes 部署&lt;/h2&gt;
&lt;h3 id=&#34;31-配置-flink-用户权限&#34;&gt;3.1 配置 flink 用户权限&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;创建用户&lt;code&gt;flink&lt;/code&gt; 并配置权限&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl create serviceaccount flink -n bigdata

kubectl create clusterrolebinding flink-role-binding-flink \
  --clusterrole=edit \
  --serviceaccount=bigdata:flink
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;32-创建-session-cluster&#34;&gt;3.2 创建 session cluster&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在安装了 Flink 的节点上进入 flink 根目录，执行以下命令并指定资源：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./bin/kubernetes-session.sh \
    -Dkubernetes.namespace=bigdata \
    -Dkubernetes.jobmanager.service-account=flink \
    -Dkubernetes.rest-service.exposed.type=NodePort \
    -Dkubernetes.cluster-id=flink-session-cluster \
    -Dtaskmanager.memory.process.size=2048m \
    -Dkubernetes.taskmanager.cpu=1 \
    -Dkubernetes.jobmanager.replicas=1 \
    -Dtaskmanager.numberOfTaskSlots=3 \
    -Dresourcemanager.taskmanager-timeout=3600000
&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221223121223.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
  &lt;/figure&gt;

&lt;p&gt;可以看到，控制台提示创建成功，并且提示了 Flink Web UI 的访问地址为：&lt;a class=&#34;link&#34; href=&#34;http://192.168.0.6:32077%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0Web&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34; &gt;http://192.168.0.6:32077，可以看到 Web
    &lt;span style=&#34;white-space: nowrap;&#34;&gt;&lt;svg width=&#34;.8em&#34; height=&#34;.8em&#34; viewBox=&#34;0 0 21 21&#34;
            xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;
            &lt;path d=&#34;m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z&#34; fill=&#34;currentColor&#34; /&gt;
            &lt;path d=&#34;M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z&#34;
                fill=&#34;currentColor&#34;&gt;
        &lt;/svg&gt;&lt;/span&gt;
    
&lt;/a&gt;
 UI 界面如下：&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/web%20ui.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
  &lt;/figure&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;继续在 flink 根目录下执行以下命令，将官方自带的 WindowJoin 任务提交到 session cluster 测试部署是否成功：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./bin/flink run -d \
  --target kubernetes-session \
  -Dkubernetes.namespace=bigdata \
  -Dkubernetes.cluster-id=flink-session-cluster \
  -Dkubernetes.service-account=flink \
  -Dkubernetes.namespace=bigdata \
  -Dkubernetes.taskmanager.cpu=1 \

  examples/streaming/WindowJoin.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/bash.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
  &lt;/figure&gt;

&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/flink-run.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
  &lt;/figure&gt;

&lt;p&gt;可以看到&lt;code&gt;WindowJoin.jar&lt;/code&gt; 已经被提交到 session cluster，占用 1 个 Slot，总共 Slot 数为 4&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-编写-wordcount-程序&#34;&gt;4 编写 WordCount 程序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;配置 POM 文件：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.cuterwrite&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;FlinkApp&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;flink.version&amp;gt;1.16.0&amp;lt;/flink.version&amp;gt;
        &amp;lt;maven.compiler.source&amp;gt;11&amp;lt;/maven.compiler.source&amp;gt;
        &amp;lt;maven.compiler.target&amp;gt;11&amp;lt;/maven.compiler.target&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;!-- Flink dependencies --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.flink&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;flink-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${flink.version}&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.flink&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;flink-streaming-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${flink.version}&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-shade-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.1.1&amp;lt;/version&amp;gt;
                &amp;lt;executions&amp;gt;
                    &amp;lt;execution&amp;gt;
                        &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
                        &amp;lt;goals&amp;gt;
                            &amp;lt;goal&amp;gt;shade&amp;lt;/goal&amp;gt;
                        &amp;lt;/goals&amp;gt;
                        &amp;lt;configuration&amp;gt;
                            &amp;lt;artifactSet&amp;gt;
                                &amp;lt;excludes&amp;gt;
                                    &amp;lt;exclude&amp;gt;com.google.code.findbugs:jsr305&amp;lt;/exclude&amp;gt;
                                &amp;lt;/excludes&amp;gt;
                            &amp;lt;/artifactSet&amp;gt;
                            &amp;lt;filters&amp;gt;
                                &amp;lt;filter&amp;gt;
                                    &amp;lt;!-- Do not copy the signatures in the META-INF folder.
                                    Otherwise, this might cause SecurityExceptions when using the JAR. --&amp;gt;
                                    &amp;lt;artifact&amp;gt;*:*&amp;lt;/artifact&amp;gt;
                                    &amp;lt;excludes&amp;gt;
                                        &amp;lt;exclude&amp;gt;META-INF/*.SF&amp;lt;/exclude&amp;gt;
                                        &amp;lt;exclude&amp;gt;META-INF/*.DSA&amp;lt;/exclude&amp;gt;
                                        &amp;lt;exclude&amp;gt;META-INF/*.RSA&amp;lt;/exclude&amp;gt;
                                    &amp;lt;/excludes&amp;gt;
                                &amp;lt;/filter&amp;gt;
                            &amp;lt;/filters&amp;gt;
                            &amp;lt;transformers&amp;gt;
                                &amp;lt;transformer implementation=&amp;quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&amp;quot;&amp;gt;
                                    &amp;lt;!-- Replace this with the main class of your job --&amp;gt;
                                    &amp;lt;mainClass&amp;gt;com.cuterwrite.WordCount&amp;lt;/mainClass&amp;gt;
                                &amp;lt;/transformer&amp;gt;
                                &amp;lt;transformer implementation=&amp;quot;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer&amp;quot;/&amp;gt;
                            &amp;lt;/transformers&amp;gt;
                        &amp;lt;/configuration&amp;gt;
                    &amp;lt;/execution&amp;gt;
                &amp;lt;/executions&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;编写&lt;code&gt;WordCount.java&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cuterwrite;

import org.apache.flink.api.common.functions.FlatMapFunction;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.sink.SinkFunction;
import org.apache.flink.streaming.api.windowing.assigners.TumblingProcessingTimeWindows;
import org.apache.flink.streaming.api.windowing.time.Time;
import org.apache.flink.util.Collector;
import org.slf4j.LoggerFactory;
import org.slf4j.Logger;

public class WordCount {
    private static final Logger log = LoggerFactory.getLogger(WordCount.class);
    public WordCount() {}

    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(3);
        // 监听 9999 端口的 socket 输入
        DataStreamSource&amp;lt;String&amp;gt; text = env.socketTextStream(&amp;quot;192.168.0.6&amp;quot;, 9999);

        text.flatMap(new FlatMapFunction&amp;lt;String, Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt;() {
            @Override
            public void flatMap(String value, Collector&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; collector) throws Exception {
                String[] tokens = value.toLowerCase().split(&amp;quot; &amp;quot;);
                for (String token : tokens) {
                    collector.collect(new Tuple2&amp;lt;&amp;gt;(token, 1));
                }
            }
            // 合并相同单词的频数
        })
        .keyBy(item -&amp;gt; item.f0)
        .window(TumblingProcessingTimeWindows.of(Time.seconds(5)))
        .sum(1)
        .addSink(new SinkFunction&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt;() {
            @Override
            public void invoke(Tuple2&amp;lt;String, Integer&amp;gt; value, Context context) throws Exception {
                log.info(&amp;quot;单词：&amp;quot; + value.f0 + &amp;quot;,频率：&amp;quot; + value.f1);
            }
        });

        env.execute(&amp;quot;Word Count&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-实验结果&#34;&gt;5 实验结果&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;提交 WordCount 程序 jar 包&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./bin/flink run -d \
  --target kubernetes-session \
  -Dkubernetes.namespace=bigdata \
  -Dkubernetes.cluster-id=flink-session-cluster \
  -Dkubernetes.service-account=flink \
  -Dkubernetes.namespace=bigdata \
  /root/FlinkApp-1.0-SNAPSHOT.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 Flink Web UI：&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-12-23%20143910.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
  &lt;/figure&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 socket 传输字符进行测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;nc 192.168.0.6 9999
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实验结果：&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/log.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
  &lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>基于 Spark on k8s 的词频统计实验</title>
        <link>http://localhost:1313/p/spark-on-k8s/</link>
        <pubDate>Fri, 23 Dec 2022 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/p/spark-on-k8s/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/92.webp" alt="Featured image of post 基于 Spark on k8s 的词频统计实验" /&gt;&lt;h1 id=&#34;基于-spark-on-k8s-的词频统计实验&#34;&gt;基于 Spark on k8s 的词频统计实验&lt;/h1&gt;
&lt;h2 id=&#34;1-简介&#34;&gt;1 简介&lt;/h2&gt;
&lt;h3 id=&#34;11-实验环境&#34;&gt;1.1 实验环境&lt;/h3&gt;
&lt;p&gt;本实验主要使用 Ubuntu 20.04 64 位作为系统环境，采用 6 台 4 核 8GB 云服务器作为 Kubernetes 集群部署机器，1 台 2 核 4GB 云服务器作为集群管理工具 Kuboard Spary 部署机器，1 台 2 核 4GB 云服务器作为 NFS Server（使用 Centos 7.6 系统）部署机器。&lt;/p&gt;
&lt;p&gt;使用的软件如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;kuboard spary&lt;/td&gt;
&lt;td&gt;v1.2.3-amd64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kubernetes&lt;/td&gt;
&lt;td&gt;v1.25.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;calico&lt;/td&gt;
&lt;td&gt;v3.23.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;etcd&lt;/td&gt;
&lt;td&gt;v3.5.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;crictl&lt;/td&gt;
&lt;td&gt;v1.25.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;crun&lt;/td&gt;
&lt;td&gt;1.4.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;krew&lt;/td&gt;
&lt;td&gt;v0.4.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;runc&lt;/td&gt;
&lt;td&gt;v1.1.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cni&lt;/td&gt;
&lt;td&gt;v1.1.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nerdctl&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;coredns&lt;/td&gt;
&lt;td&gt;v1.8.6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dnsautoscaler&lt;/td&gt;
&lt;td&gt;1.8.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pod_infra&lt;/td&gt;
&lt;td&gt;3.7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;spark&lt;/td&gt;
&lt;td&gt;3.3.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hadoop&lt;/td&gt;
&lt;td&gt;3.2.3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;12-集群规划&#34;&gt;1.2 集群规划&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Kuborad Spary&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;kuborad&lt;/td&gt;
&lt;td&gt;192.168.0.115&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;NFS Server&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NFS-server&lt;/td&gt;
&lt;td&gt;192.168.0.132&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes 集群规划&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;th&gt;控制节点&lt;/th&gt;
&lt;th&gt;etcd 节点&lt;/th&gt;
&lt;th&gt;工作节点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;node1&lt;/td&gt;
&lt;td&gt;192.168.0.76&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;node2&lt;/td&gt;
&lt;td&gt;192.168.0.213&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;node3&lt;/td&gt;
&lt;td&gt;192.168.0.2&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;node4&lt;/td&gt;
&lt;td&gt;192.168.0.41&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;node5&lt;/td&gt;
&lt;td&gt;192.168.0.73&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;node6&lt;/td&gt;
&lt;td&gt;192.168.0.12&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2-部署-kubernetes-集群&#34;&gt;2 部署 Kubernetes 集群&lt;/h2&gt;
&lt;h3 id=&#34;21-安装-kuboard-spray&#34;&gt;2.1 安装 Kuboard-Spray&lt;/h3&gt;
&lt;p&gt;Kuboard-Spray 是一款可以在图形界面引导下完成 Kubernetes 高可用集群离线安装的工具，开源仓库的地址为 &lt;a class=&#34;link&#34; href=&#34;https://github.com/eip-work/kuboard-spray&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34; &gt;Kuboard-Spray
    &lt;span style=&#34;white-space: nowrap;&#34;&gt;&lt;svg width=&#34;.8em&#34; height=&#34;.8em&#34; viewBox=&#34;0 0 21 21&#34;
            xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;
            &lt;path d=&#34;m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z&#34; fill=&#34;currentColor&#34; /&gt;
            &lt;path d=&#34;M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z&#34;
                fill=&#34;currentColor&#34;&gt;
        &lt;/svg&gt;&lt;/span&gt;
    
&lt;/a&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 kuborad 节点上安装 docker-ce&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 1. 安装必备的系统工具
sudo apt-get remove docker docker-engine docker.io containerd runc;
sudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common;

# 2. 安装 GPG 证书
curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/docker.gpg;
# 3. 写入软件源信息
echo \
  &amp;quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu \
  $(lsb_release -cs) stable&amp;quot; | sudo tee /etc/apt/sources.list.d/docker.list &amp;gt; /dev/null

# 4. 更新并安装 Docker-CE

sudo apt-get update;
sudo apt-get install docker-ce;

# 5. 配置 docker 镜像加速器(可以在阿里云获取地址)

sudo mkdir -p /etc/docker;
sudo tee /etc/docker/daemon.json &amp;lt;&amp;lt;-&#39;EOF&#39;
{
 &amp;quot;registry-mirrors&amp;quot;: [
    &amp;quot;https://docker.mirrors.ustc.edu.cn&amp;quot;,
    &amp;quot;https://cr.console.aliyun.com/&amp;quot; ]
}
EOF
sudo systemctl daemon-reload;
sudo systemctl restart docker;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 kuboard 节点上执行以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d \
  --privileged \
  --restart=unless-stopped \
  --name=kuboard-spray \
  -e TZ=Asia/Shanghai \
  -p 80:80/tcp \
  -v /var/run/docker.sock:/var/run/docker.sock \
  -v ~/kuboard-spray-data:/data \
  eipwork/kuboard-spray:v1.2.3-amd64
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在浏览器打开地址 &lt;code&gt;http://这台机器的 IP&lt;/code&gt;，输入用户名 &lt;code&gt;admin&lt;/code&gt;，默认密码 &lt;code&gt;Kuboard123&lt;/code&gt;，即可登录 Kuboard-Spray 界面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-加载离线资源包&#34;&gt;2.2 加载离线资源包&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 Kuboard-Spray 界面中，导航到 &lt;code&gt;系统设置&lt;/code&gt; &amp;ndash;&amp;gt; &lt;code&gt;资源包管理&lt;/code&gt; 界面，可以看到已经等候您多时的 &lt;code&gt;Kuboard-Spray 离线资源包&lt;/code&gt;，如下图所示&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/2022-12-08-16-02-14-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
  &lt;/figure&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击 &lt;code&gt;导入&lt;/code&gt; 按钮，在界面的引导下完成资源包的加载。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;23-安装-kubernetes-集群&#34;&gt;2.3 安装 Kubernetes 集群&lt;/h3&gt;
&lt;p&gt;在 Kuboard-Spray 界面中，导航到 &lt;code&gt;集群管理&lt;/code&gt; 界面，点击界面中的 &lt;code&gt;添加集群安装计划&lt;/code&gt; 按钮，填写表单如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;集群名称： 自定义名称，本文中填写为 &lt;code&gt;kuboard&lt;/code&gt;，此名称不可以修改；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;资源包：选择前面步骤中导入的离线资源包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击 &lt;code&gt;确定&lt;/code&gt; 按钮后，将进入集群规划页面，在该界面中添加每个集群节点的连接参数并设置节点的角色，如下图所示：&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/2022-12-08-20-13-12-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
  &lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;重要&lt;/strong&gt;： kuboard-spray 所在机器不能当做 K8S 集群的一个节点，因为安装过程中会重启集群节点的容器引擎，这会导致 kuboard-spray 被重启掉。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最少的节点数量是 1 个；&lt;/li&gt;
&lt;li&gt;ETCD 节点、控制节点的总数量必须为奇数；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击上图的 &lt;code&gt;保存&lt;/code&gt; 按钮，再点击 &lt;code&gt;执行&lt;/code&gt; 按钮，可以启动集群的离线安装过程，安装结果如下：&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/2022-12-08-22-22-52-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
  &lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-部署-spark-on-k8s&#34;&gt;3 部署 Spark on k8s&lt;/h2&gt;
&lt;h3 id=&#34;31-制作-spark-容器镜像&#34;&gt;3.1 制作 spark 容器镜像&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;下载 spark-3.3.1-bin-hadoop3&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;wget https://mirrors.pku.edu.cn/apache/spark/spark-3.3.1/spark-3.3.1-bin-hadoop3.tgz;
tar -xzf spark-3.3.1-bin-hadoop.tgz;
mv spark-3.3.1-bin-hadoop spark;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 Dockerfile 默认 apt 源加速&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd spark/kubernetes/dockerfiles/spark;
// 修改 Dockerfile 内容
// 修改前：
sed -i &#39;s/http:\/\/deb.\(.*\)/https:\/\/deb.\1/g&#39; /etc/apt/sources.list
// 修改后：
sed -i &#39;s#http://deb.debian.org#https://mirrors.ustc.edu.cn#g&#39; /etc/apt/source.list
sed -i &#39;s|security.debian.org/debian-security|mirrors.ustc.edu.cn/debian-security|g&#39; /etc/apt/source.list
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构建 docker 镜像&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd spark/bin;
// -r &amp;lt;repo&amp;gt; -t &amp;lt;tag&amp;gt;
./docker-image-tool.sh -r cuterwrite -t 0.1 build;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推送镜像到阿里云仓库（参考容器镜像服务-&amp;gt;实例列表-&amp;gt;镜像仓库）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker login --username=[阿里云账号] registry.cn-hangzhou.aliyuncs.com;
docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/[repository]:[镜像版本号];
docker push registry.cn-hangzhou.aliyuncs.com/[repository]:[镜像版本号];
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-创建命名空间&#34;&gt;3.2 创建命名空间&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;访问 Kuboard，通常默认用户名为 &lt;code&gt;admin&lt;/code&gt;，默认密码为 &lt;code&gt;Kuboard123&lt;/code&gt;，访问地址为第一个控制节点的 80 端口（取决于安装时的参数），如下图所示：&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/2022-12-09-00-41-32-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
  &lt;/figure&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击进入 default 集群，在下图所示的页面点击创建&lt;code&gt;spark&lt;/code&gt; 命名空间：&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/2022-12-09-00-43-13-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
  &lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-配置-spark-用户权限&#34;&gt;3.3 配置 spark 用户权限&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建用户&lt;code&gt;spark&lt;/code&gt; 并配置权限&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl create serviceaccount spark
kubectl create clusterrolebinding spark-role --clusterrole=edit --serviceaccount=spark:spark --namesparce=spark
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;34-配置-spark-历史服务器&#34;&gt;3.4 配置 spark 历史服务器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建一个名为&lt;code&gt;spark-history-server&lt;/code&gt; 的 deployment，配置如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;容器信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;名称：spark-history-server&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容器镜像：registry.cn-hangzhou.aliyuncs.com/[用户名]/spark:0.1（需配置仓库仓库名和密码）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;环境变量：SPARK_HISTORY_OPTS=-Dspark.history.fs.logDirectory=hdfs://192.168.0.238:8020/sparkhistory（需提前部署 HDFS)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容器端口：18080，端口名称 http&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数：[&amp;quot;/opt/spark/bin/spark-class&amp;quot;, &amp;ldquo;org.apache.spark.deploy.history.HistoryServer&amp;rdquo;]&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;端口：18080&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;协议：TCP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目标端口：18080&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NodePort：30080&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类型：NodePort&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试配置是否成功：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./spark-submit \
    --master k8s://https://127.0.0.1:6443 \
    --deploy-mode cluster \
    --name spark-pi \
    --class org.apache.spark.examples.SparkPi \
    --conf spark.kubernetes.executor.request.cores=1 \
    --conf spark.kubernetes.executor.limit.cores=1 \
    --conf spark.kubernetes.driver.limit.cores=1 \
    --conf spark.kubernetes.driver.request.cores=1 \
    --conf spark.eventLog.enabled=true \
    --conf spark.eventLog.dir=hdfs://192.168.0.238:8020/sparkhistory \
    --conf spark.kubernetes.authenticate.driver.serviceAccountName=spark \
    --conf spark.kubernetes.namespace=bigdata \
    --conf spark.executor.instances=2 \
    --conf spark.kubernetes.file.upload.path=/tmp \
    --conf spark.kubernetes.container.pullSecrets=aliyun-repository \
    --conf spark.kubernetes.container.image=registry.cn-hangzhou.aliyuncs.com/cuterwrite/spark:0.1 \
hdfs://192.168.0.238:8020/user/root/jars/spark-examples_2.12-3.3.1.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提交任务成功后可以在 Kuboard 管理界面看到一个新启动的容器组：&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/2022-12-19-16-35-20-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
  &lt;/figure&gt;

&lt;p&gt;访问 spark 历史服务器，可以看到以下记录：&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/2022-12-19-18-50-59-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
  &lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-编写-wordcount-程序&#34;&gt;4 编写 WordCount 程序&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;WordCount.java&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;package com.cuterwrite;

import org.apache.spark.api.java.function.FlatMapFunction;
import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Encoders;
import org.apache.spark.sql.Row;
import org.apache.spark.sql.SparkSession;

import java.util.Arrays;
import java.util.Iterator;

public class WordCount {
    public static void main(String[] args) throws Exception {
        SparkSession spark = SparkSession.builder().appName(&amp;quot;WordCount&amp;quot;).getOrCreate();
        Dataset&amp;lt;String&amp;gt; lines = spark.read().textFile(&amp;quot;hdfs://192.168.0.238:8020/input/news.txt&amp;quot;);
        Dataset&amp;lt;String&amp;gt; words = lines.flatMap(new FlatMapFunction&amp;lt;String, String&amp;gt;() {
            @Override
            public Iterator&amp;lt;String&amp;gt; call(String line) throws Exception {
                return Arrays.asList(line.split(&amp;quot; &amp;quot;)).iterator();
            }
        }, Encoders.STRING());
        Dataset&amp;lt;Row&amp;gt; wordCounts = words.groupBy(&amp;quot;value&amp;quot;).count();
        wordCounts.write().format(&amp;quot;csv&amp;quot;).save(&amp;quot;hdfs://192.168.0.238:8020/output/word_count_result&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-实验结果&#34;&gt;5 实验结果&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;提交词频统计任务到&lt;code&gt;Kubernetes&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./spark-submit \
    --master k8s://https://127.0.0.1:6443 \
    --deploy-mode cluster \
    --name wordcount \
    --class com.cuterwrite.WordCount \
    --conf spark.kubernetes.executor.request.cores=2 \
    --conf spark.kubernetes.executor.limit.cores=2 \
    --conf spark.kubernetes.driver.limit.cores=1 \
    --conf spark.kubernetes.driver.request.cores=1 \
    --conf spark.eventLog.enabled=true \
    --conf spark.eventLog.dir=hdfs://192.168.0.238:8020/sparkhistory \
    --conf spark.kubernetes.authenticate.driver.serviceAccountName=spark \
    --conf spark.kubernetes.namespace=bigdata \
    --conf spark.executor.instances=3 \
    --conf spark.kubernetes.file.upload.path=/tmp \
    --conf spark.kubernetes.container.pullSecrets=aliyun-repository \
    --conf spark.kubernetes.container.image=registry.cn-hangzhou.aliyuncs.com/cuterwrite/spark:0.1 \
hdfs://192.168.0.238:8020/user/root/jars/SparkApp-1.0.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;执行结果：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;hdfs dfs -cat output/wordCount/_temporary/0/task_202212221534101760903765384745539_0002_m_000000/*
&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/1671723913622.jpg&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
&lt;/figure&gt;

&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/1671723670687.jpg&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
&lt;/figure&gt;

</description>
        </item>
        <item>
        <title>MapReduce 实验</title>
        <link>http://localhost:1313/p/mapreduce/</link>
        <pubDate>Thu, 22 Dec 2022 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/p/mapreduce/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/202210221658.webp" alt="Featured image of post MapReduce 实验" /&gt;&lt;h1 id=&#34;mapreduce-实验&#34;&gt;MapReduce 实验&lt;/h1&gt;
&lt;h2 id=&#34;1-简介&#34;&gt;1 简介&lt;/h2&gt;
&lt;h3 id=&#34;11-实验环境&#34;&gt;1.1 实验环境&lt;/h3&gt;
&lt;p&gt;本实验主要使用 Ubuntu 20.04 64 位作为系统环境，采用 3 台 4 核 8GB 云服务器作为 Haddop 集群部署机器，使用的软件如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Hadoop&lt;/td&gt;
&lt;td&gt;3.2.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IDEA&lt;/td&gt;
&lt;td&gt;2022.2.3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;12-集群规划&#34;&gt;1.2 集群规划&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;th&gt;DataNode&lt;/th&gt;
&lt;th&gt;NameNode&lt;/th&gt;
&lt;th&gt;JournalNode&lt;/th&gt;
&lt;th&gt;ZKFC&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;node1&lt;/td&gt;
&lt;td&gt;192.168.0.76&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;node2&lt;/td&gt;
&lt;td&gt;192.168.0.213&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;node3&lt;/td&gt;
&lt;td&gt;192.168.0.2&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2-在-idea-中创建项目&#34;&gt;2 在 IDEA 中创建项目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;打开 IDEA 界面，点击&lt;code&gt;File&lt;/code&gt;-&amp;gt;&lt;code&gt;New Project&lt;/code&gt;，选择&lt;code&gt;Maven Archetype&lt;/code&gt;，创建一个名为&lt;strong&gt;MapReduce&lt;/strong&gt;的 Maven 项目：&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-12-23%20174744.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
  &lt;/figure&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写&lt;code&gt;pom.xml&lt;/code&gt; 文件，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.cuterwrite&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;MapReduce&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;maven.compiler.source&amp;gt;11&amp;lt;/maven.compiler.source&amp;gt;
        &amp;lt;maven.compiler.target&amp;gt;11&amp;lt;/maven.compiler.target&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;dependencies&amp;gt;
      &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;hadoop-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.2.3&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-编写-mapreduce-应用程序&#34;&gt;3 编写 MapReduce 应用程序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分别编写&lt;code&gt;IntSumReducer.java&lt;/code&gt;、&lt;code&gt;TokenizerMapper.java&lt;/code&gt;、&lt;code&gt;WordCount.java&lt;/code&gt; 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cuterwrite;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Reducer;

import java.io.IOException;
import java.util.Iterator;

public class IntSumReducer extends Reducer&amp;lt;Text, IntWritable, Text, IntWritable&amp;gt; {
    private IntWritable result = new IntWritable();
    public IntSumReducer() {

    }
    public void reduce(Text key, Iterable&amp;lt;IntWritable&amp;gt; values, Reducer&amp;lt;Text, IntWritable, Text, IntWritable&amp;gt;.Context context)
            throws IOException, InterruptedException {
        int sum = 0;
        IntWritable val;
        for (Iterator&amp;lt;IntWritable&amp;gt; iterator = values.iterator(); iterator.hasNext(); sum += val.get()) {
            val = (IntWritable)iterator.next();
        }
        this.result.set(sum);
        context.write(key, this.result);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cuterwrite;

import java.io.IOException;
import java.util.StringTokenizer;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;

public class TokenizerMapper extends Mapper&amp;lt;Object, Text, Text, IntWritable&amp;gt; {
    private static final IntWritable one = new IntWritable(1);
    private Text word = new Text();
    public TokenizerMapper() {

    }
    public void map(Object key, Text value, Mapper&amp;lt;Object, Text, Text, IntWritable&amp;gt;.Context context) throws IOException, InterruptedException {
        StringTokenizer tokenizer = new StringTokenizer(value.toString());
        while (tokenizer.hasMoreTokens()) {
            this.word.set(tokenizer.nextToken());
            context.write(this.word, one);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cuterwrite;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;

public class WordCount {
    public WordCount() {}
    public static void main(String[] args) throws Exception {
        Configuration conf = new Configuration();
        conf.set(&amp;quot;fs.defaultFS&amp;quot;, &amp;quot;hdfs://ha-cluster&amp;quot;);
        conf.set(&amp;quot;fs.hdfs.impl&amp;quot;, &amp;quot;org.apache.hadoop.hdfs.DistributedFileSystem&amp;quot;);

        String[] filePath = new String[] {
                &amp;quot;hdfs://ha-cluster/user/root/input/news1.txt&amp;quot;,
                &amp;quot;hdfs://ha-cluster/user/root/input/news2.txt&amp;quot;,
                &amp;quot;hdfs://ha-cluster/user/root/input/news3.txt&amp;quot;
        };

        Job job = Job.getInstance(conf, &amp;quot;word count&amp;quot;);
        job.setJarByClass(WordCount.class);
        job.setMapperClass(TokenizerMapper.class);
        job.setCombinerClass(IntSumReducer.class);
        job.setReducerClass(IntSumReducer.class);
        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(IntWritable.class);
        for (int i = 0; i &amp;lt; filePath.length ; i++) {
            FileInputFormat.addInputPath(job, new Path(filePath[i]));
        }
        String outputPath = &amp;quot;hdfs://ha-cluster/user/root/output/mapreduce&amp;quot;;
        FileOutputFormat.setOutputPath(job, new Path(outputPath));
        System.exit(job.waitForCompletion(true) ? 0 : 1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-实验结果&#34;&gt;4 实验结果&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将应用程序编译打包成 jar 包：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mvn clean install
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上传 jar 包至 HDFS 中的&lt;code&gt;jars&lt;/code&gt; 目录下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;hdfs dfs -put MapReduce-1.0-SNAPSHOT.jar jars
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 input、output 目录，上传数据文件至 HDFS&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;hdfs dfs -mkdir -p input
hdfs dfs -mkdir -p output
hdfs dfs -put news1.txt news2.txt news3.txt input
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行 jar 包：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;hadoop jar MapReduce-1.0-SNAPSHOT.jar com.cuterwrite.WordCount
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看执行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;hdfs dfs -cat output/mapreduce/*
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Zookeeper on k8s 部署实验</title>
        <link>http://localhost:1313/p/zookeeper-on-k8s/</link>
        <pubDate>Wed, 21 Dec 2022 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/p/zookeeper-on-k8s/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/202210172323.webp" alt="Featured image of post Zookeeper on k8s 部署实验" /&gt;&lt;h1 id=&#34;zookeeper-on-k8s-部署实验&#34;&gt;Zookeeper on k8s 部署实验&lt;/h1&gt;
&lt;h2 id=&#34;1-简介&#34;&gt;1 简介&lt;/h2&gt;
&lt;h3 id=&#34;11-实验环境&#34;&gt;1.1 实验环境&lt;/h3&gt;
&lt;p&gt;已经使用 Kuboard Spary 搭建好 Kubernetes 集群和 Kuboard，使用的软件如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;kuboard spary&lt;/td&gt;
&lt;td&gt;v1.2.3-amd64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kubernetes&lt;/td&gt;
&lt;td&gt;v1.25.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;zookeeper&lt;/td&gt;
&lt;td&gt;3.8.0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;12-集群规划&#34;&gt;1.2 集群规划&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Zookeeper（三台 4 核 8G 的 Ubuntu20.04 服务器）&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;node1&lt;/td&gt;
&lt;td&gt;192.168.0.6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;node2&lt;/td&gt;
&lt;td&gt;192.168.0.7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;node3&lt;/td&gt;
&lt;td&gt;192.168.0.14&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2-创建-configmap&#34;&gt;2 创建 ConfigMap&lt;/h2&gt;
&lt;h3 id=&#34;21-创建-zookeeper-environment&#34;&gt;2.1 创建 zookeeper-environment&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;创建一个名为&lt;code&gt;zookeeper-environment&lt;/code&gt; 的配置字典，包含变量对如下：
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Key&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ALLOW_ANONYMOUS_LOGIN&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BITNAMI_DEBUG&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ZOO_4LW_COMMANDS_WHITELIST&lt;/td&gt;
&lt;td&gt;srvr, mntr, ruok&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ZOO_DATA_LOG_DIR&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ZOO_ENABLE_AUTH&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ZOO_INIT_LIMIT&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ZOO_LOG_LEVEL&lt;/td&gt;
&lt;td&gt;ERROR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ZOO_MAX_CLIENT_CNXNS&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ZOO_PORT_NUMBER&lt;/td&gt;
&lt;td&gt;2181&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ZOO_SERVERS&lt;/td&gt;
&lt;td&gt;zookeeper-statefulset-0.zookeeper-statefulset.bigdata.svc.cluster.local:2888:3888::1 zookeeper-statefulset-1.zookeeper-statefulset.bigdata.svc.cluster.local:2888:3888::2 zookeeper-statefulset-2.zookeeper-statefulset.bigdata.svc.cluster.local:2888:3888::3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ZOO_SYNC_LIMIT&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ZOO_TICK_TIME&lt;/td&gt;
&lt;td&gt;2000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-创建-zookeeper-setup&#34;&gt;2.2 创建 zookeeper-setup&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建一个名为&lt;code&gt;zookeeper-setup&lt;/code&gt; 的配置字典，Key 为&lt;code&gt;setup.sh&lt;/code&gt;，value 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash
if [[ -f &amp;quot;/bitnami/zookeeper/data/myid&amp;quot; ]]; then
    export ZOO_SERVER_ID=&amp;quot;$(cat /bitnami/zookeeper//data/myid)&amp;quot;
else
    HOSTNAME=&amp;quot;$(hostname -s)&amp;quot;
    if [[ $HOSTNAME =~ (.*)-([0-9]+)$ ]]; then
        ORD=${BASH_REMATCH[2]}
        export ZOO_SERVER_ID=&amp;quot;$((ORD + 1 ))&amp;quot;
    else
        echo &amp;quot;Failed to get index from hostname $HOST&amp;quot;
        exit 1
    fi
fi
exec /entrypoint.sh /run.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-创建-statefulset&#34;&gt;3 创建 StatefulSet&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建一个名为&lt;code&gt;zookeeper-statefulset&lt;/code&gt; 的有状态副本集，设置 replica 为&lt;strong&gt;3&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;31-创建工作容器&#34;&gt;3.1 创建工作容器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;容器名称：zookeeper&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容器镜像：bitnami/zookeeper:3.8.0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命令：&lt;code&gt;/opt/scripts/setup.sh&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;环境变量：引用之前创建的配置字典&lt;code&gt;zookeeper-environment&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容器端口：2181&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;资源请求限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CPU 资源请求：500m&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存资源请求：500Mi&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU 资源限制：500m&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存资源限制：500Mi&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;健康检查：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;容器存活探针：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;执行命令：&lt;code&gt;/bin/bash -c &#39;echo &amp;quot;ruok&amp;quot; | timeout 2 nc -w 2 localhost 2181 | grep imok&#39;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始延迟：30 秒&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行探测频率：10 秒&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;超时时间：5 秒&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;健康阈值：1 秒&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不健康阈值：6 秒&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容器就绪探针：与容器存活探针相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容器安全上下文：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;runAsNonRoot：&lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户：1001&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-创建存储挂载&#34;&gt;3.2 创建存储挂载&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据卷：配置字典&lt;code&gt;zookeeper-setup&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;挂载路径：/opt/scripts/setup.sh&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子路径：setup.sh&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-创建-svc&#34;&gt;3.3 创建 SVC&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;服务类型：NodePort&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;端口：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;端口名称&lt;/th&gt;
&lt;th&gt;port&lt;/th&gt;
&lt;th&gt;targetPort&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;client&lt;/td&gt;
&lt;td&gt;2181&lt;/td&gt;
&lt;td&gt;2181&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;server&lt;/td&gt;
&lt;td&gt;2888&lt;/td&gt;
&lt;td&gt;2888&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;leader-election&lt;/td&gt;
&lt;td&gt;3888&lt;/td&gt;
&lt;td&gt;3888&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;34-设置亲和性&#34;&gt;3.4 设置亲和性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设置 Node 亲和性（硬策略）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须满足标签表达式：app.kubernetes.io/component=zookeeper&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置 Pod 反亲和性（软策略）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;尽量满足标签表达式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;权重：49&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;togologykey：app.kubernetes.io/name&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表达式：app.kubernetes.io/component=zookeeper&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-部署结果&#34;&gt;4 部署结果&lt;/h2&gt;
&lt;h3 id=&#34;41-集群信息&#34;&gt;4.1 集群信息&lt;/h3&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/typora/2022-12-21-21-40-07-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
&lt;/figure&gt;

&lt;h3 id=&#34;42-节点状态测试&#34;&gt;4.2 节点状态测试&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zkServer.sh status
&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/typora/2022-12-21-21-41-38-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
&lt;/figure&gt;

&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/typora/2022-12-21-21-42-22-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
&lt;/figure&gt;

</description>
        </item>
        <item>
        <title>Hadoop3 HA 模式三节点高可用集群搭建实验</title>
        <link>http://localhost:1313/p/hadoop-ha/</link>
        <pubDate>Thu, 22 Sep 2022 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/p/hadoop-ha/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/32756284e8854b9ba653bd3632af435d.webp" alt="Featured image of post Hadoop3 HA 模式三节点高可用集群搭建实验" /&gt;&lt;hr&gt;
&lt;h1 id=&#34;hadoop3-ha-模式三节点高可用集群搭建实验&#34;&gt;Hadoop3 HA 模式三节点高可用集群搭建实验&lt;/h1&gt;
&lt;h1 id=&#34;关于-hadoop3-ha-模式&#34;&gt;关于 Hadoop3 HA 模式&lt;/h1&gt;
&lt;h3 id=&#34;单点故障spof&#34;&gt;单点故障（SPOF）&lt;/h3&gt;
&lt;p&gt;简单来说，单点故障指的是分布式系统过度依赖于某一个节点，以至于只要该节点宕掉，就算整个集群的其它节点是完好的，集群也无法正常工作。而单点故障问题一般出现在集群的元数据存储节点上，这种节点一般一个集群就一个，一旦坏了整个系统就不能正常使用。Hadoop 的单点故障出现在 namenode 上，影响集群不可用主要有以下两种情况：一是 namenode 节点宕机，将导致集群不可用，重启 namenode 之后才可使用；二是计划内的 namenode 节点软件或硬件升级，导致集群短时间内不可用。&lt;/p&gt;
&lt;p&gt;为了避免出现单点故障，Hadoop 官方给出了高可用 HA 方案：可以采取同时启动两个 namenode：其中一个工作（active），另一个总是处于后备机（standby）的状态，让它只是单纯地同步活跃机的数据，当活跃机宕掉的时候就可以自动切换过去。这种模式称为&lt;strong&gt;HA 模式&lt;/strong&gt;。HA 模式下不能用[namenode 主机:端口]的模式来访问 Hadoop 集群，因为 namenode 主机已经不再是一个固定的 IP 了，而是采用 serviceid 的方式来访问，这个 serviceid 存储在 ZooKeeper 上。&lt;/p&gt;
&lt;h3 id=&#34;zookeeper&#34;&gt;Zookeeper&lt;/h3&gt;
&lt;p&gt;Zookeeper 是一个轻量级的分布式架构集群，为分布式应用提供一致性服务，提供的功能包括：配置维护、域名服务、分布式同步和组服务等。在 HA 模式中，Zookeeper 最大的功能之一是知道某个节点是否宕机了。其原理是：每一个机器在 Zookeeper 中都有一个会话，如果某个机器宕机了，这个会话就会过期，Zookeeper 就能发现该节点已宕机。&lt;/p&gt;
&lt;h2 id=&#34;实验过程和结果&#34;&gt;实验过程和结果&lt;/h2&gt;
&lt;h3 id=&#34;环境&#34;&gt;环境&lt;/h3&gt;
&lt;p&gt;本实验使用 Ubuntu 18.04 64 位作为系统环境，采用 3 台 2 核 16GB（ MA3.MEDIUM16 型号）的腾讯云服务器作为集群部署机器。&lt;/p&gt;
&lt;p&gt;使用的软件如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Hadoop&lt;/td&gt;
&lt;td&gt;3.2.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Zookeeper&lt;/td&gt;
&lt;td&gt;3.6.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JDK&lt;/td&gt;
&lt;td&gt;11.0.2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;建议：在以下的部署过程中使用 root 用户可以避免很多权限问题。&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;集群规划&#34;&gt;集群规划&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;th&gt;Namenode&lt;/th&gt;
&lt;th&gt;Datanode&lt;/th&gt;
&lt;th&gt;Zookeeper&lt;/th&gt;
&lt;th&gt;JournalNode&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;master&lt;/td&gt;
&lt;td&gt;172.31.0.12&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;slave1&lt;/td&gt;
&lt;td&gt;172.31.0.16&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;slave2&lt;/td&gt;
&lt;td&gt;172.31.0.10&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;创建-hadoop-用户&#34;&gt;创建 hadoop 用户&lt;/h3&gt;
&lt;p&gt;在终端输出如下命令创建一个名为 hadoop 的用户。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo useradd -m hadoop -s /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着使用如下命令设置密码，按提示输入两次密码，这里简单设置为 hadoop&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo passwd hadoop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此外，可以为 hadoop 用户添加管理员权限，方便后续的部署，避免一些权限问题的出现。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo adduser hadoop sudo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;主机名和网络映射配置&#34;&gt;主机名和网络映射配置&lt;/h3&gt;
&lt;p&gt;为了便于区分 master 节点和 slave 节点，可以修改各个节点的主机名。在 Ubuntu 系统中，我们可以执行以下命令来修改主机名。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo vim /etc/hostname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行上面命令后，就打开了/etc/hostname 这个文件，这个文件记录了主机名。打开这个文件之后，里面只有当前的主机名这一行内容，可以直接删除，并修改为 master 或 slave1、slave2，然后保存退出 vim 编辑器，这样就完成了主机名的修改，需要重启系统后才能看到主机名的变化。&lt;/p&gt;
&lt;p&gt;然后，在 master 节点中执行如下命令打开并修改 master 节点的/etc/hosts 文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo vim /etc/hosts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 hosts 文件中增加如下三条 IP（局域网 IP）和主机名映射关系。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;172.31.0.12 master
172.31.0.16 slave1
172.31.0.10 slave2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是，一般 hosts 文件中只能有一个 127.0.0.1，其对应主机名为 localhost，如果有多余 127.0.0.1 映射，应删除，特别是不能存在“127.0.0.1 Master”这样的映射记录。修改后需要重启 Linux 系统。&lt;/p&gt;
&lt;p&gt;上面完成了 master 节点的配置，接下来要继续完成对其他 slave 节点的配置修改。请参照上面的方法，把 slave1 节点上的“/etc/hostname”文件中的主机名修改为“slave1”，把 slave1 节点上的“/etc/hostname”文件中的主机名修改为“slave2”同时，修改“/etc/hosts”的内容，在 hosts 文件中增加如下三条 IP 和主机名映射关系：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;172.31.0.12 master
172.31.0.16 slave1
172.31.0.10 slave2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改完成以后，重新启动 slave 节点的 Linux 系统。&lt;/p&gt;
&lt;p&gt;这样就完成了 master 节点和 slave 节点的配置，然后，需要在各个节点上都执行如下命令，测试是否相互 ping 得通，如果 ping 不通，后面就无法顺利配置成功：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ping master -c 3
ping slave1 -c 3
ping slave2 -c 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如，在 master 节点上 ping slave1，如果 ping 通的话，会显示如下图所示的结果：&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/typora/2022-09-20-22-51-51-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
&lt;/figure&gt;

&lt;h3 id=&#34;安装-ssh-并配置-ssh-免密登录&#34;&gt;安装 SSH 并配置 SSH 免密登录&lt;/h3&gt;
&lt;p&gt;集群模式需要用到 SSH 登陆，Ubuntu 默认已经安装 SSH client，此外还需要安装 SSH server&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get install openssh-server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装后，可以使用如下命令登陆本机&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ssh localhost
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在集群模式中，必须要让 master 节点可以 SSH 免密登录到各个 slave 节点上。首先，生成 master 节点的公钥，如果之前已经生成过公钥，必须要删除原来生成的公钥，重新生成一次。具体命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd ~/.ssh #如果没有该目录，先执行一次 ssh localhost
rm ./id_rsa* #删除之前生成的公钥
ssh-keygen -t rsa #执行该命令后一直按回车就可以
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了让 master 节点能够 SSH 免密登录本机，需要在 master 节点上执行如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat ./id_rsa.pub &amp;gt;&amp;gt; ./authorized_keys
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成后可以执行“ssh master”来验证一下，可能会遇到提示信息，输入 yes 即可，测试成功后执行 exit 命令返回原来的终端。&lt;/p&gt;
&lt;p&gt;接下来，在 master 节点上将公钥传输到 slave1 和 slave2 节点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;scp ~/.ssh/id_rsa.pub hadoop@slave1:/home/hadoop/
scp ~/.ssh/id_rsa.pub hadoop@slave2:/home/hadoop/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着在 slave1（slave2）节点上将 SSH 公钥加入授权&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir ~/.ssh
cat ~/id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys
rm ~/id_rsa.pub #用完之后可以删除掉
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，master 节点就可以免密登录到各个 slave 节点上了，例如执行如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ssh slave1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会显示如下结果，显示已经登录到 slave1 节点上。&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/typora/2022-09-20-22-52-30-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
&lt;/figure&gt;

&lt;h3 id=&#34;安装-java-环境&#34;&gt;安装 Java 环境&lt;/h3&gt;
&lt;p&gt;Hadoop3 需要 JDK 版本在 1.8 以上，这里我选择 11 版本 JDK 作为 Java 环境，先执行以下命令下载压缩包。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /usr/local/softwares;
sudo wget https://repo.huaweicloud.com/openjdk/11.0.2/openjdk-11.0.2_linux-x64_bin.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，使用如下命令解压缩：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo tar -xzf openjdk-11.0.2_linux-x64_bin.tar.gz;
sudo mv jdk-11.0.2 openjdk;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时，可以执行以下命令查看是否安装成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd openjdk;
./bin/java --version;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果返回如下信息，则说明安装成功：&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/typora/2022-09-20-22-52-51-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
&lt;/figure&gt;

&lt;h3 id=&#34;安装-hadoop3&#34;&gt;安装 hadoop3&lt;/h3&gt;
&lt;p&gt;先执行以下命令下载压缩包。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /usr/local/softwares;
sudo wget https://mirrors.pku.edu.cn/apache/hadoop/common/hadoop-3.2.3/hadoop-3.2.3.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，使用如下命令解压缩：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo tar -xzf hadoop-3.2.3.tar.gz;
sudo mv hadoop-3.2.3 hadoop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时，可以执行以下命令查看是否安装成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd hadoop;
./bin/hadoop version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果返回如下信息，则说明安装成功：&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/typora/2022-09-20-22-53-11-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
&lt;/figure&gt;

&lt;h3 id=&#34;安装-zookeeper&#34;&gt;安装 Zookeeper&lt;/h3&gt;
&lt;p&gt;先执行以下命令下载压缩包。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /usr/local/softwares;
sudo wget https://mirrors.pku.edu.cn/apache/zookeeper/stable/apache-zookeeper-3.6.3-bin.tar.gz;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，使用如下命令解压缩：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo tar -xzf apache-zookeeper-3.6.3-bin.tar.gz;
sudo mv apache-zookeeper-3.6.3-bin zookeeper;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来，将 Zookeeper 中的 conf 文件夹里的 zoo_sample.cfg 文件复制一份，改名为 zoo.cfg，然后编辑这个文件，其他的部分不用动，需要修改 dataDir 这一行。dataDir 是 ZooKeeper 的数据文件夹的位置，在我的机器上我用的是/data/zookeeper，你们可以设置成你们的目录。此外，需要在末尾加上所有节点的信息（数字与 myid 要对应）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;server.1=master:2888:3888
server.2=slave1:2888:3888
server.3=slave2:2888:3888
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后再修改 bin/zkEnv.sh，添加以下日志输出文件夹配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ZOO_LOG_DIR=/data/logs/zookeeper
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，需要在每一个节点上的 dataDir 目录下手动创建一个文件，命名为 myid，并写入这台服务器的 Zookeeper ID。这个 ID 数字可以自己随便写，取值范围是 1~255，在这里我将 master、slave1 和 slave2 分别取值为 1，2，3。配置完成以上全部后，分别使用 zkServer.sh start 命令启动集群，ZooKeeper 会自动根据配置把所有的节点连接成一个集群。启动后使用 jps 命令可以查看到 QuorumPeerMain 进程已经启动成功。&lt;/p&gt;
&lt;h3 id=&#34;配置环境变量&#34;&gt;配置环境变量&lt;/h3&gt;
&lt;p&gt;配置环境变量后可以在任意目录中直接使用 hadoop、hdfs 等命令。配置方法也比较简单。首先执行命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo vim ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，在该文件最上面的位置加入下面内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export JAVA_HOME=/usr/local/softwares/openjdk
export HADOOP_HOME=/usr/local/softwares/hadoop
export HADOOP_PREFIX=$HADOOP_HOME
export HADOOP_MAPRED_HOME=$HADOOP_HOME
export HADOOP_COMMON_HOME=$HADOOP_HOME
export HADOOP_HDFS_HOME=$HADOOP_HOME
export YARN_HOME=$HADOOP_HOME
export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/natvie
export HADOOP_INSTALL=$HADOOP_HOME
export ZK_HOME=/usr/local/softwares/zookeeper
export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$ZK_HOME/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存后执行如下命令使配置生效：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;配置-ha-模式集群分布式环境&#34;&gt;配置 HA 模式集群分布式环境&lt;/h3&gt;
&lt;h4 id=&#34;修改文件-workers&#34;&gt;修改文件 workers&lt;/h4&gt;
&lt;p&gt;需要把所有数据节点的主机名写入该文件，每行一个，默认为 localhost（即把本机作为数据节点），在本实验中，master 和 slave1、slave2 都充当 datanode，所以该文件内容配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;master
slave1
slave2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;修改文件-core-sitexml&#34;&gt;修改文件 core-site.xml&lt;/h4&gt;
&lt;p&gt;在一般集群模式中，&lt;code&gt;fs.defaultFS&lt;/code&gt; 配置为 hdfs://master:9000，即名称节点所在的主机名加上端口号，但需要注意的是，在 HA 模式下分别有一个 active 和 standby 的名称节点，需要将该属性设置为集群 id，这里写的 ha-cluster 需要与 hdfs-site.xml 中的配置一致，所以将该文件修改为如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;configuration&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;fs.defaultFS&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hdfs://ha-cluster&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
         &amp;lt;name&amp;gt;ha.zookeeper.quorum&amp;lt;/name&amp;gt;
         &amp;lt;value&amp;gt;master:2181,slave1:2181,slave2:2181&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
         &amp;lt;name&amp;gt;ha.zookeeper.session-timeout.ms&amp;lt;/name&amp;gt;
         &amp;lt;value&amp;gt;30000&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;修改文件-hdfs-sitexml&#34;&gt;修改文件 hdfs-site.xml&lt;/h4&gt;
&lt;p&gt;对以下属性进行配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;configuration&amp;gt;
    &amp;lt;!-- 服务 ID--&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.nameservices&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;ha-cluster&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.ha.namenodes.ha-cluster&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;master,slave1&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!-- rpc 地址--&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.namenode.rpc-address.ha-cluster.master&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;master:8020&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.namenode.rpc-address.ha-cluster.slave1&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;slave1:8020&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!-- http 地址--&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.namenode.http-address.ha-cluster.master&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;master:9870&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.namenode.http-address.ha-cluster.slave1&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;slave1:9870&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!-- journalnode 集群访问地址--&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.namenode.shared.edits.dir&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;qjournal://master:8485;slave1:8485;slave2:8485/ha-cluster&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!-- dfs 客户端--&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.client.failover.proxy.provider.ha-cluster&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!-- 配置 kill 方式--&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.ha.fencing.methods&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;sshfence&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.ha.fencing.ssh.private-key-files&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;/home/hadoop/.ssh/id_rsa&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!-- 自动 failover 机制--&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.ha.automatic-failover.enabled&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
     &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;ha.zookeeper.quorum&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;master:2181,slave1:2181,slave2:2181&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!-- 冗余因子，datanode 有 3 个，所以设置为 3--&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.replication&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;3&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.namenode.name.dir&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;file:/data/hadoop/hdfs/nn&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.datanode.data.dir&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;file:/data/hadoop/hdfs/dn&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!-- 不要加 file 前缀--&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.journalnode.edits.dir&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;/data/hadoop/hdfs/jn&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;修改文件-hadoop-envsh&#34;&gt;修改文件 hadoop-env.sh&lt;/h4&gt;
&lt;p&gt;在文件开头添加以下变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export HADOOP_NAMENODE_OPS=&amp;quot; -Xms1024m -Xmx1024m -XX:+UseParallelGC&amp;quot;
export HADOOP_DATANODE_OPS=&amp;quot; -Xms1024m -Xmx1024m&amp;quot;
export HADOOP_LOG_DIR=/data/logs/hadoop
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;在所有节点上创建数据文件夹和日志文件夹&#34;&gt;在所有节点上创建数据文件夹和日志文件夹&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo mkdir -p /data/hadoop/hdfs/nn;
sudo mkdir -p /data/hadoop/hdfs/dn;
sudo mkdir -p /data/hadoop/hdfs/jn;
sudo mkdir -p /data/zookeeper;
sudo chown -R hadoop.hadoop /data/hadoop;
sudo chown -R hadoop.hadoop /data/zookeeper;
sudo mkdir /data/logs;
sudo mkdir /data/logs/hadoop;
sudo mkdir /data/logs/zookeeper;
sudo chown -R hadoop.hadoop /data/logs
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;在所有节点上分别启动-journalnode&#34;&gt;在所有节点上分别启动 journalnode&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;hdfs --daemon start journalnode
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;格式化-namenode-节点&#34;&gt;格式化 namenode 节点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在第一个 namenode 上进行格式化并启动 hdfs：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;hdfs namenode -format;
hdfs --daemon start namenode
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在第二个 namenode 上进行备用初始化&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;hdfs namenode -bootstrapStandby
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在第一个 namenode 上进行 journalnode 的初始化&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;hdfs namenode -initializeSharedEdits
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;分别在-namenode-节点上启动-zkfc&#34;&gt;分别在 namenode 节点上启动 zkfc&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shel&#34;&gt;hdfs zkfc -formatZK
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;在主节点上启动所有-datanode-节点&#34;&gt;在主节点上启动所有 datanode 节点&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;start-dfs.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;实验结果&#34;&gt;实验结果&lt;/h3&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/typora/2022-09-20-23-03-13-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
&lt;/figure&gt;

&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/typora/2022-09-20-23-03-26-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
&lt;/figure&gt;

&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/typora/2022-09-20-23-03-33-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
&lt;/figure&gt;

&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/typora/2022-09-20-23-03-42-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
&lt;/figure&gt;

&lt;h3 id=&#34;实例运行&#34;&gt;实例运行&lt;/h3&gt;
&lt;p&gt;首先创建 HDFS 上的用户目录，命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;hdfs dfs -mkdir -p /user/hadoop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，在 HDFS 中创建一个 input 目录，并将“/usr/local/softwares/hadoop/etc/hadoop”目录中的配置文件作为输入文件复制到 input 目录中，命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;hdfs dfs -mkdir input;
hdfs dfs -put /usr/local/softwares/hadoop/etc/hadoop/*.xml input
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着就可以运行 MapReduce 作业了，命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;hadoop jar /usr/local/softwares/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.2.3.jar grep input output &#39;dfs[a-z.]+&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/typora/2022-09-20-23-16-35-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
&lt;/figure&gt;

&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/typora/2022-09-20-23-17-58-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
&lt;/figure&gt;

&lt;h2 id=&#34;补充可选配置&#34;&gt;补充：可选配置&lt;/h2&gt;
&lt;h3 id=&#34;hdfs-web-ui-配置认证&#34;&gt;HDFS Web UI 配置认证&lt;/h3&gt;
&lt;p&gt;HDFS 带有一个可视化的端口号默认为 9870 的 Web UI 界面，这个界面如果没有做防火墙限制的话会暴露在公网上。而该界面又存在着大量的日志和配置信息，直接暴露在公网上不利于系统的安全，所以在这里可以配置一个简单的系统认证功能。步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安装 httpd 或安装 httpd-tools&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get install httpd
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装 nginx：这部分内容较多，不是重点，网上有大量的教程，跟着其中一个进行就行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 htpasswd 命令生成用户名和密码数据库文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;htpasswd -c passwd.db [username]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看生成的 db 文件内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat passwd.db
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 nginx 代理并设置访问身份验证&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# nginx 配置文件
vim nginx.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-textile&#34;&gt;server {
    # 使用 9871 端口替代原有的 9870 端口
    listen 9871;
    server_name localhost;

    location / {
        auth_basic &amp;quot;hadoop authentication&amp;quot;;
        auth_basic_user_file /home/hadoop/hadoop/passwd.db
        proxy_pass http://127.0.0.1:9870
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重新加载 nginx 配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /usr/local/lighthouse/softwares/nginx/sbin
./nginx -s reload
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动 nginx&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;systemctl start nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到此为止，HDFS Web UI 界面认证设置完成，效果如下：.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/typora/2022-09-26-20-15-41-image.png&#34; width=&#34;90%&#34; loading=&#34;lazy&#34;&gt;
  &lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
