<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>综合技术栈 on cuterwrite (Pang S.Z)</title>
    <link>https://cuterwrite.top/categories/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF%E6%A0%88/</link>
    <description>Recent content in 综合技术栈 on cuterwrite (Pang S.Z)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 04 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cuterwrite.top/categories/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF%E6%A0%88/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JavaSE知识点笔记</title>
      <link>https://cuterwrite.top/p/java-se/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/java-se/</guid>
      <description>Table of Contents generated with DocToc
 JavaSE知识点笔记  1 数据类型  1.1 基本类型 1.2 包装类型 1.3 缓存池   2 String  2.1 概述 2.2 不可变的优点  2.2.1 可以缓存hash值 2.2.2 String Pool 2.2.3 安全性 2.2.4 线程安全   2.3 String、StringBuilder和StringBuffer  2.3.1 可变性 2.3.2 线程安全   2.4 String Pool 2.5 new String（“abc”）   3 运算  3.1 参数传递 3.2 float与double 3.3 隐式类型转换   4 关键字  4.</description>
    </item>
    
    <item>
      <title>Java容器知识点笔记</title>
      <link>https://cuterwrite.top/p/java-collection/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/java-collection/</guid>
      <description>Table of Contents generated with DocToc
 Java容器知识点笔记  1 概述  1.1 Collection  1.1.1 Set 1.1.2 List 1.1.3 Queue     2 源码分析  2.1 ArrayList  2.1.1 概述 2.1.2 扩容 2.1.3 删除元素 2.1.4 序列化 2.1.5 Fail-fast   2.2 Vector  2.2.1 同步 2.2.2 扩容 2.2.3 与ArrayList的比较 2.2.4 替代方案   2.3 CopyOnWriteArrayList  2.3.1 读写分离 2.3.2 适用场景   2.4 LinkedList  2.4.1 概述 2.</description>
    </item>
    
    <item>
      <title>Java并发知识点笔记</title>
      <link>https://cuterwrite.top/p/java-concurrent/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/java-concurrent/</guid>
      <description>Table of Contents generated with DocToc
 Java并发知识点笔记  1 使用线程的方法 2 基础线程机制  2.1 Executor 2.2 Daemon 2.3 sleep() 2.4 yield()   3 线程中断  3.1 InterruptedException 3.2 interrupted() 3.3 Executor 的中断操作   4 互斥锁  4.1 synchronized 4.2 ReentrantLock 4.3 比较 4.4 选择   5 线程协作  5.1 join 5.2 wait/notify 5.3 await/signal   6 线程状态 7 JUC包/AQS  7.1 CountDownLatch 7.2 CyclicBarrier 7.3 Semaphore   8 JUC包其它组件  8.</description>
    </item>
    
    <item>
      <title>JVM知识点笔记</title>
      <link>https://cuterwrite.top/p/jvm/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/jvm/</guid>
      <description>Table of Contents generated with DocToc
 JVM知识点笔记  1 运行时数据区域  1.1 程序计数器 1.2 Java虚拟机栈 1.3 本地方法栈 1.4 堆 1.5 方法区 1.6 运行时常量池 1.7 直接内存   2 垃圾收集  2.1 判断一个对象是否可回收  2.1.1 引用计数算法 2.1.2 可达性分析算法 2.1.3 方法区的回收 2.1.4 finalize()   2.2 引用类型  2.2.1 强引用 2.2.2 软引用 2.2.3 弱引用 2.2.4 虚引用   2.3 垃圾收集算法  2.3.1 标记 - 清除 2.3.2 标记-整理 2.3.3 复制 2.3.4 分代收集   2.</description>
    </item>
    
    <item>
      <title>Socket与IO模型</title>
      <link>https://cuterwrite.top/p/io-model/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/io-model/</guid>
      <description>Table of Contents generated with DocToc
 Socket与IO模型  1 IO模型  1.1 阻塞式IO 1.2 非阻塞式IO 1.3 IO复用 1.4 信号驱动IO 1.5 异步IO 1.6 IO模型对比   2 IO复用  2.1 select 2.2 poll 2.3 epoll 2.4 LT与ET 2.5 select、poll、epoll对比      Socket与IO模型 1 IO模型 1.1 阻塞式IO 应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。
应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。
1.2 非阻塞式IO 应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。
由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。
1.3 IO复用 使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</description>
    </item>
    
    <item>
      <title>计算机基础知识点总结（数据库系统 &#43; MySQL &#43; Redis）</title>
      <link>https://cuterwrite.top/p/database-system/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/database-system/</guid>
      <description>Table of Contents generated with DocToc
 一、数据库系统原理  1 事务  1.1 概念 1.2 ACID 1.3 AUTOCOMMIT   2 并发一致性问题  2.1 丢失修改 2.2 读脏数据 2.3 不可重复读 2.4 幻影读   3 封锁  3.1 封锁粒度 3.2 封锁类型  3.2.1 读写锁 3.2.2 意向锁   3.3 封锁协议  3.3.1 三级封锁协议 3.3.2 二段锁协议   3.4 MySQL隐式与显示锁定   4 隔离级别  4.1 未提交读 4.2 提交读 4.3 可重复读 4.4 可串行化   5 多版本并发控制  5.</description>
    </item>
    
    <item>
      <title>ArrayList源码分析</title>
      <link>https://cuterwrite.top/p/arraylist-source-code/</link>
      <pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/arraylist-source-code/</guid>
      <description>Table of Contents generated with DocToc
 ArrayList源码分析  1 简介  1.1 ArrayList和Vector的区别 1.2 ArrayList和LinkedList的区别   2 核心源码分析  2.1 属性 2.2 构造函数 2.3 扩容机制  2.3.1 add方法 2.3.2 ensureCapacityInternal方法 2.3.3 ensureExplicitCapacity 2.3.4 grow方法 2.3.5 hugeCapacity方法   2.4 拷贝机制 2.5 ensureCapacity方法      ArrayList源码分析 1 简介 底层：Object[]，容量能动态增长。在添加大量元素前，会先调用ensureCapacity来增加ArrayList的容量，可以减少递增再分配的次数。
ArrayList继承了AbstractList，实现了List，RandomAccess，Cloneable，Serializable等接口。
 RandomAccess：标志接口，接口体是空的，只是用来表明ArrayList是支持快速随机访问的。 Cloneable：能被克隆 Serializable：可序列化  1.1 ArrayList和Vector的区别 底层都是Object[]，但是ArrayList线程不安全，Vector线程安全。
1.2 ArrayList和LinkedList的区别  线程安全：ArrayList和LinkedList都是线程不安全的。 底层数据结构：ArrayList是Object[]，LinkedList底层是双向链表。 插入和删除：ArrayList插入和删除元素的时间复杂度受元素位置的影响，为O(n - i)；LinkedList的插入和删除元素的时间复杂度不受插入元素位置的影响，都近似于O(1)，但如果在指定位置插入和删除，需要先移动到指定位置再执行操作，时间复杂度近似于O(n)。 是否支持快速随机访问：ArrayList支持，LinkedList不支持。 内存空间占用：ArrayList需要在列表末尾预留一定的容量空间，LinkedList的每一个元素都需要多消耗pre和next指针的空间。  2 核心源码分析 2.</description>
    </item>
    
    <item>
      <title>HashMap源码分析</title>
      <link>https://cuterwrite.top/p/hashmap/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/hashmap/</guid>
      <description>Table of Contents generated with DocToc
 HashMap源码分析  1 属性 2 构造方法 3 增加元素 4 读取元素 5 删除元素 6 底层数据结构分析  6.1 JDK1.8之前 6.2 JDK1.8之后      HashMap源码分析 1 属性   初始化容量
static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4;   最大容量
static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;   负载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;   红黑树阈值
static final int TREEIFY_THRESHOLD = 8;   链表阈值</description>
    </item>
    
    <item>
      <title>前端开发知识点复习-基础篇</title>
      <link>https://cuterwrite.top/p/web-development-1/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/web-development-1/</guid>
      <description>Table of Contents generated with DocToc
 前端开发知识点-基础篇  1 Cookie、Session、SessionStorage和LocalStorage 2 Http和Https的区别 3 Http2.0的特性 4 OSI七层模型 5 TCP和UDP的区别 6 TCP三次握手和四次挥手 7 HTTP状态码 8 HTTP缓存机制 9 XSS攻击和CSRF攻击 10 HTTP常见请求头 11 HTTP常见请求方法 12 输入URL到显示页面的过程 13 Websocket 14 BOM对象 15 CORS跨域请求的方式 16 CSS盒模型 17 link标签和import标签的区别 18 transition和animation的区别 19 Flex布局 20 BFC 21 块元素和行元素 22 HTML5和CSS3的新元素 23 重绘和重排 24 闭包 25 类的创建和继承 26 promise、generator、async/await 27 事件流 28 事件委托（代理） 29 事件循环 30 图片懒加载和预加载 31 new操作符 32 bind、apply、call的区别 33 节流和防抖 34 深拷贝 35 对象属性改变监听-Proxy 36 变量提升和暂时性死区 37 箭头函数 38 原型链 39 ES6新特性 40 垂直居中的方法 41 前端性能优化 42 get和post的区别 43 web worker 44 浮动清除 45 CSS选择器    前端开发知识点-基础篇 1 Cookie、Session、SessionStorage和LocalStorage Cookie：服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地的一种纯文本文件，当下一次有同源的请求时，将保存的Cookie数据添加到请求头部，发送给服务端。可以用来实现记录用户登录状态等功能。</description>
    </item>
    
    <item>
      <title>计算机基础知识点总结（操作系统&#43;计算机网络）</title>
      <link>https://cuterwrite.top/p/interview-help/</link>
      <pubDate>Thu, 22 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/interview-help/</guid>
      <description>Table of Contents generated with DocToc
 一、操作系统  1、进程与线程的区别 2、进程间的通信的几种方式 3、线程同步的方式 4、进程同步的方式 5、死锁  5.1、死锁的定义 5.2、死锁必要条件 5.3、死锁处理   6、进程的状态 7、进程调度算法 8、虚拟内存 9、页面置换算法 10、分页与分段的区别   二、计算机网络  1、计算机网络体系结构  1.1、五层协议 1.2、OSI七层协议   2、UDP和TCP的特点 3、UDP首部格式 4、TCP首部格式 5、TCP三次握手 6、TCP四次挥手 7、TCP可靠传输 8、TCP滑动窗口 9、TCP 流量控制 10、TCP 拥塞控制 11、域名系统 12、FTP协议 13、DHCP协议 14、SSH协议 15、SMTP协议 16、Web页面请求过程  16.1. DHCP 配置主机信息 16.2. ARP 解析 MAC 地址 16.3. DNS 解析域名 16.4. HTTP 请求页面      一、操作系统 1、进程与线程的区别   进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</description>
    </item>
    
    <item>
      <title>Redis入门</title>
      <link>https://cuterwrite.top/p/redis-1/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/redis-1/</guid>
      <description>Table of Contents generated with DocToc
 1、命令返回值 2、多数据库 3、命令大全  1、通用命令  keys pattern exists key del key type key   2、字符串类型  简介 set key value / get key incr key incrby key increment decr key decrby key decrement incrbyfloat key increment append key value strlen key mget key / mset key1 value1 &amp;hellip; 位操作 使用场景   3、hash类型  简介 hset key field value hget key field hmset key field value hmget key field hgetall key hexists key field hsetnx key field value hincrby key field increment hdel key field 其他命令 使用场景   4、list类型  简介 lpush key value1&amp;hellip; rpush key value1&amp;hellip; lpop key rpop key llen key lrange key start stop lrem key count value lindex key index lset key index value ltrim key start end linsert key before|after pivot value rpoplpush source destination 使用场景   5、set类型  简介 sadd key member srem key member smembers sismember key member sdiff key1 key2 &amp;hellip; sinter key1 key2&amp;hellip; sunion key1 key2&amp;hellip; scard key sdiffstore/sinterstore/sunionstore destination key1 key2&amp;hellip; srandmember key count spop 使用场景   6、zset类型  简介 zadd key score member zscore key member zrange key start stop [withscores] zrangebyscore key min max [withscores] limit offset count zrevrangebyscore key max min [withscores] limit offset count zincrby key increment member zcard key zcount key min max zrem key member1 &amp;hellip; zremrangebyranke key start stop zremrangebyscore key min max zrank key member zrevrank key member      1、命令返回值  状态回复  OK：成功 PONG：响应PING   错误回复：命令不存在或者命令格式有误  Error Unknown command   整数回复：  INCR命令：返回递增后的键值 DBSIZE命令：返回键的数量   字符串回复：  请求键的值或者请求一个其他类型键中的某个元素   多行字符串回复：  请求非字符串类型键的元素列表 Keys (Pattern)：返回数据库中符合指定规则的键名    2、多数据库  一个Redis实例提供了多个用来存储数据的字典，客户端可以指定数据存储在哪个字典中。 数据库默认从0开始递增命名，默认支持16个数据库（DB0，DB1，&amp;hellip;，DB15） 不支持自定义数据库名字，也不支持单独设置访问密码  3、命令大全 1、通用命令 keys pattern 获得符合规则的键名列表，支持？、*、[]、\x四种通配符</description>
    </item>
    
  </channel>
</rss>
