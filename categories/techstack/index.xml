<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>综合技术栈 on Cuterwrite's Blog</title><link>https://cuterwrite.top/categories/techstack/</link><description>Recent content in 综合技术栈 on Cuterwrite's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>cuterwrite</copyright><lastBuildDate>Fri, 08 Mar 2024 14:39:00 +0000</lastBuildDate><atom:link href="https://cuterwrite.top/categories/techstack/index.xml" rel="self" type="application/rss+xml"/><item><title>记录：安装 Intel® OneAPI-2024.0</title><link>https://cuterwrite.top/p/intel-oneapi/</link><pubDate>Fri, 08 Mar 2024 14:39:00 +0000</pubDate><guid>https://cuterwrite.top/p/intel-oneapi/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/crop_62cf8bae89f60c3522eb45af53a53f4b195413-2024-03-09.webp" alt="Featured image of post 记录：安装 Intel® OneAPI-2024.0" />&lt;h1 id="记录安装-intel-oneapi-20240">记录：安装 Intel® OneAPI-2024.0&lt;/h1>
&lt;p>Intel one API 由两个部分组成，前者为基础 Base Toolkit ，后者必须依赖前者，Intel one API HPC Toolkit，也就是要前后依次安装。&lt;/p>
&lt;h2 id="base-toolkit">Base Toolkit&lt;/h2>
&lt;p>Base Toolkit 是 Intel 的一个 API 基础工具包包括以下库和其他库&lt;/p>
&lt;pre>&lt;code class="language-text">Intel® oneAPI DPC++/C++ Compiler
Intel® DPC++ Compatibility Tool
Intel® oneAPI DPC++ Library
Intel® oneAPI Math Kernel Library
Intel® oneAPI Threading Building Blocks
Intel® oneAPI Collective Communications Library
Intel® oneAPI Data Analytics Library
Intel® oneAPI Deep Neural Networks Library
Intel® Integrated Performance Primitives
Intel® VTune™ Profiler
Intel® Advisor
Intel® Distribution for GDB*
Intel® Distribution for Python* (separate download required)
Intel® FPGA Add-on for oneAPI Base Toolkit (separate download required)
&lt;/code>&lt;/pre>
&lt;h3 id="base-toolkit-安装">Base Toolkit 安装&lt;/h3>
&lt;ol>
&lt;li>下载安装包&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">$ wget https://registrationcenter-download.intel.com/akdlm/IRC_NAS/163da6e4-56eb-4948-aba3-debcec61c064/l_BaseKit_p_2024.0.1.46_offline.sh
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>安装&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">$ chmod +x l_BaseKit_p_2024.0.1.46_offline.sh
$ sudo ./l_BaseKit_p_2024.0.1.46_offline.sh
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>如果自定义安装在用户目录，就不需要 root 权限&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>./l_BaseKit_p_2024.0.1.46_offline.sh
&lt;/code>&lt;/pre>
&lt;p>然后将启动一个图形安装界面，继续操作：&lt;/p>
&lt;p>&lt;strong>（1）选择 Accept &amp;amp; customize&lt;/strong>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/OneAPI-Accepet-2024-03-09.png"
alt="OneAPI-Accepet-2024-03-09" width="auto" loading="lazy">
&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>（2）选择安装的组件&lt;/strong>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/OneAPI-Select-2-2024-03-09.png"
alt="OneAPI-Select-2-2024-03-09" width="auto" loading="lazy">
&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>（3）选择安装的路径&lt;/strong>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/OneAPI-Select-3-2024-03-09.png"
alt="OneAPI-Select-3-2024-03-09" width="auto" loading="lazy">
&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>（4）选择 Next&lt;/strong>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/OneAPI-Select-4-2024-03-09.png"
alt="OneAPI-Select-4-2024-03-09" width="auto" loading="lazy">
&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>（5）选择 2 然后开始安装&lt;/strong>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/OneAPI-Select-5-2024-03-09.png"
alt="OneAPI-Select-5-2024-03-09" width="auto" loading="lazy">
&lt;/figure>
&lt;/p>
&lt;p>接下来等待安装完成即可。&lt;/p>
&lt;h2 id="hpc-toolkit">HPC Toolkit&lt;/h2>
&lt;p>运行基于 Base Toolkit ，这个必须作为后者安装&lt;/p>
&lt;pre>&lt;code class="language-text">Intel® Fortran Compiler
Intel® Fortran Compiler Classic
Intel® Inspector
Intel® MPI Library
Intel® Trace Analyzer and Collector
&lt;/code>&lt;/pre>
&lt;h3 id="hpc-toolkit-安装">HPC Toolkit 安装&lt;/h3>
&lt;ol>
&lt;li>下载安装包&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">$ wget https://registrationcenter-download.intel.com/akdlm/IRC_NAS/67c08c98-f311-4068-8b85-15d79c4f277a/l_HPCKit_p_2024.0.1.38_offline.sh
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>安装&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">$ chmod +x l_HPCKit_p_2024.0.1.38_offline.sh
$ sudo ./l_HPCKit_p_2024.0.1.38_offline.sh
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>如果自定义安装在用户目录，就不需要 root 权限&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>./l_HPCKit_p_2024.0.1.38_offline.sh
&lt;/code>&lt;/pre>
&lt;p>必须安装的库文件： Intel® MPI Library Intel® Fortran Compiler (Beta) &amp;amp; Intel® Fortran Compiler Classic Intel® oneAPI DPC++/C++ Compiler &amp;amp; Intel® C++ Compiler Classic&lt;/p>
&lt;p>安装过程与 Base Toolkit 类似，不再赘述。&lt;/p>
&lt;h2 id="环境配置">环境配置&lt;/h2>
&lt;p>安装完成后，需要配置环境变量，以便在终端中使用 Intel® oneAPI 工具。&lt;/p>
&lt;p>在 HPC 环境中，使用 &lt;code>modulefile&lt;/code> 来管理环境变量，可以使用 &lt;code>module&lt;/code> 命令来加载环境变量。&lt;/p>
&lt;p>以下是参考的 &lt;code>modulefile&lt;/code> 文件，可以根据自己的安装路径进行修改。&lt;/p>
&lt;pre>&lt;code class="language-modulefile">#%Module1.0#####################################################################
##
## modules modulefile
##
proc ModulesHelp { } {
global version prefix
puts stderr &amp;quot;\tmodules - loads the modules software &amp;amp; application environment&amp;quot;
puts stderr &amp;quot;\n\tThis adds $prefix/* to several of the&amp;quot;
puts stderr &amp;quot;\tenvironment variables.&amp;quot;
puts stderr &amp;quot;\n\tVersion $version\n&amp;quot;
}
module-whatis &amp;quot;loads intel/oneapi2024.0&amp;quot;
# for Tcl script use only
set version oneapi2024.0
set prefix /opt/software/intel/oneapi2024.0
conflict intel
prepend-path TBBROOT ${prefix}/tbb/2021.11/env/..
prepend-path DAALROOT ${prefix}/cdal/2024.0
prepend-path DPCT_BUNDLE_ROOT ${prefix}/dpcpp-ct/2024.0
prepend-path INSPECTOR_2023_DIR ${prefix}/inspector/2024.0
prepend-path ONEAPI_ROOT ${prefix}
prepend-path PKG_CONFIG_PATH ${prefix}/vtune/2024.0/include/pkgconfig/lib64:${prefix}/tbb/2021.11/env/../lib/pkgconfig:${prefix}/mpi/2021.11/lib/pkgconfig:${prefix}/mkl/2024.0/lib/pkgconfig:${prefix}/ippcp/2021.9/lib/pkgconfig:${prefix}/inspector/2024.0/include/pkgconfig/lib64:${prefix}/dpl/2022.3/lib/pkgconfig:${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp/../lib/pkgconfig:${prefix}/cdal/2024.0/lib/pkgconfig:${prefix}/compiler/2024.0/lib/pkgconfig:${prefix}/ccl/2021.11/lib/pkgconfig:${prefix}/advisor/2024.0/include/pkgconfig/lib64:
#prepend-path PKG_CONFIG_PATH ${prefix}/vtune/2024.0/include/pkgconfig/lib64:${prefix}/tbb/2021.11/env/../lib/pkgconfig:${prefix}/mkl/2024.0/lib/pkgconfig:${prefix}/ippcp/2021.9/lib/pkgconfig:${prefix}/inspector/2024.0/include/pkgconfig/lib64:${prefix}/dpl/2022.3/lib/pkgconfig:${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp/../lib/pkgconfig:${prefix}/cdal/2024.0/lib/pkgconfig:${prefix}/compiler/2024.0/lib/pkgconfig:${prefix}/ccl/2021.11/lib/pkgconfig:${prefix}/advisor/2024.0/include/pkgconfig/lib64:
prepend-path VT_MPI impi4
prepend-path ACL_BOARD_VENDOR_PATH /opt/Intel/OpenCLFPGA/oneAPI/Boards
prepend-path FPGA_VARS_DIR ${prefix}/compiler/2024.0/lib/oclfpga
prepend-path CCL_ROOT ${prefix}/ccl/2021.11
prepend-path VT_ADD_LIBS &amp;quot;-ldwarf -lelf -lvtunwind -lm -lpthread&amp;quot;
prepend-path I_MPI_ROOT ${prefix}/mpi/2021.11
prepend-path FI_PROVIDER_PATH ${prefix}/mpi/2021.11//libfabric/lib/prov:/usr/lib/x86_64-linux-gnu/libfabric
prepend-path DNNLROOT ${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp
prepend-path DIAGUTIL_PATH ${prefix}/vtune/2024.0/sys_check/vtune_sys_check.py:${prefix}/dpcpp-ct/2024.0/sys_check/sys_check.sh:${prefix}/debugger/2024.0/sys_check/debugger_sys_check.py:${prefix}/compiler/2024.0/sys_check/sys_check.sh:${prefix}/advisor/2024.0/sys_check/advisor_sys_check.py:
prepend-path CCL_CONFIGURATION cpu_gpu_dpcpp
prepend-path DPL_ROOT ${prefix}/dpl/2022.3
prepend-path MANPATH ${prefix}/mpi/2021.11/man:${prefix}/itac/2022.0/man:${prefix}/debugger/2024.0/documentation/man:${prefix}/compiler/2024.0/documentation/en/man/common:::
#prepend-path MANPATH ${prefix}/itac/2022.0/man:${prefix}/debugger/2024.0/documentation/man:${prefix}/compiler/2024.0/documentation/en/man/common:::
prepend-path GDB_INFO ${prefix}/debugger/2024.0/documentation/info/
prepend-path SETVARS_COMPLETED 1
prepend-path APM ${prefix}/advisor/2024.0/perfmodels
prepend-path CMAKE_PREFIX_PATH ${prefix}/tbb/2021.11/env/..:${prefix}/ipp/2021.10/lib/cmake/ipp:${prefix}/ipp/2021.10/lib/cmake/ipp:${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp/../lib/cmake:${prefix}/cdal/2024.0:${prefix}/compiler/2024.0/IntelDPCPP:${prefix}/ccl/2021.11/lib/cmake/oneCCL
prepend-path VTUNE_PROFILER_2023_DIR ${prefix}/vtune/2024.0
prepend-path CMPLR_ROOT ${prefix}/compiler/2024.0
prepend-path ADVISOR_2023_DIR ${prefix}/advisor/2024.0
prepend-path FPGA_VARS_ARGS &amp;quot;&amp;quot;
prepend-path INFOPATH ${prefix}/debugger/2024.0/gdb/intel64/lib
prepend-path IPPROOT ${prefix}/ipp/2021.10
prepend-path IPP_TARGET_ARCH intel64
prepend-path PYTHONPATH ${prefix}/advisor/2024.0/pythonapi
prepend-path VT_ROOT ${prefix}/itac/2022.0
prepend-path DALROOT ${prefix}/cdal/2024.0
prepend-path LIBRARY_PATH ${prefix}/tbb/2021.11/env/../lib/intel64/gcc4.8:${prefix}/mpi/2021.11//libfabric/lib:${prefix}/mpi/2021.11//lib/release:${prefix}/mpi/2021.11//lib:${prefix}/mkl/2024.0/lib/intel64:${prefix}/ipp/2021.10/lib/intel64:${prefix}/ippcp/2021.9/lib/intel64:${prefix}/ipp/2021.10/lib/intel64:${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp/lib:${prefix}/cdal/2024.0/lib/intel64:${prefix}/compiler/2024.0/compiler/lib/intel64_lin:${prefix}/compiler/2024.0/lib:${prefix}/ccl/2021.11/lib/cpu_gpu_dpcpp
#prepend-path LIBRARY_PATH ${prefix}/tbb/2021.11/env/../lib/intel64/gcc4.8:${prefix}/mkl/2024.0/lib/intel64:${prefix}/ipp/2021.10/lib/intel64:${prefix}/ippcp/2021.9/lib/intel64:${prefix}/ipp/2021.10/lib/intel64:${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp/lib:${prefix}/cdal/2024.0/lib/intel64:${prefix}/compiler/2024.0/compiler/lib/intel64_lin:${prefix}/compiler/2024.0/lib:${prefix}/ccl/2021.11/lib/cpu_gpu_dpcpp
prepend-path DAL_MAJOR_BINARY 1
prepend-path IPPCRYPTOROOT ${prefix}/ippcp/2021.9
prepend-path IPPCP_TARGET_ARCH intel64
prepend-path OCL_ICD_FILENAMES libintelocl_emu.so:libalteracl.so:${prefix}/compiler/2024.0/lib/x64/libintelocl.so
prepend-path CLASSPATH ${prefix}/mpi/2021.11//lib/mpi.jar:${prefix}/cdal/2024.0/lib/onedal.jar
#prepend-path CLASSPATH ${prefix}/cdal/2024.0/lib/onedal.jar
prepend-path INTELFPGAOCLSDKROOT ${prefix}/compiler/2024.0/lib/oclfpga
prepend-path LD_LIBRARY_PATH ${prefix}/tbb/2021.11/env/../lib/intel64/gcc4.8:${prefix}/mpi/2021.11//libfabric/lib:${prefix}/mpi/2021.11//lib/release:${prefix}/mpi/2021.11//lib:${prefix}/mkl/2024.0/lib/intel64:${prefix}/itac/2022.0/slib:${prefix}/ipp/2021.10/lib/intel64:${prefix}/ippcp/2021.9/lib/intel64:${prefix}/ipp/2021.10/lib/intel64:${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp/lib:${prefix}/debugger/2024.0/gdb/intel64/lib:${prefix}/debugger/2024.0/libipt/intel64/lib:${prefix}/debugger/2024.0/dep/lib:${prefix}/cdal/2024.0/lib/intel64:${prefix}/compiler/2024.0/lib:${prefix}/compiler/2024.0/lib/x64:${prefix}/compiler/2024.0/lib/oclfpga/host/linux64/lib:${prefix}/compiler/2024.0/compiler/lib/intel64_lin:${prefix}/ccl/2021.11/lib/cpu_gpu_dpcpp:${prefix}/compiler/2024.0/compiler/lib/intel64_lin:${prefix}/ccl/2021.11/lib/cpu_gpu_dpcpp
#prepend-path LD_LIBRARY_PATH ${prefix}/tbb/2021.11/env/../lib/intel64/gcc4.8:${prefix}/mkl/2024.0/lib/intel64:${prefix}/itac/2022.0/slib:${prefix}/ipp/2021.10/lib/intel64:${prefix}/ippcp/2021.9/lib/intel64:${prefix}/ipp/2021.10/lib/intel64:${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp/lib:${prefix}/debugger/2024.0/gdb/intel64/lib:${prefix}/debugger/2024.0/libipt/intel64/lib:${prefix}/debugger/2024.0/dep/lib:${prefix}/cdal/2024.0/lib/intel64:${prefix}/compiler/2024.0/lib:${prefix}/compiler/2024.0/lib/x64:${prefix}/compiler/2024.0/lib/oclfpga/host/linux64/lib:${prefix}/compiler/2024.0/compiler/lib/intel64_lin:${prefix}/ccl/2021.11/lib/cpu_gpu_dpcpp:${prefix}/compiler/2024.0/compiler/lib/intel64_lin:${prefix}/ccl/2021.11/lib/cpu_gpu_dpcpp
prepend-path VT_LIB_DIR ${prefix}/itac/2022.0/lib
prepend-path VTUNE_PROFILER_DIR ${prefix}/vtune/2024.0
prepend-path VT_SLIB_DIR ${prefix}/itac/2022.0/slib
prepend-path MKLROOT ${prefix}/mkl/2024.0
prepend-path DAL_MINOR_BINARY 1
prepend-path NLSPATH ${prefix}/mkl/2024.0/lib/intel64/locale/%l_%t/%N:${prefix}/compiler/2024.0/compiler/lib/intel64_lin/locale/%l_%t/%N
prepend-path PATH ${prefix}/vtune/2024.0/bin64:${prefix}/mpi/2021.11//libfabric/bin:${prefix}/mpi/2021.11//bin:${prefix}/mkl/2024.0/bin/intel64:${prefix}/itac/2022.0/bin:${prefix}/inspector/2024.0/bin64:${prefix}/dpcpp-ct/2024.0/bin:${prefix}/dev-utilities/2024.0/bin:${prefix}/debugger/2024.0/gdb/intel64/bin:${prefix}/compiler/2024.0/lib/oclfpga/bin:${prefix}/compiler/2024.0/bin/intel64:${prefix}/compiler/2024.0/bin:${prefix}/advisor/2024.0/bin64
#prepend-path PATH ${prefix}/vtune/2024.0/bin64:${prefix}/mkl/2024.0/bin/intel64:${prefix}/itac/2022.0/bin:${prefix}/inspector/2024.0/bin64:${prefix}/dpcpp-ct/2024.0/bin:${prefix}/dev-utilities/2024.0/bin:${prefix}/debugger/2024.0/gdb/intel64/bin:${prefix}/compiler/2024.0/lib/oclfpga/bin:${prefix}/compiler/2024.0/bin/intel64:${prefix}/compiler/2024.0/bin:${prefix}/advisor/2024.0/bin64
prepend-path INTEL_PYTHONHOME ${prefix}/debugger/2024.0/dep
prepend-path INTEL_LICENSE_FILE /opt/intel/licenses:/root/intel/licenses
prepend-path CPATH ${prefix}/tbb/2021.11/env/../include:${prefix}/mpi/2021.11//include:${prefix}/mkl/2024.0/include:${prefix}/ipp/2021.10/include:${prefix}/ippcp/2021.9/include:${prefix}/ipp/2021.10/include:${prefix}/dpl/2022.3/linux/include:${prefix}/dpcpp-ct/2024.0/include:${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp/include:${prefix}/dev-utilities/2024.0/include:${prefix}/cdal/2024.0/include:${prefix}/compiler/2024.0/lib/oclfpga/include:${prefix}/ccl/2021.11/include/cpu_gpu_dpcpp
#prepend-path CPATH ${prefix}/tbb/2021.11/env/../include:${prefix}/mkl/2024.0/include:${prefix}/ipp/2021.10/include:${prefix}/ippcp/2021.9/include:${prefix}/ipp/2021.10/include:${prefix}/dpl/2022.3/linux/include:${prefix}/dpcpp-ct/2024.0/include:${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp/include:${prefix}/dev-utilities/2024.0/include:${prefix}/cdal/2024.0/include:${prefix}/compiler/2024.0/lib/oclfpga/include:${prefix}/ccl/2021.11/include/cpu_gpu_dpcpp
&lt;/code>&lt;/pre>
&lt;h2 id="运行测试">运行测试&lt;/h2>
&lt;p>通过 &lt;code>module load&lt;/code> 命令加载环境变量&lt;/p>
&lt;pre>&lt;code class="language-bash">$ module load intel/oneapi2024.0
&lt;/code>&lt;/pre>
&lt;p>测试是否安装成功&lt;/p>
&lt;pre>&lt;code class="language-bash">$ icx -v
&lt;/code>&lt;/pre>
&lt;p>如果输出版本信息，则安装成功。&lt;/p>
&lt;pre>&lt;code class="language-bash">Intel(R) oneAPI DPC++/C++ Compiler 2024.0.2 (2024.0.2.20231213)
Target: x86_64-unknown-linux-gnu
Thread model: posix
InstalledDir: /opt/software/intel/oneapi2024.0/compiler/2024.0/bin/compiler
Configuration file: /opt/software/intel/oneapi2024.0/compiler/2024.0/bin/compiler/../icx.cfg
Found candidate GCC installation: /opt/rh/devtoolset-11/root/usr/lib/gcc/x86_64-redhat-linux/11
Selected GCC installation: /opt/rh/devtoolset-11/root/usr/lib/gcc/x86_64-redhat-linux/11
Candidate multilib: .;@m64
Candidate multilib: 32;@m32
Selected multilib: .;@m64
&lt;/code>&lt;/pre>
&lt;p>继续测试 MPI&lt;/p>
&lt;pre>&lt;code class="language-bash">$ mpirun --version
&lt;/code>&lt;/pre>
&lt;p>如果输出版本信息，则安装成功。&lt;/p>
&lt;pre>&lt;code class="language-bash">Intel(R) MPI Library for Linux* OS, Version 2021.11 Build 20231005 (id: 74c4a23)
Copyright 2003-2023, Intel Corporation.
&lt;/code>&lt;/pre>
&lt;h2 id="icx-说明">icx 说明&lt;/h2>
&lt;blockquote>
&lt;p>&lt;strong>Intel® oneAPI DPC++/C++ Compiler (icx)&lt;/strong> is Intel nextgen compiler based on Clang /LLVM technology plus Intel proprietary optimizations and code generation.&lt;/p>&lt;span class="cite">&lt;span>― &lt;/span>&lt;span>Intel®, &lt;/span>&lt;a href="https://www.intel.cn/content/www/cn/zh/developer/articles/technical/adoption-of-llvm-complete-icx.html">&lt;cite>Intel® C/C&amp;#43;&amp;#43; Compilers Complete Adoption of LLVM&lt;/cite>&lt;/a>&lt;/span>&lt;/blockquote>
&lt;p>icx 是基于 Clang /LLVM 技术的 Intel 下一代编译器，加上 Intel 专有的优化和代码生成。&lt;/p>
&lt;p>LLVM 帮助实现了为英特尔架构提供更加优秀的 C/C++编译器这一目标。最新的英特尔 C/C++编译器使用 LLVM 架构，可提供更快的编译时间、更好的优化、增强的标准支持以及对 GPU 和 FPGA 负载转移（offloading）的支持。&lt;/p>
&lt;h3 id="采用-llvm-的好处">采用 LLVM 的好处&lt;/h3>
&lt;p>LLVM 开源项目是模块化和可重用的编译器和一系列工具链技术的集合，整个项目支持多种处理器架构和编程语言。Clang 开源项目提供了一个 C/C++前端，为 LLVM 项目支持了最新的语言标准。包括 Clang 在内，LLVM 是由一个庞大且非常活跃的开发社区维护的。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/v2-7ac93f64b283ba0b5c5371b7cd524210_1440w-2024-03-09.webp"
alt="v2-7ac93f64b283ba0b5c5371b7cd524210_1440w-2024-03-09" width="auto" loading="lazy">
&lt;/figure>
&lt;p>采用 LLVM 的好处有很多，第一条要说的是更快的构建时间。众所周知，Clang 是很快的！我们使用英特尔 oneAPI 2021.3 工具包中的英特尔 C/C++编译器时，测得构建时间减少了 14％。除了减少构建时间外，采用 Clang 使我们可以从社区支持最新 C++语言标准的一系列成果中受益，并贡献成果来反哺社区。&lt;/p>
&lt;p>英特尔为开源项目提供贡献和支持的历史颇为悠久，其中向 LLVM 做出贡献就有十年时间了。我们今天的主动合作行为包括了优化报告补充、扩大的浮点模型支持，以及向量增强。英特尔直接对 LLVM 项目做出贡献，也有一个临时区域（英特尔 LLVM 技术项目），针对 SYCL 支持。&lt;/p>
&lt;p>在英特尔架构上，英特尔 C/C++编译器预期能提供比基础 Clang+LLVM 编译器更高的性能。接下来英特尔 C/C++编译器都会是采用了 LLVM 开源基础架构的版本（icx）。我们会继续之前的长期努力，持续为 Clang 和 LLVM 项目做出贡献，包括为它们提供优化。并非所有的优化技术都会被上游采纳，有时是因为它们太新了，有时因为它们过于针对英特尔架构。这是可以预料的，并且与其他已经采用 LLVM 的编译器是同样的情况。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/v2-1a1672571e4a8a60c335e5abe38ee86b_1440w-2024-03-09.webp"
alt="v2-1a1672571e4a8a60c335e5abe38ee86b_1440w-2024-03-09" width="auto" loading="lazy">
&lt;/figure>
&lt;p>英特尔 C/C++编译器一直都在提供最优秀的性能。经典版本的英特尔 C/C++编译器取得了对 GCC 18％的优势，而基于 LLVM 的英特尔 C/C++编译器取得了 41％的优势。&lt;/p></description></item><item><title>搭建玄铁 900 系列工具链与 xuantie-qemu 环境</title><link>https://cuterwrite.top/p/thead-tools/</link><pubDate>Tue, 20 Feb 2024 01:51:00 +0000</pubDate><guid>https://cuterwrite.top/p/thead-tools/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/59aa9fecb7e1a3a2b2c88811e6360647195413.jpg@1256w_774h_!web-article-pic-2024-02-20.webp" alt="Featured image of post 搭建玄铁 900 系列工具链与 xuantie-qemu 环境" />&lt;h1 id="搭建玄铁-900-系列工具链与-xuantie-qemu-环境">搭建玄铁 900 系列工具链与 xuantie-qemu 环境&lt;/h1>
&lt;h2 id="一搭建平台">一、搭建平台&lt;/h2>
&lt;ul>
&lt;li>Linux 发行版：CentOS Linux release 7.6.1810 (Core)&lt;/li>
&lt;li>内核版本：3.10.0-957.el7.x86_64&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-bash">$ cat /etc/centos-release
CentOS Linux release 7.6.1810 (Core)
$ uname -r
3.10.0-957.el7.x86_64
&lt;/code>&lt;/pre>
&lt;h2 id="二搭建玄铁-900-系列工具链环境">二、搭建玄铁 900 系列工具链环境&lt;/h2>
&lt;h3 id="1-下载玄铁-900-系列工具链">1. 下载玄铁 900 系列工具链&lt;/h3>
&lt;p>首先，我们需要下载适用于 RISC-V 架构的 Xuantie GNU 工具链。前往&lt;a class="link" href="https://www.xrvm.cn/" target="_blank" rel="noopener" >玄铁官网
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
获取最新版本的预编译包，并根据你的操作系统进行安装。在 Linux 系统中，通常解压后通过添加 &lt;code>bin&lt;/code> 路径到 &lt;code>$PATH&lt;/code> 环境变量即可。&lt;/p>
&lt;p>工具链安装包由于执行平台和目标程序平台的不同分为不同的版本，如 Xuantie-&lt;em>-elf-&lt;/em>-x86_64-V*-.tar.gz 是 64 位 linux 平台的 riscv 裸程序工具链套件。具体分类如下：&lt;/p>
&lt;ul>
&lt;li>根据执行平台
&lt;ul>
&lt;li>x86_64：64 位 linux 平台&lt;/li>
&lt;li>i386：32 位 linux 平台&lt;/li>
&lt;li>mingw：Windows Mingw 平台&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>根据目标程序平台
&lt;ul>
&lt;li>elf：裸程序编译套件&lt;/li>
&lt;li>linux：linux 应用程序编译套件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>这里我们下载最新的版本为 2.8.1 的适用于 64 位 linux 平台的 linux 应用程序编译套件，即 Xuantie-900-gcc-linux-5.10.4-glibc-x86_64 。&lt;/p>
&lt;pre>&lt;code class="language-bash">wget https://occ-oss-prod.oss-cn-hangzhou.aliyuncs.com/resource//1705395627867/Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.1-20240115.tar.gz
tar -xzvf Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.1-20240115.tar.gz
sudo mv Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.1-20240115 /opt
export PATH=/opt/Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.1-20240115/bin:$PATH
&lt;/code>&lt;/pre>
&lt;h3 id="2-验证工具链安装">2. 验证工具链安装&lt;/h3>
&lt;pre>&lt;code class="language-bash">$ riscv64-unknown-linux-gnu-gcc -v
Using built-in specs.
COLLECT_GCC=riscv64-unknown-linux-gnu-gcc
COLLECT_LTO_WRAPPER=/opt/Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.0/bin/../libexec/gcc/riscv64-unknown-linux-gnu/10.4.0/lto-wrapper
Target: riscv64-unknown-linux-gnu
Configured with: /mnt/ssd/jenkins_iotsw/slave/workspace/Toolchain/build-gnu-riscv_4/./source/riscv/riscv-gcc/configure --target=riscv64-unknown-linux-gnu --with-gmp=/mnt/ssd/jenkins_iotsw/slave/workspace/Toolchain/build-gnu-riscv_4/build-gcc-riscv64-unknown-linux-gnu/build-Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.0/lib-for-gcc-x86_64-linux --with-mpfr=/mnt/ssd/jenkins_iotsw/slave/workspace/Toolchain/build-gnu-riscv_4/build-gcc-riscv64-unknown-linux-gnu/build-Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.0/lib-for-gcc-x86_64-linux --with-mpc=/mnt/ssd/jenkins_iotsw/slave/workspace/Toolchain/build-gnu-riscv_4/build-gcc-riscv64-unknown-linux-gnu/build-Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.0/lib-for-gcc-x86_64-linux --with-libexpat-prefix=/mnt/ssd/jenkins_iotsw/slave/workspace/Toolchain/build-gnu-riscv_4/build-gcc-riscv64-unknown-linux-gnu/build-Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.0/lib-for-gcc-x86_64-linux --with-libmpfr-prefix=/mnt/ssd/jenkins_iotsw/slave/workspace/Toolchain/build-gnu-riscv_4/build-gcc-riscv64-unknown-linux-gnu/build-Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.0/lib-for-gcc-x86_64-linux --with-pkgversion='Xuantie-900 linux-5.10.4 glibc gcc Toolchain V2.8.0 B-20231018' CXXFLAGS='-g -O2 -DTHEAD_VERSION_NUMBER=2.8.0 ' --prefix=/mnt/ssd/jenkins_iotsw/slave/workspace/Toolchain/build-gnu-riscv_4/build-gcc-riscv64-unknown-linux-gnu/Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.0 --with-sysroot=/mnt/ssd/jenkins_iotsw/slave/workspace/Toolchain/build-gnu-riscv_4/build-gcc-riscv64-unknown-linux-gnu/Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.0/sysroot --with-system-zlib --enable-shared --enable-tls --enable-languages=c,c++,fortran --disable-libmudflap --disable-libssp --disable-libquadmath --enable-libsanitizer --disable-nls --disable-bootstrap --src=https://cuterwrite.top/mnt/ssd/jenkins_iotsw/slave/workspace/Toolchain/build-gnu-riscv_4/./source/riscv/riscv-gcc --enable-multilib --with-abi=lp64d --with-arch=rv64gc_zfh_xtheadc 'CFLAGS_FOR_TARGET=-O2 -mcmodel=medany' 'CXXFLAGS_FOR_TARGET=-O2 -mcmodel=medany'
Thread model: posix
Supported LTO compression algorithms: zlib
gcc version 10.4.0 (Xuantie-900 linux-5.10.4 glibc gcc Toolchain V2.8.0 B-20231018)
&lt;/code>&lt;/pre>
&lt;p>可以看到输出了 gcc 的版本信息，说明工具链安装成功。&lt;/p>
&lt;h2 id="三搭建-xuantie-qemu-环境">三、搭建 xuantie-qemu 环境&lt;/h2>
&lt;h3 id="1-前提条件">1. 前提条件&lt;/h3>
&lt;p>在安装 xuantie-qemu 之前，需要确保系统含有以下工具或库。&lt;/p>
&lt;ul>
&lt;li>gcc 编译器&lt;/li>
&lt;li>automake&lt;/li>
&lt;li>autoconf&lt;/li>
&lt;li>libtool&lt;/li>
&lt;li>glib2 库&lt;/li>
&lt;li>其它&amp;hellip;..&lt;/li>
&lt;/ul>
&lt;p>通过以下命令安装上述工具或库。&lt;/p>
&lt;pre>&lt;code class="language-bash">sudo yum update -y
sudo yum install -y autoconf automake libtool make gcc gcc-c++ gawk bison flex texinfo gperf patchutils bc \
zlib-devel mpfr-devel gmp-devel curl-devel expat-devel git \
glib2-devel libfdt-devel pixman-devel ncurses-devel ncurses-compat-libs
&lt;/code>&lt;/pre>
&lt;p>如果是 Ubuntu/Dedian 系统，可以使用以下命令安装。&lt;/p>
&lt;pre>&lt;code class="language-bash">sudo apt-get update
sudo apt-get install -y autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \
gawk build-essential bison flex texinfo gperf libtool patchutils bc \
zlib1g-dev libexpat-dev git \
libglib2.0-dev libfdt-dev libpixman-1-dev \
libncurses5-dev libncursesw5-dev
&lt;/code>&lt;/pre>
&lt;h3 id="2-下载并安装-xuantie-qemu">2. 下载并安装 xuantie-qemu&lt;/h3>
&lt;p>访问 &lt;a class="link" href="https://github.com/T-head-Semi/qemu.git" target="_blank" rel="noopener" >Xuantie QEMU 官方仓库
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
，获取适用于玄铁 900 系列芯片的 xuantie-qemu 源代码，然后按照常规步骤编译安装：&lt;/p>
&lt;pre>&lt;code class="language-bash">git clone https://github.com/T-head-Semi/qemu.git
git checkout xuantie-qemu-6.1.0
&lt;/code>&lt;/pre>
&lt;h3 id="3-编译安装-xuantie-qemu">3. 编译安装 xuantie-qemu&lt;/h3>
&lt;pre>&lt;code class="language-bash">cd qemu
mkdir build
cd build
../configure --target-list=riscv64-softmmu,riscv64-linux-user --prefix=/opt/qemu/6.1.0-xuantie
make -j $(nproc)
sudo make install
export PATH=/opt/qemu/6.1.0-xuantie/bin:$PATH
&lt;/code>&lt;/pre>
&lt;h3 id="4-验证-xuantie-qemu-安装">4. 验证 xuantie-qemu 安装&lt;/h3>
&lt;p>安装完毕后如果执行如下命令后能够查看到 qemu 的具体版本，则说明安装成功&lt;/p>
&lt;pre>&lt;code class="language-bash">$ qemu-riscv64 --version
qemu-riscv64 version 6.0.94 (v6.1.0-12-g03813c9)
Copyright (c) 2003-2021 Fabrice Bellard and the QEMU Project developers
&lt;/code>&lt;/pre>
&lt;p>编写一段 C 语言程序，如下所示：&lt;/p>
&lt;pre>&lt;code class="language-c">#include &amp;lt;stdio.h&amp;gt;
int main() {
printf(&amp;quot;Hello RISC-V \n&amp;quot;);
return 0;
}
&lt;/code>&lt;/pre>
&lt;p>使用 Xuantie 900 系列工具链编译该程序，并使用用户模式的 xuantie-qemu 运行程序。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ riscv64-unknown-linux-gnu-gcc -static -o hello hello.c
$ qemu-riscv64 ./hello
Hello RISC-V
&lt;/code>&lt;/pre>
&lt;p>再写一段 RVV 向量化的 C 语言程序，如下所示：&lt;/p>
&lt;details>
&lt;summary>&lt;strong>RVV 向量化 C 语言程序&lt;/strong>&lt;/summary>
&lt;pre>&lt;code class="language-c">#include &amp;lt;riscv_vector.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#define N 15
float vsum(float* v, int n) {
vfloat32m1_t vs, vv, vtmp;
float s = 0.0;
int i;
int vlmax;
vlmax = vsetvlmax_e32m1();
printf(&amp;quot;vlmax:%d\n&amp;quot;, vlmax);
vs = vfmv_v_f_f32m1(0.0, vlmax);
vtmp = vfmv_v_f_f32m1(0.0, vlmax);
for (i = 0; i &amp;lt; n - vlmax; i += vlmax) {
vv = vle32_v_f32m1(&amp;amp;v[i], vlmax);
vtmp = vfadd_vv_f32m1(vtmp, vv, vlmax);
}
vs = vfredusum_vs_f32m1_f32m1(vs, vtmp, vs, vlmax);
s = vfmv_f_s_f32m1_f32(vs);
for (; i &amp;lt; n; i++) {
s += v[i];
}
return s;
}
float vsum1(float* v, int n) {
vfloat32m1_t vs, vv;
float s;
int i;
int vl, vlmax;
vlmax = vsetvlmax_e32m1();
vs = vfmv_v_f_f32m1(0.0, vlmax);
for (i = 0; n &amp;gt; 0; i += vl, n -= vl) {
vl = vsetvl_e32m1(n);
printf(&amp;quot;vl:%d\n&amp;quot;, vl);
vv = vle32_v_f32m1(&amp;amp;v[i], vl);
vs = vfredusum_vs_f32m1_f32m1(vs, vv, vs, vl);
}
s = vfmv_f_s_f32m1_f32(vs);
return s;
}
float vsum2(float* v, int n) {
vfloat32m2_t vv;
vfloat32m1_t vs;
float s;
int i;
int vl, vlmax;
vlmax = vsetvlmax_e32m1();
vs = vfmv_v_f_f32m1(0.0, vlmax);
for (i = 0; n &amp;gt; 0; i += vl, n -= vl) {
vl = vsetvl_e32m2(n);
printf(&amp;quot;vl:%d\n&amp;quot;, vl);
vv = vle32_v_f32m2(&amp;amp;v[i], vl);
vs = vfredusum_vs_f32m2_f32m1(vs, vv, vs, vl);
}
s = vfmv_f_s_f32m1_f32(vs);
return s;
}
int main() {
int i;
float v[N], sum = 0.0;
printf(&amp;quot;Hello RISC-V!\n&amp;quot;);
for (i = 0; i &amp;lt; N; i++) {
v[i] = i;
}
sum = vsum(v, N);
printf(&amp;quot;%f\n&amp;quot;, sum);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/details>
&lt;p>编译并运行该程序（这时需要指定 &lt;code>-cpu&lt;/code> ，否则会报非法指定的异常，即 Illegal instruction (core dumped)）：&lt;/p>
&lt;pre>&lt;code class="language-bash">$ riscv64-unknown-linux-gnu-gcc -static -O3 -march=rv64imafdcv0p7_zfh_xtheadc -o test_vec test_vec.c
$ qemu-riscv64 -cpu c920 ./test_vec
Hello RISC-V!
vlmax:4
105.000000
&lt;/code>&lt;/pre>
&lt;h2 id="四在-qemu-上运行-risc-v-64-位-linux-系统">四、在 QEMU 上运行 RISC-V 64 位 Linux 系统&lt;/h2>
&lt;h3 id="1-制作内核">1. 制作内核&lt;/h3>
&lt;h4 id="11-下载内核源码">1.1 下载内核源码&lt;/h4>
&lt;pre>&lt;code class="language-bash">$ wget https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.10.42.tar.gz
$ tar -xzvf linux-5.10.42.tar.gz
&lt;/code>&lt;/pre>
&lt;p>下载后进入内核源码目录&lt;/p>
&lt;pre>&lt;code class="language-bash">$ cd linux-5.10.42
&lt;/code>&lt;/pre>
&lt;h4 id="12-配置和编译内核">1.2 配置和编译内核&lt;/h4>
&lt;pre>&lt;code class="language-bash">$ make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- defconfig
$ make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- -j $(nproc)
...
AR drivers/built-in.a
GEN .version
CHK include/generated/compile.h
LD vmlinux.o
MODPOST vmlinux.symvers
MODINFO modules.builtin.modinfo
GEN modules.builtin
LD .tmp_vmlinux.kallsyms1
KSYMS .tmp_vmlinux.kallsyms1.S
AS .tmp_vmlinux.kallsyms1.S
LD .tmp_vmlinux.kallsyms2
KSYMS .tmp_vmlinux.kallsyms2.S
AS .tmp_vmlinux.kallsyms2.S
LD vmlinux
SYSMAP System.map
MODPOST modules-only.symvers
GEN Module.symvers
CC [M] fs/efivarfs/efivarfs.mod.o
OBJCOPY arch/riscv/boot/Image
GZIP arch/riscv/boot/Image.gz
LD [M] fs/efivarfs/efivarfs.ko
Kernel: arch/riscv/boot/Image.gz is ready
&lt;/code>&lt;/pre>
&lt;h3 id="2-制作-rootfs">2. 制作 rootfs&lt;/h3>
&lt;h4 id="21-下载-busybox-源码">2.1 下载 busybox 源码&lt;/h4>
&lt;pre>&lt;code class="language-bash">$ wget https://busybox.net/downloads/busybox-1.33.1.tar.bz2
&lt;/code>&lt;/pre>
&lt;p>下载完后进入 busybox 源码目录&lt;/p>
&lt;pre>&lt;code class="language-bash">cd busybox-1.33.1
&lt;/code>&lt;/pre>
&lt;h4 id="22-配置-busybox">2.2 配置 busybox&lt;/h4>
&lt;pre>&lt;code class="language-bash">$ make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- defconfig
$ make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- menuconfig
&lt;/code>&lt;/pre>
&lt;p>打开配置菜单后进入第一行的 &amp;ldquo;Settings&amp;rdquo;，在 &amp;ldquo;Build Options&amp;rdquo; 节中，选中 “Build static binary (no shared libs)”，设置好后退出保存配置。&lt;/p>
&lt;p>检查 &lt;code>.config&lt;/code> 文件中是否有 &lt;code>CONFIG_STATIC=y&lt;/code> ，如果没有则手动添加。&lt;/p>
&lt;h4 id="23-编译和安装-busybox">2.3 编译和安装 busybox&lt;/h4>
&lt;pre>&lt;code class="language-bash">$ make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- -j $(nproc)
$ make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- install
&lt;/code>&lt;/pre>
&lt;p>此时源码目录 busyboxsource 下会新出现一个 &lt;code>_install&lt;/code> 目录 ，可以看到生成的东西。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ ls _install
bin linuxrc sbin usr
&lt;/code>&lt;/pre>
&lt;p>进入 &lt;code>_install&lt;/code> 目录，创建以下目录&lt;/p>
&lt;pre>&lt;code class="language-bash">$ cd _install
$ mkdir proc sys dev etc etc/init.d
$ ls
bin dev etc linuxrc proc sbin sys usr
&lt;/code>&lt;/pre>
&lt;p>然后另外再新建一个最简单的 init 的 RC 文件：&lt;/p>
&lt;pre>&lt;code class="language-bash">$ cd etc/init.d/
$ touch rcS
$ vim rcS
&lt;/code>&lt;/pre>
&lt;p>编辑该文件内容为：&lt;/p>
&lt;pre>&lt;code class="language-bash">#!/bin/sh
mount -t proc none /proc
mount -t sysfs none /sys
/sbin/mdev -s
&lt;/code>&lt;/pre>
&lt;p>然后修改 rcS 文件权限，加上可执行权限&lt;/p>
&lt;pre>&lt;code class="language-bash">$ chmod +x rcS
&lt;/code>&lt;/pre>
&lt;h4 id="24-制作文件系统">2.4 制作文件系统&lt;/h4>
&lt;p>继续在 &lt;code>_install&lt;/code> 目录下执行如下命令：&lt;/p>
&lt;pre>&lt;code class="language-bash">$ find -print0 | cpio -0oH newc | gzip -9 &amp;gt; ../rootfs.img
3276 blocks
&lt;/code>&lt;/pre>
&lt;h3 id="3-启动运行">3. 启动运行&lt;/h3>
&lt;p>创建一个新的目录，将编译好的内核 &lt;code>Image&lt;/code> 和制作好的 &lt;code>rootfs.img&lt;/code> 移动到该目录下。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ mkdir riscv64-linux
$ cd riscv64-linux
$ cp ../linux-5.10.42/arch/riscv/boot/Image .
$ cp ../busybox-1.33.1/rootfs.img .
&lt;/code>&lt;/pre>
&lt;p>执行如下命令：&lt;/p>
&lt;pre>&lt;code class="language-bash">$ qemu-system-riscv64 \
-nographic -machine virt \
-kernel Image \
-initrd rootfs.img \
-append &amp;quot;root=/dev/ram rdinit=/sbin/init&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>将显示 Linux Kernel 启动流程：&lt;/p>
&lt;details>
&lt;summary>&lt;strong>点击展开&lt;/strong>&lt;/summary>
&lt;pre>&lt;code class="language-bash">OpenSBI v0.9
____ _____ ____ _____
/ __ \ / ____| _ \_ _|
| | | |_ __ ___ _ __ | (___ | |_) || |
| | | | '_ \ / _ \ '_ \ \___ \| _ &amp;lt; | |
| |__| | |_) | __/ | | |____) | |_) || |_
\____/| .__/ \___|_| |_|_____/|____/_____|
| |
|_|
Platform Name : riscv-virtio,qemu
Platform Features : timer,mfdeleg
Platform HART Count : 1
Firmware Base : 0x80000000
Firmware Size : 100 KB
Runtime SBI Version : 0.2
Domain0 Name : root
Domain0 Boot HART : 0
Domain0 HARTs : 0*
Domain0 Region00 : 0x0000000080000000-0x000000008001ffff ()
Domain0 Region01 : 0x0000000000000000-0xffffffffffffffff (R,W,X)
Domain0 Next Address : 0x0000000080200000
Domain0 Next Arg1 : 0x0000000087000000
Domain0 Next Mode : S-mode
Domain0 SysReset : yes
Boot HART ID : 0
Boot HART Domain : root
Boot HART ISA : rv64imafdcvsu
Boot HART Features : scounteren,mcounteren,time
Boot HART PMP Count : 16
Boot HART PMP Granularity : 4
Boot HART PMP Address Bits: 54
Boot HART MHPM Count : 0
Boot HART MHPM Count : 0
Boot HART MIDELEG : 0x0000000000000222
Boot HART MEDELEG : 0x000000000000b109
[ 0.000000] Linux version 5.10.42 (root@centos) (riscv64-unknown-linux-gnu-gcc (Xuantie-900 linux-5.10.4 glibc gcc Toolchain V2.8.0 B-20231018) 10.4.0, GNU ld (GNU Binutils) 2.35) #1 SMP Wed Feb 21 02:07:46 CST 2024
[ 0.000000] OF: fdt: Ignoring memory range 0x80000000 - 0x80200000
[ 0.000000] efi: UEFI not found.
[ 0.000000] Initial ramdisk at: 0x(____ptrval____) (1085440 bytes)
[ 0.000000] Zone ranges:
[ 0.000000] DMA32 [mem 0x0000000080200000-0x0000000087ffffff]
[ 0.000000] Normal empty
[ 0.000000] Movable zone start for each node
[ 0.000000] Early memory node ranges
[ 0.000000] node 0: [mem 0x0000000080200000-0x0000000087ffffff]
[ 0.000000] Initmem setup node 0 [mem 0x0000000080200000-0x0000000087ffffff]
[ 0.000000] software IO TLB: Cannot allocate buffer
[ 0.000000] SBI specification v0.2 detected
[ 0.000000] SBI implementation ID=0x1 Version=0x9
[ 0.000000] SBI v0.2 TIME extension detected
[ 0.000000] SBI v0.2 IPI extension detected
[ 0.000000] SBI v0.2 RFENCE extension detected
[ 0.000000] SBI v0.2 HSM extension detected
[ 0.000000] riscv: ISA extensions acdfimsuv
[ 0.000000] riscv: ELF capabilities acdfim
[ 0.000000] percpu: Embedded 17 pages/cpu s32360 r8192 d29080 u69632
[ 0.000000] Built 1 zonelists, mobility grouping on. Total pages: 31815
[ 0.000000] Kernel command line: root=/dev/ram rdinit=/sbin/init
[ 0.000000] Dentry cache hash table entries: 16384 (order: 5, 131072 bytes, linear)
[ 0.000000] Inode-cache hash table entries: 8192 (order: 4, 65536 bytes, linear)
[ 0.000000] Sorting __ex_table...
[ 0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off
[ 0.000000] Memory: 108240K/129024K available (7084K kernel code, 3993K rwdata, 4096K rodata, 223K init, 342K bss, 20784K reserved, 0K cma-reserved)
[ 0.000000] Virtual kernel memory layout:
[ 0.000000] fixmap : 0xffffffcefee00000 - 0xffffffceff000000 (2048 kB)
[ 0.000000] pci io : 0xffffffceff000000 - 0xffffffcf00000000 ( 16 MB)
[ 0.000000] vmemmap : 0xffffffcf00000000 - 0xffffffcfffffffff (4095 MB)
[ 0.000000] vmalloc : 0xffffffd000000000 - 0xffffffdfffffffff (65535 MB)
[ 0.000000] lowmem : 0xffffffe000000000 - 0xffffffe007e00000 ( 126 MB)
[ 0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
[ 0.000000] rcu: Hierarchical RCU implementation.
[ 0.000000] rcu: RCU restricting CPUs from NR_CPUS=8 to nr_cpu_ids=1.
[ 0.000000] rcu: RCU debug extended QS entry/exit.
[ 0.000000] Tracing variant of Tasks RCU enabled.
[ 0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 jiffies.
[ 0.000000] rcu: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=1
[ 0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0
[ 0.000000] riscv-intc: 64 local interrupts mapped
[ 0.000000] plic: plic@c000000: mapped 53 interrupts with 1 handlers for 2 contexts.
[ 0.000000] random: get_random_bytes called from start_kernel+0x31a/0x48c with crng_init=0
[ 0.000000] riscv_timer_init_dt: Registering clocksource cpuid [0] hartid [0]
[ 0.000000] clocksource: riscv_clocksource: mask: 0xffffffffffffffff max_cycles: 0x24e6a1710, max_idle_ns: 440795202120 ns
[ 0.000150] sched_clock: 64 bits at 10MHz, resolution 100ns, wraps every 4398046511100ns
[ 0.003557] Console: colour dummy device 80x25
[ 0.008887] printk: console [tty0] enabled
[ 0.012368] Calibrating delay loop (skipped), value calculated using timer frequency.. 20.00 BogoMIPS (lpj=40000)
[ 0.012666] pid_max: default: 32768 minimum: 301
[ 0.014227] Mount-cache hash table entries: 512 (order: 0, 4096 bytes, linear)
[ 0.014306] Mountpoint-cache hash table entries: 512 (order: 0, 4096 bytes, linear)
[ 0.040922] rcu: Hierarchical SRCU implementation.
[ 0.042741] EFI services will not be available.
[ 0.044926] smp: Bringing up secondary CPUs ...
[ 0.045062] smp: Brought up 1 node, 1 CPU
[ 0.054128] devtmpfs: initialized
[ 0.061463] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns
[ 0.061753] futex hash table entries: 256 (order: 2, 16384 bytes, linear)
[ 0.067460] NET: Registered protocol family 16
[ 0.131233] vgaarb: loaded
[ 0.132530] SCSI subsystem initialized
[ 0.134485] usbcore: registered new interface driver usbfs
[ 0.134834] usbcore: registered new interface driver hub
[ 0.135035] usbcore: registered new device driver usb
[ 0.150024] clocksource: Switched to clocksource riscv_clocksource
[ 0.167109] NET: Registered protocol family 2
[ 0.168330] IP idents hash table entries: 2048 (order: 2, 16384 bytes, linear)
[ 0.172076] tcp_listen_portaddr_hash hash table entries: 128 (order: 0, 5120 bytes, linear)
[ 0.172242] TCP established hash table entries: 1024 (order: 1, 8192 bytes, linear)
[ 0.172480] TCP bind hash table entries: 1024 (order: 3, 32768 bytes, linear)
[ 0.172690] TCP: Hash tables configured (established 1024 bind 1024)
[ 0.173861] UDP hash table entries: 256 (order: 2, 24576 bytes, linear)
[ 0.174481] UDP-Lite hash table entries: 256 (order: 2, 24576 bytes, linear)
[ 0.175963] NET: Registered protocol family 1
[ 0.179024] RPC: Registered named UNIX socket transport module.
[ 0.179111] RPC: Registered udp transport module.
[ 0.179150] RPC: Registered tcp transport module.
[ 0.179186] RPC: Registered tcp NFSv4.1 backchannel transport module.
[ 0.179332] PCI: CLS 0 bytes, default 64
[ 0.182716] Unpacking initramfs...
[ 0.263706] Freeing initrd memory: 1056K
[ 0.265678] workingset: timestamp_bits=62 max_order=15 bucket_order=0
[ 0.281052] NFS: Registering the id_resolver key type
[ 0.282003] Key type id_resolver registered
[ 0.282074] Key type id_legacy registered
[ 0.282505] nfs4filelayout_init: NFSv4 File Layout Driver Registering...
[ 0.282631] nfs4flexfilelayout_init: NFSv4 Flexfile Layout Driver Registering...
[ 0.283481] 9p: Installing v9fs 9p2000 file system support
[ 0.284918] NET: Registered protocol family 38
[ 0.285416] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 251)
[ 0.285593] io scheduler mq-deadline registered
[ 0.285692] io scheduler kyber registered
[ 0.295484] pci-host-generic 30000000.pci: host bridge /soc/pci@30000000 ranges:
[ 0.296336] pci-host-generic 30000000.pci: IO 0x0003000000..0x000300ffff -&amp;gt; 0x0000000000
[ 0.296861] pci-host-generic 30000000.pci: MEM 0x0040000000..0x007fffffff -&amp;gt; 0x0040000000
[ 0.296961] pci-host-generic 30000000.pci: MEM 0x0400000000..0x07ffffffff -&amp;gt; 0x0400000000
[ 0.299940] pci-host-generic 30000000.pci: ECAM at [mem 0x30000000-0x3fffffff] for [bus 00-ff]
[ 0.301083] pci-host-generic 30000000.pci: PCI host bridge to bus 0000:00
[ 0.301328] pci_bus 0000:00: root bus resource [bus 00-ff]
[ 0.301486] pci_bus 0000:00: root bus resource [io 0x0000-0xffff]
[ 0.301528] pci_bus 0000:00: root bus resource [mem 0x40000000-0x7fffffff]
[ 0.301568] pci_bus 0000:00: root bus resource [mem 0x400000000-0x7ffffffff]
[ 0.302864] pci 0000:00:00.0: [1b36:0008] type 00 class 0x060000
[ 0.377412] Serial: 8250/16550 driver, 4 ports, IRQ sharing disabled
[ 0.389894] 10000000.uart: ttyS0 at MMIO 0x10000000 (irq = 2, base_baud = 230400) is a 16550A
[ 0.428017] printk: console [ttyS0] enabled
[ 0.430410] [drm] radeon kernel modesetting enabled.
[ 0.457312] loop: module loaded
[ 0.460726] libphy: Fixed MDIO Bus: probed
[ 0.464996] e1000e: Intel(R) PRO/1000 Network Driver
[ 0.465383] e1000e: Copyright(c) 1999 - 2015 Intel Corporation.
[ 0.466272] ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver
[ 0.466724] ehci-pci: EHCI PCI platform driver
[ 0.467203] ehci-platform: EHCI generic platform driver
[ 0.467683] ohci_hcd: USB 1.1 'Open' Host Controller (OHCI) Driver
[ 0.468129] ohci-pci: OHCI PCI platform driver
[ 0.468593] ohci-platform: OHCI generic platform driver
[ 0.469968] usbcore: registered new interface driver uas
[ 0.470477] usbcore: registered new interface driver usb-storage
[ 0.471603] mousedev: PS/2 mouse device common for all mice
[ 0.475055] goldfish_rtc 101000.rtc: registered as rtc0
[ 0.476070] goldfish_rtc 101000.rtc: setting system clock to 2024-02-20T19:37:51 UTC (1708457871)
[ 0.478889] syscon-poweroff soc:poweroff: pm_power_off already claimed (____ptrval____) sbi_shutdown
[ 0.479494] syscon-poweroff: probe of soc:poweroff failed with error -16
[ 0.480977] usbcore: registered new interface driver usbhid
[ 0.481324] usbhid: USB HID core driver
[ 0.483516] NET: Registered protocol family 10
[ 0.491589] Segment Routing with IPv6
[ 0.492256] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver
[ 0.495528] NET: Registered protocol family 17
[ 0.497086] 9pnet: Installing 9P2000 support
[ 0.497667] Key type dns_resolver registered
[ 0.498706] debug_vm_pgtable: [debug_vm_pgtable ]: Validating architecture page table helpers
[ 0.533266] Freeing unused kernel memory: 220K
[ 0.539682] Run /sbin/init as init process
Please press Enter to activate this console.
&lt;/code>&lt;/pre>
&lt;/details>
&lt;p>见到 &lt;code>&amp;quot;Please press Enter to activate this console.&amp;quot;&lt;/code> 提示后直接回车，无需密码就进入系统了。&lt;/p>
&lt;p>执行几个常用命令测试一下，都能正常工作：&lt;/p>
&lt;pre>&lt;code class="language-bash">/ # ls
bin etc proc sbin usr
dev linuxrc root sys
/ # pwd
/
/ # cd bin
/bin #
/ # ls
arch dumpkmap kill netstat setarch
ash echo link nice setpriv
base32 ed linux32 nuke setserial
base64 egrep linux64 pidof sh
busybox false ln ping sleep
cat fatattr login ping6 stat
chattr fdflush ls pipe_progress stty
chgrp fgrep lsattr printenv su
chmod fsync lzop ps sync
chown getopt makemime pwd tar
conspy grep mkdir reformime touch
cp gunzip mknod resume true
cpio gzip mktemp rev umount
cttyhack hostname more rm uname
date hush mount rmdir usleep
dd ionice mountpoint rpm vi
df iostat mpstat run-parts watch
dmesg ipcalc mt scriptreplay zcat
dnsdomainname kbd_mode mv sed
/bin #
&lt;/code>&lt;/pre>
&lt;p>退出 QEMU 的方法是按下 &lt;code>Ctrl + A&lt;/code> ，松开后再按下 &lt;code>x&lt;/code> 键即可退出 QEMU 。&lt;/p>
&lt;p>如果想要往 QEMU 里面传输文件，可以使用挂载的方式，如下所示：&lt;/p>
&lt;pre>&lt;code class="language-bash">$ mkdir rootfs
$ sudo mount -o loop rootfs.img rootfs
$ cp [-r] [file] ./rootfs/
$ sudo umount rootfs
&lt;/code>&lt;/pre>
&lt;h2 id="五总结">五、总结&lt;/h2>
&lt;p>至此，我们已经成功搭建了玄铁 900 系列的工具链环境以及 xuantie-qemu 仿真环境，这为后续的开发、编译、链接以及运行和调试基于玄铁 900 系列芯片的 RISC-V 应用程序奠定了基础。&lt;/p></description></item><item><title>GCC-13.2.0 编译安装</title><link>https://cuterwrite.top/p/gcc-13-source-install/</link><pubDate>Tue, 30 Jan 2024 11:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/gcc-13-source-install/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/cropped-2024-01-30.webp" alt="Featured image of post GCC-13.2.0 编译安装" />&lt;h1 id="gcc-1320-编译安装">GCC-13.2.0 编译安装&lt;/h1>
&lt;p>GCC 13.1 已被发布为 GCC 13 的第一个稳定版本，作为 GNU 编译器集合的年度功能发布。&lt;/p>
&lt;p>GCC 13.1 是一个重大更新，为那些对一些老式编程感兴趣的人添加了 Modula-2 语言前端，虽然有新的 GCC Rust &lt;code>gccrs&lt;/code> 代码，但它在 v13.1 中被禁用。在这个版本，GCC 的静态分析器继续改进，有更多的 C23 和 C++23 功能，并支持许多新的 x86_64/RISC-V/AArch64 处理器。&lt;/p>
&lt;p>GCC 13.1 还提供了对 Ryzen 7000 系列和 EPYC 9004 系列处理器的初始 AMD Zen 4(Znver4)支持，OpenMP 卸载改进，支持以 JSON 为基础的 SARIF 格式发出诊断程序，Ada 2022 附加功能，各种新的 C/C++警告，支持 AMD 本能 MI200 系列用于 AMDGCN 后端，Ampere-1A 支持，Neoverse-V2/Cortex-X3/Cortex-X1C/Cortex-A715 支持，以及许多新的 Intel CPU 支持。GCC 13 增加了针对 Raptor Lake, Meteor Lake, Sierra Forest, Grand Ridge, Emerald Rapids 以及 Granite Rapids 的英特尔 CPU Target，以及相关的新英特尔 CPU 指令集扩展，如 AMX-FP16、AVX-IFMA、AVX-VNNI-INT8、AVX-NE-CONVERT、RAO-INT 和 AMX-Complex。&lt;/p>
&lt;p>为了体验 C++20 的新功能，GCC 13.1 也是一个很好的选择，因为它包括对 C++20 的许多新功能的支持。截止到本文撰写时，GCC-13.2 也已发布，所以我直接选择了最新的版本。&lt;/p>
&lt;h2 id="下载-gcc-1320-源码">下载 GCC-13.2.0 源码&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>下载地址：&lt;a class="link" href="https://mirror.koddos.net/gcc/releases/gcc-13.2.0/" target="_blank" rel="noopener" >Index of /gcc/releases/gcc-13.2.0
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>下载与解压 GCC-13.2.0 源码&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-bash">wget https://mirror.koddos.net/gcc/releases/gcc-13.2.0/gcc-13.2.0.tar.gz
tar -xzvf gcc-13.2.0.tar.gz
cd gcc-13.2.0
&lt;/code>&lt;/pre>
&lt;h2 id="开始编译">开始编译&lt;/h2>
&lt;ul>
&lt;li>编译命令：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-bash">./contrib/download_prerequisites
mkdir build &amp;amp;&amp;amp; cd build
../configure --prefix=/root/software/gcc-13.2.0 \
--with-pkgversion='glibc gcc V13.2.0' \
--enable-checking=release \
--enable-languages=c,c++ \
--disable-multilib \
--enable-bootstrap \
--enable-threads=posix \
--with-system-zlib \
--with-gmp=$GMP_HOME \
--with-mpfr=$MPFR_HOME \
--with-mpc=$MPC_HOME \
make -j$(nproc)
make install
&lt;/code>&lt;/pre>
&lt;h2 id="设置环境变量">设置环境变量&lt;/h2>
&lt;pre>&lt;code class="language-bash"># gcc-13.0.2.env
export GCC13_HOME=/root/software/gcc-13.2.0
export PATH=$GCC13_HOME/bin:$PATH
export LD_LIBRARY_PATH=$GCC13_HOME/lib64:$LD_LIBRARY_PATH
export LD_LIBRARY_PATH=$GCC13_HOME/lib:$LD_LIBRARY_PATH
export LD_LIBRARY_PATH=$GCC13_HOME/libexec:$LD_LIBRARY_PATH
export CPATH=$GCC13_HOME/include:$CPATH
export INCLUDE=$GCC13_HOME/include:$CPATH
export CC=$GCC13_HOME/bin/gcc
export CXX=$GCC13_HOME/bin/g++
export FC=$GCC13_HOME/bin/gfortran
export F77=$GCC13_HOME/bin/gfortran
export F90=$GCC13_HOME/bin/gfortran
export F95=$GCC13_HOME/bin/gfortran
&lt;/code>&lt;/pre>
&lt;h2 id="命令行测试">命令行测试&lt;/h2>
&lt;pre>&lt;code class="language-cmd">$ gcc -v
&lt;/code>&lt;/pre>
&lt;p>输出结果为：&lt;/p>
&lt;pre>&lt;code class="language-text">Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/root/software/gcc-13.2.0/libexec/gcc/x86_64-pc-linux-gnu/13.2.0/lto-wrapper
Target: x86_64-pc-linux-gnu
Configured with: ../configure --prefix=/root/software/gcc-13.2.0 --with-pkgversion='glibc gcc V13.2.0' --enable-checking=release --enable-languages=c,c++,fortran --enable-threads=posix --enable-bootstrap --disable-multilib --with-system-zlib --with-gmp=/root/software/gmp/6.2.1 --with-mpfr=/root/software/mpfr/4.1.0 --with-mpc=/root/software/mpc/1.2.1
Thread model: posix
Supported LTO compression algorithms: zlib
gcc version 13.2.0 (glibc gcc V13.2.0)
&lt;/code>&lt;/pre>
&lt;p>即为编译安装成功。&lt;/p>
&lt;h2 id="c-20-主要新特性">C++ 20 主要新特性&lt;/h2>
&lt;ul>
&lt;li>C++ 20 的主要新特性如下：
&lt;ul>
&lt;li>Concepts（概念）：概念是对模板参数的类型约束，它们使得模板代码更加清晰和易于理解。概念允许开发者定义一个接口，模板参数必须满足这个接口才能被接受。&lt;/li>
&lt;li>Ranges（范围库）：这是对标准模板库（STL）的一个重大扩展，它引入了“范围”概念，以支持更加声明式的数据处理方式。&lt;/li>
&lt;li>Spaceship Operator(三路比较运算符)：&amp;lt;=&amp;gt;被称为三路比较运算符，它可以一次性比较两个值，返回它们的相对顺序（小于、等于、大于）。&lt;/li>
&lt;li>Modules (模块)：模块旨在替代传统的头文件和源文件分离方式，提供一种新的编译单元，可以显著改善编译时间和代码组织。&lt;/li>
&lt;li>&lt;strong>Coroutines&lt;/strong> (协程)：协程是一种轻量级的线程，它可以在不同的执行点之间切换，而不是在函数调用之间切换。协程是一种用于编写异步代码的新方法，它允许函数在不同的时间点暂停和恢复执行，而不需要回调函数或复杂的状态机。&lt;/li>
&lt;li>constexpr 改进：C++20 大大扩展了可以在编译时计算的代码的范围，包括允许 &lt;code>virtual&lt;/code> 函数、&lt;code>try&lt;/code> 和 &lt;code>catch&lt;/code> 块在 &lt;code>constexpr&lt;/code> 函数中使用。&lt;/li>
&lt;li>初始化器列表的 &lt;code>std::to_array&lt;/code> ：这允许将初始化器列表转换为 std::array ，从而提供了一种类型安全的方式来处理固定大小的数组。&lt;/li>
&lt;li>模板语法的简化：typename 和 class 在模板参数中可以互换使用，简化了模板的语法。&lt;/li>
&lt;li>新的标准属性：引入了多个新的属性，如 &lt;code>[[likely]]&lt;/code> 和 &lt;code>[[unlikely]]&lt;/code> ，用于向编译器提供分支预测的提示。&lt;/li>
&lt;li>新的标准库组件：例如 &lt;code>std::span&lt;/code> ，它提供了一个视图，可以表示数组或其他连续序列的一部分，而不需要复制数据。&lt;/li>
&lt;li>新的同步库：例如 &lt;code>std::latch&lt;/code> 和 &lt;code>std::barrier&lt;/code> ，为多线程编程提供了新的同步原语。&lt;/li>
&lt;li>std::format：这是一个新的格式化库，它提供了一种类型安全的方式来格式化字符串。&lt;/li>
&lt;li>其它等等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="c-23-主要新特性">C++ 23 主要新特性&lt;/h2>
&lt;ul>
&lt;li>C++ 23 的主要新特性如下：
&lt;ul>
&lt;li>Lambada
&lt;ol>
&lt;li>修复省略参数括号 () 的问题。&lt;/li>
&lt;li>更改 lambda 尾部返回类型的作用域。&lt;/li>
&lt;li>让支持函数的 attributes 都支持 lambda。这个功能其实很多编译器早已支持。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>编译期计算：主要修复一些 bug 和继续完善编译期计算的能力。&lt;/li>
&lt;li>&lt;strong>Deducing this&lt;/strong> : Deducing this 是 C++23 中最重要的特性之一。它其实就是提供一种将非静态成员函数的“隐式对象参数”变为“显式对象参数”的方法。
&lt;ul>
&lt;li>Deducing this 的主要动机是消除成员函数修饰所带来的冗余。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>多维数组：
&lt;ol>
&lt;li>支持多维下标运算符，即 operator[a, b, c, …]。&lt;/li>
&lt;li>标准库引入 std::mdspan。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>标准库：
&lt;ul>
&lt;li>增强 std::string 和 std::string_view&lt;/li>
&lt;li>增强 std::optional&lt;/li>
&lt;li>std::flat_map 和 std::flat_set， 替代 std::map 和 std::set。&lt;/li>
&lt;li>std::stacktrace：用于 exception 捕获后，展开调用栈，方便调试。将 stacktrace 引入标准库，可以看作是对 C++ 异常处理能力的加强。&lt;/li>
&lt;li>std::excepted：对 C++ 通过返回值进行错误处理的能力加强。和 std::optional 差不多，但是 std::optional 只能表示正常值和空值（std::nullopt）。而 std::expected 则可以表示一个期望的值和一个错误的值，相当于两个成员的 std::variant，但是 std::excepted 的接口使用起来更方便。&lt;/li>
&lt;li>std::unreachable()：给编译器的优化提示，告诉编译器这个地方是不可到达的。如果 std::unreachable() 被调用，其结果是 undefined behavior。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>其它：
&lt;ul>
&lt;li>静态 operator() 和 静态 operator[]&lt;/li>
&lt;li>假定表达式 [[assume(expr)]]&lt;/li>
&lt;li>size_t 字面量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="corutines-协程示例">Corutines 协程示例&lt;/h2>
&lt;pre>&lt;code class="language-cpp">#include &amp;lt;coroutine&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;optional&amp;gt;
template&amp;lt;typename T&amp;gt;
struct Generator {
struct promise_type;
using handle_type = std::coroutine_handle&amp;lt;promise_type&amp;gt;;
struct promise_type {
std::optional&amp;lt;T&amp;gt; current_value;
static auto get_return_object_on_allocation_failure() { return Generator{nullptr}; }
auto get_return_object() { return Generator{handle_type::from_promise(*this)}; }
auto initial_suspend() { return std::suspend_always{}; }
auto final_suspend() noexcept { return std::suspend_always{}; }
void unhandled_exception() { std::exit(1); }
template&amp;lt;typename U&amp;gt;
auto yield_value(U&amp;amp;&amp;amp; value) {
current_value = std::forward&amp;lt;U&amp;gt;(value);
return std::suspend_always{};
}
void return_void() {}
};
handle_type coro;
Generator(handle_type h): coro(h) {}
Generator(Generator const&amp;amp;) = delete;
Generator(Generator&amp;amp;&amp;amp; o) : coro(o.coro) { o.coro = nullptr; }
~Generator() { if (coro) coro.destroy(); }
T next() {
if (coro) {
coro.resume();
if (coro.done()) {
coro.promise().current_value.reset();
}
return *coro.promise().current_value;
}
return T{};
}
};
Generator&amp;lt;int&amp;gt; generateNumbers(int start, int end) {
for (int i = start; i &amp;lt;= end; ++i) {
co_yield i;
}
}
int main() {
auto numbers = generateNumbers(1, 5);
for (int i = 1; i &amp;lt;= 5; ++i) {
std::cout &amp;lt;&amp;lt; numbers.next() &amp;lt;&amp;lt; std::endl;
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;p>编译命令：&lt;/p>
&lt;pre>&lt;code class="language-bash">g++ -o coroutines coroutines.cpp -std=c++20 -fcoroutines -O3
&lt;/code>&lt;/pre>
&lt;p>运行结果:&lt;/p>
&lt;pre>&lt;code class="language-bash">./coroutines
1
2
3
4
5
&lt;/code>&lt;/pre>
&lt;h2 id="deducing-this-示例">Deducing this 示例&lt;/h2>
&lt;pre>&lt;code class="language-cpp">#include &amp;lt;iostream&amp;gt;
struct Test {
template &amp;lt;typename Self&amp;gt;
void explicitCall(this Self&amp;amp;&amp;amp; self, const std::string&amp;amp; text) {
std::cout &amp;lt;&amp;lt; text &amp;lt;&amp;lt; &amp;quot;: &amp;quot;;
std::forward&amp;lt;Self&amp;gt;(self).implicitCall();
std::cout &amp;lt;&amp;lt; '\n';
}
void implicitCall() &amp;amp; {
std::cout &amp;lt;&amp;lt; &amp;quot;non const lvalue&amp;quot;;
}
void implicitCall() const&amp;amp; {
std::cout &amp;lt;&amp;lt; &amp;quot;const lvalue&amp;quot;;
}
void implicitCall() &amp;amp;&amp;amp; {
std::cout &amp;lt;&amp;lt; &amp;quot;non const rvalue&amp;quot;;
}
void implicitCall() const&amp;amp;&amp;amp; {
std::cout &amp;lt;&amp;lt; &amp;quot;const rvalue&amp;quot;;
}
};
int main() {
std::cout &amp;lt;&amp;lt; '\n';
Test test;
const Test constTest;
test.explicitCall(&amp;quot;test&amp;quot;);
constTest.explicitCall(&amp;quot;constTest&amp;quot;);
std::move(test).explicitCall(&amp;quot;std::move(test)&amp;quot;);
std::move(constTest).explicitCall(&amp;quot;std::move(consTest)&amp;quot;);
std::cout &amp;lt;&amp;lt; '\n';
}
&lt;/code>&lt;/pre></description></item><item><title>使用 Pillow + Plugin 处理 AVIF 和 HEIC 图片</title><link>https://cuterwrite.top/p/processing-avif-heic-images-pillow-plugins/</link><pubDate>Thu, 21 Dec 2023 11:45:14 +0000</pubDate><guid>https://cuterwrite.top/p/processing-avif-heic-images-pillow-plugins/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/4674616682ccadfd81f2dc86c6241f23195413.jpg@1256w_704h_!web-article-pic-2023-12-22-2023-12-31.webp" alt="Featured image of post 使用 Pillow + Plugin 处理 AVIF 和 HEIC 图片" />&lt;h2 id="一引言">一、引言&lt;/h2>
&lt;p>随着图片格式的不断发展，AVIF 和 HEIC 这两种高效的图片格式逐渐受到了开发者的关注。AVIF（AV1 Image File Format）是一种基于 AV1 视频编码的图像格式，具有高压缩率和高质量的特点。HEIC（High Efficiency Image Format）是一种基于 HEVC（High Efficiency Video Coding）编码的图像格式，同样具有高压缩率和高质量的优势。为了方便处理这两种格式的图片，我们可以使用 Pillow-AVIF-Plugin 和 Pillow-HEIC 库。&lt;/p>
&lt;h2 id="二安装">二、安装&lt;/h2>
&lt;p>首先，我们需要安装 Pillow 库，它是一个强大的 Python 图像处理库。使用以下命令安装：&lt;/p>
&lt;pre>&lt;code class="language-bash">pip install pillow
&lt;/code>&lt;/pre>
&lt;p>接下来，安装 Pillow-AVIF-Plugin 和 Pillow-HEIC 库：&lt;/p>
&lt;pre>&lt;code class="language-bash">pip install pillow-avif-plugin
pip install pillow-heic
&lt;/code>&lt;/pre>
&lt;h2 id="三使用方法">三、使用方法&lt;/h2>
&lt;h3 id="1-处理-avif-图片">1. 处理 AVIF 图片&lt;/h3>
&lt;p>使用 Pillow-AVIF-Plugin 处理 AVIF 图片非常简单。首先，导入所需的库：&lt;/p>
&lt;pre>&lt;code class="language-python">from PIL import Image
import pillow_avif
&lt;/code>&lt;/pre>
&lt;p>然后，使用 &lt;code>Image.open()&lt;/code> 方法打开 AVIF 图片：&lt;/p>
&lt;pre>&lt;code class="language-python">image = Image.open('example.avif')
&lt;/code>&lt;/pre>
&lt;p>接下来，可以对图片进行各种操作，例如调整大小、旋转等。也可以使用以下方法将图片保存为其他格式（例如 PNG ）：&lt;/p>
&lt;pre>&lt;code class="language-python">with Image.open(file_path) as im:
png_file_path = os.path.splitext(file_path)[0] + &amp;quot;.png&amp;quot;
im.save(png_file_path, format=&amp;quot;PNG&amp;quot;)
os.remove(file_path)
&lt;/code>&lt;/pre>
&lt;h3 id="2-处理-heic-图片">2. 处理 HEIC 图片&lt;/h3>
&lt;p>处理 HEIC 图片的方法与处理 AVIF 图片类似。首先，导入所需的库：&lt;/p>
&lt;pre>&lt;code class="language-python">from PIL import Image
from pillow_heif import register_heif_opener
register_heif_opener()
&lt;/code>&lt;/pre>
&lt;p>然后，使用 &lt;code>Image.open()&lt;/code> 方法打开 HEIC 图片：&lt;/p>
&lt;pre>&lt;code class="language-python">image = Image.open('example.heic')
&lt;/code>&lt;/pre>
&lt;p>接下来，可以对图片进行各种操作，例如调整大小、旋转等。也可以使用以下方法将图片保存为其他格式（例如 PNG ）：&lt;/p>
&lt;pre>&lt;code class="language-python">with Image.open(file_path) as im:
png_file_path = os.path.splitext(file_path)[0] + &amp;quot;.png&amp;quot;
im.save(png_file_path, format=&amp;quot;PNG&amp;quot;)
os.remove(file_path)
&lt;/code>&lt;/pre>
&lt;h2 id="四结论">四、结论&lt;/h2>
&lt;p>通过使用 Pillow-AVIF-Plugin 和 Pillow-HEIC 库，我们可以轻松地处理 AVIF 和 HEIC 格式的图片。这两个库为开发者提供了简单易用的接口，使得在实际项目中处理这些高效的图片格式变得更加方便。希望本文能对你有所帮助。&lt;/p></description></item><item><title>Ring buffer 详解</title><link>https://cuterwrite.top/p/ring-buffer/</link><pubDate>Sat, 02 Dec 2023 02:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/ring-buffer/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/9fd865ce11924381a127462463ae2234-2023-12-02.webp" alt="Featured image of post Ring buffer 详解" />&lt;h1 id="ring-buffer-详解">Ring buffer 详解&lt;/h1>
&lt;h2 id="一概述">一、概述&lt;/h2>
&lt;p>&lt;code>ring buffer&lt;/code> 称作 &lt;strong>环形缓冲区&lt;/strong> ，也称作环形队列（circular queue），是一种用于表示一个固定尺寸、头尾相连的缓冲区的数据结构，适合缓存数据流。如下为 &lt;strong>环形缓冲区（ring buffer）&lt;/strong> 的概念示意图。&lt;/p>
&lt;p>在任务间的通信、串口数据收发、log 缓存、网卡处理网络数据包、音频/视频流处理中均有 &lt;strong>环形缓冲区（ring buffer）&lt;/strong> 的应用。在 &lt;strong>RT-Thread&lt;/strong> 的 &lt;code>ringbuffer.c&lt;/code> 和 &lt;code>ringbuffer.h&lt;/code> 文件中，Linux 内核文件 &lt;code>kfifo.h&lt;/code> 和 &lt;code>kfifo.c&lt;/code> 中也有 &lt;strong>环形缓冲区（ring buffer）&lt;/strong> 的代码实现。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20231202213555-2023-12-02.webp"
alt="20231202213555-2023-12-02" width="auto" loading="lazy">
&lt;/figure>
&lt;p>环形缓冲区的一些使用特点如下：&lt;/p>
&lt;ul>
&lt;li>当一个数据元素被读取出后，其余数据元素不需要移动其存储位置；&lt;/li>
&lt;li>适合于事先明确了缓冲区的最大容量的情形。缓冲区的容量（长度）一般固定，可以用一个静态数组来充当缓冲区，无需重复申请内存；&lt;/li>
&lt;li>如果缓冲区的大小需要经常调整，就不适合用环形缓冲区，因为在扩展缓冲区大小时，需要搬移其中的数据，这种场合使用链表更加合适；&lt;/li>
&lt;li>因为缓冲区成头尾相连的环形，写操作可能会覆盖未及时读取的数据，有的场景允许这种情况发生，有的场景又严格限制这种情况发生。选择何种策略和具体应用场景相关。&lt;/li>
&lt;/ul>
&lt;h2 id="二原理">二、原理&lt;/h2>
&lt;p>由于计算机内存是线性地址空间，因此 &lt;strong>环形缓冲区（ring buffer）&lt;/strong> 需要特别的算法设计才可以从逻辑上实现。&lt;/p>
&lt;h3 id="1-一个简单例子">1. 一个简单例子&lt;/h3>
&lt;p>先不要想 &lt;strong>环形缓冲区（ring buffer）&lt;/strong> 的具体实现细节，来看一个简单的例子。如下是一个空间大小为 7 的环形缓冲区，其中底部的单线箭头表示头尾相连形成一个环形地址空间：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/375px-Circular_buffer_-_empty.svg-2023-12-02.webp"
alt="375px-Circular_buffer_-_empty.svg-2023-12-02" width="auto" loading="lazy">
&lt;/figure>
&lt;p>假设 &lt;code>1&lt;/code> 被写入圆形缓冲区的中心（在环形缓冲区中，最初的写入位置在哪里是无关紧要的）：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/375px-Circular_buffer_-_XX1XXXX.svg-2023-12-02.webp"
alt="375px-Circular_buffer_-_XX1XXXX.svg-2023-12-02" width="auto" loading="lazy">
&lt;/figure>
&lt;p>再 &lt;strong>写入两个&lt;/strong> 元素，分别是 &lt;code>2&lt;/code> 和 &lt;code>3&lt;/code> ，这两个元素被追加到 &lt;code>1&lt;/code> 之后：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/375px-Circular_buffer_-_XX123XX.svg-2023-12-02.webp"
alt="375px-Circular_buffer_-_XX123XX.svg-2023-12-02" width="auto" loading="lazy">
&lt;/figure>
&lt;p>如果 &lt;strong>读出两个&lt;/strong> 元素，那么环形缓冲区中最老的两个元素将被读出（先进先出原则）。在本例中 &lt;code>1&lt;/code> 和 &lt;code>2&lt;/code> 被读出，缓冲区中剩下 &lt;code>3&lt;/code> ：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/375px-Circular_buffer_-_XXXX3XX.svg-2023-12-02.webp"
alt="375px-Circular_buffer_-_XXXX3XX.svg-2023-12-02" width="auto" loading="lazy">
&lt;/figure>
&lt;p>紧接着，向缓冲区中 &lt;strong>写入六个&lt;/strong> 元素 &lt;code>4、5、6、7、8、9&lt;/code> ，这时缓冲区会被装满：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/375px-Circular_buffer_-_6789345.svg-2023-12-02.webp"
alt="375px-Circular_buffer_-_6789345.svg-2023-12-02" width="auto" loading="lazy">
&lt;/figure>
&lt;p>如果缓冲区是满的，又要写入新的数据，这时有两种策略：一种是覆盖掉最老的数据，也就是将老数据丢掉；另一种是返回错误码或者抛出异常。来看策略一，例如，这时写入两个元素 &lt;code>A&lt;/code> 和 &lt;code>B&lt;/code> ，就会覆盖掉 &lt;code>3&lt;/code> 和 &lt;code>4&lt;/code> ：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/375px-Circular_buffer_-_6789AB5.svg-2023-12-02.webp"
alt="375px-Circular_buffer_-_6789AB5.svg-2023-12-02" width="auto" loading="lazy">
&lt;/figure>
&lt;p>再看，这时如果读出两个元素，就不是 &lt;code>3&lt;/code> 和 &lt;code>4&lt;/code> 而是 &lt;code>5&lt;/code> 和 &lt;code>6&lt;/code>（ &lt;code>5&lt;/code> 和 &lt;code>6&lt;/code> 这时最老），&lt;code>3&lt;/code> 和 &lt;code>4&lt;/code> 已经被 &lt;code>A&lt;/code> 和 &lt;code>B&lt;/code> 覆盖掉。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/375px-Circular_buffer_-_X789ABX.svg-2023-12-02.webp"
alt="375px-Circular_buffer_-_X789ABX.svg-2023-12-02" width="auto" loading="lazy">
&lt;/figure>
&lt;p>通过这个简单的例子，可以总结出要实现 &lt;strong>环形缓冲区（ring buffer）&lt;/strong> 需要注意到几个问题点：&lt;/p>
&lt;ul>
&lt;li>在缓冲区满的时候写数据，有两种策略可以使用：第一覆盖掉老数据；第二抛出异常；&lt;/li>
&lt;li>读数据时，一定要读出缓冲区中最老的数据（缓冲区中数据满足 FIFO 特性）；&lt;/li>
&lt;li>怎样来判断缓冲区是满的；&lt;/li>
&lt;li>如何实现一个线性地址空间的循环读写。&lt;/li>
&lt;/ul>
&lt;h3 id="2-具体操作">2. 具体操作&lt;/h3>
&lt;p>一般的，对一个环形缓冲区进行读写操作，最少需要 &lt;code>4&lt;/code> 个信息：&lt;/p>
&lt;ul>
&lt;li>在内存中的实际 &lt;strong>开始位置&lt;/strong> （例如：一片内存的头指针，数组的第一个元素指针）；&lt;/li>
&lt;li>在内存中的实际 &lt;strong>结束位置&lt;/strong> （也可以是缓冲区实际空间大小，结合开始位置，可以算出结束位置）；&lt;/li>
&lt;li>在缓冲区中进行写操作时的 &lt;strong>写索引&lt;/strong> 值；&lt;/li>
&lt;li>在缓冲区中进行读操作时的 &lt;strong>读索引&lt;/strong> 值。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缓冲区开始位置&lt;/strong> 和 &lt;strong>缓冲区结束位置（或空间大小）&lt;/strong> 实际上定义了环形缓冲区的实际逻辑空间和大小。 &lt;strong>读索引&lt;/strong> 和 &lt;strong>写索引&lt;/strong> 标记了缓冲区进行读操作和写操作时的具体位置。&lt;/p>
&lt;p>具体来说，读写逻辑如下：&lt;/p>
&lt;ol>
&lt;li>当环形缓冲区为空时，读索引和写索引指向相同的位置（因为是环形缓冲区，可以出现在任何位置）；&lt;/li>
&lt;li>当向缓冲区写入一个元素时，元素被写入 &lt;strong>写索引&lt;/strong> 当前所指向位置，然后写索引加 1，指向下一个位置；&lt;/li>
&lt;li>当从缓冲区读出一个元素时，在 &lt;strong>读索引&lt;/strong> 当前所指向位置的元素被读出，然后读索引加 1，指向下一个位置；&lt;/li>
&lt;li>当缓冲区满时，写索引和读索引指向相同的位置（和缓冲区为空时一样）。&lt;/li>
&lt;/ol>
&lt;h4 id="21-在缓冲区满的时候写数据有两种策略可以使用">2.1 在缓冲区满的时候写数据，有两种策略可以使用&lt;/h4>
&lt;p>缓冲区变满在 &lt;strong>环形缓冲区（ring buffer）&lt;/strong> 中会实际发生，一般会有两种处理策略，第一覆盖掉老数据；第二抛出“异常”。这两种策略该如何选择要结合具体的应用场景。如音/视频流中，丢掉一些数据不要紧，可以选择第一种策略；在任务间通信的时候，要严格保证数据正确传输，这个时候就要选择第二种策略。&lt;/p>
&lt;h4 id="22-读数据时一定要读出缓冲区中最老的数据">2.2 读数据时，一定要读出缓冲区中最老的数据&lt;/h4>
&lt;p>&lt;strong>环形缓冲区（ring buffer）&lt;/strong> 也是 &lt;code>FIFO&lt;/code> 类型的数据结构，需要满足先进先出的原则。写就相当于进，读就相当于出。所以读数据时，一定要保证读最老的数据。一般的情况下不会有问题，但有一种场景需要小心： &lt;strong>当缓冲区是满的时候，继续写入元素（覆盖），除了写索引要变，读索引也要跟着变，保证读索引一定是指向缓冲区中最老的元素&lt;/strong> 。&lt;/p>
&lt;h4 id="23-怎样来判断缓冲区是满的">2.3 怎样来判断缓冲区是满的&lt;/h4>
&lt;p>判断缓冲区是满还是空，在环形缓冲区（ring buffer）中是一个重点问题，在&lt;a class="link" href="https://en.wikipedia.org/wiki/Circular_buffer" target="_blank" rel="noopener" >维基百科
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
中，讲解了五种判断方法，感兴趣可以看一下。在平衡各方优缺点后，本节重点讲解 &lt;strong>镜像指示位&lt;/strong> 方法，在 &lt;code>linux&lt;/code> 和 &lt;code>RT-Thread&lt;/code> 实现的环形缓冲区中，也都是用的该策略（或者说是该策略的扩展）。&lt;/p>
&lt;blockquote>
&lt;p>镜像指示位：缓冲区的长度如果是 n ，逻辑地址空间则为 0 至 n-1 ；那么，规定 n 至 2n-1 为镜像逻辑地址空间。本策略规定读写指针的地址空间为 0 至 2n-1 ，其中低半部分对应于常规的逻辑地址空间，高半部分对应于镜像逻辑地址空间。当指针值大于等于 2n 时，使其折返（wrapped）到 ptr-2n。使用一位表示写指针或读指针是否进入了虚拟的镜像存储区：置位表示进入，不置位表示没进入还在基本存储区。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>在读写指针的值相同情况下，如果二者的指示位相同，说明缓冲区为空；如果二者的指示位不同，说明缓冲区为满。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这种方法优点是测试缓冲区满/空很简单；不需要做取余数操作；读写线程可以分别设计专用算法策略，能实现精致的并发控制。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>缺点是读写指针各需要额外的一位作为指示位。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果缓冲区长度是 &lt;code>2&lt;/code> 的幂，则本方法可以省略镜像指示位。如果读写指针的值相等，则缓冲区为空；如果读写指针相差 &lt;code>n&lt;/code> ，则缓冲区为满，这可以用条件表达式（写指针 == (读指针 异或 缓冲区长度)）来判断。—— 维基百科&lt;/p>
&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/v2-22cba7a9b8ff0746184d752a63621981_1440w-2023-12-02.webp"
alt="v2-22cba7a9b8ff0746184d752a63621981_1440w-2023-12-02" width="auto" loading="lazy">
&lt;/figure>
&lt;p>上面是维基百科中对 &lt;strong>镜像指示位&lt;/strong> 的整体描述，但是单凭上面这一个描述，去理解 &lt;strong>镜像指示位&lt;/strong> 方法还是有一定困难，下面来进行一些讨论。&lt;/p>
&lt;p>上面描述中提到了 &lt;strong>读/写指针&lt;/strong> 的概念，注意这个读/写指针和上文提到的 &lt;strong>读索引&lt;/strong> 和 &lt;strong>写索引&lt;/strong> 不是一回事。读写指针的范围是 $[0, 2n-1]$ ，而 &lt;strong>读索引&lt;/strong> 和 &lt;strong>写索引&lt;/strong> 的范围是 $[0, n - 1]$ ，其必须和缓冲区的实际逻辑空间一致。但是 &lt;strong>读/写指针&lt;/strong> 和 &lt;strong>读索引&lt;/strong> 和 &lt;strong>写索引&lt;/strong> 有一个转换关系：&lt;/p>
&lt;p>$$
读索引 = 读指针 \bmod 缓冲区长度 \\
写索引 = 写指针 \bmod 缓冲区长度
$$&lt;/p>
&lt;p>但是如果缓冲区长度是 &lt;code>2&lt;/code> 的幂，那么求余运算可以等价的转换为如下的 &lt;strong>按位与&lt;/strong> 运算：&lt;/p>
&lt;p>$$
读索引 = 读指针 \&amp;amp; (缓冲区长度 - 1) \\
写索引 = 写指针 \&amp;amp; (缓冲区长度 - 1)
$$&lt;/p>
&lt;p>按位与的运算效率要比求余运算高的多，在 &lt;code>linux&lt;/code> 内核中将缓冲区长度扩展为 &lt;code>2&lt;/code> 的幂长度随处可见，都是为了用按位与操作代替求余操作。为了判断缓冲区是否为空或者满，镜像指示位策略引入了两个布尔变量（指示位），来分别标记读指针或写指针是否进入了镜像区间 $[n, 2n-1]$ ，在读写指针的值相同情况下，如果二者的指示位相同，说明缓冲区 &lt;strong>为空&lt;/strong> ；如果二者的指示位不同，说明缓冲区 &lt;strong>为满&lt;/strong> 。但如果缓冲区的长度是 &lt;code>2&lt;/code> 的幂，则可以省略镜像指示位。如果读写指针的值相等，则缓冲区为空；如果读写指针相差 &lt;code>n&lt;/code> ，则缓冲区为满。&lt;/p>
&lt;h4 id="24-如何实现一个线性地址空间的循环读写">2.4 如何实现一个线性地址空间的循环读写&lt;/h4>
&lt;p>理解了 2.3 节的描述，再来理解用一个线性地址空间来实现循环读写就比较容易。如一个环形缓冲区的长度为 &lt;strong>七&lt;/strong> ，则其读写索引的区间为 $[0, 6]$ 。当写索引的值为 &lt;code>6&lt;/code> ，再向缓冲区中写入一个元素时，写索引应该要回到缓冲区的起始索引位置 &lt;code>0&lt;/code> ，读索引在碰到这种情况也是类似处理。总结为一句话就是，当写索引或读索引已经到了环形缓冲区的结束位置时，进行下一步操作时，其应该要回到环形缓冲区的开始位置。&lt;/p>
&lt;h2 id="三实现">三、实现&lt;/h2>
&lt;p>对于环形缓冲区的代码实现，本文会分析 &lt;strong>RT-Thread&lt;/strong> 的 &lt;code>ringbuffer.c&lt;/code> 和 &lt;code>ringbuffer.h&lt;/code> 文件，&lt;strong>Linux&lt;/strong> 内核中的 &lt;code>kfifo.h&lt;/code> 和 &lt;code>kfifo.c&lt;/code> 文件。&lt;/p>
&lt;h3 id="1-rt-thread-中实现的-ring-buffer">1. RT-Thread 中实现的 ring buffer&lt;/h3>
&lt;p>下面分析 &lt;strong>RT-Thread&lt;/strong> 的 &lt;strong>ring buffer&lt;/strong> 实现，主要会讨论 &lt;strong>环形缓冲区结构体&lt;/strong> 、 &lt;strong>缓冲区初始化操作&lt;/strong> 、&lt;strong>写操作&lt;/strong> 、 &lt;strong>读操作&lt;/strong> 、&lt;strong>判断缓冲区是否为空或满&lt;/strong> 。&lt;/p>
&lt;h4 id="11-环形缓冲区结构体">1.1 环形缓冲区结构体&lt;/h4>
&lt;p>&lt;code>RT-Thread&lt;/code> 中定义了结构体 &lt;code>rt_ringbuffer&lt;/code> ，其中 &lt;code>buffer_ptr&lt;/code> 、 &lt;code>buffer_size&lt;/code> 、 &lt;code>read_index&lt;/code> 、 &lt;code>write_index&lt;/code> 和之前介绍的 4 个信息是完全对应的。为了判断缓冲区是空还是满，还定义了两个布尔型变量 &lt;code>read_mirror&lt;/code> 和 &lt;code>write_mirror&lt;/code> ，其是通过位域的定义方式来实现。&lt;/p>
&lt;pre>&lt;code class="language-c">struct rt_ringbuffer
{
rt_uint8_t *buffer_ptr;
rt_uint16_t read_mirror : 1;
rt_uint16_t read_index : 15;
rt_uint16_t write_mirror : 1;
rt_uint16_t write_index : 15;
rt_int16_t buffer_size;
};
&lt;/code>&lt;/pre>
&lt;h4 id="12-缓冲区初始化操作">1.2 缓冲区初始化操作&lt;/h4>
&lt;p>初始化操作 &lt;code>rt_ringbuffer_init&lt;/code> 很容易理解，就是将申请好的内存地址赋值给环形缓冲区，缓冲区实际逻辑大小也传入进去。&lt;code>read_index&lt;/code> 、&lt;code>write_index&lt;/code> 、&lt;code>read_mirror&lt;/code> 和 &lt;code>write_mirror&lt;/code> 全部初始化为零。&lt;/p>
&lt;pre>&lt;code class="language-c">void rt_ringbuffer_init(struct rt_ringbuffer *rb,
rt_uint8_t *pool,
rt_int16_t size)
{
RT_ASSERT(rb != RT_NULL);
RT_ASSERT(size &amp;gt; 0);
/* initialize read and write index */
rb-&amp;gt;read_mirror = rb-&amp;gt;read_index = 0;
rb-&amp;gt;write_mirror = rb-&amp;gt;write_index = 0;
/* set buffer pool and size */
rb-&amp;gt;buffer_ptr = pool;
rb-&amp;gt;buffer_size = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);
}
&lt;/code>&lt;/pre>
&lt;h4 id="13-写操作和读操作">1.3 写操作和读操作&lt;/h4>
&lt;p>写操作有两个接口 &lt;code>rt_ringbuffer_put&lt;/code> 和 &lt;code>rt_ringbuffer_put_force&lt;/code> ，当缓冲区满的时候，前一个不会写入，后一个会强制写入（覆盖）；读操作有一个接口 &lt;code>rt_ringbuffer_get&lt;/code> 。&lt;/p>
&lt;p>这里先说明一下， &lt;strong>RT-Thread&lt;/strong> 的 &lt;strong>ring buffer&lt;/strong> 实现虽然借鉴了上一章讲的 &lt;strong>镜像指示位&lt;/strong> 策略，但其并没有使用读写指针，而是直接用的 &lt;strong>写索引&lt;/strong> 和 &lt;strong>读索引&lt;/strong> ，也就是说结构体中的 &lt;code>read_index&lt;/code> 和 &lt;code>write_index&lt;/code> 就是写索引和读索引，无需进行转换，直接可以用来操作缓冲区。这一点和 &lt;code>linux&lt;/code> 的实现方式不同，在下面的 &lt;code>linux&lt;/code> 章节中会看到。但 &lt;code>read_mirror&lt;/code> 和 &lt;code>write_mirror&lt;/code> 是和 &lt;strong>镜像指示位策略&lt;/strong> 中讲的一样，用来标记是否进入了镜像区间。&lt;/p>
&lt;p>先来看 &lt;code>rt_ringbuffer_put&lt;/code> 的实现，该函数的返回值是实际写入大小，就是如果传入的 &lt;code>length&lt;/code> 大于缓冲区的剩余空间，则 &lt;code>length&lt;/code> 只有部分会被写入缓冲区。&lt;/p>
&lt;ul>
&lt;li>当 &lt;code>if (rb-&amp;gt;buffer_size - rb-&amp;gt;write_index &amp;gt; length)&lt;/code> 为真时，就是说从 &lt;strong>写索引&lt;/strong> 到缓冲区结束位置这一段空间能容纳全部所写入数据。写索引无需回环。对应的代码就是 &lt;code>rt_memcpy(&amp;amp;rb-&amp;gt;buffer_ptr[rb-&amp;gt;write_index], ptr, length);&lt;/code> 。&lt;/li>
&lt;li>当 &lt;code>if (rb-&amp;gt;buffer_size - rb-&amp;gt;write_index &amp;gt; length)&lt;/code> 为假时，就是说从 &lt;strong>写索引&lt;/strong> 到缓冲区结束位置这一段空间无法全部容纳所写入数据，写索引需要回环到缓冲区开头，写入剩下的数据。对应代码就是 &lt;code>rt_memcpy(&amp;amp;rb-&amp;gt;buffer_ptr[rb-&amp;gt;write_index],&amp;amp;ptr[0],rb-&amp;gt;buffer_size - rb-&amp;gt;write_index);&lt;/code> 和 &lt;code>rt_memcpy(&amp;amp;rb-&amp;gt;buffer_ptr[0],&amp;amp;ptr[rb-&amp;gt;buffer_size - rb-&amp;gt;write_index],length - (rb-&amp;gt;buffer_size - rb-&amp;gt;write_index));&lt;/code> 。因为写索引已经回环了，所以要将 &lt;code>write_mirror&lt;/code> 做一下取反操作：&lt;code>rb-&amp;gt;write_mirror = ~rb-&amp;gt;write_mirror;&lt;/code> 。&lt;/li>
&lt;/ul>
&lt;p>写操作接口 &lt;code>rt_ringbuffer_put_force&lt;/code> 和上面介绍的基本一样，其实就是多了当传入的 &lt;code>length&lt;/code> 大于缓冲区的剩余空间时，会将已有的元素覆盖掉。如果发生了元素覆盖，那缓冲区一定会变满，&lt;code>read_index&lt;/code> 和 &lt;code>write_index&lt;/code> 会相等，对应语句 &lt;code>if (length &amp;gt; space_length) rb-&amp;gt;read_index = rb-&amp;gt;write_index;&lt;/code> 。因为会操作 &lt;code>read_index&lt;/code> 元素，也要考虑其是否发生了回环，发生了回环后 &lt;code>read_mirror&lt;/code> 需要取反，对应语句 &lt;code>rb-&amp;gt;read_mirror = ~rb-&amp;gt;read_mirror;&lt;/code>。&lt;/p>
&lt;p>读接口 &lt;code>rt_ringbuffer_get&lt;/code> 和写接口的操作逻辑基本一致，也是通过条件 &lt;code>if (rb-&amp;gt;buffer_size - rb-&amp;gt;write_index &amp;gt; length)&lt;/code> 将读操作分成了两种情形，过程和写操作接口 &lt;code>rt_ringbuffer_put&lt;/code> 没有差异。&lt;/p>
&lt;pre>&lt;code class="language-c">/**
* @brief Put a block of data into the ring buffer. If the capacity of ring buffer is insufficient, it will discard out-of-range data.
*
* @param rb A pointer to the ring buffer object.
* @param ptr A pointer to the data buffer.
* @param length The size of data in bytes.
*
* @return Return the data size we put into the ring buffer.
*/
rt_size_t rt_ringbuffer_put(struct rt_ringbuffer *rb,
const rt_uint8_t *ptr,
rt_uint16_t length)
{
rt_uint16_t size;
RT_ASSERT(rb != RT_NULL);
/* whether has enough space */
size = rt_ringbuffer_space_len(rb);
/* no space */
if (size == 0)
return 0;
/* drop some data */
if (size &amp;lt; length)
length = size;
if (rb-&amp;gt;buffer_size - rb-&amp;gt;write_index &amp;gt; length)
{
/* read_index - write_index = empty space */
rt_memcpy(&amp;amp;rb-&amp;gt;buffer_ptr[rb-&amp;gt;write_index], ptr, length);
/* this should not cause overflow because there is enough space for
* length of data in current mirror */
rb-&amp;gt;write_index += length;
return length;
}
rt_memcpy(&amp;amp;rb-&amp;gt;buffer_ptr[rb-&amp;gt;write_index],
&amp;amp;ptr[0],
rb-&amp;gt;buffer_size - rb-&amp;gt;write_index);
rt_memcpy(&amp;amp;rb-&amp;gt;buffer_ptr[0],
&amp;amp;ptr[rb-&amp;gt;buffer_size - rb-&amp;gt;write_index],
length - (rb-&amp;gt;buffer_size - rb-&amp;gt;write_index));
/* we are going into the other side of the mirror */
rb-&amp;gt;write_mirror = ~rb-&amp;gt;write_mirror;
rb-&amp;gt;write_index = length - (rb-&amp;gt;buffer_size - rb-&amp;gt;write_index);
return length;
}
RTM_EXPORT(rt_ringbuffer_put);
/**
* @brief Put a block of data into the ring buffer. If the capacity of ring buffer is insufficient, it will overwrite the existing data in the ring buffer.
*
* @param rb A pointer to the ring buffer object.
* @param ptr A pointer to the data buffer.
* @param length The size of data in bytes.
*
* @return Return the data size we put into the ring buffer.
*/
rt_size_t rt_ringbuffer_put_force(struct rt_ringbuffer *rb,
const rt_uint8_t *ptr,
rt_uint16_t length)
{
rt_uint16_t space_length;
RT_ASSERT(rb != RT_NULL);
space_length = rt_ringbuffer_space_len(rb);
if (length &amp;gt; rb-&amp;gt;buffer_size)
{
ptr = &amp;amp;ptr[length - rb-&amp;gt;buffer_size];
length = rb-&amp;gt;buffer_size;
}
if (rb-&amp;gt;buffer_size - rb-&amp;gt;write_index &amp;gt; length)
{
/* read_index - write_index = empty space */
rt_memcpy(&amp;amp;rb-&amp;gt;buffer_ptr[rb-&amp;gt;write_index], ptr, length);
/* this should not cause overflow because there is enough space for
* length of data in current mirror */
rb-&amp;gt;write_index += length;
if (length &amp;gt; space_length)
rb-&amp;gt;read_index = rb-&amp;gt;write_index;
return length;
}
rt_memcpy(&amp;amp;rb-&amp;gt;buffer_ptr[rb-&amp;gt;write_index],
&amp;amp;ptr[0],
rb-&amp;gt;buffer_size - rb-&amp;gt;write_index);
rt_memcpy(&amp;amp;rb-&amp;gt;buffer_ptr[0],
&amp;amp;ptr[rb-&amp;gt;buffer_size - rb-&amp;gt;write_index],
length - (rb-&amp;gt;buffer_size - rb-&amp;gt;write_index));
/* we are going into the other side of the mirror */
rb-&amp;gt;write_mirror = ~rb-&amp;gt;write_mirror;
rb-&amp;gt;write_index = length - (rb-&amp;gt;buffer_size - rb-&amp;gt;write_index);
if (length &amp;gt; space_length)
{
if (rb-&amp;gt;write_index &amp;lt;= rb-&amp;gt;read_index)
rb-&amp;gt;read_mirror = ~rb-&amp;gt;read_mirror;
rb-&amp;gt;read_index = rb-&amp;gt;write_index;
}
return length;
}
RTM_EXPORT(rt_ringbuffer_put_force);
/**
* @brief Get data from the ring buffer.
*
* @param rb A pointer to the ring buffer.
* @param ptr A pointer to the data buffer.
* @param length The size of the data we want to read from the ring buffer.
*
* @return Return the data size we read from the ring buffer.
*/
rt_size_t rt_ringbuffer_get(struct rt_ringbuffer *rb,
rt_uint8_t *ptr,
rt_uint16_t length)
{
rt_size_t size;
RT_ASSERT(rb != RT_NULL);
/* whether has enough data */
size = rt_ringbuffer_data_len(rb);
/* no data */
if (size == 0)
return 0;
/* less data */
if (size &amp;lt; length)
length = size;
if (rb-&amp;gt;buffer_size - rb-&amp;gt;read_index &amp;gt; length)
{
/* copy all of data */
rt_memcpy(ptr, &amp;amp;rb-&amp;gt;buffer_ptr[rb-&amp;gt;read_index], length);
/* this should not cause overflow because there is enough space for
* length of data in current mirror */
rb-&amp;gt;read_index += length;
return length;
}
rt_memcpy(&amp;amp;ptr[0],
&amp;amp;rb-&amp;gt;buffer_ptr[rb-&amp;gt;read_index],
rb-&amp;gt;buffer_size - rb-&amp;gt;read_index);
rt_memcpy(&amp;amp;ptr[rb-&amp;gt;buffer_size - rb-&amp;gt;read_index],
&amp;amp;rb-&amp;gt;buffer_ptr[0],
length - (rb-&amp;gt;buffer_size - rb-&amp;gt;read_index));
/* we are going into the other side of the mirror */
rb-&amp;gt;read_mirror = ~rb-&amp;gt;read_mirror;
rb-&amp;gt;read_index = length - (rb-&amp;gt;buffer_size - rb-&amp;gt;read_index);
return length;
}
RTM_EXPORT(rt_ringbuffer_get);
&lt;/code>&lt;/pre>
&lt;h4 id="14-判断缓冲区是否为空或满">1.4 判断缓冲区是否为空或满&lt;/h4>
&lt;p>判断缓冲区是否为空或满，通过函数 &lt;code>rt_ringbuffer_status&lt;/code> 来实现。其逻辑是：在读写指针的值相同情况下，如果二者的指示位相同，说明缓冲区 &lt;strong>为空&lt;/strong> ；如果二者的指示位不同，说明缓冲区 &lt;strong>为满&lt;/strong> 。注意这里的读写指针已经在读写( &lt;code>rt_ringbuffer_get&lt;/code> 和 &lt;code>rt_ringbuffer_put&lt;/code> )过程中转换为了读写索引。&lt;/p>
&lt;pre>&lt;code class="language-c">rt_inline enum rt_ringbuffer_state rt_ringbuffer_status(struct rt_ringbuffer *rb)
{
if (rb-&amp;gt;read_index == rb-&amp;gt;write_index)
{
if (rb-&amp;gt;read_mirror == rb-&amp;gt;write_mirror)
return RT_RINGBUFFER_EMPTY;
else
return RT_RINGBUFFER_FULL;
}
return RT_RINGBUFFER_HALFFULL;
}
&lt;/code>&lt;/pre>
&lt;h4 id="小结">小结&lt;/h4>
&lt;ul>
&lt;li>在多线程中，对同一个环形缓冲区进行读写操作时，需要加上锁，不然存在访问不安全问题；&lt;/li>
&lt;li>当只有一个读线程和一个写线程（单生产者单消费者模型）时，用 &lt;code>rt_ringbuffer_put&lt;/code> 和 &lt;code>rt_ringbuffer_get&lt;/code> 进行读写操作缓冲区是线程安全的，无需加锁；但是 &lt;code>rt_ringbuffer_put_force&lt;/code> 不行，因为其可能对 &lt;strong>读写索引&lt;/strong> 都进行操作的场景，这个时候再进行 &lt;code>rt_ringbuffer_get&lt;/code> 读操作，就是不安全访问；&lt;/li>
&lt;li>读写指针已经在读写( &lt;code>rt_ringbuffer_get&lt;/code> 和 &lt;code>rt_ringbuffer_put&lt;/code> )过程中转换为了读写索引。所以 &lt;code>read_index&lt;/code>(读索引)和 &lt;code>write_index&lt;/code> (写索引)可以直接用来操作缓冲区，无需转换；&lt;/li>
&lt;li>&lt;code>read_index&lt;/code> 和 &lt;code>write_index&lt;/code> 的大小区间为$[0, n-1]$ ， $n$ 为缓冲区大小；&lt;/li>
&lt;li>&lt;strong>RT-Thread&lt;/strong> 的环形缓冲区不需要 &lt;code>buffer&lt;/code> 大小为 &lt;strong>2 的幂&lt;/strong> 。&lt;/li>
&lt;/ul>
&lt;h3 id="2-linux-中实现的-ring-buffer">2. Linux 中实现的 ring buffer&lt;/h3>
&lt;p>在 &lt;code>linux&lt;/code> 内核中， &lt;code>kfifo&lt;/code> 就是 &lt;strong>ring buffer&lt;/strong> 的经典实现方式，本文将介绍 &lt;code>linux 2.6&lt;/code> 版本中的 &lt;strong>ring buffer&lt;/strong> 实现方式，主要介绍 &lt;strong>缓冲区结构体&lt;/strong> 、 &lt;strong>缓冲区初始化&lt;/strong> 、 &lt;strong>读操作&lt;/strong> 、 &lt;strong>写操作&lt;/strong> 、 &lt;strong>判断缓冲区是否为空或满&lt;/strong> 。&lt;/p>
&lt;h4 id="21-缓冲区结构体">2.1 缓冲区结构体&lt;/h4>
&lt;p>&lt;code>kfifo&lt;/code> 的 &lt;strong>ring buffer&lt;/strong> 结构体定义如下，其中 &lt;code>buffer、size、in、out&lt;/code> 环形缓冲区 4 个信息是一一对应的。但其中 &lt;code>in&lt;/code> 、 &lt;code>out&lt;/code> 分别是 &lt;strong>写指针&lt;/strong> 和 &lt;strong>读指针&lt;/strong> ，而不是 &lt;strong>写索引&lt;/strong> 和 &lt;strong>读索引&lt;/strong> 。参数 &lt;code>lock&lt;/code> 是自旋锁，在多进程/线程对同一个环形缓冲区进行读写操作时，需要进行锁保护。和 &lt;strong>RT-Thread&lt;/strong> 对比，可以看到其并没有读写的 &lt;strong>镜像指示位&lt;/strong> 。&lt;/p>
&lt;pre>&lt;code class="language-c">struct kfifo {
unsigned char *buffer; /* the buffer holding the data */
unsigned int size; /* the size of the allocated buffer */
unsigned int in; /* data is added at offset (in % size) */
unsigned int out; /* data is extracted from off. (out % size) */
spinlock_t *lock; /* protects concurrent modifications */
};
&lt;/code>&lt;/pre>
&lt;h4 id="22-缓冲区初始化">2.2 缓冲区初始化&lt;/h4>
&lt;p>在 &lt;code>kfifo&lt;/code> 的初始化 &lt;code>kfifo_init&lt;/code> 中可以看出，其会对所传入的 &lt;code>size&lt;/code> 大小进行扩展，使其满足 &lt;code>size&lt;/code> 为 &lt;strong>2 的幂&lt;/strong> 。这样就可以使用性质： &lt;strong>如果缓冲区的长度是 2 的幂 ，则可以省略镜像指示位。如果读写指针的值相等，则缓冲区为空；如果读写指针相差 n(缓冲区大小)，则缓冲区为满&lt;/strong> 。所以在传入 &lt;code>buffer&lt;/code> 的 &lt;code>size&lt;/code> 大小时，最好开始就将其确定为 &lt;strong>2 的幂&lt;/strong> 。&lt;/p>
&lt;pre>&lt;code class="language-c">struct kfifo *kfifo_init(unsigned char *buffer, unsigned int size,
int gfp_mask, spinlock_t *lock)
{
struct kfifo *fifo;
/* size must be a power of 2 */
BUG_ON(size &amp;amp; (size - 1));
fifo = kmalloc(sizeof(struct kfifo), gfp_mask);
if (!fifo)
return ERR_PTR(-ENOMEM);
fifo-&amp;gt;buffer = buffer;
fifo-&amp;gt;size = size;
fifo-&amp;gt;in = fifo-&amp;gt;out = 0;
fifo-&amp;gt;lock = lock;
return fifo;
}
&lt;/code>&lt;/pre>
&lt;h4 id="23-读操作和写操作">2.3 读操作和写操作&lt;/h4>
&lt;p>可以看到 &lt;code>kfifo&lt;/code> 对读操作和写操作的实现非常简洁。在进行读操作和写操作时，其充分利用了无符号整型的性质。在 &lt;code>__kfifo_put&lt;/code> (写操作)和 &lt;code>__kfifo_get&lt;/code> (读操作)时， &lt;code>in&lt;/code> (写指针)和 &lt;code>out&lt;/code> (读指针)都是正向增加的，当达到最大值时，产生溢出，使得从 &lt;code>0&lt;/code> 开始，进行循环使用。 &lt;strong>in(写指针)&lt;/strong> 和 &lt;strong>out(读指针)&lt;/strong> 会恒定的保持如下关系：&lt;/p>
&lt;ul>
&lt;li>读指针 + 缓冲区已存储数据长度 = 写指针&lt;/li>
&lt;/ul>
&lt;p>其中读指针是 &lt;code>out&lt;/code> ，写指针是 &lt;code>in&lt;/code> 。 &lt;strong>out(读指针)&lt;/strong> 永远不会超过 &lt;strong>in(写指针)&lt;/strong> 的大小，最多两者相等，相等就是缓冲区为空的时候。&lt;/p>
&lt;p>先看 &lt;code>__kfifo_put&lt;/code> 的源码。 &lt;code>len = min(len, fifo-&amp;gt;size - fifo-&amp;gt;in + fifo-&amp;gt;out);&lt;/code> 中表达的意思就是实际写入的长度一定要小于缓冲区的可用空间大小，防止发生覆盖已有元素的场景。来看这一句 &lt;code>l = min(len, fifo-&amp;gt;size - (fifo-&amp;gt;in &amp;amp; (fifo-&amp;gt;size - 1)));&lt;/code> ，其中 &lt;code>(fifo-&amp;gt;in &amp;amp; (fifo-&amp;gt;size - 1))&lt;/code> 就是将 &lt;strong>in(写指针)&lt;/strong> 转换为写索引，整体表达的意思是从 &lt;strong>写索引&lt;/strong> 到缓冲区结束位置这一段所能写入数据的大小，这一段写入操作的代码为 &lt;code>memcpy(fifo-&amp;gt;buffer + (fifo-&amp;gt;in &amp;amp; (fifo-&amp;gt;size - 1)), buffer, l);&lt;/code> 。如果这一段还不够，需要折返到缓冲区的开始位置，将剩下的部分写入到缓冲区中，其代码为 &lt;code>memcpy(fifo-&amp;gt;buffer, buffer + l, len - l);&lt;/code> 。而且 $len &amp;gt;= l$, 当 $len=l$ 就说明第一段已经可以容纳所写入大小，缓冲区无需折返，第二个 &lt;code>memcpy&lt;/code> 拷贝了零个字节，相当于什么也没有发生。&lt;/p>
&lt;p>再看 &lt;code>__kfifo_get&lt;/code> 的源码。其思路基本和 &lt;code>__kfifo_put&lt;/code> 一致，了解了上面的转换关系，就比较好理解：&lt;/p>
&lt;pre>&lt;code class="language-c">/*
* __kfifo_put - puts some data into the FIFO, no locking version
* @fifo: the fifo to be used.
* @buffer: the data to be added.
* @len: the length of the data to be added.
*
* This function copies at most 'len' bytes from the 'buffer' into
* the FIFO depending on the free space, and returns the number of
* bytes copied.
*
* Note that with only one concurrent reader and one concurrent
* writer, you don't need extra locking to use these functions.
*/
unsigned int __kfifo_put(struct kfifo *fifo,
unsigned char *buffer, unsigned int len)
{
unsigned int l;
len = min(len, fifo-&amp;gt;size - fifo-&amp;gt;in + fifo-&amp;gt;out);
/* first put the data starting from fifo-&amp;gt;in to buffer end */
l = min(len, fifo-&amp;gt;size - (fifo-&amp;gt;in &amp;amp; (fifo-&amp;gt;size - 1)));
memcpy(fifo-&amp;gt;buffer + (fifo-&amp;gt;in &amp;amp; (fifo-&amp;gt;size - 1)), buffer, l);
/* then put the rest (if any) at the beginning of the buffer */
memcpy(fifo-&amp;gt;buffer, buffer + l, len - l);
fifo-&amp;gt;in += len;
return len;
}
EXPORT_SYMBOL(__kfifo_put);
unsigned int __kfifo_get(struct kfifo *fifo,
unsigned char *buffer, unsigned int len)
{
unsigned int l;
len = min(len, fifo-&amp;gt;in - fifo-&amp;gt;out);
/* first get the data from fifo-&amp;gt;out until the end of the buffer */
l = min(len, fifo-&amp;gt;size - (fifo-&amp;gt;out &amp;amp; (fifo-&amp;gt;size - 1)));
memcpy(buffer, fifo-&amp;gt;buffer + (fifo-&amp;gt;out &amp;amp; (fifo-&amp;gt;size - 1)), l);
/* then get the rest (if any) from the beginning of the buffer */
memcpy(buffer + l, fifo-&amp;gt;buffer, len - l);
fifo-&amp;gt;out += len;
return len;
}
EXPORT_SYMBOL(__kfifo_get);
&lt;/code>&lt;/pre>
&lt;h4 id="24-判断缓冲区是否为空或满">2.4 判断缓冲区是否为空或满&lt;/h4>
&lt;p>&lt;code>kfifo&lt;/code> 中没有专门的函数判断缓冲区是否为空或满，但可以通过 &lt;code>__kfifo_len&lt;/code> 函数获取 &lt;strong>缓冲区已存储数据长度&lt;/strong> 。如果其值等于零就说明缓冲区为空，如果其值等于缓冲区大小，就说明缓冲区满。&lt;/p>
&lt;pre>&lt;code class="language-c">static inline unsigned int __kfifo_len(struct kfifo *fifo)
{
return fifo-&amp;gt;in - fifo-&amp;gt;out;
}
&lt;/code>&lt;/pre>
&lt;h4 id="小结-1">小结&lt;/h4>
&lt;ul>
&lt;li>&lt;code>linux&lt;/code> 中环形缓冲区（ring buffer）的实现，其实是对 &lt;strong>镜像指示位&lt;/strong> 策略的扩展，读指针和写指针区间范围不再局限在镜像区间 $[0, 2n-1]$ ，而是整个 unsigned int 大小的空间，对于 32 位机器，读指针和写指针的区间范围是 $[0, 2^{32} - 1]$ ;&lt;/li>
&lt;li>进行扩展后，还能维持如下的关系，是因为缓冲区大小 &lt;code>n&lt;/code> 会被扩展为 &lt;strong>2 的幂&lt;/strong> ，那么 $2^32$ 肯定是 $n$ 扩展后的整数倍，所以还是能够满足如下关系；
&lt;ul>
&lt;li>读索引 = 读指针 &amp;amp; (缓冲区长度 - 1)&lt;/li>
&lt;li>写索引 = 写指针 &amp;amp; (缓冲区长度 - 1)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>读索引和写索引的区间范围仍然是 $[0, n-1]$ ， $n$ 为缓冲区大小；&lt;/li>
&lt;li>在多进程/线程中，对同一个环形缓冲区进行读写操作时，需要加上锁，不然存在访问不安全问题；&lt;/li>
&lt;li>当只有一个读进程/线程和一个写进程/线程时，无需加锁，也能保证访问安全。&lt;/li>
&lt;/ul>
&lt;h3 id="3-517版本的-linux-中实现的-ring-buffer">3. 5.17+版本的 Linux 中实现的 ring buffer&lt;/h3>
&lt;p>在 &lt;code>linux5.17+&lt;/code> 版本中的 &lt;code>kfifo.c&lt;/code> 和 &lt;code>kfifo.h&lt;/code> 中，其源码实现已经和 &lt;code>linux 2.6&lt;/code> 版本有很大的不同，但是最新版本的 &lt;strong>ring buffer&lt;/strong> 核心思想和 &lt;code>linux 2.6&lt;/code> 版本并没有不同。&lt;/p>
&lt;p>&lt;code>kfifo.h&lt;/code> 文件中定义的 ring buffer 结构体，其中 &lt;code>in&lt;/code> 、 &lt;code>out&lt;/code> 依然是 &lt;strong>写指针&lt;/strong> 和 &lt;strong>读指针&lt;/strong> ，&lt;code>mask&lt;/code> 是缓冲区大小减 1（做&amp;amp;操作，更方便的将读写指针转换为 &lt;strong>读写索引&lt;/strong> ）， &lt;code>esize&lt;/code> 缓冲区单个存储元素的字节大小(在 &lt;code>linux 2.6&lt;/code> 版本中，一个元素就是一个字节大小，最新版本将其进行了扩展)， &lt;code>data&lt;/code> 缓冲区的逻辑起始地址（指针类型不再是字节）。其它的 &lt;strong>初始化接口&lt;/strong> 、 &lt;strong>读接口&lt;/strong> 、 &lt;strong>写接口&lt;/strong> 、 &lt;strong>判断缓冲区是否为空或满接口逻辑&lt;/strong> 和 &lt;code>linux 2.6&lt;/code> 大致差不多，可以对照源码看一下。&lt;/p>
&lt;pre>&lt;code class="language-c">struct __kfifo {
unsigned int in;
unsigned int out;
unsigned int mask;
unsigned int esize;
void *data;
};
&lt;/code>&lt;/pre>
&lt;h2 id="四总结">四、总结&lt;/h2>
&lt;ul>
&lt;li>环形缓冲区（ring buffer）适合于事先明确了缓冲区的最大容量的情形。缓冲区的容量（长度）一般固定，可以用一个静态数组来充当缓冲区，无需重复申请内存；&lt;/li>
&lt;li>如果缓冲区的大小需要经常调整，就不适合用环形缓存区，因为在扩展缓冲区大小时，需要搬移其中的数据，这种场合使用链表更加合适；&lt;/li>
&lt;li>因为缓冲区成头尾相连的环形，写操作可能会覆盖未及时读取的数据，有的场景允许这种情况发生，有的场景又严格限制这种情况发生。选择何种策略和具体应用场景相关；&lt;/li>
&lt;li>环形缓冲区（ring buffer）特别适合于通信双方循环发送数据的场景；&lt;/li>
&lt;li>镜像指示位是一种高效判断缓冲区是否为空或满的策略，在 &lt;strong>RT-Thread&lt;/strong> 和 &lt;strong>linux&lt;/strong> 中都使用了该策略（或者是该策略的扩展），其能够保证在只有一个读线程（或进程）和一个写线程（或进程）中无需锁也能做到线程安全；&lt;/li>
&lt;li>注意区分写指针和写索引，读指针和读索引，最终对缓冲区进行操作还是需要写索引和读索引；&lt;/li>
&lt;li>如果自己嵌入式项目中需要使用环形缓冲区（ring buffer），可以借鉴 &lt;code>linux 2.6&lt;/code> 版本的 &lt;code>kfifo&lt;/code> 实现，很容易改写，而且非常高效。&lt;/li>
&lt;/ul>
&lt;h2 id="五参考资料">五、参考资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/Circular_buffer" target="_blank" rel="noopener" >环形缓冲区
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/li>
&lt;li>&lt;a class="link" href="https://zhuanlan.zhihu.com/p/534098236" target="_blank" rel="noopener" >ring buffer，一篇文章讲透它？
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/li>
&lt;/ul></description></item><item><title>性能刺客之伪共享</title><link>https://cuterwrite.top/p/false-sharing/</link><pubDate>Sat, 02 Dec 2023 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/false-sharing/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/6c3f8961290e41f894f5a1cbb768aba9-2023-12-02.webp" alt="Featured image of post 性能刺客之伪共享" />&lt;h1 id="性能刺客之伪共享">性能刺客之伪共享&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>在多核并发编程中，如果将互斥锁的争用比作 &lt;strong>性能杀手&lt;/strong> 的话，那么伪共享则相当于 &lt;strong>性能刺客&lt;/strong>。&lt;strong>杀手&lt;/strong> 与 &lt;strong>刺客&lt;/strong> 的区别在于杀手是可见的，遇到杀手时我们可以选择战斗、逃跑、绕路、求饶等多种手段去应付，但 &lt;strong>刺客&lt;/strong> 却不同， &lt;strong>刺客&lt;/strong> 永远隐藏在暗处，伺机给你致命一击，防不胜防。具体到我们的并发编程中，遇到锁争用影响并发性能情况时，我们可以采取多种措施（如缩短临界区，原子操作等等）去提高程序性能，但是伪共享却是我们从所写代码中看不出任何蛛丝马迹的，发现不了问题也就无法解决问题，从而导致伪共享在暗处严重拖累程序的并发性能，但我们却束手无策。&lt;/p>
&lt;h2 id="二缓存行">二、缓存行&lt;/h2>
&lt;p>为了进行下面的讨论，我们需要首先熟悉缓存行的概念，学过操作系统课程存储结构这部分内容的同学应该对存储器层次结构的金字塔模型印象深刻，金字塔从上往下代表存储介质的成本降低、容量变大，从下往上则代表存取速度的提高。位于金字塔模型最上层的是 CPU 中的寄存器，其次是 CPU 缓存（L1，L2，L3），再往下是内存，最底层是磁盘，操作系统采用这种存储层次模型主要是为了解决 CPU 的高速与内存磁盘低速之间的矛盾，CPU 将最近使用的数据预先读取到 Cache 中，下次再访问同样数据的时候，可以直接从速度比较快的 CPU 缓存中读取，避免从内存或磁盘读取拖慢整体速度。&lt;/p>
&lt;p>CPU 缓存的最小单位就是缓存行，缓存行大小依据架构不同有不同大小，最常见的有 &lt;code>64Byte&lt;/code> 和 &lt;code>32Byte&lt;/code> ，CPU 缓存从内存取数据时以缓存行为单位进行，每一次都取需要读取数据所在的整个缓存行，即使相邻的数据没有被用到也会被缓存到 CPU 缓存中。&lt;/p>
&lt;h2 id="三缓存一致性">三、缓存一致性&lt;/h2>
&lt;p>在单核 CPU 情况下，上述方法可以正常工作，可以确保缓存到 CPU 缓存中的数据永远是 &lt;strong>干净&lt;/strong> 的，因为不会有其他 CPU 去更改内存中的数据，但是在多核 CPU 下，情况就变得更加复杂一些。多 CPU 中，每个 CPU 都有自己的私有缓存（可能共享 L3 缓存），当一个 CPU1 对 Cache 中缓存数据进行操作时，如果 CPU2 在此之前更改了该数据，则 CPU1 中的数据就不再是 &lt;strong>干净&lt;/strong> 的，即应该是失效数据，缓存一致性就是为了保证多 CPU 之间的缓存一致。&lt;/p>
&lt;p>Linux 系统中采用 &lt;code>MESI&lt;/code> 协议处理缓存一致性，所谓 &lt;code>MESI&lt;/code> 即是指 CPU 缓存的四种状态：&lt;/p>
&lt;ul>
&lt;li>M（修改，Modified）：本地处理器已经修改缓存行，即是脏行，它的内容与内存中的内容不一样，并且此 cache 只有本地一个拷贝(专有)；&lt;/li>
&lt;li>E（专有，Exclusive）：缓存行内容和内存中的一样，而且其它处理器都没有这行数据；&lt;/li>
&lt;li>S（共享，Shared）：缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝；&lt;/li>
&lt;li>I（无效，Invalid）：缓存行失效, 不能使用。&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20231202205445-2023-12-02.webp"
alt="20231202205445-2023-12-02" width="auto" loading="lazy">
&lt;/figure>
&lt;p>每个 CPU 缓存行都在四个状态之间互相转换，以此决定 CPU 缓存是否失效，比如 CPU1 对一个缓存行执行了写入操作，则此操作会导致其他 CPU 的该缓存行进入 Invalid 无效状态， CPU 需要使用该缓存行的时候需要从内存中重新读取。由此就解决了多 CPU 之间的缓存一致性问题。&lt;/p>
&lt;h2 id="四伪共享">四、伪共享&lt;/h2>
&lt;p>何谓伪共享？上面我们提过 CPU 的缓存是 &lt;strong>以缓存行为单位&lt;/strong> 进行的，即除了本身所需读写的数据之外还会缓存与该数据在同一缓存行的数据，假设缓存行大小是 32 字节，内存中有 &lt;code>abcdefgh&lt;/code> 八个 int 型数据，当 CPU 读取 &lt;code>d&lt;/code> 这个数据时， CPU 会将 &lt;code>abcdefgh&lt;/code> 八个 int 数据组成一个缓存行加入到 CPU 缓存中。假设计算机有两个 CPU：CPU1 和 CPU2 ， CPU1 只对 &lt;code>a&lt;/code> 这个数据进行频繁读写， CPU2 只对 &lt;code>b&lt;/code> 这个数据进行频繁读写，按理说这两个 CPU 读写数据没有任何关联，也就不会产生任何竞争，不会有性能问题，但是由于 CPU 缓存是以缓存行为单位进行存取的，也是以缓存行为单位失效的，即使 CPU1 只更改了缓存行中 &lt;code>a&lt;/code> 数据，也会导致 CPU2 中该缓存行完全失效，同理，CPU2 对&lt;code> b&lt;/code> 的改动也会导致 CPU1 中该缓存行失效，由此引发了该缓存行在两个 CPU 之间 &lt;strong>乒乓&lt;/strong> ，缓存行频繁失效，最终导致程序性能下降，这就是伪共享。&lt;/p>
&lt;p>下面是维基百科的定义：&lt;/p>
&lt;blockquote>
&lt;p>In computer science, &lt;strong>false sharing&lt;/strong> is a performance-degrading usage pattern that can arise in systems with distributed, coherent caches at the size of the smallest resource block managed by the caching mechanism. When a system participant attempts to periodically access data that is not being altered by another party, but that data shares a cache block with data that is being altered, the caching protocol may force the first participant to reload the whole cache block despite a lack of logical necessity. The caching system is unaware of activity within this block and forces the first participant to bear the caching system overhead required by true shared access of a resource.&lt;/p>
&lt;p>在计算机科学中，伪共享是一种性能降低的使用模式，可能出现在具有分布式、一致性缓存的系统中，缓存大小为缓存机制管理的最小资源块。当一个系统参与者试图定期访问未被其他方修改的数据，但该数据与正在被修改的数据共享一个缓存块时，缓存协议可能会强制第一个参与者重新加载整个缓存块，尽管在逻辑上没有必要。 缓存系统无法感知这个块内的活动，并强制第一个参与者承担由真正共享资源访问所需的缓存系统开销。&lt;/p>
&lt;/blockquote>
&lt;h2 id="五如何避免伪共享">五、如何避免伪共享&lt;/h2>
&lt;p>避免伪共享主要有以下两种方式：&lt;/p>
&lt;ul>
&lt;li>缓存行填充（Padding）：为了避免伪共享就需要将可能造成伪共享的多个变量处于不同的缓存行中，可以采用在变量后面填充字节的方式达到该目的。&lt;/li>
&lt;li>使用某些语言或编译器中强制变量对齐，将变量都对齐到缓存行大小，避免伪共享发生。&lt;/li>
&lt;/ul>
&lt;h2 id="六获取缓存行大小">六、获取缓存行大小&lt;/h2>
&lt;p>在 C++11 中，可以使用 &lt;code>std::hardware_destructive_interference_size&lt;/code> 和 &lt;code>std::hardware_constructive_interference_size&lt;/code> 获取缓存行大小，前者获取的是缓存行大小，后者获取的是缓存行大小的两倍，即 &lt;code>2 * std::hardware_destructive_interference_size&lt;/code>。&lt;/p>
&lt;p>在 C 语言中，可以读取 &lt;code>coherency_line_size&lt;/code> 文件获取缓存行大小，该文件位于 &lt;code>/sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size&lt;/code> ，该文件中存储的是缓存行大小的字节数，可以使用 &lt;code>cat&lt;/code> 命令查看。也可以通过 &lt;code>long cache_line_size = sysconf(_SC_LEVEL1_DCACHE_LINESIZE)&lt;/code> 的方式获取。&lt;/p>
&lt;h2 id="七通过对齐解决伪共享">七、通过对齐解决伪共享&lt;/h2>
&lt;p>C 语言中可以使用 &lt;code>posix_memalign&lt;/code> 函数来实现对齐，该函数的声明如下：&lt;/p>
&lt;pre>&lt;code class="language-c">int posix_memalign(void **memptr, size_t alignment, size_t size);
&lt;/code>&lt;/pre>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>一般伪共享都很隐蔽，很难被发现，当伪共享真正构成性能瓶颈的时候，我们有必要去努力找到并解决它，但是在大部分对性能追求没有那么高的应用中，伪共享的存在对程序的危害很小，有时并不值得耗费精力和额外的内存空间（缓存行填充）去查找系统存在的伪共享。还是那句我们一直以来应该遵循的原则 &lt;strong>“不要过度优化，不要提前优化。”&lt;/strong> 。&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a class="link" href="https://zhuanlan.zhihu.com/p/37069591" target="_blank" rel="noopener" >C++性能榨汁机之伪共享
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/li>
&lt;/ul></description></item><item><title>程序调试与优化分析工具</title><link>https://cuterwrite.top/p/debug-and-optimize/</link><pubDate>Wed, 02 Aug 2023 01:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/debug-and-optimize/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/1c86d46879544786889dcdbaa1cf158f1fb36107.jpg@1256w_1774h_!web-article-pic.webp" alt="Featured image of post 程序调试与优化分析工具" />&lt;h1 id="程序调试与优化分析工具">程序调试与优化分析工具&lt;/h1>
&lt;h2 id="一概述">一、概述&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>在编程中我们通常会遇到如下问题：&lt;/p>
&lt;ol>
&lt;li>程序运行慢，效率低&lt;/li>
&lt;li>消耗了大量的内存&lt;/li>
&lt;li>segmentation fault&lt;/li>
&lt;li>程序崩溃&lt;/li>
&lt;li>程序运行结果不正确&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>随着处理器复杂度的增加&lt;/p>
&lt;ul>
&lt;li>我们不再能够轻松地跟踪代码段的执行
&lt;ul>
&lt;li>静态/动态分支预测、预取、顺序调度&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>仅使用墙钟时间来衡量代码性能是不够的。&lt;/li>
&lt;li>我们还需要了解到底发生了什么&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>对于性能评估，有直接和间接两种方法&lt;/p>
&lt;ul>
&lt;li>直接方法：需要某些形式的显示插装
&lt;ul>
&lt;li>追踪
&lt;ul>
&lt;li>为每个测量事件生成记录&lt;/li>
&lt;li>只有在产生大量数据情况下，出现的性能异常数据才有用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>聚合
&lt;ul>
&lt;li>减少数据在运行时平均/最小/最大测量&lt;/li>
&lt;li>适用于应用程序和体系结构和描述和优化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>间接方法：不需要插装，可不修改应用程序&lt;/li>
&lt;li>事实上，直接和间接方法的界限有些模糊
&lt;ul>
&lt;li>聚合：如 gprof，可以不修改程序，但是需要重新编译链接&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>实际编程中，常见的分析工具如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">类型&lt;/th>
&lt;th style="text-align:center">工具&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">程序调试&lt;/td>
&lt;td style="text-align:center">gdb&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">程序调试&lt;/td>
&lt;td style="text-align:center">valgrind&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">程序优化&lt;/td>
&lt;td style="text-align:center">gprof&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">程序优化&lt;/td>
&lt;td style="text-align:center">perf&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">程序优化&lt;/td>
&lt;td style="text-align:center">Intel VTune Amplifier&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;h2 id="二程序调试分析工具简介">二、程序调试分析工具简介&lt;/h2>
&lt;ul>
&lt;li>程序中的错误按其性质可以分为三种：
&lt;ul>
&lt;li>&lt;strong>编译错误&lt;/strong> ：即语法错误，主要是程序代码中有不符合所用编程语言语法规则的错误。&lt;/li>
&lt;li>&lt;strong>运行时错误&lt;/strong> ：如对负数开平方、除数为 0、循环终止条件永远不能达到等。&lt;/li>
&lt;li>&lt;strong>逻辑错误&lt;/strong> ：这类错误往往是编程前对求解的问题理解不正确或算法不正确引起的，它们很难查找（数组越界、空指针）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>程序调试就是查找程序中的错误，诊断其准确位置，并予以改正。&lt;/li>
&lt;/ul>
&lt;h3 id="1-gdb">1. gdb&lt;/h3>
&lt;ul>
&lt;li>GDB 是 GNU 开源组织发布的一个强大的 UNIX 下的程序调试工具&lt;/li>
&lt;li>GDB 具备如下 4 个方面的功能：
&lt;ul>
&lt;li>启动程序，可以按用户要求影响程序的运行行为&lt;/li>
&lt;li>可以让被调试的程序在用户所指定的断点处暂停（断点可以是条件表达式）&lt;/li>
&lt;li>当程序被暂停时，可以检查此时用户程序中所发生的事情&lt;/li>
&lt;li>动态改变用户程序的执行环境，这样就可以先纠正一个错误的影响，然后再纠正其他错误&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>为了发挥 GDB 的全部功能，需要在编译源程序时使用&lt;code>-g&lt;/code> 选项&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gcc -g test.c -o proc
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>启动 GDB，以参数形式将可执行程序传递给 GDB&lt;/p>
&lt;ul>
&lt;li>gdb program&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gdb ./proc
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>gdb -p pid&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gdb -p `pidof proc`
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>gdb program core&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gdb ./proc core.xxx
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>gdb attach pid&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gdb attach 2313
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>启动 gdb 后就显示其提示符：（gdb），并等待用户输入相应的内部命令&lt;/p>
&lt;ul>
&lt;li>设置断点、设置运行参数和环境变量、跟踪调试命令、查看栈信息……&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>用户可以利用命令 quit 终止其执行，退出 gdb 环境&lt;/p>
&lt;/li>
&lt;li>
&lt;p>gdb 常用命令列表如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>命令&lt;/th>
&lt;th>解释&lt;/th>
&lt;th>简写&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>file&lt;/td>
&lt;td>装入想要调试的可执行文件&lt;/td>
&lt;td>无&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>list&lt;/td>
&lt;td>列出产生执行文件源代码的一部分&lt;/td>
&lt;td>l&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>next&lt;/td>
&lt;td>执行一行源代码但不进入函数内部&lt;/td>
&lt;td>n&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>step&lt;/td>
&lt;td>执行一行源代码而且进入函数内部&lt;/td>
&lt;td>s&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>run&lt;/td>
&lt;td>执行当前被调试的程序&lt;/td>
&lt;td>r&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>continue&lt;/td>
&lt;td>继续执行程序&lt;/td>
&lt;td>c&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>quit&lt;/td>
&lt;td>终止 GDB&lt;/td>
&lt;td>q&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>print&lt;/td>
&lt;td>输出当前指定变量的值&lt;/td>
&lt;td>p&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>break&lt;/td>
&lt;td>在代码里设置断点&lt;/td>
&lt;td>b&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>info break&lt;/td>
&lt;td>查看设置断点的信息&lt;/td>
&lt;td>ib&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>delete&lt;/td>
&lt;td>删除设置的断点&lt;/td>
&lt;td>d&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>watch&lt;/td>
&lt;td>监视一个变量的值，一旦值有变化，程序停住&lt;/td>
&lt;td>wa&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>help&lt;/td>
&lt;td>GDB 中的帮助命令&lt;/td>
&lt;td>h&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>设置断点：&lt;/p>
&lt;ul>
&lt;li>编译源程序时需要使用&lt;code>-g&lt;/code> 选项&lt;/li>
&lt;li>在 GDB 中用 break 命令（其缩写形式为 b）设置断点：
&lt;ul>
&lt;li>break linenum 在当前文件指定行 linenum 处设置断点，停在该行开头&lt;/li>
&lt;li>break linenum if condition 在当前文件指定行 linenum 处设置断点，但仅在条件表达式 condition 成立时才停止程序执行&lt;/li>
&lt;li>break function 在当前文件函数 function 的入口处设置断点&lt;/li>
&lt;li>break file:linenum 在源文件 file 的 linenum 行上设置断点&lt;/li>
&lt;li>break file:function 在源文件 file 的函数 function 的入口处设置断点&lt;/li>
&lt;li>break *address 运行程序在指定的内存地址 address 处停止&lt;/li>
&lt;li>break 不带任何参数，则表示在下一条指令处停止&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>断点应设置在可执行的行上，不应是变量定义之类的语句&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>删除断点：&lt;/p>
&lt;ul>
&lt;li>delete [bkptnums]&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>显示断点：&lt;/p>
&lt;ul>
&lt;li>info breakpoints [num]&lt;/li>
&lt;li>info break [num]&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>运行程序：&lt;/p>
&lt;ul>
&lt;li>run [args]&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>程序的单步跟踪和&lt;/p>
&lt;ul>
&lt;li>step [N] 参数 N 表示每步执行的语句行数，进入被调用函数内部执行&lt;/li>
&lt;li>next [N] 参数 N 表示每步执行的语句行数，被调用函数被当做一条指令执行&lt;/li>
&lt;li>stepi（缩写为 si）或 nexti（缩写为 ni）命令一条一条地执行机器指令&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>程序的连续执行&lt;/p>
&lt;ul>
&lt;li>利用 continue，c 或 fg 命令连续执行到下一个断点&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>显示源文件命令 list （l）&lt;/p>
&lt;ul>
&lt;li>list：没有参数，显示当前行之后或周围的 10 多行&lt;/li>
&lt;li>list -：显示之前的 10 行&lt;/li>
&lt;li>list [file]:num：显示源文件 file 中给定行号 num 周围的 10 行。如果缺少 file，则默认为当前文件。例如，list 100&lt;/li>
&lt;li>list start, end：显示从行号 start 至 end 之间的代码行。例如，list 20,38&lt;/li>
&lt;li>list [file:]fun：显示源文件 file 中指定函数 function 的代码行。如果缺少 file，则默认为当前文件。例如，list meng1.c:square&lt;/li>
&lt;li>set listsize linenum : 可以使用该命令设置一次显示的行数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>查看运行时数据命令 print （p）&lt;/p>
&lt;ul>
&lt;li>当被调试的程序停止时，可以用 print 命令或同义命令 inspect 来查看当前程序中运行的数据&lt;/li>
&lt;li>print 命令的一般使用格式：print [/fmt] exp
&lt;ul>
&lt;li>print i （或 p i） 显示当前变量 i 的值&lt;/li>
&lt;li>print i*j (或 p i*j) 将根据程序当前运行的实际情况显示出 i*j 的值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>print 所支持的运算符：
&lt;ul>
&lt;li>取地址&amp;amp;符号&lt;/li>
&lt;li>@ 是一个与数组有关的双目运算符，使用形式如
&lt;ul>
&lt;li>print array@10 打印从 array（数组名，即数组的基地址）开始的 10 个值&lt;/li>
&lt;li>print array[3]@5 打印从 array 第三个元素开始的 5 个数组元素的数值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>file::i 或 function ::i 表示文件或者函数中 i 的值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="notice notice-note" >
&lt;div class="notice-title">&lt;svg t="1705946198814" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23141" width="200" height="200">&lt;path d="M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864a149.333333 149.333333 0 0 1-149.333334 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z m426.666667 0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864a149.333333 149.333333 0 0 1-149.333333 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z" p-id="23142" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;p>GDB 使用示例&lt;/p>&lt;/div>
&lt;pre>&lt;code class="language-c">// test.c
#include &amp;lt;stdio.h&amp;gt;
int sum(int n);
int main(int argc, char **argv)
{
int i, result = 0;
for (i = 1; i &amp;lt;= 50; i++)
{
result += i;
}
printf(&amp;quot;result[1-50]=%d\n&amp;quot;, result);
printf(&amp;quot;result[1-100]=%d\n&amp;quot;, sum(100));
}
int sum(int n)
{
int i, sum;
for (i = 1; i &amp;lt;= n; i++)
{
sum += i;
}
return sum;
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>编译带调试信息的可执行文件&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gcc -g test.c -o test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>启动 GDB&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gdb test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>调试结果&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &amp;quot;show copying&amp;quot; and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;x86_64-linux-gnu&amp;quot;.
Type &amp;quot;show configuration&amp;quot; for configuration details.
For bug reporting instructions, please see:
&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;.
Find the GDB manual and other documentation resources online at:
&amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;.
For help, type &amp;quot;help&amp;quot;.
Type &amp;quot;apropos word&amp;quot; to search for commands related to &amp;quot;word&amp;quot;...
Reading symbols from test...
(gdb) list
1 #include &amp;lt;stdio.h&amp;gt;
2
3 int sum(int n);
4
5 int main(int argc, char **argv)
6 {
7 int i, result = 0;
8 for (i = 1; i &amp;lt;= 50; i++)
9 {
10 result += i;
(gdb)
11 }
12 printf(&amp;quot;result[1-50]=%d\n&amp;quot;, result);
13 printf(&amp;quot;result[1-100]=%d\n&amp;quot;, sum(100));
14 }
15
16 int sum(int n)
17 {
18 int i, sum;
19 for (i = 1; i &amp;lt;= n; i++)
20 {
(gdb)
21 sum += i;
22 }
23 return sum;
24 }
(gdb) b 8
Breakpoint 1 at 0x1163: file test.c, line 8.
(gdb) info b
Num Type Disp Enb Address What
1 breakpoint keep y 0x0000000000001163 in main at test.c:8
(gdb) r
Starting program: /root/workspace/test
Breakpoint 1, main (argc=1, argv=0x7fffffffe2d8) at test.c:8
8 for (i = 1; i &amp;lt;= 50; i++)
(gdb) p i
$1 = 0
(gdb) p result
$2 = 0
(gdb) n
10 result += i;
(gdb) n
8 for (i = 1; i &amp;lt;= 50; i++)
(gdb) p i
$3 = 1
(gdb) p result
$4 = 1
(gdb) d 1
(gdb) info b
No breakpoints or watchpoints.
(gdb) c
Continuing.
result[1-50]=1275
result[1-100]=26895
[Inferior 1 (process 286758) exited normally]
(gdb) q
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>总的来说，GDB 调试的过程为：
&lt;ul>
&lt;li>编译带调试信息的可执行文件&lt;/li>
&lt;li>启动 GDB，开始调试&lt;/li>
&lt;li>GDB 中查看文件&lt;/li>
&lt;li>设置断点&lt;/li>
&lt;li>查看断点情况&lt;/li>
&lt;li>运行代码&lt;/li>
&lt;li>跟踪变量值&lt;/li>
&lt;li>删除所设断点&lt;/li>
&lt;li>恢复程序运行&lt;/li>
&lt;li>退出 GDB&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="2-valgrind">2. Valgrind&lt;/h3>
&lt;ul>
&lt;li>Valgrind 是一个 Linux 下灵活的调试和剖析工具&lt;/li>
&lt;li>收集各种有用的运行时信息，可以帮助找到程序中潜在的 bug 和性能瓶颈&lt;/li>
&lt;li>Valgrind 包含多个工具：&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>工具&lt;/th>
&lt;th>功能&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Memcheck&lt;/td>
&lt;td>这是 valgrind 应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存、使用已经释放了的内存、内存访问越界等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Callgrind&lt;/td>
&lt;td>主要用来检查程序中函数调用过程中出现的问题&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Cachegrind&lt;/td>
&lt;td>主要用来检查程序中缓存使用出现的问题&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Helgrind&lt;/td>
&lt;td>主要用来检查多线程程序中出现的竞争问题&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Massif&lt;/td>
&lt;td>主要用来检查程序中堆栈使用中出现的问题&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Extensio&lt;/td>
&lt;td>可以利用 core 提供的功能，自己编写特定的内存调试工具&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>Valgrind 使用需要先进行安装，在 ubuntu 下可以使用 apt-get 进行安装&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">sudo apt-get install valgrind
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>为了使 Valgrind 发现的错误更精确，建议在编译时加上&lt;code>-g&lt;/code> 参数，编译优化选择&lt;code>O0&lt;/code>，即：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gcc -g -O0 test.c -o test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>valgrind 命令格式为: &lt;code>valgrind [options] prog-and-args [options]&lt;/code>&lt;/p>
&lt;ul>
&lt;li>[options]: 常用选项，适用于所有 Valgrind 工具&lt;/li>
&lt;li>&amp;ndash;tool=&amp;lt;name&amp;gt;： 最常用的选项，运行 valgrind 中名为 toolname 的工具，默认 memcheck&lt;/li>
&lt;li>-h|&amp;ndash;help：显示帮助信息&lt;/li>
&lt;li>&amp;ndash;version：显示 valgrind 内核的版本，每个工具都有各自的版本&lt;/li>
&lt;li>-q|&amp;ndash;quiet：安静地运行，只打印错误信息&lt;/li>
&lt;li>-v|&amp;ndash;verbose：更详细的信息，增加错误数统计&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Memcheck 内存错误检查：&lt;/p>
&lt;ul>
&lt;li>可以检查出下列几种错误
&lt;ul>
&lt;li>使用已经释放的内存&lt;/li>
&lt;li>内存块越界&lt;/li>
&lt;li>使用未初始化的变量&lt;/li>
&lt;li>内存泄漏&lt;/li>
&lt;li>同一个内存块释放多次&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Memcheck 命令行选项：
&lt;ul>
&lt;li>&amp;ndash;leak-check=&amp;lt;no|summary|yes|full&amp;gt; [default: summary]
&lt;ul>
&lt;li>summary 是给出最后 leak 的汇总，yes 或者 full 将会给出比较详细的 leak 信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&amp;ndash;leak-resolution=&amp;lt;low|med|high&amp;gt; [default: high]
&lt;ul>
&lt;li>用于合并 leak 信息来源的 backtraces，low 是有两层匹配的时候就可以合并，med 是四层，high 必须完全比配。该选项不影响查找 leak 的能力，只影响结果的显示方式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Cachegrind 缓存检查&lt;/p>
&lt;ul>
&lt;li>通过模拟 cpu 的 1,3 级缓存，收集应用程序运行时关于 cpu 的一些统计数据，最后在将明细数据和汇总信息打印出来&lt;/li>
&lt;li>执行方式：
&lt;ul>
&lt;li>$ valgrind &amp;ndash;tool=cachegrind your_application
&lt;ul>
&lt;li>cachegrind 的结果也会以输出文件的方式输出更多的细节，输出文件的缺省文件名是 cachegrind.out.&lt;!-- raw HTML omitted -->，其中&lt;!-- raw HTML omitted -->是当前进程的 pid。该文件名可以通过&amp;ndash;cachegrind-out-file 选择指定更可读的文件名，这个文件将会成为 cg_annotate 的输入&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Cachegrind 命令行选项：
&lt;ul>
&lt;li>&amp;ndash;cache-sim=no|yes [yes]
&lt;ul>
&lt;li>指定是否收集 cache accesses 和 miss counts&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&amp;ndash;branch-sim=no|yes [no]
&lt;ul>
&lt;li>指定是否收集 branch instruction 和 misprediction counts&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Callgrind 函数调用分析&lt;/p>
&lt;ul>
&lt;li>Callgrind 收集程序运行时的一些数据，建立函数调用关系图，还可以有选择地进行 cache 模拟。被分析的程序编译时要加&lt;code>-g&lt;/code>，编译优化选项建议选择&lt;code>-O2&lt;/code>&lt;/li>
&lt;li>执行方式：
&lt;ul>
&lt;li>$ valgrind &amp;ndash;tool=callgrind your_application
&lt;ul>
&lt;li>输出文件的缺省文件名是 callgrind.out.&lt;!-- raw HTML omitted --> ，其中&lt;!-- raw HTML omitted -->是当前进程的 pid&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Cachegrind 命令行选项：
&lt;ul>
&lt;li>&amp;ndash;callgrind-out-file=&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>指定 profile data 的输出文件，而不是缺省命名规则生成的文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&amp;ndash;dump-line=&amp;lt;no|yes&amp;gt; [default: yes]
&lt;ul>
&lt;li>事件计数将以 source line 作为统计的粒度，但是源程序在编译的时候加入&lt;code>-g&lt;/code> 选项&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Helgrind 多线程分析器&lt;/p>
&lt;ul>
&lt;li>主要用来检查多线程程序中出现的竞争问题&lt;/li>
&lt;li>执行方式：
&lt;ul>
&lt;li>$ valgrind &amp;ndash;tool=helgrind your_application&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Massif 堆栈分析&lt;/p>
&lt;ul>
&lt;li>堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。Massif 能帮助我们减少内存的使用&lt;/li>
&lt;li>执行方式：
&lt;ul>
&lt;li>$ valgrind &amp;ndash;tool=massif your_application
&lt;ul>
&lt;li>输出文件：massif.&lt;!-- raw HTML omitted -->.ps massif. &lt;!-- raw HTML omitted -->.txt，其中&lt;!-- raw HTML omitted -->是当前进程的 pid&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="notice notice-note" >
&lt;div class="notice-title">&lt;svg t="1705946198814" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23141" width="200" height="200">&lt;path d="M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864a149.333333 149.333333 0 0 1-149.333334 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z m426.666667 0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864a149.333333 149.333333 0 0 1-149.333333 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z" p-id="23142" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;p>Valgrind 使用示例 1：内存检查&lt;/p>&lt;/div>
&lt;pre>&lt;code class="language-c">// test.c
#include &amp;lt;stdlib.h&amp;gt;
void f(void)
{
int* x = malloc(10 * sizeof(int));
x[10] = 0; // 问题 1：数组下标越界
// 问题 2：内存泄漏，没有 free(x)
}
int main(int argc, char** argv)
{
f();
return 0;
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>编译并运行：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gcc -g -O0 test.c -o test
valgrind --tool=memcheck --leak-check=full ./test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>输出结果：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-text">==292701== Memcheck, a memory error detector
==292701== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==292701== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==292701== Command: ./test
==292701==
==292701== Invalid write of size 4
==292701== at 0x10916B: f (test.c:6)
==292701== by 0x10918B: main (test.c:12)
==292701== Address 0x4a4b068 is 0 bytes after a block of size 40 alloc'd
==292701== at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==292701== by 0x10915E: f (test.c:5)
==292701== by 0x10918B: main (test.c:12)
==292701==
==292701==
==292701== HEAP SUMMARY:
==292701== in use at exit: 40 bytes in 1 blocks
==292701== total heap usage: 1 allocs, 0 frees, 40 bytes allocated
==292701==
==292701== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1
==292701== at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==292701== by 0x10915E: f (test.c:5)
==292701== by 0x10918B: main (test.c:12)
==292701==
==292701== LEAK SUMMARY:
==292701== definitely lost: 40 bytes in 1 blocks
==292701== indirectly lost: 0 bytes in 0 blocks
==292701== possibly lost: 0 bytes in 0 blocks
==292701== still reachable: 0 bytes in 0 blocks
==292701== suppressed: 0 bytes in 0 blocks
==292701==
==292701== For lists of detected and suppressed errors, rerun with: -s
==292701== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>可以看到：valgrind 检测到了两个错误，一个是内存越界，一个是内存泄漏
&lt;ul>
&lt;li>Invalid write of size 4：提示了内存越界的错误&lt;/li>
&lt;li>40 bytes in 1 blocks are definitely lost in loss record 1 of 1：提示了内存泄漏的错误&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="notice notice-note" >
&lt;div class="notice-title">&lt;svg t="1705946198814" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23141" width="200" height="200">&lt;path d="M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864a149.333333 149.333333 0 0 1-149.333334 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z m426.666667 0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864a149.333333 149.333333 0 0 1-149.333333 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z" p-id="23142" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;p>Valgrind 使用示例 2：Cachegrind 缓存检查&lt;/p>&lt;/div>
&lt;pre>&lt;code class="language-c">// test.c
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(void)
{
char *arr = malloc(4);
int *arr2 = malloc(sizeof(int));
strcpy(arr, &amp;quot;1234&amp;quot;);
exit(arr2[0]);
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>编译并运行：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gcc -g -O0 test.c -o test
valgrind --tool=cachegrind ./test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>当前目录下会生成一个 cachegrind.out.&lt;!-- raw HTML omitted -->文件，其中&lt;!-- raw HTML omitted -->是当前进程的 pid，使用&lt;code>ls&lt;/code> 命令查看：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">$ ls
cachegrind.out.293847 test test.c
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>使用&lt;code>cg_annnotate&lt;/code> 命令查看 cachegrind.out.&lt;!-- raw HTML omitted -->文件的内容：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">$ cg_annotate cachegrind.out.293847
--------------------------------------------------------------------------------
I1 cache: 32768 B, 64 B, 8-way associative
D1 cache: 32768 B, 64 B, 8-way associative
LL cache: 31457280 B, 64 B, 15-way associative
Command: ./test
Data file: cachegrind.out.293847
Events recorded: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds: 0.1 100 100 100 100 100 100 100 100
Include dirs:
User annotated:
Auto-annotation: off
/* 以下内容省略 */
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>可以看到，cachegrind.out.&lt;!-- raw HTML omitted -->文件中记录了程序运行时的缓存信息，包括 I1 cache，D1 cache，LL cache 等，这些信息可以帮助我们分析程序的缓存使用情况&lt;/li>
&lt;li>cachegrind 输出的信息中，我们比较关注的是：
&lt;ul>
&lt;li>Ir: 指令读取次数&lt;/li>
&lt;li>I1mr：指令读取 miss 次数&lt;/li>
&lt;li>ILmr：指令读取 miss 次数&lt;/li>
&lt;li>Dr：数据读取次数&lt;/li>
&lt;li>D1mr：数据读取 miss 次数&lt;/li>
&lt;li>DLmr：数据读取 miss 次数&lt;/li>
&lt;li>Dw：数据写入次数&lt;/li>
&lt;li>D1mw：数据写入 miss 次数&lt;/li>
&lt;li>DLmw：数据写入 miss 次数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="notice notice-note" >
&lt;div class="notice-title">&lt;svg t="1705946198814" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23141" width="200" height="200">&lt;path d="M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864a149.333333 149.333333 0 0 1-149.333334 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z m426.666667 0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864a149.333333 149.333333 0 0 1-149.333333 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z" p-id="23142" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;p>Valgrind 使用示例 3：Callgrind 调用图检查&lt;/p>&lt;/div>
&lt;pre>&lt;code class="language-c">// test.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
void f(void)
{
int *x = malloc(10 * sizeof(int));
x[10] = 0; // 问题 1: 数组下标越界
} //问题 2: 内存没有释放
int main(void)
{
int i;
f();
printf(&amp;quot;i=%d\n&amp;quot;, i); // 问题 3：变量没有赋初值
return 0;
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>编译并运行：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gcc -g -O2 test.c -o test
valgrind --tool=callgrind ./test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>当前目录下会生成一个 callgrind.out.&lt;!-- raw HTML omitted -->文件，其中&lt;!-- raw HTML omitted -->是当前进程的 pid，使用&lt;code>ls&lt;/code> 命令查看：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">$ ls
callgrind.out.295036 test test.c
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>使用&lt;code>callgrind_annotate&lt;/code> 命令查看 callgrind.out.&lt;!-- raw HTML omitted -->文件的内容：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">$ callgrind_annotate callgrind.out.295036
--------------------------------------------------------------------------------
Profile data file 'callgrind.out.295036' (creator: callgrind-3.15.0)
--------------------------------------------------------------------------------
I1 cache:
D1 cache:
LL cache:
Timerange: Basic block 0 - 43734
Trigger: Program termination
Profiled target: ./test (PID 295036, part 1)
Events recorded: Ir
Events shown: Ir
Event sort order: Ir
Thresholds: 99
Include dirs:
User annotated:
Auto-annotation: off
--------------------------------------------------------------------------------
Ir
--------------------------------------------------------------------------------
193,311 PROGRAM TOTALS
--------------------------------------------------------------------------------
Ir file:function
--------------------------------------------------------------------------------
71,545 /build/glibc-SzIz7B/glibc-2.31/elf/dl-addr.c:_dl_addr [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
/* 以下内容省略 */
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>可以看到，callgrind.out.&lt;!-- raw HTML omitted -->文件中记录了程序运行时的调用图信息，包括函数调用次数，函数调用路径等，这些信息可以帮助我们分析程序的调用图使用情况&lt;/li>
&lt;li>callgrind 输出的信息中，我们比较关注的是：
&lt;ul>
&lt;li>Ir：指令读取次数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="三程序优化分析工具简介">三、程序优化分析工具简介&lt;/h2>
&lt;ul>
&lt;li>运行缓慢的代码将消耗大量的 CPU 时间, 因此，我们必需评估代码的运行效率, 在整个代码的设计和实现周期里都需考虑性能。&lt;/li>
&lt;li>Amdahl 定律：在一个系统中，如果某部分的执行时间占总执行时间的比例为 p，那么优化这部分的执行时间，系统的整体执行时间至少降低 p 倍。&lt;/li>
&lt;/ul>
&lt;p>$$
\begin{array}{c}T_{new} = T_{old} \times (1-p) + \frac{T_{old} \times p}{k} \ = T_{old} \times (1-p + \frac{p}{k})\end{array}
$$&lt;/p>
&lt;ul>
&lt;li>根据 Amdahl 定律，对热点部分进行性能优化能够获得最大收益&lt;/li>
&lt;li>常见的程序优化分析工具有：
&lt;ul>
&lt;li>gprof&lt;/li>
&lt;li>perf&lt;/li>
&lt;li>Vtune&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="1-gprof">1. gprof&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Gprof，又称 GNU profiler，是 Linux/Unix 系统上的性能 profiling 软件，其功能是获得程序各个函数运行时间，帮助找出耗时最多的函数，以及显示函数调用关系，包括调用次数，帮助分析程序运行流程。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基本原理为：&lt;/p>
&lt;ul>
&lt;li>编译链接程序时，编译器在程序的每个函数中都加入了一个函数，程序里的每一个函数都会调用该函数, 该函数 会在内存中保存一张函数调用图，并通过函数调用堆栈的形式查找子函数和父函数的地址&lt;/li>
&lt;li>调用图也保存了所有与函数相关的调用时间，调用次数等信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Gprof 需要先使用&lt;code>-pg&lt;/code> 编译和链接应用程序&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">ifort -pg -O3 -o prog prog.f90
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>执行应用程序使之生成供 gprof 分析的数据，生成 gmon.out&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">./prog
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>使用 gprof 程序分析应用程序生成的数据&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gprof prog gmon.out &amp;gt; gprof.out
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>gprof 的输出信息包括：&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>序号&lt;/th>
&lt;th>列名&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>time&lt;/td>
&lt;td>函数执行时间占总执行时间的百分比&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>cumulative seconds&lt;/td>
&lt;td>函数和上列函数累计执行的时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>self seconds&lt;/td>
&lt;td>函数本身所执行的时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>calls&lt;/td>
&lt;td>函数被调用次数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>self ms/call&lt;/td>
&lt;td>每一次调用花费在函数的时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>total ms/call&lt;/td>
&lt;td>每一次调用，花费在函数及其衍生函数的平均时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7&lt;/td>
&lt;td>name&lt;/td>
&lt;td>函数名&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>gprof 常用的命令选项有：&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>选项&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>-b&lt;/td>
&lt;td>不再输出统计图表中每个字段的详细描述&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-p&lt;/td>
&lt;td>只输出函数的调用图&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-q&lt;/td>
&lt;td>只输出函数的时间消耗列表&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-e Name&lt;/td>
&lt;td>不再输出函数 Name 及其子函数的调用图&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-E Name&lt;/td>
&lt;td>不再输出函数 Name 及其子函数的调用图，在总时间和百分比时间计算中排除了由函数 Name 及其子函数所用的时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-f Name&lt;/td>
&lt;td>输出函数 Name 及其子函数的调用图&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-F Name&lt;/td>
&lt;td>输出函数 Name 及其子函数的调用图，类似于-f，但它在总时间和百分比时间计算中仅使用所打印的例程的时间&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>对于由多个源文件组成的程序，编译时需要在生成每个.o 文件的时候加上&lt;code>-pg&lt;/code> 参数，同时在链接的时候也要加上&lt;code>-pg&lt;/code> 参数&lt;/li>
&lt;li>&lt;code>-pg&lt;/code> 参数只能记录源代码中各个函数的调用关系，而不能记录库函数的调用情况&lt;/li>
&lt;li>要想记录每个库函数（如 memcpy、memset、sprintf 等函数）的调用情况，链接的时候必须指定库函数的动态（或者静态）链接库 libc_p.a，即加上-lc_p，而不是-lc
&lt;ul>
&lt;li>$ gcc example1.c –pg -lc_p -o example1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>若只有部分代码在编译时指定了&lt;code>-pg&lt;/code> 参数，则生成的 gmon.out 文件中将缺少部分函数，也没有这些函数的调用关系，但是并不影响 gprof 对其它函数进行记录&lt;/li>
&lt;/ul>
&lt;div class="notice notice-note" >
&lt;div class="notice-title">&lt;svg t="1705946198814" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23141" width="200" height="200">&lt;path d="M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864a149.333333 149.333333 0 0 1-149.333334 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z m426.666667 0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864a149.333333 149.333333 0 0 1-149.333333 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z" p-id="23142" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;p>gprof 使用示例&lt;/p>&lt;/div>
&lt;pre>&lt;code class="language-c">// test.c
#include &amp;lt;stdio.h&amp;gt;
int fast_multiply(int x, int y)
{
return x * y;
}
int slow_multiply(int x, int y)
{
int i, j, z;
for (i = 0, z = 0; i &amp;lt; x; i++)
z = z + y;
return z;
}
int main(int argc, char *argv[])
{
int i, j;
int x, y;
for (i = 0; i &amp;lt; 200; i++)
{
for (j = 0; j &amp;lt; 30; j++)
{
x = fast_multiply(i, j);
y = slow_multiply(i, j);
}
}
printf(&amp;quot;x=%d, y=%d\n&amp;quot;, x, y);
return 0;
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>编译链接并运行程序&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gcc -pg -o test test.c
./test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>在当前目录下生成 gmon.out 文件，使用 gprof 分析&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gprof -b test gmon.out &amp;gt; gprof.out
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>gprof.out 文件内容如下&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-text">Flat profile:
Each sample counts as 0.01 seconds.
no time accumulated
% cumulative self self total
time seconds seconds calls Ts/call Ts/call name
0.00 0.00 0.00 6000 0.00 0.00 fast_multiply
0.00 0.00 0.00 6000 0.00 0.00 slow_multiply
Call graph
granularity: each sample hit covers 2 byte(s) no time propagated
index % time self children called name
0.00 0.00 6000/6000 main [8]
[1] 0.0 0.00 0.00 6000 fast_multiply [1]
-----------------------------------------------
0.00 0.00 6000/6000 main [8]
[2] 0.0 0.00 0.00 6000 slow_multiply [2]
-----------------------------------------------
Index by function name
[1] fast_multiply [2] slow_multiply
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>可以看到：程序中只有两个函数，fast_multiply 和 slow_multiply，gprof 分析结果中也只有这两个函数，但是这两个函数的调用次数都是 6000 次，这是因为 gprof 默认的采样周期是 0.01 秒，而程序运行时间很短，所以两个函数的调用次数都是 6000 次，如果程序运行时间更长，那么两个函数的调用次数就会不一样了。&lt;/li>
&lt;/ul>
&lt;h3 id="2-perf">2. perf&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Perf 是内置于 Linux 内核源码树中的性能剖析(profiling)工具，基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析，常用于性能瓶颈的查找与热点代码的定位。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Perf 包含 22 种子工具的工具集，以下是最常用的 5 种：&lt;/p>
&lt;ul>
&lt;li>perf list：列出当前系统支持的所有性能事件。包括硬件性能事件、软件性能事件以及检查点&lt;/li>
&lt;li>perf top：类似于 Linux 的 top 命令，对系统性能进行实时分析&lt;/li>
&lt;li>perf stat：剖析某个特定进程的性能概况，包括 CPI、Cache 丢失率等&lt;/li>
&lt;li>perf record：收集采样信息，并将其记录在数据文件中&lt;/li>
&lt;li>perf report：读取 perf record 创建的数据文件，并给出热点分析结果&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>perf list&lt;/p>
&lt;ul>
&lt;li>查看当前软硬件平台支持的性能事件列表&lt;/li>
&lt;li>事件分为以下三种：
&lt;ul>
&lt;li>&lt;strong>Hardware Event&lt;/strong>: 由 PMU 硬件产生的事件，比如 cache 命中，当要了解程序对硬件特性的使用情况时，便需要对这些事件进行采样&lt;/li>
&lt;li>&lt;strong>Software Event&lt;/strong>: 内核软件产生的事件，比如进程切换、tick 数等&lt;/li>
&lt;li>&lt;strong>Tracepoint event&lt;/strong>: 内核中的静态 tracepoint 所触发的事件，这些 tracepoint 用来判断程序运行期间内核的行为细节，比如 slab 分配器的分配次数等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>命令格式：&lt;code>perf list [hw | sw | cache | tracepoint]&lt;/code>&lt;/li>
&lt;li>perf list 工具仅列出了具有字符描述的硬件性能事件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>perf top&lt;/p>
&lt;ul>
&lt;li>主要用于实时分析各个函数在某个性能事件上的热度，能够快速的定位热点函数，包括应用程序函数、模块函数与内核函数，甚至能够定位到热点指令，默认的性能事件为 cpu cycles&lt;/li>
&lt;li>命令格式： &lt;code>perf top [&amp;lt;options&amp;gt;]&lt;/code>&lt;/li>
&lt;li>常用命令行参数
&lt;ul>
&lt;li>-e &lt;!-- raw HTML omitted -->：指明要分析的性能事件&lt;/li>
&lt;li>-p &lt;!-- raw HTML omitted -->：仅分析目标进程及其创建的线程&lt;/li>
&lt;li>-k &lt;!-- raw HTML omitted -->：带符号表的内核映像所在的路径&lt;/li>
&lt;li>-K：不显示属于内核或模块的符号&lt;/li>
&lt;li>-U：不显示属于用户态程序的符号&lt;/li>
&lt;li>-d &lt;!-- raw HTML omitted -->：界面的刷新周期，默认为 2s&lt;/li>
&lt;li>-G：得到函数的调用关系图&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>perf stat&lt;/p>
&lt;ul>
&lt;li>用于分析指定程序的性能概况&lt;/li>
&lt;li>命令格式：&lt;code>perf stat [&amp;lt;options&amp;gt;] [&amp;lt;command&amp;gt;]&lt;/code>&lt;/li>
&lt;li>常用命令行参数
&lt;ul>
&lt;li>-p &lt;!-- raw HTML omitted -->：仅分析目标进程及其创建的线程&lt;/li>
&lt;li>-a：从所有 CPU 上收集性能数据&lt;/li>
&lt;li>-r &lt;!-- raw HTML omitted -->：重复执行命令求平均&lt;/li>
&lt;li>-C &lt;!-- raw HTML omitted -->：从指定 CPU 上收集性能数据&lt;/li>
&lt;li>-v：显示更多性能数据&lt;/li>
&lt;li>-n：只显示任务的执行时间&lt;/li>
&lt;li>-x &lt;!-- raw HTML omitted -->：指定输出列的分隔符&lt;/li>
&lt;li>-o &lt;!-- raw HTML omitted -->：指定输出文件。&amp;ndash;append 指定追加模式，&amp;ndash;pre &lt;!-- raw HTML omitted -->执行目标程序前先执行的程序，&amp;ndash;post &lt;!-- raw HTML omitted -->执行目标程序后再执行的程序&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>perf record&lt;/p>
&lt;ul>
&lt;li>收集采样信息，并将其记录在数据文件中&lt;/li>
&lt;li>随后可以通过其它工具(perf report)对数据文件进行分析，结果类似于 perf top&lt;/li>
&lt;li>命令格式：&lt;code>perf record [&amp;lt;options&amp;gt;] [&amp;lt;command&amp;gt;]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>perf report&lt;/p>
&lt;ul>
&lt;li>读取 perf record 创建的数据文件，并给出热点分析结果&lt;/li>
&lt;li>命令格式：&lt;code>perf report [&amp;lt;options&amp;gt;] [&amp;lt;datafile&amp;gt;]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="notice notice-note" >
&lt;div class="notice-title">&lt;svg t="1705946198814" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23141" width="200" height="200">&lt;path d="M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864a149.333333 149.333333 0 0 1-149.333334 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z m426.666667 0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864a149.333333 149.333333 0 0 1-149.333333 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z" p-id="23142" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;p>perf 使用示例&lt;/p>&lt;/div>
&lt;ul>
&lt;li>apt-get 安装 perf&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">sudo apt-get install linux-tools-common linux-tools-generic linux-tools-`uname -r`
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>使用 perf list 查看当前系统支持的性能事件&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">perf list
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>perf list 结果：&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230803181340.webp"
alt="20230803181340" width="90%" loading="lazy">
&lt;/figure>
&lt;ul>
&lt;li>使用 perf top 查看当前系统的热点函数&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">perf top
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>perf top 结果：&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230803181307.webp"
alt="20230803181307" width="90%" loading="lazy">
&lt;/figure>
&lt;ul>
&lt;li>
&lt;p>使用 perf stat 查看测试程序的性能概况&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用在 gprof 时的程序代码 test.c&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行 perf stat&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">perf stat ./test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>perf stat 结果：&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230803182003.webp"
alt="20230803182003" width="90%" loading="lazy">
&lt;/figure>
&lt;ul>
&lt;li>使用 perf record 和 perf report 查看热点函数&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">perf record ./test
perf report
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>perf report 结果：&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230803182110.webp"
alt="20230803182110" width="90%" loading="lazy">
&lt;/figure>
&lt;ul>
&lt;li>
&lt;p>进阶：火炬图 FlameGraph：基于 perf record 和 perf report 的结果绘制火炬图&lt;/p>
&lt;ul>
&lt;li>
&lt;p>下载 FlameGraph 工具：&lt;/p>
&lt;pre>&lt;code class="language-shell">git clone https://github.com/brendangregg/FlameGraph.git
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>收集性能数据：&lt;/p>
&lt;pre>&lt;code class="language-shell">perf record -g ./test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>对可执行文件 test 进行采样，每秒 99 次，采样结果保存在 perf.data 文件中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>使用 FlameGraph 生成火炬图：运行以下命令使用 FlameGraph 生成火炬图：&lt;/p>
&lt;pre>&lt;code class="language-shell">perf script | ./FlameGraph/stackcollapse-perf.pl &amp;gt; out.perf-folded
./FlameGraph/flamegraph.pl out.perf-folded &amp;gt; perf.svg
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>FlameGrpah 绘制结果：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230803191123.webp"
alt="20230803191123" width="90%" loading="lazy">
&lt;/figure>
&lt;h3 id="3-vtune">3. Vtune&lt;/h3>
&lt;ul>
&lt;li>Intel VTune Amplifier XE 是 Intel 针对其处理器的性能测试分析工具，支持 Windows/Linux，提供图形用户界面和命令行接口，支持 C、C++、Fortran、C#、Java、.NET 等多种语言。&lt;/li>
&lt;li>Vtune 基于硬件性能监视部件(PMU)性能测试，获得微体系结构级数据
&lt;ul>
&lt;li>指令类型与数目&lt;/li>
&lt;li>存储访问事件&lt;/li>
&lt;li>指令流水线事件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Vtune 性能分析粒度包括：进程、线程、子程序、代码行&lt;/li>
&lt;li>Vtune 可以帮助用户分析算法选择，标识出应用程序怎样更好的利用可用的硬件资源，可以帮助用户如下性能方面问题：
&lt;ul>
&lt;li>程序中或者整个系统中时间消耗最多的函数&lt;/li>
&lt;li>没有有效利用处理器时间的代码片段&lt;/li>
&lt;li>优化串行和线程化性能的最好代码片段&lt;/li>
&lt;li>影响程序性能的同步对象&lt;/li>
&lt;li>程序的 I/O 操作是否花费很多时间，以及在哪里、为什么花费时间&lt;/li>
&lt;li>不同的同步方法，不同的线程数量或者不同算法对于性能的影响&lt;/li>
&lt;li>线程活跃性和变迁&lt;/li>
&lt;li>代码中硬件相关的瓶颈&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Vtune 还可以提供寻找热点、分析锁和等待以及标识硬件问题等功能&lt;/li>
&lt;li>Vtune 命令格式为：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">amplxe-cl &amp;lt;-action&amp;gt; [-action-option] [-global-option] [[--] &amp;lt;target&amp;gt; [target-options]]
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>amplxe-cl：VTune Amplifier 命令行工具名称&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&amp;lt;-action&amp;gt; ：要执行的操作，如 collect 或 report。每个命令必须只有一个操作。如，一个命令中不能同时有收集数据和生成报表&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[-action-option] ：操作选项，用于修改特定操作的行为。每个操作可以有多个操作选项，操作选项使用不当会导致使用错误&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[-global-option] ：全局选项，用于以相同的方式修改所有操作的行为。每个操作可以有多个全局选项&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[&amp;ndash;] &lt;!-- raw HTML omitted --> ：要分析的目标程序&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[target-options] ：目标程序参数选项&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Actions：amplxe-cl 支持不同的命令选项&lt;/p>
&lt;ul>
&lt;li>collect：运行指定的分析类型并将数据收集到结果中&lt;/li>
&lt;li>collect-with：运行用户设置的基于事件的硬件采样或用户模式采样，并跟踪收集&lt;/li>
&lt;li>command：向正在运行的收集操作发出命令&lt;/li>
&lt;li>finalize：执行符号解析以完成或重新获得结果&lt;/li>
&lt;li>help： 显示命令行参数的简短解释&lt;/li>
&lt;li>import：导入一个或多个收集数据文件/目录&lt;/li>
&lt;li>report：从分析结果中生成指定类型的报表&lt;/li>
&lt;li>version：显示 amplxe-cl 版本信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Action Options&lt;/p>
&lt;ul>
&lt;li>定义适用于指定操作的行为，如“-result-dir”选项是指定收集操作结果的目录路径&lt;/li>
&lt;li>若要访问操作的可用操作选项列表，请使用命令“amplxe-cl –help&lt;!-- raw HTML omitted -->” ，其中 &lt;!-- raw HTML omitted --> 是可用操作之一；要查看所有可用的操作, 请使用命令“amplxe-cl –help”&lt;/li>
&lt;li>如果在同一命令行上使用了相反的操作选项，则将应用最后的操作选项&lt;/li>
&lt;li>忽略上下文中冗余或没有意义的操作选项&lt;/li>
&lt;li>使用不适当的操作选项，会导致意外行为返回使用错误&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Global Options&lt;/p>
&lt;ul>
&lt;li>定义适用于所有操作的行为，如“-quiet”选项会取消所有操作的非必需消息。每个命令可能有一个或多个全局选项&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="notice notice-note" >
&lt;div class="notice-title">&lt;svg t="1705946198814" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23141" width="200" height="200">&lt;path d="M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864a149.333333 149.333333 0 0 1-149.333334 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z m426.666667 0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864a149.333333 149.333333 0 0 1-149.333333 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z" p-id="23142" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;p>Vtune 使用示例：&lt;/p>&lt;/div>
&lt;ul>
&lt;li>
&lt;p>同样使用在 gprof 时的程序代码 test.c，但是需要使用 icc 编译器编译，因为 Vtune 只支持 icc 编译器编译的程序&lt;/p>
&lt;/li>
&lt;li>
&lt;p>安装 icc 编译器：&lt;a class="link" href="https://software.intel.com/content/www/us/en/develop/tools/oneapi/components/dpc-compiler.html" target="_blank" rel="noopener" >Intel C++ Compiler
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;ul>
&lt;li>注：icc 编译器是收费的，需要购买或者申请学生许可&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>安装 Vtune：&lt;a class="link" href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/vtune-profiler-download.html?operatingsystem=linux&amp;amp;distributions=online" target="_blank" rel="noopener" >Intel Vtune
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Ubuntu 下 apt 安装 Vtune&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">wget -O- https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB \
| gpg --dearmor | sudo tee /usr/share/keyrings/oneapi-archive-keyring.gpg &amp;gt; /dev/null
echo &amp;quot;deb [signed-by=/usr/share/keyrings/oneapi-archive-keyring.gpg] https://apt.repos.intel.com/oneapi all main&amp;quot; | sudo tee /etc/apt/sources.list.d/oneAPI.list
sudo apt update
sudo apt install intel-oneapi-vtune
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>编译程序：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">icc test.c -o test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>激活 vtune 环境：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">source /opt/intel/oneapi/vtune/latest/amplxe-vars.sh
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>收集 hosspot 数据：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">ampxel-cl -collect hotspots -result-dir res ./test
&lt;/code>&lt;/pre>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本文介绍了几种常用的程序调试与优化分析工具，这些工具在软件开发过程中发挥着重要的作用。调试工具如 gdb 和 Valgrind 帮助开发人员快速定位和解决程序中的错误和问题，保障了代码的质量和稳定性。而优化分析工具，如 gprof、perf 和 Vtune，则专注于提升程序性能，帮助开发人员找到性能瓶颈并进行优化。&lt;/p>
&lt;p>通过合理使用这些工具，开发人员可以更高效地开发和维护代码，减少调试时间，提高软件性能，并且为用户提供更好的使用体验。在今后的软件开发过程中，了解和掌握这些工具将是提高开发技能和水平的重要一步。同时，不断了解新的调试与优化工具也是跟上技术发展的必要途径。&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;p>[1] &lt;a class="link" href="https://www.gnu.org/software/gdb/" target="_blank" rel="noopener" >gdb 官方网站
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;p>[2] &lt;a class="link" href="https://www.valgrind.org/" target="_blank" rel="noopener" >valgrind 官方网站
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;p>[3] &lt;a class="link" href="https://sourceware.org/binutils/docs/gprof/" target="_blank" rel="noopener" >gprof 官方文档
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;p>[4] &lt;a class="link" href="https://perf.wiki.kernel.org/index.php/Main_Page" target="_blank" rel="noopener" >perf 文档
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;p>[5] &lt;a class="link" href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/vtune-profiler.html" target="_blank" rel="noopener" >Intel Vtune Profiler
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p></description></item><item><title>高性能异步 I/O 框架：io_uring</title><link>https://cuterwrite.top/p/efficient-liburing/</link><pubDate>Tue, 01 Aug 2023 01:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/efficient-liburing/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230801145236.webp" alt="Featured image of post 高性能异步 I/O 框架：io_uring" />&lt;h1 id="高性能异步-io-框架io_uring">高性能异步 I/O 框架：io_uring&lt;/h1>
&lt;h2 id="一-引言">一、 引言&lt;/h2>
&lt;h3 id="1-linux-原生-aio-接口">1. Linux 原生 aio 接口&lt;/h3>
&lt;p>在 Linux 中，有很多方法可以进行基于文件的 I/O。最早的和最基本的就是系统调用 read(2)和 write(2)。后来增加了允许传入偏移量的 pread(2)和 pwrite(2)，以及基于 vector 的 preadv(2)和 pwrite(2)。再后来，Linux 提供了 preadv2(2)和 pwritev2(2)。它们进一步扩展了 API 以允许修饰符标志。抛开这些系统调用的不同点不谈，它们有一个共同的特点：都是同步接口。这意味着当数据准备好读（或写入）时，系统调用才会返回。对于某些场景，这远远不够，因此还需要异步接口。POSIX 提供了 aio_read(3)和 aio_write(3)来满足这种需求，但是它们的实现通常性能不佳。Linux 原生 aio 接口是 Linux 内核中提供的一种异步 I/O 接口，它使用 io_submit(2)、io_getevents(2)等系统调用来提交和获取 I/O 请求，并使用 struct iocb 来描述每个 I/O 请求。它支持 O_DIRECT（或非缓冲）访问的异步 I/O，并且可以使用信号或回调函数来通知 I/O 完成事件。&lt;/p>
&lt;p>然而，Linux 原生 aio 接口存在着许多的限制与不足之处：&lt;/p>
&lt;ul>
&lt;li>最大的限制是它只能支持 O_DIRECT（或非缓冲）访问的异步 I/O。由于 O_DIRECT 的限制（缓存绕过和大小/对齐限制），这使得原生 aio 接口在大多数情况下都无法使用。对于普遍的缓冲 I/O，接口会以同步方式运行。&lt;/li>
&lt;li>即使满足了 I/O 异步的所有约束条件，有时也会出现阻塞。I/O 提交可能会通过多种方式导致阻塞：
&lt;ol>
&lt;li>如果执行 I/O 时需要元数据，提交就会阻塞，等待元数据。&lt;/li>
&lt;li>对于存储设备，有固定数量的请求槽可用。如果这些插槽目前都在使用中，提交就会阻塞，等待有一个插槽可用。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>I/O 请求元数据开销大：每次 I/O 提交都需要复制 64 + 8 字节的数据，而每次完成则需要复制 32 字节的数据。这意味着对于所谓的零拷贝 I/O 来说，每次操作都需要复制 104 字节的内存。根据 I/O 的大小不同，这种内存复制的开销可能是明显可见的。而且，暴露的完成事件环缓冲区实际上会妨碍完成操作的速度，并且很难（甚至不可能）从应用程序中正确地使用。这可能意味着使用这个 API 进行 I/O 操作时，完成操作的效率会受到影响。此外，在 Spectre/Meltdown 漏洞修复后，I/O 总是需要至少两个系统调用（提交+等待完成），这会导致严重的性能下降。这可能是因为在修复这些漏洞后，系统对于系统调用的处理变得更加复杂和缓慢。&lt;/li>
&lt;li>IOPOLL 支持不好。&lt;/li>
&lt;/ul>
&lt;p>随着时间的推移，尽管有一些努力试图解决这些限制，但没有成功。随着具备亚 10 微秒延迟和非常高 IOPS 的设备的出现，这个接口开始显现出其性能缺陷。对于这些类型的设备来说，慢速和非确定性的提交延迟是一个很大的问题，而且单个核心无法提供足够的性能。此外，由于前面提到的限制，可以说原生的 Linux aio 接口用途并不广泛。它被限制在应用程序的一小部分领域中，并且伴随着一些问题。&lt;/p>
&lt;h3 id="2-io_uring-接口">2. io_uring 接口&lt;/h3>
&lt;p>io_uring 是 Linux 内核中的一种新的异步 I/O 接口，旨在提供高效和可扩展的 I/O 操作。它通过使用一对环形队列（提交队列和完成队列）作为应用程序和内核之间的通信通道，实现了零拷贝的 I/O 操作。&lt;/p>
&lt;p>io_uring 的设计目标是在提供高性能的同时解决传统异步 I/O 接口的一些限制和问题。它避免了内存复制和内存方向性，通过共享数据结构和内存来优雅地实现应用程序和内核之间的协调。这种设计使得 io_uring 能够更高效地处理 I/O 请求，并且不需要频繁的系统调用来同步和通信。&lt;/p>
&lt;p>通过 io_uring，应用程序可以作为生产者将 I/O 请求提交到提交队列，而内核作为消费者处理这些请求。一旦请求完成，内核会生成相应的完成事件，并将其放入完成队列中，应用程序可以从完成队列中消费这些事件。这种异步的方式使得应用程序能够更好地利用系统资源，提高 I/O 操作的效率和性能。&lt;/p>
&lt;p>io_uring 的优势主要在于：&lt;/p>
&lt;ul>
&lt;li>使用方便：简单且强大的系统调用，提供三个系统调用，liburing 用户态库编程友好 (io_uring_setup, io_uring_enter, io_uring_register)。&lt;/li>
&lt;li>通用性强：提供内核统一的异步编程框架，既支持传统 I/O (Buffer I/O + Direct I/O)，也支持类 epoll 型编程。&lt;/li>
&lt;li>特性丰富：支持非常多的高级特性。&lt;/li>
&lt;li>高性能：I/O 请求 overhead 小。&lt;/li>
&lt;/ul>
&lt;h3 id="3-liburing-库">3. liburing 库&lt;/h3>
&lt;p>liburing 是一个基于 io_uring 接口的用户空间库，它是 Linux 内核开发者 Axboe 于 2019 年发布的一个开源项目。io_uring 是一种新的 Linux 异步 I/O 接口，它通过使用一对环形缓冲区（ring buffer）来实现用户空间和内核空间之间的通信，从而避免了传统异步 I/O 接口（如 AIO）所需的系统调用、信号、回调等机制。这样，用户空间可以直接向内核提交 I/O 请求，并从内核获取 I/O 结果，而无需等待或切换上下文。这大大提高了异步 I/O 操作的效率和性能。&lt;/p>
&lt;p>liburing 是对 io_uring 接口的封装和扩展，它提供了一套简洁和灵活的 API，让开发者可以方便地使用 io_uring 的功能，而无需关心底层的细节和复杂性。liburing 主要包括以下几个组件：&lt;/p>
&lt;ul>
&lt;li>liburing.h：定义了 liburing 库的主要数据结构和函数&lt;/li>
&lt;li>liburing.a：提供了 liburing 库的静态链接版本&lt;/li>
&lt;li>liburing.so：提供了 liburing 库的动态链接版本&lt;/li>
&lt;li>liburing/io_uring.h：定义了 io_uring 接口相关的数据结构和常量&lt;/li>
&lt;li>liburing/compat.h：提供了一些兼容性相关的宏定义&lt;/li>
&lt;/ul>
&lt;h2 id="二io_uring-的核心数据结构与原理">二、io_uring 的核心数据结构与原理&lt;/h2>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230802172119.webp"
alt="20230802172119" width="90%" loading="lazy">
&lt;/figure>
&lt;h3 id="1-io_uring-的核心数据结构">1. io_uring 的核心数据结构&lt;/h3>
&lt;ul>
&lt;li>每个 io_uring 实例都有两个环形队列(称为 ring)，在内核和应用程序之间共享：
&lt;ol>
&lt;li>提交队列：submission queue( SQ )&lt;/li>
&lt;li>完成队列：completion queue( CQ )&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230802000924.webp"
alt="20230802000924" width="90%" loading="lazy">
&lt;/figure>
&lt;ul>
&lt;li>这两个队列：
&lt;ol>
&lt;li>都是单生产者、单消费者的队列，size 为 2 的幂次方。&lt;/li>
&lt;li>提供无锁接口，内部使用内存屏障来进行同步。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>请求时：
&lt;ol>
&lt;li>应用创建 SQ Entries (SQE)，更新 SQ tail&lt;/li>
&lt;li>内核消费 SQE，更新 SQ head&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>完成后：
&lt;ol>
&lt;li>内核为完成的一个或多个请求创建 CQ Entries (CQE)，更新 CQ tail&lt;/li>
&lt;li>应用消费 CQE，更新 CQ head&lt;/li>
&lt;li>完成事件可能以任意顺序到达，到总是与特定的 SQE 相关联的&lt;/li>
&lt;li>消费 CQE 过程无需切换内核态&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>这样做的好处在于：
&lt;ol>
&lt;li>原本需要多次系统调用，现在变成批处理一次提交&lt;/li>
&lt;li>此外，io_uring 使异步 I/O 的使用场景也不再仅限于数据库应用， 普通的非数据库应用也能用&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h3 id="2-io_uring-的三种工作模式">2. io_uring 的三种工作模式：&lt;/h3>
&lt;ol>
&lt;li>中断驱动模式 (interrupt-driven)
&lt;ul>
&lt;li>默认模式, 可通过 io_uring_enter()提交 I/O 请求，然后直接检查 CQ 状态判断是否完成。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>轮询模式 (polling)
&lt;ul>
&lt;li>Busy waiting for I/O completion，而不是通过异步 IRQ(Interrupt Request)来接收通知&lt;/li>
&lt;li>这种模式需要文件系统和块设备支持轮询功能。相比中断驱动模式，这种方式延迟更低，但是 CPU 占用率可能会更高。&lt;/li>
&lt;li>目前，只有指定了 O_DIRECT 标志打开的文件描述符才能使用这种模式。当一个读或写请求提交给轮询上下文之后，应用必须调用 io_uring_enter()来轮询 CQ 队列，判断请求是否完成。&lt;/li>
&lt;li>对于一个 io_uring 实例来说，不支持混合使用轮询和非轮询模式。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>内核轮询模式 (kernel polling)
&lt;ul>
&lt;li>这种模式会创建一个内核线程来执行 SQ 的轮询工作。&lt;/li>
&lt;li>使用这种模式的 io_uring 实例，应用无需切到内核态就能触发 I/O 操作。通过 SQ 来提交 SQE，以及监控 CQ 的完成状态，应用无需任何系统调用，就能提交和收割 I/O。&lt;/li>
&lt;li>如果内核线程的空闲事件超过了用户的配置值，它会通知应用，然后进入 idle 状态。这种情况下，应用必须调用 io_uring_enter()来唤醒内核线程。如果 I/O 一直很繁忙，内核线程是不会 sleep 的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="3-io_uring-的系统调用-api">3. io_uring 的系统调用 API&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>io_uring 的系统调用 API 有三个，分别是：&lt;/p>
&lt;ul>
&lt;li>io_uring_setup(2)&lt;/li>
&lt;li>io_uring_register(2)&lt;/li>
&lt;li>io_uring_enter(2)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>首先是 io_uring_setup(2)：&lt;/p>
&lt;pre>&lt;code class="language-c">int io_uring_setup(unsigned entries, struct io_uring_params *p);
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>用于创建一个 io_uring 实例，返回一个文件描述符，用于后续的 io_uring 系统调用。&lt;/li>
&lt;li>参数：
&lt;ul>
&lt;li>entries：SQ 和 CQ 的大小，必须是 2 的幂次方&lt;/li>
&lt;li>params：io_uring 的参数，包括 flags、sq_thread_cpu 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>返回值：
&lt;ul>
&lt;li>成功：返回一个文件描述符&lt;/li>
&lt;li>失败：返回-1，并设置 errno&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>创建一个 SQ 和一个 CQ，它们的大小都是 entries。如果 entries 是 0，那么 SQ 和 CQ 的大小都是默认值(4096)。SQ 和 CQ 在应用和内核之间共享，避免了在初始化和完成 I/O 时拷贝数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>io_uring_register(2)：&lt;/p>
&lt;pre>&lt;code class="language-c">int io_uring_register(int fd, unsigned int opcode, const void *arg, unsigned int nr_args);
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>注册用于异步 I/O 的文件或用户缓冲区，使内核能长时间持有对该文件在内核内部的数据结构引用，或创建应用内存的长期映射，这个操作只会在注册时执行一次，而不是每个 I/O 操作都会处理，因此减少了 per-I/O 的 overhead 开销。&lt;/li>
&lt;li>参数：
&lt;ul>
&lt;li>fd：文件描述符&lt;/li>
&lt;li>opcode：操作码，用于指定注册的类型，如 IORING_REGISTER_BUFFERS、IORING_REGISTER_FILES 等&lt;/li>
&lt;li>arg：指向一个数组，数组中的每个元素都是一个指向用户缓冲区或文件描述符的指针&lt;/li>
&lt;li>nr_args：arg 数组的大小&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>返回值：
&lt;ul>
&lt;li>成功：返回 0&lt;/li>
&lt;li>失败：返回-1，并设置 errno&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>注册的缓冲区将会被锁定到内存中，并计入用户的 RLIMIT_MEMLOCK 限制。如果注册的是文件描述符，那么内核会增加对该文件的引用计数，直到应用调用 io_uring_unregister(2)来注销它。&lt;/li>
&lt;li>每个缓冲区有 1GB 的大小限制。&lt;/li>
&lt;li>缓冲区必须是匿名的、非文件后端的内存，例如 malloc(3)或带 MAP_ANONYMOUS 标识的 mmap(2)返回的内存。&lt;/li>
&lt;li>Huge pages 也是支持的。整个 Huge page 都会被 pin 到内核，即使只使用其中一部分。&lt;/li>
&lt;li>已经注册的缓冲区无法调整大小，想调整只能先 unregister，再重新注册。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>io_uring_enter(2):&lt;/p>
&lt;pre>&lt;code class="language-c">int io_uring_enter(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig);
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>这个系统调用用于初始化和完成（initiate and complete）I/O，使用共享的 SQ 和 CQ。单次调用同时执行：
&lt;ol>
&lt;li>提交新的 I/O 请求&lt;/li>
&lt;li>等待 I/O 完成&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>参数：
&lt;ul>
&lt;li>fd：io_uring 实例的文件描述符&lt;/li>
&lt;li>to_submit：SQ 中提交的 I/O 请求数量&lt;/li>
&lt;li>min_complete：最少完成的 I/O 请求数量&lt;/li>
&lt;li>flags：用于指定 I/O 请求的类型，如 IORING_ENTER_GETEVENTS、IORING_ENTER_SQ_WAKEUP 等&lt;/li>
&lt;li>sig：用于指定信号集，如果 flags 指定了 IORING_ENTER_GETEVENTS，那么 sig 必须是一个有效的信号集&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在默认模式下，如果指定了 min_complete，那么 io_uring_enter(2)会等待至少 min_complete 个 I/O 请求完成，然后返回。如果没有指定 min_complete，那么 io_uring_enter(2)会等待 SQ 中所有的 I/O 请求完成，然后返回。在 polling 模式下，如果指定了 min_complete，如果 min_complete 为 0，则要求内核返回当前以及完成的所有 events，无阻塞；如果 min_complete 大于 0，如果有事件完成，内核仍然立即返回；如果没有完成事件，内核会 poll，等待指定的次数完成，或者这个进程的时间片用完。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="4-io_uring-的高级特性">4. io_uring 的高级特性&lt;/h3>
&lt;ul>
&lt;li>io_uring 还提供了一些用于特殊场景的高级特性
&lt;ul>
&lt;li>File registration(文件注册)：每次发起一个指定文件描述的操作，内核都需要花费一些时钟周期(cycles)文件描述符映射到内部表示。对于那些 &lt;strong>针对同一文件进行重复操作&lt;/strong> 的场景，io_uring 支持提前注册这些文件，后面直接查找就行了。&lt;/li>
&lt;li>Buffer registration(缓冲区注册)：与 file registration 类似，Direct I/O 场景中，内核需要 map/unmap memory areas。io_uring 支持提前注册这些缓冲区（buffers）。&lt;/li>
&lt;li>Poll ring(轮询环形缓冲区)：对于非常快是设备，处理中断的开销是比较大的。io_uring 允许用户关闭中断，使用轮询模式。&lt;/li>
&lt;li>Linked operations(链接操作)：允许用户发送串联的请求。这两个请求同时提交，但后面的会等前面的处理完才开始执行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="三io_uring-的使用示例">三、io_uring 的使用示例&lt;/h2>
&lt;p>liburing 提供了一个简单的高层 API， 可用于一些基本场景，应用程序避免了直接使用更底层的系统调用。此外，这个 API 还避免了一些重复操作的代码，如设置 io_uring 实例。&lt;/p>
&lt;h3 id="1-在项目中引入-liburing">1. 在项目中引入 liburing&lt;/h3>
&lt;ol>
&lt;li>apt-get 安装 liburing
&lt;ul>
&lt;li>在 ubuntu 系统下安装 liburing 十分简单，只需要执行以下命令即可 （注意：ubuntu 版本需要大于等于 20.04，因为内核版本需要大于等于 5.4）
&lt;pre>&lt;code class="language-shell">sudo apt-get install liburing-dev
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>在项目中引入 liburing 的头文件
&lt;pre>&lt;code class="language-c">#include &amp;quot;liburing.h&amp;quot;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>在项目中引入 liburing 的库文件
&lt;pre>&lt;code class="language-c">-luring
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>手动安装
&lt;ul>
&lt;li>下载 liburing 的源码
&lt;pre>&lt;code class="language-shell">git clone https://github.com/axboe/liburing.git
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>编译 liburing
&lt;pre>&lt;code class="language-shell">cd liburing
./configure
make -j
sudo make install
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>在项目中引入 liburing 的头文件
&lt;pre>&lt;code class="language-c">#include &amp;quot;liburing.h&amp;quot;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>在项目中引入 liburing 的库文件
&lt;pre>&lt;code class="language-c">-luring
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="2-代码示例">2. 代码示例&lt;/h3>
&lt;ul>
&lt;li>使用 4 个 SQE，从输入文件中读取最多 16KB 的数据。&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-c">#include &amp;quot;liburing.h&amp;quot;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
// io_uring 队列长度
#define QUEUE_DEPTH 4
int main(int argc, char** argv)
{
int fd, pending, done;
void* buf;
// 1. 初始化一个 io_uring 实例
struct io_uring ring;
// 创建一个 io_uring 实例，队列长度为 QUEUE_DEPTH，flags 为 0，使用默认模式
int ret = io_uring_queue_init(QUEUE_DEPTH, &amp;amp;ring, 0);
if (ret)
{
fprintf(stderr, &amp;quot;io_uring_queue_init: %s\n&amp;quot;, strerror(-ret));
return 1;
}
// 2. 打开输入文件，指定 O_DIRECT 标志
fd = open(argv[1], O_RDONLY | O_DIRECT);
struct stat st;
fstat(fd, &amp;amp;st);
// 3. 初始化 4 个读缓冲区
size_t filesize = 0;
struct iovec *iovecs = calloc(QUEUE_DEPTH, sizeof(struct iovec));
for (int i = 0; i &amp;lt; QUEUE_DEPTH; i++)
{
if (posix_memalign(&amp;amp;buf, 4096, 4096))
{
perror(&amp;quot;posix_memalign&amp;quot;);
return 1;
}
iovecs[i].iov_base = buf;
iovecs[i].iov_len = 4096;
filesize += 4096;
}
// 4. 依次准备 4 个读请求，指定将随后读入的数据写入 iovecs 中
struct io_uring_sqe *sqe;
size_t offset = 0;
int i = 0;
do
{
sqe = io_uring_get_sqe(&amp;amp;ring);
io_uring_prep_readv(sqe, fd, &amp;amp;iovecs[i], 1, offset);
offset += iovecs[i].iov_len;
i++;
// 如果超出文件大小，停止准备后面的 SQE
if (offset &amp;gt;= st.st_size)
{
break;
}
} while (1);
// 5. 提交 SQE 读请求
ret = io_uring_submit(&amp;amp;ring);
if (ret &amp;lt; 0)
{
fprintf(stderr, &amp;quot;io_uring_submit: %s\n&amp;quot;, strerror(-ret));
return 1;
} else if (ret != i) {
fprintf(stderr, &amp;quot;io_uring_submit submitted less %d\n&amp;quot;, ret);
return 1;
}
// 6. 等待读请求完成
struct io_uring_cqe *cqe;
done = 0;
pending = ret;
filesize = 0;
for (int i = 0; i &amp;lt; pending; i++) {
// 等待一个读完成事件
io_uring_wait_cqe(&amp;amp;ring, &amp;amp;cqe);
done++;
if (cqe-&amp;gt;res != 4096 &amp;amp;&amp;amp; cqe-&amp;gt;res + filesize != st.st_size) {
fprintf(stderr, &amp;quot;cqe-&amp;gt;res: %d\n&amp;quot;, cqe-&amp;gt;res);
return 1;
}
filesize += cqe-&amp;gt;res;
// 更新完成队列
io_uring_cqe_seen(&amp;amp;ring, cqe);
}
// 7. 打印统计信息
printf(&amp;quot;Submitted = %d, completed = %d, bytes = %lu\n&amp;quot;, pending, done, (unsigned long)filesize);
// 8. 销毁资源
close(fd);
io_uring_queue_exit(&amp;amp;ring);
return 0;
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>link-cp：使用 io_uring 高级特性 SQE chaining 实现复制文件功能，将创建一个长度为 2 的 SQE 链，第一个 SQE 用于读，第二个 SQE 用于写。&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-c">#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;inttypes.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;quot;liburing.h&amp;quot;
#define QD 64
#define BS (32 * 1024)
struct io_data
{
size_t offset;
int index;
struct iovec iov;
};
static int infd, outfd;
static int inflight;
static int setup_context(unsigned entries, struct io_uring *ring)
{
int ret;
ret = io_uring_queue_init(entries, ring, 0);
if (ret &amp;lt; 0)
{
fprintf(stderr, &amp;quot;queue_init: %s\n&amp;quot;, strerror(-ret));
return -1;
}
return 0;
}
static int get_file_size(int fd, off_t *size)
{
struct stat st;
if (fstat(fd, &amp;amp;st) &amp;lt; 0)
return -1;
if (S_ISREG(st.st_mode))
{
*size = st.st_size;
return 0;
}
else if (S_ISBLK(st.st_mode))
{
unsigned long long bytes;
if (ioctl(fd, BLKGETSIZE64, &amp;amp;bytes) != 0)
return -1;
*size = bytes;
return 0;
}
return -1;
}
static void queue_rw_pair(struct io_uring *ring, off_t size, off_t offset)
{
struct io_uring_sqe *sqe;
struct io_data *data;
void *ptr;
ptr = malloc(size + sizeof(*data));
data = ptr + size;
data-&amp;gt;index = 0;
data-&amp;gt;offset = offset;
data-&amp;gt;iov.iov_base = ptr;
data-&amp;gt;iov.iov_len = size;
sqe = io_uring_get_sqe(ring);
io_uring_prep_readv(sqe, infd, &amp;amp;data-&amp;gt;iov, 1, offset);
sqe-&amp;gt;flags |= IOSQE_IO_LINK;
io_uring_sqe_set_data(sqe, data);
sqe = io_uring_get_sqe(ring);
io_uring_prep_writev(sqe, outfd, &amp;amp;data-&amp;gt;iov, 1, offset);
io_uring_sqe_set_data(sqe, data);
}
static int handle_cqe(struct io_uring *ring, struct io_uring_cqe *cqe)
{
struct io_data *data = io_uring_cqe_get_data(cqe);
int ret = 0;
data-&amp;gt;index++;
if (cqe-&amp;gt;res &amp;lt; 0)
{
if (cqe-&amp;gt;res == -ECANCELED)
{
queue_rw_pair(ring, data-&amp;gt;iov.iov_len, data-&amp;gt;offset);
inflight += 2;
}
else
{
printf(&amp;quot;cqe error: %s\n&amp;quot;, strerror(-cqe-&amp;gt;res));
ret = 1;
}
}
if (data-&amp;gt;index == 2)
{
void *ptr = (void *)data - data-&amp;gt;iov.iov_len;
free(ptr);
}
io_uring_cqe_seen(ring, cqe);
return ret;
}
static int copy_file(struct io_uring *ring, off_t insize)
{
struct io_uring_cqe *cqe;
off_t this_size;
off_t offset;
offset = 0;
while (insize)
{
int has_inflight = inflight;
int depth;
while (insize &amp;amp;&amp;amp; inflight &amp;lt; QD)
{
this_size = BS;
if (this_size &amp;gt; insize)
this_size = insize;
queue_rw_pair(ring, this_size, offset);
offset += this_size;
insize -= this_size;
inflight += 2;
}
if (has_inflight != inflight)
io_uring_submit(ring);
if (insize)
depth = QD;
else
depth = 1;
while (inflight &amp;gt;= depth)
{
int ret;
ret = io_uring_wait_cqe(ring, &amp;amp;cqe);
if (ret &amp;lt; 0)
{
printf(&amp;quot;wait cqe: %s\n&amp;quot;, strerror(-ret));
return 1;
}
if (handle_cqe(ring, cqe))
return 1;
inflight--;
}
}
return 0;
}
int main(int argc, char *argv[])
{
struct io_uring ring;
off_t insize;
int ret;
if (argc &amp;lt; 3)
{
printf(&amp;quot;%s: infile outfile\n&amp;quot;, argv[0]);
return 1;
}
infd = open(argv[1], O_RDONLY);
if (infd &amp;lt; 0)
{
perror(&amp;quot;open infile&amp;quot;);
return 1;
}
outfd = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644);
if (outfd &amp;lt; 0)
{
perror(&amp;quot;open outfile&amp;quot;);
return 1;
}
if (setup_context(QD, &amp;amp;ring))
return 1;
if (get_file_size(infd, &amp;amp;insize))
return 1;
ret = copy_file(&amp;amp;ring, insize);
close(infd);
close(outfd);
io_uring_queue_exit(&amp;amp;ring);
return ret;
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>copy_file()：高层复制循环逻辑；它会调用 queue_rw_pair(ring, this_size, offset) 来构造 SQE pair；并通过一次 io_uring_submit() 调用将所有构建的 SQE pair 提交。 这个函数维护了一个最大 DQ 数量的 inflight SQE，只要数据 copy 还在进行中；否则，即数据已经全部读取完成，就开始等待和收割所有的 CQE。&lt;/li>
&lt;li>queue_rw_pair() 构造一个 read-write SQE pair. read SQE 的 IOSQE_IO_LINK flag 表示开始一个 chain，write SQE 不用设置这个 flag，标志着这个 chain 的结束。用户 data 字段设置为同一个 data 描述符，并且在随后的 completion 处理中会用到。&lt;/li>
&lt;li>handle_cqe() 从 CQE 中提取之前由  queue_rw_pair() 保存的 data 描述符，并在描述符中记录处理进展（index）。 如果之前请求被取消，它还会重新提交 read-write pair。 一个 CQE pair 的两个 member 都处理完成之后（index==2），释放共享的 data descriptor。最后通知内核这个 CQE 已经被消费。&lt;/li>
&lt;/ul>
&lt;h3 id="3-最佳实践">3. 最佳实践&lt;/h3>
&lt;p>io_uring 是一个高性能的异步 I/O 框架，它在 Linux 内核中引入了一种新的 I/O 模型，可以显著提高 I/O 操作的吞吐量和响应速度。然而，要充分发挥 io_uring 的优势，需要注意一些优化和最佳实践。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>优化&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>批量提交（Batch Submission）&lt;/td>
&lt;td>io_uring 支持批量提交多个 I/O 请求，以减少系统调用的开销。通过一次性提交多个请求，可以减少上下文切换和系统调用的次数，提高效率。建议根据系统的负载和性能需求，合理选择批量提交的数量。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>预分配 I/O 请求（Pre-allocate I/O Requests）&lt;/td>
&lt;td>在使用 io_uring 之前，可以预先分配一定数量的 I/O 请求，避免在运行时动态分配请求的开销。这样可以减少内存分配和释放的次数，提高性能。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>使用 I/O 链接（I/O Linking）&lt;/td>
&lt;td>io_uring 支持将多个 I/O 请求链接在一起，形成一个链表。这样可以减少上下文切换的开销，提高效率。在链接 I/O 请求时，需要注意保持请求的顺序和正确处理链接的完成。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>使用 I/O 向量（I/O Vector）&lt;/td>
&lt;td>io_uring 支持使用 I/O 向量来进行批量的读写操作。通过使用 I/O 向量，可以减少系统调用的次数，提高效率。在使用 I/O 向量时，需要注意正确设置每个向量的偏移量和长度。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>使用事件完成通知（Event Completion Notification）&lt;/td>
&lt;td>io_uring 支持使用事件完成通知来提高效率。通过使用事件完成通知，可以避免轮询等待 I/O 完成，而是在 I/O 完成时立即得到通知。这样可以减少 CPU 的占用和响应时间。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>合理设置 I/O 队列深度（I/O Queue Depth）&lt;/td>
&lt;td>io_uring 的性能受到 I/O 队列深度的影响。较大的队列深度可以提高并发性能，但也会增加内存开销。建议根据系统的负载和性能需求，合理设置 I/O 队列深度。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>使用合适的内存分配策略&lt;/td>
&lt;td>io_uring 的性能也受到内存分配策略的影响。建议使用高效的内存分配器，如 jemalloc 或 tcmalloc，来减少内存分配和释放的开销。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>避免阻塞操作&lt;/td>
&lt;td>io_uring 是一个异步 I/O 框架，应尽量避免在 io_uring 的上下文中进行阻塞操作。阻塞操作会导致 io_uring 的性能下降，甚至可能引起死锁。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>使用合适的文件描述符（File Descriptor）&lt;/td>
&lt;td>io_uring 支持对文件、套接字和管道等不同类型的文件描述符进行操作。在使用 io_uring 时，需要根据实际情况选择合适的文件描述符类型，并正确设置相关的参数。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>注意错误处理&lt;/td>
&lt;td>在使用 io_uring 时，需要注意正确处理错误。io_uring 的错误码可能是负数，可以使用 errno.h 中定义的错误码来进行解析和处理。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>通过遵循上述优化和最佳实践，可以充分发挥 io_uring 的性能优势，提高系统的 I/O 性能和响应速度。然而，需要根据具体的应用场景和需求，进行合理的调优和配置。在实际使用中，可以通过性能测试和监测来评估和优化 io_uring 的性能。&lt;/p>
&lt;h2 id="结论">结论&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>io_uring 是一个高性能的异步 I/O 框架，通过在 Linux 内核中引入新的 I/O 模型，它能够显著提高 I/O 操作的吞吐量和响应速度。本章节我们深入探讨了 io_uring 的优化和最佳实践，以帮助开发者充分发挥其性能优势。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在使用 io_uring 时，我们可以采取一系列优化措施来提高性能。首先，批量提交多个 I/O 请求可以减少系统调用的开销，提高效率。此外，预分配 I/O 请求、使用 I/O 链接和 I/O 向量等技术也能够减少内存分配和系统调用的次数，进一步提升性能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>除了以上的优化技巧，我们还介绍了一些最佳实践。合理设置 I/O 队列深度、使用事件完成通知和选择合适的文件描述符类型等都能够对性能产生积极影响。此外，避免阻塞操作和正确处理错误也是使用 io_uring 时需要注意的事项。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过遵循这些优化和最佳实践，开发者可以充分发挥 io_uring 的性能优势，提高系统的 I/O 性能和响应速度。然而，需要根据具体的应用场景和需求，进行合理的调优和配置。在实际使用中，可以通过性能测试和监测来评估和优化 io_uring 的性能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>io_uring 作为一个新兴的异步 I/O 框架，具有很大的潜力和广阔的应用前景。它已经在许多领域得到了广泛的应用，如数据库、网络服务器和存储系统等。随着对 io_uring 的进一步研究和优化，相信它将在未来发挥更大的作用，并成为开发者们的首选工具之一。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;p>[1] io_uring 官方文档：&lt;a class="link" href="https://kernel.dk/io_uring.pdf" target="_blank" rel="noopener" >https://kernel.dk/io_uring.pdf
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;p>[2] How io_uring and eBPF Will Revolutionize Programming in Linux[1], ScyllaDB&lt;/p>
&lt;p>[3] 2020 An Introduction to the io_uring Asynchronous I/O Framework[2], Oracle, 2020&lt;/p>
&lt;p>[4] liburing GitHub 仓库：&lt;a class="link" href="https://github.com/axboe/liburing" target="_blank" rel="noopener" >https://github.com/axboe/liburing
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p></description></item><item><title>Java-Stream 常见用法</title><link>https://cuterwrite.top/p/java-stream/</link><pubDate>Tue, 11 May 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/java-stream/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/bridge-5621201_1920.6p53ez4buso0.webp" alt="Featured image of post Java-Stream 常见用法" />&lt;hr>
&lt;h1 id="stream-常见用法">Stream 常见用法&lt;/h1>
&lt;h2 id="1-stream-概述">1 Stream 概述&lt;/h2>
&lt;p>&lt;code>Stream&lt;/code> 将要处理的元素集合看作一种流，在流的过程中，借助&lt;code>Stream API&lt;/code> 对流中的元素进行操作，比如：筛选、排序、聚合等。&lt;/p>
&lt;p>&lt;code>Stream&lt;/code> 可以由数组或集合创建，对流的操作分为两种：&lt;/p>
&lt;ol>
&lt;li>中间操作，每次返回一个新的流，可以有多个。&lt;/li>
&lt;li>终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值。&lt;/li>
&lt;/ol>
&lt;p>另外，&lt;code>Stream&lt;/code> 有几个特性：&lt;/p>
&lt;ol>
&lt;li>stream 不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。&lt;/li>
&lt;li>stream 不会改变数据源，通常情况下会产生一个新的集合或一个值。&lt;/li>
&lt;li>stream 具有延迟执行特性，只有调用终端操作时，中间操作才会执行。&lt;/li>
&lt;/ol>
&lt;h2 id="2-stream-创建">2 Stream 创建&lt;/h2>
&lt;h3 id="21-collectionstream">2.1 Collection.stream()&lt;/h3>
&lt;pre>&lt;code class="language-java">List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
Stream&amp;lt;Integer&amp;gt; stream = list.stream();
//并行流
Stream&amp;lt;Integer&amp;gt; parallelStream = list.parallelStream();
&lt;/code>&lt;/pre>
&lt;h3 id="22-arraysstreamt-array">2.2 Arrays.stream(T[] array)&lt;/h3>
&lt;pre>&lt;code class="language-java">int[] array = new int[]{1, 2, 3, 4, 5};
IntStream stream = Arrays.stream(array)
&lt;/code>&lt;/pre>
&lt;h3 id="23-streamof--iterate--generate">2.3 Stream.of / iterate / generate&lt;/h3>
&lt;pre>&lt;code>Stream&amp;lt;Integer&amp;gt; stream = Stream.of(1, 2, 3, 4, 5, 6);
//创建从 0 开始，间距为 3 的 stream（个数为 4）
Stream&amp;lt;Integer&amp;gt; stream2 = Stream.iterate(0, x -&amp;gt; x + 3).limit(4);
&lt;/code>&lt;/pre>
&lt;h2 id="3-stream-使用">3 Stream 使用&lt;/h2>
&lt;h3 id="31-optional">3.1 Optional&lt;/h3>
&lt;p>&lt;code>Optional&lt;/code> 类是一个可以为&lt;code>null&lt;/code> 的容器对象。如果值存在则&lt;code>isPresent()&lt;/code>方法会返回&lt;code>true&lt;/code>，调用&lt;code>get()&lt;/code>方法会返回该对象。&lt;/p>
&lt;h3 id="32-遍历-foreachfindmatch">3.2 遍历 forEach/find/match&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>遍历输出符合条件的元素&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().filter(x -&amp;gt; x &amp;gt; 6).forEach(System.out::println);
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>遍历对元素执行某个方法&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().forEach(methodName);
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>匹配一个&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().filter(x -&amp;gt; x &amp;gt; 6).findFirst();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>是否包含特定条件的元素&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().anyMatch(x -&amp;gt; x &amp;lt; 6);
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>所有元素满足条件&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().allMatch(x -&amp;gt; x == 1);
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h3 id="33-筛选-filter">3.3 筛选 filter&lt;/h3>
&lt;p>同上，直接在 stream 对象上使用就行&lt;/p>
&lt;h3 id="34-聚合-maxmincount">3.4 聚合 max/min/count&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>获取 int 数组中中的最大值&lt;/p>
&lt;pre>&lt;code class="language-java">Arrays.stream(array).max().getAsInt();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>获取 Integer 列表中的最大值，需要传入一个 Comparator 对象&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().max(Integer::compareTo).get();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>获取 String 列里中长度最长的元素&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().max(Comparator.comparing(String::length)).get();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>获取员工列表工资最高的员工&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().max(Comparator.comparing(Person::getSalary)).get();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>计算 Integer 集合中大于 6 的元素的个数&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().filter(x -&amp;gt; x &amp;gt; 6).count();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h3 id="35-映射-mapflatmap">3.5 映射 map/flatMap&lt;/h3>
&lt;p>映射，可以将一个流的元素按照一定的映射规则映射到另一个流中。分为&lt;code>map&lt;/code> 和&lt;code>flatMap&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>&lt;code>map&lt;/code>：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。&lt;/li>
&lt;li>&lt;code>flatMap&lt;/code>：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ul>
&lt;li>
&lt;p>将字符串数组的元素全部改成大写&lt;/p>
&lt;pre>&lt;code class="language-java">Arrays.stream(array).map(String::toUpperCase).collect(Collectors.toList());
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>将员工薪资全部增加 1000&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().map(person -&amp;gt; {
person.setSalary(person.getSalary() + 1000);
return person;
}).collect(Collectors.toList());
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h3 id="36-规约-reduce">3.6 规约 reduce&lt;/h3>
&lt;p>将一个流缩减为一个值，能实现集合求和，求乘积和求最值操作等。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>求 Integer 列表的元素之和，乘积和最大值&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().reduce(Integer::sum).get();
list.stream().reduce((x,y) -&amp;gt; x + y).get();
list.stream().reduce((x,y) -&amp;gt; x * y).get();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h3 id="37-收集-collect">3.7 收集 collect&lt;/h3>
&lt;p>就是把一个流收集起来，最终可以是收集成一个值也可以收集成一个新的集合。&lt;/p>
&lt;p>&lt;code>collect&lt;/code> 主要依赖&lt;code>java.util.stream.Collectors&lt;/code> 类内置的静态方法。&lt;/p>
&lt;ul>
&lt;li>归集：toList()，toSet()，toMap()&lt;/li>
&lt;li>统计：counting、averagingInt、averagingLong、averagingDouble、maxBy、minBy、summingInt、summingLong、summingDouble、sumarizingInt、sumarizingLong、sumarizingDouble&lt;/li>
&lt;/ul>
&lt;h3 id="38-分组-groupingbypartitioningby">3.8 分组 groupingBy/partitioningBy&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>将员工按薪资是否高于 8000 分组&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().collect(Collectors.groupingBy(x -&amp;gt; x.getSalary() &amp;gt; 8000))
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>将员工按性别分组&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().collect(Collectors.groupingBy(Person::getSex));
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h3 id="39-连接-joining">3.9 连接 joining&lt;/h3>
&lt;p>将 stream 中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().collect(Collectors.joining(&amp;quot;,&amp;quot;));
&lt;/code>&lt;/pre>
&lt;h3 id="310-排序-sorted">3.10 排序 sorted&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>按工资升序排序&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().sorted(Compartor.comparing(Person::getSalary));
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>按工资倒序排序&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().sorted(Compartor.comparing(Person::getSalary)).reversed();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>多列排序&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().sorted(Compartor.comparing(Person::getSalary).thenComparing(Person::getAge));
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul></description></item><item><title>Java 并发知识点笔记</title><link>https://cuterwrite.top/p/java-concurrent/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/java-concurrent/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/santorini-1578440_1920.3ldusy6rm1k0.webp" alt="Featured image of post Java 并发知识点笔记" />&lt;h1 id="java-并发知识点笔记">Java 并发知识点笔记&lt;/h1>
&lt;h2 id="1-使用线程的方法">1 使用线程的方法&lt;/h2>
&lt;ul>
&lt;li>实现 Runnable 接口；&lt;/li>
&lt;li>实现 Callable 接口；&lt;/li>
&lt;li>继承 Thread 类。&lt;/li>
&lt;/ul>
&lt;h2 id="2-基础线程机制">2 基础线程机制&lt;/h2>
&lt;h3 id="21-executor">2.1 Executor&lt;/h3>
&lt;p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。&lt;/p>
&lt;p>主要有三种 Executor：&lt;/p>
&lt;ul>
&lt;li>CachedThreadPool：一个任务创建一个线程；&lt;/li>
&lt;li>FixedThreadPool：所有任务只能使用固定大小的线程；&lt;/li>
&lt;li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。&lt;/li>
&lt;/ul>
&lt;h3 id="22-daemon">2.2 Daemon&lt;/h3>
&lt;p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。&lt;/p>
&lt;p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。&lt;/p>
&lt;p>main() 属于非守护线程。&lt;/p>
&lt;p>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。&lt;/p>
&lt;h3 id="23-sleep">2.3 sleep()&lt;/h3>
&lt;p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。&lt;/p>
&lt;p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。&lt;/p>
&lt;h3 id="24-yield">2.4 yield()&lt;/h3>
&lt;p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。&lt;/p>
&lt;h2 id="3-线程中断">3 线程中断&lt;/h2>
&lt;p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。&lt;/p>
&lt;h3 id="31-interruptedexception">3.1 InterruptedException&lt;/h3>
&lt;p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。&lt;/p>
&lt;h3 id="32-interrupted">3.2 interrupted()&lt;/h3>
&lt;p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。&lt;/p>
&lt;p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。&lt;/p>
&lt;h3 id="33-executor-的中断操作">3.3 Executor 的中断操作&lt;/h3>
&lt;p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。&lt;/p>
&lt;h2 id="4-互斥锁">4 互斥锁&lt;/h2>
&lt;p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。&lt;/p>
&lt;h3 id="41-synchronized">4.1 synchronized&lt;/h3>
&lt;ul>
&lt;li>同步代码块：锁对象&lt;/li>
&lt;li>同步一个方法：锁对象&lt;/li>
&lt;li>同步一个类：锁整个类&lt;/li>
&lt;li>同步一个静态方法：锁整个类&lt;/li>
&lt;/ul>
&lt;h3 id="42-reentrantlock">4.2 ReentrantLock&lt;/h3>
&lt;p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。&lt;/p>
&lt;p>通过 lock 和 unlock 操作&lt;/p>
&lt;h3 id="43-比较">4.3 比较&lt;/h3>
&lt;p>&lt;strong>1. 锁的实现&lt;/strong>&lt;/p>
&lt;p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。&lt;/p>
&lt;p>&lt;strong>2. 性能&lt;/strong>&lt;/p>
&lt;p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。&lt;/p>
&lt;p>&lt;strong>3. 等待可中断&lt;/strong>&lt;/p>
&lt;p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。&lt;/p>
&lt;p>ReentrantLock 可中断，而 synchronized 不行。&lt;/p>
&lt;p>&lt;strong>4. 公平锁&lt;/strong>&lt;/p>
&lt;p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。&lt;/p>
&lt;p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。&lt;/p>
&lt;p>&lt;strong>5. 锁绑定多个条件&lt;/strong>&lt;/p>
&lt;p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。&lt;/p>
&lt;h3 id="44-选择">4.4 选择&lt;/h3>
&lt;p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。&lt;/p>
&lt;h2 id="5-线程协作">5 线程协作&lt;/h2>
&lt;h3 id="51-join">5.1 join&lt;/h3>
&lt;p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。&lt;/p>
&lt;h3 id="52-waitnotify">5.2 wait/notify&lt;/h3>
&lt;p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。&lt;/p>
&lt;p>它们都属于 Object 的一部分，而不属于 Thread。&lt;/p>
&lt;p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。&lt;/p>
&lt;p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁&lt;/p>
&lt;p>&lt;strong>wait() 和 sleep() 的区别&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；&lt;/li>
&lt;li>wait() 会释放锁，sleep() 不会。&lt;/li>
&lt;/ul>
&lt;h3 id="53-awaitsignal">5.3 await/signal&lt;/h3>
&lt;p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。&lt;/p>
&lt;p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。&lt;/p>
&lt;p>使用 Lock 来获取一个 Condition 对象。&lt;/p>
&lt;h2 id="6-线程状态">6 线程状态&lt;/h2>
&lt;ul>
&lt;li>new&lt;/li>
&lt;li>runable&lt;/li>
&lt;li>blocked&lt;/li>
&lt;li>waiting&lt;/li>
&lt;li>timed_waiting&lt;/li>
&lt;li>terminated&lt;/li>
&lt;/ul>
&lt;h2 id="7-juc-包aqs">7 JUC 包/AQS&lt;/h2>
&lt;h3 id="71-countdownlatch">7.1 CountDownLatch&lt;/h3>
&lt;p>用来控制一个或者多个线程等待多个线程。&lt;/p>
&lt;p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="72-cyclicbarrier">7.2 CyclicBarrier&lt;/h3>
&lt;p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。&lt;/p>
&lt;p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。&lt;/p>
&lt;p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。&lt;/p>
&lt;p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png" width="90%" loading="lazy">
&lt;/figure>
&lt;h3 id="73-semaphore">7.3 Semaphore&lt;/h3>
&lt;p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。&lt;/p>
&lt;h2 id="8-juc-包其它组件">8 JUC 包其它组件&lt;/h2>
&lt;h3 id="81-futuretask">8.1 FutureTask&lt;/h3>
&lt;p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future&amp;lt;V&amp;gt; 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future&amp;lt;V&amp;gt; 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。&lt;/p>
&lt;p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。&lt;/p>
&lt;h3 id="82-blockingqueue">8.2 BlockingQueue&lt;/h3>
&lt;p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>FIFO 队列&lt;/strong> ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）&lt;/li>
&lt;li>&lt;strong>优先级队列&lt;/strong> ：PriorityBlockingQueue&lt;/li>
&lt;/ul>
&lt;p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。&lt;/p>
&lt;h3 id="83-forkjoin">8.3 ForkJoin&lt;/h3>
&lt;p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。&lt;/p>
&lt;p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。&lt;/p>
&lt;h2 id="9-内存模型">9 内存模型&lt;/h2>
&lt;p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。&lt;/p>
&lt;h3 id="91-主内存与工作内存">9.1 主内存与工作内存&lt;/h3>
&lt;p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。&lt;/p>
&lt;p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942ca0d2-9d5c-45a4-89cb-5fd89b61913f.png" width="90%" loading="lazy">
&lt;/figure>
&lt;p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。&lt;/p>
&lt;p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15851555-5abc-497d-ad34-efed10f43a6b.png" width="90%" loading="lazy">
&lt;/figure>
&lt;h3 id="92-内存间交互操作">9.2 内存间交互操作&lt;/h3>
&lt;p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8b7ebbad-9604-4375-84e3-f412099d170c.png" width="90%" loading="lazy">
&lt;/figure>
&lt;ul>
&lt;li>read：把一个变量的值从主内存传输到工作内存中&lt;/li>
&lt;li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中&lt;/li>
&lt;li>use：把工作内存中一个变量的值传递给执行引擎&lt;/li>
&lt;li>assign：把一个从执行引擎接收到的值赋给工作内存的变量&lt;/li>
&lt;li>store：把工作内存的一个变量的值传送到主内存中&lt;/li>
&lt;li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中&lt;/li>
&lt;li>lock：作用于主内存的变量&lt;/li>
&lt;li>unlock&lt;/li>
&lt;/ul>
&lt;h3 id="93-内存模型三大特性">9.3 内存模型三大特性&lt;/h3>
&lt;h4 id="931-原子性">9.3.1. 原子性&lt;/h4>
&lt;p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。&lt;/p>
&lt;p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。&lt;/p>
&lt;p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。&lt;/p>
&lt;p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2797a609-68db-4d7b-8701-41ac9a34b14f.jpg" width="90%" loading="lazy">
&lt;/figure>
&lt;p>AtomicInteger 能保证多个线程修改的原子性。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dd563037-fcaa-4bd8-83b6-b39d93a12c77.jpg" width="90%" loading="lazy">
&lt;/figure>
&lt;p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。&lt;/p>
&lt;h4 id="932-可见性">9.3.2. 可见性&lt;/h4>
&lt;p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。&lt;/p>
&lt;p>主要有三种实现可见性的方式：&lt;/p>
&lt;ul>
&lt;li>volatile&lt;/li>
&lt;li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。&lt;/li>
&lt;li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。&lt;/li>
&lt;/ul>
&lt;p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。&lt;/p>
&lt;h4 id="933-有序性">9.3.3. 有序性&lt;/h4>
&lt;p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。&lt;/p>
&lt;p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。&lt;/p>
&lt;p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。&lt;/p>
&lt;h3 id="94-先行发生原则">9.4 先行发生原则&lt;/h3>
&lt;p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。&lt;/p>
&lt;ol>
&lt;li>单一线程原则：在一个线程内，在程序前面的操作先行发生于后面的操作。&lt;/li>
&lt;li>管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。&lt;/li>
&lt;li>volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。&lt;/li>
&lt;li>线程启动规则：Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。&lt;/li>
&lt;li>线程加入规则：Thread 对象的结束先行发生于 join() 方法返回。&lt;/li>
&lt;li>线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。&lt;/li>
&lt;li>对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。&lt;/li>
&lt;li>传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。&lt;/li>
&lt;/ol>
&lt;h2 id="10-线程安全策略">10 线程安全策略&lt;/h2>
&lt;h3 id="101-不可变">10.1 不可变&lt;/h3>
&lt;p>不可变的类型：&lt;/p>
&lt;ul>
&lt;li>final 关键字修饰的基本数据类型&lt;/li>
&lt;li>String&lt;/li>
&lt;li>枚举类型&lt;/li>
&lt;li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。&lt;/li>
&lt;/ul>
&lt;p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。&lt;/p>
&lt;h3 id="102-互斥同步">10.2 互斥同步&lt;/h3>
&lt;p>synchronized 和 ReentrantLock。&lt;/p>
&lt;h3 id="103-非阻塞同步">10.3 非阻塞同步&lt;/h3>
&lt;ul>
&lt;li>CAS&lt;/li>
&lt;li>AtomicInteger&lt;/li>
&lt;/ul>
&lt;p>ABA 问题：如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。&lt;/p>
&lt;p>解决方法：J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。&lt;/p>
&lt;h3 id="104-无同步">10.4 无同步&lt;/h3>
&lt;h4 id="1041-栈封闭">10.4.1 栈封闭&lt;/h4>
&lt;p>多个线程访问同一个方法的&lt;strong>局部变量&lt;/strong>时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。&lt;/p>
&lt;h4 id="1042-线程本地存储">10.4.2 线程本地存储&lt;/h4>
&lt;p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围&lt;strong>限制在同一个线程之内&lt;/strong>，这样，无须同步也能保证线程之间不出现数据争用的问题。&lt;/p>
&lt;p>它提供了线程本地变量，也就是如果你创建了一个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作的自己本地内存里面的变量，从而避免了线程安全问题&lt;/p>
&lt;p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。&lt;/p>
&lt;p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&amp;gt;value 键值对插入到该 Map 中。&lt;/p>
&lt;h4 id="1043-可重入代码">10.4.3 可重入代码&lt;/h4>
&lt;p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。&lt;/p>
&lt;p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。&lt;/p>
&lt;h2 id="11-锁优化">11 锁优化&lt;/h2>
&lt;h3 id="111-自旋锁">11.1 自旋锁&lt;/h3>
&lt;p>自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。&lt;/p>
&lt;p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于&lt;strong>共享数据的锁定状态很短&lt;/strong>的场景。&lt;/p>
&lt;p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。&lt;/p>
&lt;h3 id="112-锁消除">11.2 锁消除&lt;/h3>
&lt;p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。&lt;/p>
&lt;p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。&lt;/p>
&lt;h3 id="113-锁粗化">11.3 锁粗化&lt;/h3>
&lt;p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。&lt;/p>
&lt;p>如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。&lt;/p>
&lt;h3 id="114-轻量级锁">11.4 轻量级锁&lt;/h3>
&lt;p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。&lt;/p>
&lt;p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。&lt;/p>
&lt;h3 id="115-偏向锁">11.5 偏向锁&lt;/h3>
&lt;p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。&lt;/p>
&lt;hr>
&lt;p>本文转载自：&lt;a class="link" href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener" >https://github.com/CyC2018/CS-Notes
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
，用于个人复习。&lt;/p></description></item></channel></rss>