<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Cuterwrite's Blog</title><link>https://cuterwrite.top/post/</link><description>Recent content in Posts on Cuterwrite's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>cuterwrite</copyright><lastBuildDate>Sat, 15 Jun 2024 01:00:00 +0000</lastBuildDate><atom:link href="https://cuterwrite.top/post/index.xml" rel="self" type="application/rss+xml"/><item><title>RDMA 之 Address Handle</title><link>https://cuterwrite.top/p/rdma-address-handle/</link><pubDate>Sat, 15 Jun 2024 01:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/rdma-address-handle/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-16_116373922_p9_master1200.webp" alt="Featured image of post RDMA 之 Address Handle" />&lt;h1 id="rdma-之-address-handle">RDMA 之 Address Handle&lt;/h1>
&lt;p>&lt;strong>本文欢迎非商业转载，转载请注明出处。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>声明：仅用于收藏，便于阅读&lt;/p>&lt;span class="cite">&lt;span>― &lt;/span>&lt;span>Savir, &lt;/span>&lt;a href="https://zhuanlan.zhihu.com/p/163552044">&lt;cite>知乎专栏：8. RDMA 之 Address Handle&lt;/cite>&lt;/a>&lt;/span>&lt;/blockquote>
&lt;p>前面已经介绍过，RDMA 通信的基本单元是 QP。我们来思考一个问题，假设 A 节点的某个 QP 要跟 B 节点的某个 QP 交换信息，除了要知道 B 节点的 QP 序号——QPN 之外，还需要什么信息？要知道，QPN 是每个节点独立维护的序号，不是整个网络中唯一的。比如 A 的 QP 3 要跟 B 的 QP 5 通信，网络中可不止一个 QP5，可能有很多个节点都有自己的 QP 5。所以我们自然可以想到，还需要找到让每个节点都有一个独立的标识。&lt;/p>
&lt;p>在传统 TCP-IP 协议栈中，使用了家喻户晓的 IP 地址来标识网络层的每个节点。而 IB 协议中的这个标识被称为&lt;strong>GID（Global Identifier，全局 ID）&lt;/strong>，是一个 128 bits 的序列。关于 GID 本篇不展开讨论，将在后面介绍。&lt;/p>
&lt;h2 id="ah-是什么">AH 是什么&lt;/h2>
&lt;p>AH 全称为 Address Handle，没有想到特别合适的中文翻译，就先直译为“地址句柄”吧。这里的地址，指的是一组用于找到某个远端节点的信息的集合，在 IB 协议中，地址指的是 GID、端口号等等信息；而所谓句柄，我们可以理解为一个指向某个对象的指针。&lt;/p>
&lt;p>大家是否还记得 IB 协议中有四种基本服务类型——RC、UD、RD 和 UC，其中最常用的是 RC 和 UD。RC 的特点是两个节点的 QP 之间会建立可靠的连接，一旦建立连接关系便不容易改变，对端的信息是创建 QP 的时候储存在 QP Context 中的；&lt;/p>
&lt;p>而对于 UD 来说，QP 间没有连接关系，用户想发给谁，就在 WQE 中填好对端的地址信息就可以了。&lt;strong>用户不是直接把对端的地址信息填到 WQE 中的，而是提前准备了一个“地址薄”，每次通过一个索引来指定对端节点的地址信息，而这个索引就是 AH。&lt;/strong>&lt;/p>
&lt;p>AH 的概念大致可以用下图表示：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-16_8_1.webp"
alt="2024-06-16_8_1" width="auto" loading="lazy">&lt;figcaption>
&lt;h4>Address Handle 功能示意图&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>对于每一个目的节点，本端都会创建一个对应的 AH，而同一个 AH 可以被多个 QP 共同使用。&lt;/p>
&lt;h2 id="ah-的作用">AH 的作用&lt;/h2>
&lt;p>每次进行 UD 服务类型的通信之前，用户都需要先通过 IB 框架提供的接口，来&lt;strong>为每一个可能的对端节点创建一个 AH&lt;/strong>，然后这些 AH 会被驱动放到一个“安全”的区域，并返回一个索引（指针/句柄）给用户。用户真正下发 WR（Work Request）时，就把这个索引传递进来就可以了。&lt;/p>
&lt;p>上述过程如下图所示，A 节点收到用户的这样一个任务——使用本端的 QP4 与 B 节点（通过 AH 指定）的 QP3 进行数据交换：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-16_8_2.webp"
alt="2024-06-16_8_2" width="auto" loading="lazy">&lt;figcaption>
&lt;h4>UD 服务类型使用 AH 指定对端节点&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>IB 协议中并没有对为什么使用 AH 做出解释，我认为定义 AH 的概念的原因有以下三种：&lt;/p>
&lt;ol>
&lt;li>保证目的地址可用，提高效率&lt;/li>
&lt;/ol>
&lt;p>因为 UD 无连接的特点，用户可以在用户态直接通过 WR 来指定目的地。而如果让用户随意填写地址信息，然后硬件就根据这些信息进行组包的话，是会带来问题的。比如有这样一种场景：用户通过 WR 告诉硬件请给 GID 为 X，MAC 地址为 Y 的节点的端口 Z 发送数据。然而 X，Y，Z 可能不是一个合法的组合，或者 GID 为 X 的节点压根都不存在于网络中，而硬件是无力校验这些内容的，只能乖乖的组包、发送数据，这个目的地无效的数据包就白白发送出去了。&lt;/p>
&lt;p>而提前准备好地址信息，则可以避免上述情况。用户在创建 AH 时会陷入内核态，如果用户传递的参数有效，内核会把这些目的节点信息储存起来，生成一个指针返回给用户；如果用户传递的参数无效，AH 将创建失败。这一过程可以保证地址信息是有效的。用户通过指针就可以快速指定目的节点，加快数据交互流程。&lt;/p>
&lt;p>可能有人会问，既然内核是可信的，为什么不能在发送数据时陷入内核态去校验用户传递的地址信息呢？请别忘了 RDMA 技术的一大优势在哪里——数据流程可以直接从用户空间到硬件，完全绕过内核，这样可以避免系统调用和拷贝的开销。如果每次发送都要检验地址合法性的话，必然会降低通信速率。&lt;/p>
&lt;ol start="2">
&lt;li>向用户隐藏底层地址细节&lt;/li>
&lt;/ol>
&lt;p>用户创建 AH 时，只需要传递 gid、端口号、静态速率等信息，而其他通信所需的地址信息（主要是 MAC 地址）是内核驱动通过查询系统邻居表等方式解析到的，底层没有必要暴露这些额外的信息给用户层。&lt;/p>
&lt;ol start="3">
&lt;li>可以使用 PD 对目的地址进行管理&lt;/li>
&lt;/ol>
&lt;p>前文我们介绍保护域时曾经提过，除了 QP、MR 之外，AH 也由 PD 来进行资源划分。当定义了 AH 这个软件实体之后，我们就可以对所有的 QP 可达的目的地进行相互隔离和管理。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-16_8_3.webp"
alt="2024-06-16_8_3" width="auto" loading="lazy">&lt;figcaption>
&lt;h4>使用 PD 隔离 AH&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>​比如上图中，AH1~3 只能被同一个 PD 下的 QP3 和 QP9 使用，而 AH4 只能被 QP5 使用。&lt;/p>
&lt;h2 id="协议相关章节">协议相关章节&lt;/h2>
&lt;p>协议中关于 AH 的篇幅并不多，甚至没有独立介绍其概念的章节：&lt;/p>
&lt;p>[1] 9.8.3 UD 服务类型中的目的地址由哪些部分组成：包括 AH、 QPN 和 Q_key&lt;/p>
&lt;p>[2] 10.2.2.2 目的地址的相关注意事项&lt;/p>
&lt;p>[3] 11.2.2.1 AH 相关的 Verbs 接口&lt;/p>
&lt;p>AH 就介绍到这里，感谢阅读。下一篇打算向大家描述更多关于 QP 的细节。&lt;/p></description></item><item><title>Docker Hub 镜像下架解决方案</title><link>https://cuterwrite.top/p/dockerhub-takedown/</link><pubDate>Wed, 12 Jun 2024 19:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/dockerhub-takedown/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/2024-05-28_crop_68935d3d33a3abc75c797b67ad25160f195413.webp" alt="Featured image of post Docker Hub 镜像下架解决方案" />&lt;h1 id="docker-hub-镜像下架解决方案">Docker Hub 镜像下架解决方案&lt;/h1>
&lt;p>Docker Hub 作为 Docker 官方的镜像仓库，拥有着丰富的镜像资源， 极大地方便了开发者获取和使用各种软件和服务。然而，从 2024 年 6 月 6 日开始，国内各大镜像站点陆续出现了 Docker Hub 镜像下架的情况，包括阿里云、科大、南大、上交等全部挂掉，导致很多开发者无法正常拉取镜像。在执行 &lt;code>docker pull&lt;/code> 命令拉取镜像 docker 镜像时无反应，会一直循环尝试。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-13_takedown-dockerhub.webp"
alt="2024-06-13_takedown-dockerhub" width="auto" loading="lazy">
&lt;/figure>
&lt;p>Docker Hub 镜像下架的可能原因主要为一些镜像包含违规内容，导致上面信息监管部门出了最新要求，要求各大镜像站点下架相关镜像。&lt;/p>
&lt;h2 id="解决方案">解决方案&lt;/h2>
&lt;p>面对 Docker Hub 镜像下架问题，目前我们可以通过以下几种方式解决：&lt;/p>
&lt;h3 id="1-使用-atomhub-镜像站点">1. 使用 AtomHub 镜像站点&lt;/h3>
&lt;p>AtomHub 是由开放原子开源基金会发起，遵循 OCI 标准，旨在为开发者提供开放中立、安全可信、高效便捷的新一代开源容器镜像中心。其具有官方背书，是当前唯一正常的 Docker Hub 镜像站点。&lt;/p>
&lt;p>不过，AtomHub 的问题是镜像数量较少，目前只有几百个镜像文件；以及，部分软件的版本较旧。&lt;/p>
&lt;h4 id="配置-atomhub-镜像站点">配置 AtomHub 镜像站点&lt;/h4>
&lt;ul>
&lt;li>修改 /etc/docker/daemon.json 文件，添加以下内容：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-json">{
&amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://atomhub.openatom.cn&amp;quot;]
}
&lt;/code>&lt;/pre>
&lt;h4 id="重启-docker-服务">重启 Docker 服务：&lt;/h4>
&lt;pre>&lt;code class="language-bash">sudo systemctl daemon-reload
sudo systemctl restart docker
&lt;/code>&lt;/pre>
&lt;p>然后就可以正常拉取一些常用镜像了。但是，如果你需要的镜像不在 AtomHub 上，这个方法就不适用了。&lt;/p>
&lt;h3 id="2-配置-vpn-代理">2. 配置 VPN 代理&lt;/h3>
&lt;p>通过配置 VPN 代理，可以访问被屏蔽的 Docker Hub 源站点，从而拉取镜像。但是，这种方法需要自备 VPN 服务，且速度可能较慢且不稳定。&lt;/p>
&lt;h4 id="配置方法">配置方法&lt;/h4>
&lt;ul>
&lt;li>创建 &lt;code>/etc/systemd/system/docker.service.d/http-proxy.conf&lt;/code> 文件，并添加以下内容：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-bash">[Service]
Environment=&amp;quot;HTTP_PROXY=http://your_proxy_server:port&amp;quot;
Environment=&amp;quot;HTTPS_PROXY=http://your_proxy_server:port&amp;quot;
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>重启 Docker 服务：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-bash">sudo systemctl daemon-reload
sudo systemctl restart docker
&lt;/code>&lt;/pre>
&lt;h3 id="3-使用-skopeo-拷贝镜像到私有镜像仓库">3. 使用 Skopeo 拷贝镜像到私有镜像仓库&lt;/h3>
&lt;p>Skopeo 是一个命令行工具，可以用于在不同的镜像仓库之间复制、检查和签名镜像。该方法需要一台海外云主机，且需要没有被墙。&lt;/p>
&lt;h4 id="具体步骤">具体步骤&lt;/h4>
&lt;p>这里以阿里云私有镜像仓库为例，将 Docker Hub 上的镜像复制到阿里云私有镜像仓库。&lt;/p>
&lt;ul>
&lt;li>首先，你需要启用&lt;a class="link" href="https://cr.console.aliyun.com/" target="_blank" rel="noopener" >阿里云容器镜像服务
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
，创建一个个人实例：&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-13_aliyun-container.webp"
alt="2024-06-13_aliyun-container" width="90%" loading="lazy">
&lt;/figure>
&lt;ul>
&lt;li>进入个人实例，创建一个命名空间：&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-13_create-namespace.webp"
alt="2024-06-13_create-namespace" width="90%" loading="lazy">
&lt;/figure>
&lt;ul>
&lt;li>创建一个镜像仓库（对应你想要复制的镜像）：&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-13_create-repository.webp"
alt="2024-06-13_create-repository" width="90%" loading="lazy">
&lt;/figure>
&lt;ul>
&lt;li>设置访问凭证：&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-13_set-pass.webp"
alt="2024-06-13_set-pass" width="90%" loading="lazy">
&lt;/figure>
&lt;ul>
&lt;li>然后，登录到你的海外云主机，先安装 Skopeo：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-bash">sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install -y skopeo
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>使用 Skopeo 拷贝镜像：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-bash">docker login --username=yourusername registry.cn-hangzhou.aliyuncs.com
skopeo copy docker://docker.io/library/image:tag docker://registry.cn-hangzhou.aliyuncs.com/yournamespace/yourimage:tag
&lt;/code>&lt;/pre>
&lt;h3 id="4-部署私有镜像仓库">4. 部署私有镜像仓库&lt;/h3>
&lt;p>除了以上方法，还可以通过最近一大佬开源的 &lt;a class="link" href="https://github.com/dqzboy/Docker-Proxy" target="_blank" rel="noopener" >Docker-Proxy
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
项目搭建自己的私有镜像仓库。&lt;/p>
&lt;a href="https://github.com/dqzboy/Docker-Proxy" target="_blank" class="card-github fetch-waiting no-styling" repo="dqzboy/Docker-Proxy" id="0.7121153272704787-card">
&lt;div class="gc-titlebar">
&lt;div class="gc-titlebar-left">
&lt;div class="gc-owner">
&lt;div id="0.7121153272704787-avatar" class="gc-avatar">&lt;/div>
&lt;div class="gc-user">dqzboy&lt;/div>
&lt;/div>
&lt;div class="gc-divider">/&lt;/div>
&lt;div class="gc-repo">Docker-Proxy&lt;/div>
&lt;/div>
&lt;div class="github-logo">&lt;/div>
&lt;/div>
&lt;div id="0.7121153272704787-description" class="gc-description">Waiting for api.github.com...&lt;/div>
&lt;div class="gc-infobar">
&lt;div id="0.7121153272704787-stars" class="gc-stars">0&lt;/div>
&lt;div id="0.7121153272704787-forks" class="gc-forks">0&lt;/div>
&lt;div id="0.7121153272704787-license" class="gc-license">unkown&lt;/div>
&lt;div id="0.7121153272704787-language" class="gc-language">Waiting...&lt;/div>
&lt;/div>
&lt;/a>
&lt;script id="0.7121153272704787-script" type="text/javascript" defer>
fetch('https://api.cuterwrite.top/api/repos/dqzboy\/Docker-Proxy', {
referrerPolicy: "no-referrer"
})
.then(response => response.json())
.then(data => {
document.getElementById('0.7121153272704787-description').innerText = data.description.replace(
/:[a-zA-Z0-9_]+:/g, '');
document.getElementById('0.7121153272704787-language').innerText = data.language;
document.getElementById('0.7121153272704787-forks').innerText = Intl.NumberFormat('en-us', {
notation: "compact",
maximumFractionDigits: 1
}).format(data.forks).replaceAll("\u202f", '');
document.getElementById('0.7121153272704787-stars').innerText = Intl.NumberFormat('en-us', {
notation: "compact",
maximumFractionDigits: 1
}).format(data.stargazers_count).replaceAll("\u202f", '');
const avatarEl = document.getElementById('0.7121153272704787-avatar');
avatarEl.style.backgroundImage = 'url(' + data.owner.avatar_url + ')';
avatarEl.style.backgroundColor = 'transparent';
if (data.license?.spdx_id) {
document.getElementById('0.7121153272704787-license').innerText = data.license.spdx_id
} else {
document.getElementById('0.7121153272704787-license').classList.add = "no-license"
};
document.getElementById('0.7121153272704787-card').classList.remove("fetch-waiting");
console.log("[GITHUB-CARD] Loaded card for dqzboy\/Docker-Proxy | 0.7121153272704787.")
}).catch(err => {
const c = document.getElementById('0.7121153272704787-card');
c.classList.add("fetch-error");
console.warn("[GITHUB-CARD] (Error) Loading card for dqzboy\/Docker-Proxy | 0.7121153272704787.")
})
&lt;/script>
&lt;p>该方法也需要一台海外云主机，且需要没有被墙；以及一个域名（不需要备案）。&lt;/p>
&lt;h4 id="部署">部署&lt;/h4>
&lt;p>目前项目提供了三种部署方式，我采用的是第一种方式，使用项目脚本一键部署。&lt;/p>
&lt;ul>
&lt;li>使用项目脚本一键部署：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-bash"># CentOS
yum -y install wget curl
# ubuntu
apt -y install wget curl
bash -c &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/dqzboy/Docker-Proxy/main/install/DockerProxy_Install.sh)&amp;quot;
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>部署到 Render&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://github.com/dqzboy/Docker-Proxy/blob/main/Render/README.md" target="_blank" rel="noopener" >使用 Render 快速部署
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Docker Compose 部署&lt;/p>
&lt;ol>
&lt;li>下载 config 目录下对应的 yml 文件到你本地机器上&lt;/li>
&lt;li>下载 &lt;a class="link" href="https://github.com/dqzboy/Docker-Proxy/blob/main/docker-compose.yaml" target="_blank" rel="noopener" >docker-compose.yaml
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
文件到你本地机器上，并且与配置文件同级目录下&lt;/li>
&lt;li>执行 &lt;code>docker compose&lt;/code> 命令启动容器服务&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">docker compose up -d
# 查看容器日志
docker logs -f [容器 ID 或名称]
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;p>最后，需要登录域名解析方，将 &lt;code>hub&lt;/code>、&lt;code>gcr&lt;/code>、&lt;code>ghcr&lt;/code>、&lt;code>k8s-gcr&lt;/code>、&lt;code>ui&lt;/code>、&lt;code>quay&lt;/code> 等 A 记录解析到你的海外云主机 IPv4 地址，然后就可以将 &lt;code>/etc/docker/daemon.json&lt;/code> 中的 &lt;strong>registry-mirrors&lt;/strong> 设置为 &lt;code>https://hub.yourdomain&lt;/code> 进行镜像加速了。&lt;/p></description></item><item><title>RDMA 之 Protection Domain</title><link>https://cuterwrite.top/p/rdma-protection-domain/</link><pubDate>Thu, 18 Apr 2024 21:42:00 +0000</pubDate><guid>https://cuterwrite.top/p/rdma-protection-domain/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/d31a474af07682028ca085f871bc5d07195413-2024-04-19.webp" alt="Featured image of post RDMA 之 Protection Domain" />&lt;h1 id="rdma-之-protection-domain">RDMA 之 Protection Domain&lt;/h1>
&lt;p>&lt;strong>本文欢迎非商业转载，转载请注明出处。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>声明：仅用于收藏，便于阅读&lt;/p>&lt;span class="cite">&lt;span>― &lt;/span>&lt;span>Savir, &lt;/span>&lt;a href="https://zhuanlan.zhihu.com/p/159493100">&lt;cite>知乎专栏：7. RDMA 之 Protection Domain&lt;/cite>&lt;/a>&lt;/span>&lt;/blockquote>
&lt;p>前文我们简单介绍了 RDMA 中最常见的一些资源，包括各种 Queue，以及 MR 的概念等等。MR 用于控制和管理 HCA 对于本端和远端内存的访问权限，确保 HCA 只有拿到正确 Key 之后才能读写用户已经注册了的内存区域。为了更好的保障安全性，IB 协议又提出了 Protection Domain（PD）的概念，用于保证 RDMA 资源间的相互隔离，本文就介绍一下 PD 的概念。&lt;/p>
&lt;h2 id="pd-是什么">PD 是什么&lt;/h2>
&lt;p>PD 全称是 Protection Domain，意为&amp;quot;保护域&amp;quot;。域的概念我们经常见到，从数学上的“实数域”、“复数域”，到地理上的“空域”、“海域”等等，表示一个空间/范围。在 RDMA 中，PD 像是一个容纳了各种资源（QP、MR 等）的“容器”，将这些资源纳入自己的保护范围内，避免他们被未经授权的访问。一个节点中可以定义多个保护域，各个 PD 所容纳的资源彼此隔离，无法一起使用。&lt;/p>
&lt;p>概念还是有些抽象，下面我们来看一下 PD 有什么作用，具体解决了什么问题。&lt;/p>
&lt;h2 id="pd-的作用">PD 的作用&lt;/h2>
&lt;p>一个用户可能创建多个 QP 和多个 MR，每个 QP 可能和不同的远端 QP 建立了连接，比如下图这样（灰色箭头表示 QP 间的连接关系）：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/7_1-2024-04-19.webp"
alt="7_1-2024-04-19" width="auto" loading="lazy">&lt;figcaption>
&lt;h4>图 1：没有 PD 概念时的 RDMA 资源&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>由于 MR 和 QP 之间并没有绑定关系，这就意味着一旦某个远端的 QP 与本端的一个 QP 建立了连接，具备了通信的条件，那么理论上远端节点只要知道 VA 和 R_key（甚至可以靠不断的猜测直到得到一对有效的值），就可以访问本端节点某个 MR 的内容。&lt;/p>
&lt;p>其实一般情况下，MR 的虚拟地址 VA 和秘钥 R_Key 是很难猜到的，已经可以保证一定的安全性了。但是为了更好的保护内存中的数据，把各种资源的权限做进一步的隔离和划分，我们在又在每个节点中定义了 PD，如下图所示&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/7_2-2024-04-19.webp"
alt="7_2-2024-04-19" width="auto" loading="lazy">&lt;figcaption>
&lt;h4>图 2：加入 PD 概念时的 RDMA 资源&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>图中 Node 0 上有两个 PD，将 3 个 QP 和 2 个 MR 分为了两组，此外 Node 1 和 Node 2 中各有一个 PD 包含了所有 QP 和 MR。Node 0 上的两个 PD 中的资源不可以一起使用，也就是说 QP3 和 QP9 不能访问 MR1 的数据，QP6 也不可以访问 MR0 的数据。如果我们在数据收发时，指定硬件使用 QP3 和 MR1，那么硬件校验他们不属于同一个 PD 后，会返回错误。&lt;/p>
&lt;p>对于远端节点来说，Node1 只能通过 QP8 相连的 QP3 来访问 Node0 的内存，但是因为 Node 0 的 QP3 被“圈”到了 PD0 这个保护域中，所以 Node 1 的 QP8 也只能访问 MR0 对应的内存，&lt;strong>无论如何都无法访问 MR1 中的数据&lt;/strong>，这是从两个方面限制的：&lt;/p>
&lt;ol>
&lt;li>Node 1 的 QP8 只跟 Node 0 的 QP3 有连接关系，无法通过 Node 0 的 QP6 进行内存访问。&lt;/li>
&lt;li>Node 0 的 MR1 和 QP3 属于不同的 PD，就算 Node 1 的 QP8 拿到了 MR1 的 VA 和 R_key，硬件也会因为 PD 不同而拒绝提供服务。&lt;/li>
&lt;/ol>
&lt;p>所以就如本文一开始所说的，PD 就像是一个容器，将一些 RDMA 资源保护起来，彼此隔离，以提高安全性。其实 RDMA 中不止有 QP、MR 这些资源，后文即将介绍的 Address Handle，Memory Window 等也是由 PD 进行隔离保护的。&lt;/p>
&lt;h2 id="如何使用-pd">如何使用 PD&lt;/h2>
&lt;p>还是看上面的图，我们注意到 Node 0 为了隔离资源，存在两个 PD；而 Node 1 和 Node 2 只有一个 PD 包含了所有资源。&lt;/p>
&lt;p>我之所以这样画，是为了说明一个节点上划分多少个 PD 完全是由用户决定的，&lt;strong>如果想提高安全性，那么对每个连接到远端节点的 QP 和供远端访问的 MR 都应该尽量通过划分 PD 做到隔离；如果不追求更高的安全性，那么创建一个 PD，囊括所有的资源也是可以的&lt;/strong>。&lt;/p>
&lt;p>IB 协议中规定：&lt;strong>每个节点都至少要有一个 PD，每个 QP 都必须属于一个 PD，每个 MR 也必须属于一个 PD&lt;/strong>。&lt;/p>
&lt;p>那么 PD 的包含关系在软件上是如何体现的呢？它本身是有一个软件实体的（结构体），记录了这个保护域的一些信息。用户在创建 QP 和 MR 等资源之前，必须先通过 IB 框架的接口创建一个 PD，拿到它的指针/句柄。接下来在创建 QP 和 MR 的时候，需要传入这个 PD 的指针/句柄，PD 信息就会包含在 QP 和 MR 中。硬件收发包时，会对 QP 和 MR 的 PD 进行校验。更多的软件协议栈的内容，我会在后面的文章中介绍。&lt;/p>
&lt;p>另外需要强调的是，&lt;strong>PD 是本地概念，仅存在于节点内部&lt;/strong>，对其他节点是不可见的；而 MR 是对本端和对端都可见的。&lt;/p>
&lt;p>为了方便大家查阅和学习，以后我会列出文章涉及的协议章节，前面的内容有时间的时候我也会补充一下。&lt;/p>
&lt;h2 id="pd-相关协议章节">PD 相关协议章节&lt;/h2>
&lt;ul>
&lt;li>3.5.5 PD 的基本概念和作用&lt;/li>
&lt;li>10.2.3 介绍了 PD 和其他一些 RDMA 资源的关系，以及 PD 相关的软件接口。&lt;/li>
&lt;li>10.6.3.5 再次强调 PD 和 MR 及 QP 的关系。&lt;/li>
&lt;li>11.2.1.5 详细介绍 PD 的 Verbs 接口，包括作用、入参、出参和返回值等。&lt;/li>
&lt;/ul>
&lt;p>好了，关于 PD 的介绍就到这里。下文我会介绍用于 UD 服务类型的 Address Handle 的概念。&lt;/p></description></item><item><title>RDMA 之 Memory Region</title><link>https://cuterwrite.top/p/rdma-mr/</link><pubDate>Wed, 03 Apr 2024 16:17:00 +0000</pubDate><guid>https://cuterwrite.top/p/rdma-mr/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/8fa232626b76940fddc8cc52a49c49e9195413-2024-04-04.webp" alt="Featured image of post RDMA 之 Memory Region" />&lt;h1 id="rdma-之-memory-region">RDMA 之 Memory Region&lt;/h1>
&lt;p>&lt;strong>本文欢迎非商业转载，转载请注明出处。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>声明：仅用于收藏，便于阅读&lt;/p>&lt;span class="cite">&lt;span>― &lt;/span>&lt;span>Savir, &lt;/span>&lt;a href="https://zhuanlan.zhihu.com/p/156975042">&lt;cite>知乎专栏：6. RDMA 之 Memory Region&lt;/cite>&lt;/a>&lt;/span>&lt;/blockquote>
&lt;p>我们假设一种场景，同时也顺便温习一下 RDMA WRITE 操作的流程：&lt;/p>
&lt;p>如下图所示，A 节点想要通过 IB 协议向 B 节点的内存中写入一段数据，上层应用给本节点的 RDMA 网卡下发了一个 WQE，WQE 中包含了源内存地址、目的内存地址、数据长度和秘钥等信息，然后硬件会从内存中取出数据，组包发送到对端网卡。B 节点的网卡收到数据后，解析到其中的目的内存地址，把数据写入到本节点的内存中。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/6_1-2024-04-04.webp"
alt="6_1-2024-04-04" width="auto" loading="lazy">
&lt;/figure>
&lt;p>那么问题来了，APP 提供的地址都是虚拟地址（Virtual Address，下文称 VA），经过 MMU 的转换才能得到真实的物理地址（Physical Address，下文称 PA），我们的&lt;strong>RDMA 网卡是如何得到 PA 从而去内存中拿到数据的呢&lt;/strong>？就算网卡知道上哪去取数据，&lt;strong>如果用户恶意指定了一个非法的 VA，那网卡岂不是有可能被“指使”去读写关键内存&lt;/strong>？&lt;/p>
&lt;p>为了解决上面的问题，IB 协议提出了 MR 的概念。&lt;/p>
&lt;h2 id="mr-是什么">MR 是什么&lt;/h2>
&lt;p>MR 全称为 Memory Region，指的是由 RDMA 软件层在内存中规划出的一片区域，用于存放收发的数据。IB 协议中，用户在申请完用于存放数据的内存区域之后，都需要通过调用 IB 框架提供的 API 注册 MR，才能让 RDMA 网卡访问这片内存区域。由下图可以看到，MR 就是一片特殊的内存而已：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/6_2-2024-04-04.webp"
alt="6_2-2024-04-04" width="auto" loading="lazy">
&lt;/figure>
&lt;p>在对 IB 协议进行相关描述时，我们通常称 RDMA 硬件为&lt;strong>HCA（Host Channel Adapter， 宿主通道适配器）&lt;/strong>，IB 协议中对其的定义是“处理器和 I/O 单元中能够产生和消耗数据包的 IB 设备”，为了与协议保持一致，我们在包括本文及之后的文章中都称硬件部分为 HCA。&lt;/p>
&lt;h2 id="为什么要注册-mr">为什么要注册 MR&lt;/h2>
&lt;p>下面我们来看一下 MR 是如何解决本文开篇提出的两个问题的：&lt;/p>
&lt;h3 id="1-注册-mr-以实现虚拟地址与物理地址转换">1. 注册 MR 以实现虚拟地址与物理地址转换&lt;/h3>
&lt;p>我们都知道 APP 只能看到虚拟地址，而且会在 WQE 中直接把 VA 传递给 HCA（既包括本端的源 VA，也包括对端的目的 VA）。现在的 CPU 都有 MMU 和页表这一“利器”来进行 VA 和 PA 之间的转换，而 HCA 要么直接连接到总线上，要么通过 IOMMU/SMMU 做地址转换后连接到总线上，它是“看不懂”APP 提供的 VA 所对应的真实物理内存地址的。&lt;/p>
&lt;p>所以注册 MR 的过程中，硬件会在内存中创建并填写一个 VA to PA 的映射表，这样需要的时候就能通过查表把 VA 转换成 PA 了。我们还是提供一个具体的例子来讲一下这个过程：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/6_3-2024-04-04.webp"
alt="6_3-2024-04-04" width="auto" loading="lazy">
&lt;/figure>
&lt;p>现在假设左边的节点向右边的节点发起了 RDMA WRITE 操作，即直接向右节点的内存区域中写入数据。假设图中两端都已经完成了注册 MR 的动作，MR 即对应图中的“数据 Buffer”，同时也创建好了 VA-&amp;gt;PA 的映射表。&lt;/p>
&lt;ul>
&lt;li>首先本端 APP 会下发一个 WQE 给 HCA，告知 HCA，用于存放待发送数据的本地 Buffer 的虚拟地址，以及即将写入的对端数据 Buffer 的虚拟地址。&lt;/li>
&lt;li>本端 HCA 查询 VA-&amp;gt;PA 映射表，得知待发数据的物理地址，然后从内存中拿到数据，组装数据包并发送出去。&lt;/li>
&lt;li>对端 HCA 收到了数据包，从中解析出了目的 VA。&lt;/li>
&lt;li>对端 HCA 通过存储在本地内存中的 VA-&amp;gt;PA 映射表，查到真实的物理地址，核对权限无误后，将数据存放到内存中。&lt;/li>
&lt;/ul>
&lt;p>再次强调一下，对于右侧节点来说，&lt;strong>无论是地址转换还是写入内存，完全不用其 CPU 的参与&lt;/strong>。&lt;/p>
&lt;h3 id="2-mr-可以控制-hca-访问内存的权限">2. MR 可以控制 HCA 访问内存的权限&lt;/h3>
&lt;p>因为 HCA 访问的内存地址来自于用户，如果用户传入了一个非法的地址（比如系统内存或者其他进程使用的内存），HCA 对其进行读写可能造成信息泄露或者内存覆盖。所以我们需要一种机制来确保 HCA 只能访问已被授权的、安全的内存地址。IB 协议中，APP 在为数据交互做准备的阶段，需要执行注册 MR 的动作。&lt;/p>
&lt;p>而用户注册 MR 的动作会产生两把钥匙——L_KEY（Local Key）和 R_KEY（Remote Key），说是钥匙，它们的实体其实就是一串序列而已。它们将分别用于保障对于本端和远端内存区域的访问权限。下面两张图分别是描述 L_Key 和 R_Key 的作用的示意图：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/6_4-2024-04-04.webp"
alt="6_4-2024-04-04" width="auto" loading="lazy">&lt;figcaption>
&lt;h4>L_Key&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/6_5-2024-04-04.webp"
alt="6_5-2024-04-04" width="auto" loading="lazy">&lt;figcaption>
&lt;h4>R_Key&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>这里大家可能会有疑问，本端是如何知道对端节点的可用 VA 和对应的 R_Key 的？其实两端的节点在真正的 RDMA 通信之前，都会通过某些方式先建立一条链路（可能是 Socket 连接，也可能是 CM 连接）并通过这条链路交换一些 RDMA 通信所必须的信息（VA，Key，QPN 等），我们称这一过程叫做“建链”和“握手”。我将在后面的文章中详细介绍。&lt;/p>
&lt;p>除了上面两个点之外，注册 MR 还有个重要的作用：&lt;/p>
&lt;h3 id="3-mr-可以避免换页">3. MR 可以避免换页&lt;/h3>
&lt;p>因为物理内存是有限的，所以操作系统通过换页机制来暂时把某个进程不用的内存内容保存到硬盘中。当该进程需要使用时，再通过缺页中断把硬盘中的内容搬移回内存，这一过程几乎必然导致 VA-PA 的映射关系发生改变。&lt;/p>
&lt;p>由于 HCA 经常会绕过 CPU 对用户提供的 VA 所指向的物理内存区域进行读写，如果前后的 VA-PA 映射关系发生改变，那么我们在前文提到的 VA-&amp;gt;PA 映射表将失去意义，HCA 将无法找到正确的物理地址。&lt;/p>
&lt;p>为了防止换页所导致的 VA-PA 映射关系发生改变，注册 MR 时会 &amp;ldquo;Pin&amp;rdquo; 住这块内存（亦称“锁页”），即锁定 VA-PA 的映射关系。也就是说，MR 这块内存区域会长期存在于物理内存中不被换页，直到完成通信之后，用户主动注销这片 MR。&lt;/p>
&lt;p>好了，至此我们介绍完了 MR 的概念和作用，下一篇文章我将给大家介绍一下 PD（Protection Domain，保护域）的概念。&lt;/p>
&lt;h2 id="代码示例">代码示例&lt;/h2>
&lt;p>下面是一个简单的 RDMA 程序，展示了如何注册 MR：&lt;/p>
&lt;pre>&lt;code class="language-c">#include &amp;lt;infiniband/verbs.h&amp;gt;
int main() {
// 省略初始化过程...
struct ibv_mr *mr;
mr = ibv_reg_mr(pd, buf, 1024, IBV_ACCESS_LOCAL_WRITE |
IBV_ACCESS_REMOTE_WRITE);
// 获取 L_Key 和 R_Key
uint32_t lkey = mr-&amp;gt;lkey;
uint32_t rkey = mr-&amp;gt;rkey;
// 省略其它代码...
}
&lt;/code>&lt;/pre></description></item><item><title>记录：安装 Intel® OneAPI-2024.0</title><link>https://cuterwrite.top/p/intel-oneapi/</link><pubDate>Fri, 08 Mar 2024 14:39:00 +0000</pubDate><guid>https://cuterwrite.top/p/intel-oneapi/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/crop_62cf8bae89f60c3522eb45af53a53f4b195413-2024-03-09.webp" alt="Featured image of post 记录：安装 Intel® OneAPI-2024.0" />&lt;h1 id="记录安装-intel-oneapi-20240">记录：安装 Intel® OneAPI-2024.0&lt;/h1>
&lt;p>Intel one API 由两个部分组成，前者为基础 Base Toolkit ，后者必须依赖前者，Intel one API HPC Toolkit，也就是要前后依次安装。&lt;/p>
&lt;h2 id="base-toolkit">Base Toolkit&lt;/h2>
&lt;p>Base Toolkit 是 Intel 的一个 API 基础工具包包括以下库和其他库&lt;/p>
&lt;pre>&lt;code class="language-text">Intel® oneAPI DPC++/C++ Compiler
Intel® DPC++ Compatibility Tool
Intel® oneAPI DPC++ Library
Intel® oneAPI Math Kernel Library
Intel® oneAPI Threading Building Blocks
Intel® oneAPI Collective Communications Library
Intel® oneAPI Data Analytics Library
Intel® oneAPI Deep Neural Networks Library
Intel® Integrated Performance Primitives
Intel® VTune™ Profiler
Intel® Advisor
Intel® Distribution for GDB*
Intel® Distribution for Python* (separate download required)
Intel® FPGA Add-on for oneAPI Base Toolkit (separate download required)
&lt;/code>&lt;/pre>
&lt;h3 id="base-toolkit-安装">Base Toolkit 安装&lt;/h3>
&lt;ol>
&lt;li>下载安装包&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">$ wget https://registrationcenter-download.intel.com/akdlm/IRC_NAS/163da6e4-56eb-4948-aba3-debcec61c064/l_BaseKit_p_2024.0.1.46_offline.sh
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>安装&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">$ chmod +x l_BaseKit_p_2024.0.1.46_offline.sh
$ sudo ./l_BaseKit_p_2024.0.1.46_offline.sh
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>如果自定义安装在用户目录，就不需要 root 权限&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>./l_BaseKit_p_2024.0.1.46_offline.sh
&lt;/code>&lt;/pre>
&lt;p>然后将启动一个图形安装界面，继续操作：&lt;/p>
&lt;p>&lt;strong>（1）选择 Accept &amp;amp; customize&lt;/strong>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/OneAPI-Accepet-2024-03-09.png"
alt="OneAPI-Accepet-2024-03-09" width="auto" loading="lazy">
&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>（2）选择安装的组件&lt;/strong>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/OneAPI-Select-2-2024-03-09.png"
alt="OneAPI-Select-2-2024-03-09" width="auto" loading="lazy">
&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>（3）选择安装的路径&lt;/strong>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/OneAPI-Select-3-2024-03-09.png"
alt="OneAPI-Select-3-2024-03-09" width="auto" loading="lazy">
&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>（4）选择 Next&lt;/strong>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/OneAPI-Select-4-2024-03-09.png"
alt="OneAPI-Select-4-2024-03-09" width="auto" loading="lazy">
&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>（5）选择 2 然后开始安装&lt;/strong>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/OneAPI-Select-5-2024-03-09.png"
alt="OneAPI-Select-5-2024-03-09" width="auto" loading="lazy">
&lt;/figure>
&lt;/p>
&lt;p>接下来等待安装完成即可。&lt;/p>
&lt;h2 id="hpc-toolkit">HPC Toolkit&lt;/h2>
&lt;p>运行基于 Base Toolkit ，这个必须作为后者安装&lt;/p>
&lt;pre>&lt;code class="language-text">Intel® Fortran Compiler
Intel® Fortran Compiler Classic
Intel® Inspector
Intel® MPI Library
Intel® Trace Analyzer and Collector
&lt;/code>&lt;/pre>
&lt;h3 id="hpc-toolkit-安装">HPC Toolkit 安装&lt;/h3>
&lt;ol>
&lt;li>下载安装包&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">$ wget https://registrationcenter-download.intel.com/akdlm/IRC_NAS/67c08c98-f311-4068-8b85-15d79c4f277a/l_HPCKit_p_2024.0.1.38_offline.sh
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>安装&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">$ chmod +x l_HPCKit_p_2024.0.1.38_offline.sh
$ sudo ./l_HPCKit_p_2024.0.1.38_offline.sh
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>如果自定义安装在用户目录，就不需要 root 权限&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>./l_HPCKit_p_2024.0.1.38_offline.sh
&lt;/code>&lt;/pre>
&lt;p>必须安装的库文件： Intel® MPI Library Intel® Fortran Compiler (Beta) &amp;amp; Intel® Fortran Compiler Classic Intel® oneAPI DPC++/C++ Compiler &amp;amp; Intel® C++ Compiler Classic&lt;/p>
&lt;p>安装过程与 Base Toolkit 类似，不再赘述。&lt;/p>
&lt;h2 id="环境配置">环境配置&lt;/h2>
&lt;p>安装完成后，需要配置环境变量，以便在终端中使用 Intel® oneAPI 工具。&lt;/p>
&lt;p>在 HPC 环境中，使用 &lt;code>modulefile&lt;/code> 来管理环境变量，可以使用 &lt;code>module&lt;/code> 命令来加载环境变量。&lt;/p>
&lt;p>以下是参考的 &lt;code>modulefile&lt;/code> 文件，可以根据自己的安装路径进行修改。&lt;/p>
&lt;pre>&lt;code class="language-modulefile">#%Module1.0#####################################################################
##
## modules modulefile
##
proc ModulesHelp { } {
global version prefix
puts stderr &amp;quot;\tmodules - loads the modules software &amp;amp; application environment&amp;quot;
puts stderr &amp;quot;\n\tThis adds $prefix/* to several of the&amp;quot;
puts stderr &amp;quot;\tenvironment variables.&amp;quot;
puts stderr &amp;quot;\n\tVersion $version\n&amp;quot;
}
module-whatis &amp;quot;loads intel/oneapi2024.0&amp;quot;
# for Tcl script use only
set version oneapi2024.0
set prefix /opt/software/intel/oneapi2024.0
conflict intel
prepend-path TBBROOT ${prefix}/tbb/2021.11/env/..
prepend-path DAALROOT ${prefix}/cdal/2024.0
prepend-path DPCT_BUNDLE_ROOT ${prefix}/dpcpp-ct/2024.0
prepend-path INSPECTOR_2023_DIR ${prefix}/inspector/2024.0
prepend-path ONEAPI_ROOT ${prefix}
prepend-path PKG_CONFIG_PATH ${prefix}/vtune/2024.0/include/pkgconfig/lib64:${prefix}/tbb/2021.11/env/../lib/pkgconfig:${prefix}/mpi/2021.11/lib/pkgconfig:${prefix}/mkl/2024.0/lib/pkgconfig:${prefix}/ippcp/2021.9/lib/pkgconfig:${prefix}/inspector/2024.0/include/pkgconfig/lib64:${prefix}/dpl/2022.3/lib/pkgconfig:${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp/../lib/pkgconfig:${prefix}/cdal/2024.0/lib/pkgconfig:${prefix}/compiler/2024.0/lib/pkgconfig:${prefix}/ccl/2021.11/lib/pkgconfig:${prefix}/advisor/2024.0/include/pkgconfig/lib64:
#prepend-path PKG_CONFIG_PATH ${prefix}/vtune/2024.0/include/pkgconfig/lib64:${prefix}/tbb/2021.11/env/../lib/pkgconfig:${prefix}/mkl/2024.0/lib/pkgconfig:${prefix}/ippcp/2021.9/lib/pkgconfig:${prefix}/inspector/2024.0/include/pkgconfig/lib64:${prefix}/dpl/2022.3/lib/pkgconfig:${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp/../lib/pkgconfig:${prefix}/cdal/2024.0/lib/pkgconfig:${prefix}/compiler/2024.0/lib/pkgconfig:${prefix}/ccl/2021.11/lib/pkgconfig:${prefix}/advisor/2024.0/include/pkgconfig/lib64:
prepend-path VT_MPI impi4
prepend-path ACL_BOARD_VENDOR_PATH /opt/Intel/OpenCLFPGA/oneAPI/Boards
prepend-path FPGA_VARS_DIR ${prefix}/compiler/2024.0/lib/oclfpga
prepend-path CCL_ROOT ${prefix}/ccl/2021.11
prepend-path VT_ADD_LIBS &amp;quot;-ldwarf -lelf -lvtunwind -lm -lpthread&amp;quot;
prepend-path I_MPI_ROOT ${prefix}/mpi/2021.11
prepend-path FI_PROVIDER_PATH ${prefix}/mpi/2021.11//libfabric/lib/prov:/usr/lib/x86_64-linux-gnu/libfabric
prepend-path DNNLROOT ${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp
prepend-path DIAGUTIL_PATH ${prefix}/vtune/2024.0/sys_check/vtune_sys_check.py:${prefix}/dpcpp-ct/2024.0/sys_check/sys_check.sh:${prefix}/debugger/2024.0/sys_check/debugger_sys_check.py:${prefix}/compiler/2024.0/sys_check/sys_check.sh:${prefix}/advisor/2024.0/sys_check/advisor_sys_check.py:
prepend-path CCL_CONFIGURATION cpu_gpu_dpcpp
prepend-path DPL_ROOT ${prefix}/dpl/2022.3
prepend-path MANPATH ${prefix}/mpi/2021.11/man:${prefix}/itac/2022.0/man:${prefix}/debugger/2024.0/documentation/man:${prefix}/compiler/2024.0/documentation/en/man/common:::
#prepend-path MANPATH ${prefix}/itac/2022.0/man:${prefix}/debugger/2024.0/documentation/man:${prefix}/compiler/2024.0/documentation/en/man/common:::
prepend-path GDB_INFO ${prefix}/debugger/2024.0/documentation/info/
prepend-path SETVARS_COMPLETED 1
prepend-path APM ${prefix}/advisor/2024.0/perfmodels
prepend-path CMAKE_PREFIX_PATH ${prefix}/tbb/2021.11/env/..:${prefix}/ipp/2021.10/lib/cmake/ipp:${prefix}/ipp/2021.10/lib/cmake/ipp:${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp/../lib/cmake:${prefix}/cdal/2024.0:${prefix}/compiler/2024.0/IntelDPCPP:${prefix}/ccl/2021.11/lib/cmake/oneCCL
prepend-path VTUNE_PROFILER_2023_DIR ${prefix}/vtune/2024.0
prepend-path CMPLR_ROOT ${prefix}/compiler/2024.0
prepend-path ADVISOR_2023_DIR ${prefix}/advisor/2024.0
prepend-path FPGA_VARS_ARGS &amp;quot;&amp;quot;
prepend-path INFOPATH ${prefix}/debugger/2024.0/gdb/intel64/lib
prepend-path IPPROOT ${prefix}/ipp/2021.10
prepend-path IPP_TARGET_ARCH intel64
prepend-path PYTHONPATH ${prefix}/advisor/2024.0/pythonapi
prepend-path VT_ROOT ${prefix}/itac/2022.0
prepend-path DALROOT ${prefix}/cdal/2024.0
prepend-path LIBRARY_PATH ${prefix}/tbb/2021.11/env/../lib/intel64/gcc4.8:${prefix}/mpi/2021.11//libfabric/lib:${prefix}/mpi/2021.11//lib/release:${prefix}/mpi/2021.11//lib:${prefix}/mkl/2024.0/lib/intel64:${prefix}/ipp/2021.10/lib/intel64:${prefix}/ippcp/2021.9/lib/intel64:${prefix}/ipp/2021.10/lib/intel64:${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp/lib:${prefix}/cdal/2024.0/lib/intel64:${prefix}/compiler/2024.0/compiler/lib/intel64_lin:${prefix}/compiler/2024.0/lib:${prefix}/ccl/2021.11/lib/cpu_gpu_dpcpp
#prepend-path LIBRARY_PATH ${prefix}/tbb/2021.11/env/../lib/intel64/gcc4.8:${prefix}/mkl/2024.0/lib/intel64:${prefix}/ipp/2021.10/lib/intel64:${prefix}/ippcp/2021.9/lib/intel64:${prefix}/ipp/2021.10/lib/intel64:${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp/lib:${prefix}/cdal/2024.0/lib/intel64:${prefix}/compiler/2024.0/compiler/lib/intel64_lin:${prefix}/compiler/2024.0/lib:${prefix}/ccl/2021.11/lib/cpu_gpu_dpcpp
prepend-path DAL_MAJOR_BINARY 1
prepend-path IPPCRYPTOROOT ${prefix}/ippcp/2021.9
prepend-path IPPCP_TARGET_ARCH intel64
prepend-path OCL_ICD_FILENAMES libintelocl_emu.so:libalteracl.so:${prefix}/compiler/2024.0/lib/x64/libintelocl.so
prepend-path CLASSPATH ${prefix}/mpi/2021.11//lib/mpi.jar:${prefix}/cdal/2024.0/lib/onedal.jar
#prepend-path CLASSPATH ${prefix}/cdal/2024.0/lib/onedal.jar
prepend-path INTELFPGAOCLSDKROOT ${prefix}/compiler/2024.0/lib/oclfpga
prepend-path LD_LIBRARY_PATH ${prefix}/tbb/2021.11/env/../lib/intel64/gcc4.8:${prefix}/mpi/2021.11//libfabric/lib:${prefix}/mpi/2021.11//lib/release:${prefix}/mpi/2021.11//lib:${prefix}/mkl/2024.0/lib/intel64:${prefix}/itac/2022.0/slib:${prefix}/ipp/2021.10/lib/intel64:${prefix}/ippcp/2021.9/lib/intel64:${prefix}/ipp/2021.10/lib/intel64:${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp/lib:${prefix}/debugger/2024.0/gdb/intel64/lib:${prefix}/debugger/2024.0/libipt/intel64/lib:${prefix}/debugger/2024.0/dep/lib:${prefix}/cdal/2024.0/lib/intel64:${prefix}/compiler/2024.0/lib:${prefix}/compiler/2024.0/lib/x64:${prefix}/compiler/2024.0/lib/oclfpga/host/linux64/lib:${prefix}/compiler/2024.0/compiler/lib/intel64_lin:${prefix}/ccl/2021.11/lib/cpu_gpu_dpcpp:${prefix}/compiler/2024.0/compiler/lib/intel64_lin:${prefix}/ccl/2021.11/lib/cpu_gpu_dpcpp
#prepend-path LD_LIBRARY_PATH ${prefix}/tbb/2021.11/env/../lib/intel64/gcc4.8:${prefix}/mkl/2024.0/lib/intel64:${prefix}/itac/2022.0/slib:${prefix}/ipp/2021.10/lib/intel64:${prefix}/ippcp/2021.9/lib/intel64:${prefix}/ipp/2021.10/lib/intel64:${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp/lib:${prefix}/debugger/2024.0/gdb/intel64/lib:${prefix}/debugger/2024.0/libipt/intel64/lib:${prefix}/debugger/2024.0/dep/lib:${prefix}/cdal/2024.0/lib/intel64:${prefix}/compiler/2024.0/lib:${prefix}/compiler/2024.0/lib/x64:${prefix}/compiler/2024.0/lib/oclfpga/host/linux64/lib:${prefix}/compiler/2024.0/compiler/lib/intel64_lin:${prefix}/ccl/2021.11/lib/cpu_gpu_dpcpp:${prefix}/compiler/2024.0/compiler/lib/intel64_lin:${prefix}/ccl/2021.11/lib/cpu_gpu_dpcpp
prepend-path VT_LIB_DIR ${prefix}/itac/2022.0/lib
prepend-path VTUNE_PROFILER_DIR ${prefix}/vtune/2024.0
prepend-path VT_SLIB_DIR ${prefix}/itac/2022.0/slib
prepend-path MKLROOT ${prefix}/mkl/2024.0
prepend-path DAL_MINOR_BINARY 1
prepend-path NLSPATH ${prefix}/mkl/2024.0/lib/intel64/locale/%l_%t/%N:${prefix}/compiler/2024.0/compiler/lib/intel64_lin/locale/%l_%t/%N
prepend-path PATH ${prefix}/vtune/2024.0/bin64:${prefix}/mpi/2021.11//libfabric/bin:${prefix}/mpi/2021.11//bin:${prefix}/mkl/2024.0/bin/intel64:${prefix}/itac/2022.0/bin:${prefix}/inspector/2024.0/bin64:${prefix}/dpcpp-ct/2024.0/bin:${prefix}/dev-utilities/2024.0/bin:${prefix}/debugger/2024.0/gdb/intel64/bin:${prefix}/compiler/2024.0/lib/oclfpga/bin:${prefix}/compiler/2024.0/bin/intel64:${prefix}/compiler/2024.0/bin:${prefix}/advisor/2024.0/bin64
#prepend-path PATH ${prefix}/vtune/2024.0/bin64:${prefix}/mkl/2024.0/bin/intel64:${prefix}/itac/2022.0/bin:${prefix}/inspector/2024.0/bin64:${prefix}/dpcpp-ct/2024.0/bin:${prefix}/dev-utilities/2024.0/bin:${prefix}/debugger/2024.0/gdb/intel64/bin:${prefix}/compiler/2024.0/lib/oclfpga/bin:${prefix}/compiler/2024.0/bin/intel64:${prefix}/compiler/2024.0/bin:${prefix}/advisor/2024.0/bin64
prepend-path INTEL_PYTHONHOME ${prefix}/debugger/2024.0/dep
prepend-path INTEL_LICENSE_FILE /opt/intel/licenses:/root/intel/licenses
prepend-path CPATH ${prefix}/tbb/2021.11/env/../include:${prefix}/mpi/2021.11//include:${prefix}/mkl/2024.0/include:${prefix}/ipp/2021.10/include:${prefix}/ippcp/2021.9/include:${prefix}/ipp/2021.10/include:${prefix}/dpl/2022.3/linux/include:${prefix}/dpcpp-ct/2024.0/include:${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp/include:${prefix}/dev-utilities/2024.0/include:${prefix}/cdal/2024.0/include:${prefix}/compiler/2024.0/lib/oclfpga/include:${prefix}/ccl/2021.11/include/cpu_gpu_dpcpp
#prepend-path CPATH ${prefix}/tbb/2021.11/env/../include:${prefix}/mkl/2024.0/include:${prefix}/ipp/2021.10/include:${prefix}/ippcp/2021.9/include:${prefix}/ipp/2021.10/include:${prefix}/dpl/2022.3/linux/include:${prefix}/dpcpp-ct/2024.0/include:${prefix}/dnnl/2024.0/cpu_dpcpp_gpu_dpcpp/include:${prefix}/dev-utilities/2024.0/include:${prefix}/cdal/2024.0/include:${prefix}/compiler/2024.0/lib/oclfpga/include:${prefix}/ccl/2021.11/include/cpu_gpu_dpcpp
&lt;/code>&lt;/pre>
&lt;h2 id="运行测试">运行测试&lt;/h2>
&lt;p>通过 &lt;code>module load&lt;/code> 命令加载环境变量&lt;/p>
&lt;pre>&lt;code class="language-bash">$ module load intel/oneapi2024.0
&lt;/code>&lt;/pre>
&lt;p>测试是否安装成功&lt;/p>
&lt;pre>&lt;code class="language-bash">$ icx -v
&lt;/code>&lt;/pre>
&lt;p>如果输出版本信息，则安装成功。&lt;/p>
&lt;pre>&lt;code class="language-bash">Intel(R) oneAPI DPC++/C++ Compiler 2024.0.2 (2024.0.2.20231213)
Target: x86_64-unknown-linux-gnu
Thread model: posix
InstalledDir: /opt/software/intel/oneapi2024.0/compiler/2024.0/bin/compiler
Configuration file: /opt/software/intel/oneapi2024.0/compiler/2024.0/bin/compiler/../icx.cfg
Found candidate GCC installation: /opt/rh/devtoolset-11/root/usr/lib/gcc/x86_64-redhat-linux/11
Selected GCC installation: /opt/rh/devtoolset-11/root/usr/lib/gcc/x86_64-redhat-linux/11
Candidate multilib: .;@m64
Candidate multilib: 32;@m32
Selected multilib: .;@m64
&lt;/code>&lt;/pre>
&lt;p>继续测试 MPI&lt;/p>
&lt;pre>&lt;code class="language-bash">$ mpirun --version
&lt;/code>&lt;/pre>
&lt;p>如果输出版本信息，则安装成功。&lt;/p>
&lt;pre>&lt;code class="language-bash">Intel(R) MPI Library for Linux* OS, Version 2021.11 Build 20231005 (id: 74c4a23)
Copyright 2003-2023, Intel Corporation.
&lt;/code>&lt;/pre>
&lt;h2 id="icx-说明">icx 说明&lt;/h2>
&lt;blockquote>
&lt;p>&lt;strong>Intel® oneAPI DPC++/C++ Compiler (icx)&lt;/strong> is Intel nextgen compiler based on Clang /LLVM technology plus Intel proprietary optimizations and code generation.&lt;/p>&lt;span class="cite">&lt;span>― &lt;/span>&lt;span>Intel®, &lt;/span>&lt;a href="https://www.intel.cn/content/www/cn/zh/developer/articles/technical/adoption-of-llvm-complete-icx.html">&lt;cite>Intel® C/C&amp;#43;&amp;#43; Compilers Complete Adoption of LLVM&lt;/cite>&lt;/a>&lt;/span>&lt;/blockquote>
&lt;p>icx 是基于 Clang /LLVM 技术的 Intel 下一代编译器，加上 Intel 专有的优化和代码生成。&lt;/p>
&lt;p>LLVM 帮助实现了为英特尔架构提供更加优秀的 C/C++编译器这一目标。最新的英特尔 C/C++编译器使用 LLVM 架构，可提供更快的编译时间、更好的优化、增强的标准支持以及对 GPU 和 FPGA 负载转移（offloading）的支持。&lt;/p>
&lt;h3 id="采用-llvm-的好处">采用 LLVM 的好处&lt;/h3>
&lt;p>LLVM 开源项目是模块化和可重用的编译器和一系列工具链技术的集合，整个项目支持多种处理器架构和编程语言。Clang 开源项目提供了一个 C/C++前端，为 LLVM 项目支持了最新的语言标准。包括 Clang 在内，LLVM 是由一个庞大且非常活跃的开发社区维护的。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/v2-7ac93f64b283ba0b5c5371b7cd524210_1440w-2024-03-09.webp"
alt="v2-7ac93f64b283ba0b5c5371b7cd524210_1440w-2024-03-09" width="auto" loading="lazy">
&lt;/figure>
&lt;p>采用 LLVM 的好处有很多，第一条要说的是更快的构建时间。众所周知，Clang 是很快的！我们使用英特尔 oneAPI 2021.3 工具包中的英特尔 C/C++编译器时，测得构建时间减少了 14％。除了减少构建时间外，采用 Clang 使我们可以从社区支持最新 C++语言标准的一系列成果中受益，并贡献成果来反哺社区。&lt;/p>
&lt;p>英特尔为开源项目提供贡献和支持的历史颇为悠久，其中向 LLVM 做出贡献就有十年时间了。我们今天的主动合作行为包括了优化报告补充、扩大的浮点模型支持，以及向量增强。英特尔直接对 LLVM 项目做出贡献，也有一个临时区域（英特尔 LLVM 技术项目），针对 SYCL 支持。&lt;/p>
&lt;p>在英特尔架构上，英特尔 C/C++编译器预期能提供比基础 Clang+LLVM 编译器更高的性能。接下来英特尔 C/C++编译器都会是采用了 LLVM 开源基础架构的版本（icx）。我们会继续之前的长期努力，持续为 Clang 和 LLVM 项目做出贡献，包括为它们提供优化。并非所有的优化技术都会被上游采纳，有时是因为它们太新了，有时因为它们过于针对英特尔架构。这是可以预料的，并且与其他已经采用 LLVM 的编译器是同样的情况。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/v2-1a1672571e4a8a60c335e5abe38ee86b_1440w-2024-03-09.webp"
alt="v2-1a1672571e4a8a60c335e5abe38ee86b_1440w-2024-03-09" width="auto" loading="lazy">
&lt;/figure>
&lt;p>英特尔 C/C++编译器一直都在提供最优秀的性能。经典版本的英特尔 C/C++编译器取得了对 GCC 18％的优势，而基于 LLVM 的英特尔 C/C++编译器取得了 41％的优势。&lt;/p></description></item><item><title>笔记：Pure - 改进消息传递以更好地利用节点内的共享内存</title><link>https://cuterwrite.top/p/pure/</link><pubDate>Sun, 03 Mar 2024 01:16:00 +0000</pubDate><guid>https://cuterwrite.top/p/pure/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/crop_e9af4c445d695be5002248c7c814c67d195413-2024-03-04.webp" alt="Featured image of post 笔记：Pure - 改进消息传递以更好地利用节点内的共享内存" />&lt;h1 id="笔记pure-改进消息传递以更好地利用节点内的共享内存">笔记：Pure: 改进消息传递以更好地利用节点内的共享内存&lt;/h1>
&lt;h2 id="引用出处">引用出处&lt;/h2>
&lt;p>James Psota and Armando Solar-Lezama. 2024. Pure: Evolving Message Passing To Better Leverage Shared Memory Within Nodes. In Proceedings of the 29th ACM SIGPLAN Annual Symposium on Principles and Practice of Parallel Programming (&lt;strong>PPoPP &amp;lsquo;24&lt;/strong>). Association for Computing Machinery, New York, NY, USA, 133–146. &lt;a class="link" href="https://doi.org/10.1145/3627535.3638503" target="_blank" rel="noopener" >https://doi.org/10.1145/3627535.3638503
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;h2 id="关键词">关键词&lt;/h2>
&lt;ul>
&lt;li>并行编程模型&lt;/li>
&lt;li>分布式运行时系统&lt;/li>
&lt;li>基于任务的并行模型&lt;/li>
&lt;li>并发数据结构&lt;/li>
&lt;li>无锁数据结构&lt;/li>
&lt;/ul>
&lt;h2 id="摘要">摘要&lt;/h2>
&lt;p>Pure 是一种新的编程模型和运行时系统，旨在在基于消息传递接口（增强使用任务利用空闲核心能力）的环境中充分利用节点内部的共享内存。Pure 通过两种方式利用共享内存：(1) 允许 rank 在等待消息到达时从彼此那里窃取工作；(2) 利用高效无锁的数据结构实现节点内各进程间高性能的消息传递和集合操作。研究者通过 micro benchmark 测试评估了 Pure 的关键消息传递和集合特性，并展示了在 CoMD 分子动力学和 miniAMR 自适应网格细化应用中，当扩展到 4096 个 rank 时，Pure 可实现高达 &lt;strong>2.1x&lt;/strong> 的应用加速。&lt;/p>
&lt;h2 id="1-引言">1. 引言&lt;/h2>
&lt;p>在过去的几十年里，高性能计算领域经历了从大型向量计算机到由单处理器构成的集群的转变，这些集群通过网络互连。MPI 成为了分布式内存系统上并行编程的事实标准。随着硬件的进步，多核集群的出现使得节点内的核心能够共享内存并通过网络进行通信，这促使社区不断寻求新的范式，以更有效地利用现代集群资源。目前主要的策略有两种：一种是维持统一的 MPI 编程方法，通过改进 MPI 运行时系统来更好地利用共享内存；另一种是采用 MPI+X 等混合编程模式，在节点内部采用共享内存并行性，而在节点之间继续使用 MPI。&lt;strong>然而，这些方法要么可能受到 MPI 标准对接口行为规定的限制，无法最大化性能；要么给程序员带来了管理两种编程模型的挑战&lt;/strong>。&lt;/p>
&lt;p>社区已经尝试了许多其他方法，其中包括 &lt;strong>PGAS&lt;/strong> 模型，它提供了一种集群范围内的共享内存抽象，以及 &lt;strong>Legion 、Chapel&lt;/strong> 和 &lt;strong>X10&lt;/strong> 等隐式并行编程语言，这些语言提供了高级抽象，并尝试自动高效地协调应用程序。尽管取得了一定的进展，许多现代 HPC 应用仍然依赖于 MPI。&lt;strong>MPC&lt;/strong> 和 &lt;strong>AMPI&lt;/strong> 也尝试通过将线程作为 MPI Rank 来利用内部的共享内存，以提高性能。&lt;/p>
&lt;p>然而，仅使用 MPI 的方法往往比混合编程方法表现更佳。这可能是因为接口的局限性和无法充分利用节点内的共享内存，导致 MPI 未能充分发挥其潜在性能。因此，本文提出的 Pure 系统基于 MPI-everywhere 方法构建，打破了一些 MPI 的传统假设，更有效地利用了共享内存，同时避免了对现有程序进行重大重构的需求。Pure 采用了与 MPI 类似的编程模型，从而能够利用 HPC 社区现有的 MPI 知识和应用程序基础。&lt;/p>
&lt;p>Pure 的设计灵感源自 MPI，其核心编程模型是基于消息传递的，并可选择性地整合任务并行性。与 MPI 不同，Pure 摒弃了使用进程级别的 rank 和对旧版语言的支持限制，转而采用线程作为 rank 的实现，而非传统的进程。这种转变使得 Pure 能够高效地采用轻量级的无锁同步机制，实现同一节点内各线程间的协调。利用这种线程化的 rank 架构，Pure 构建了高效的节点内集体操作功能，并通过无锁算法来优化这些操作的性能。此外，Pure 支持将应用程序中的一部分并行代码块以标准的 C++ lambda 表达式的形式运行，这些表达式能够被当前拥有 rank 的线程以及其他空闲的 rank 自动且并发地执行，而这一切的操作都由 Pure Runtime 运行时系统自动进行调度。&lt;/p>
&lt;p>论文提出的优化策略涵盖了以下几点：&lt;/p>
&lt;ul>
&lt;li>一种无锁消息传递方法，适用于小消息和大数据消息的传输。&lt;/li>
&lt;li>无锁数据结构，用于高效实现集合通信算法。&lt;/li>
&lt;li>一个无锁任务调度器，允许空闲线程高效地从其他线程中“窃取”工作负载。&lt;/li>
&lt;/ul>
&lt;p>作者采用了标准的 C++ 库来确保 Pure 的广泛兼容性，并证明了 Pure 相较于经过高度优化的 MPI 基准测试，在性能上有显著提升。此外，作者还展示了 Pure 编程模型在语义上与 MPI 非常相似，这意味着从现有应用程序迁移到 Pure 是直接且简便的，这一点通过源码到源码的转换工具 mpi2pure 得到了进一步的证明。总体而言，论文的主要贡献可以总结为以下几点：&lt;/p>
&lt;ol>
&lt;li>提出了一种新的编程模型和运行时系统，该系统有效地结合了消息传递和任务并行性，并且利用了标准 C++ 的特性来实现。&lt;/li>
&lt;li>展示了现代 C++ 如何支持更加灵活的并行运行时系统接口。&lt;/li>
&lt;li>描述了一个设计精良的无锁、多线程和分布式运行时系统，该系统在节点内部相比 MPI 显示出了显著的速度提升。&lt;/li>
&lt;li>证明了通过仅对现有的 MPI 应用程序进行最小的源代码修改，就能在 micro benchmark 测试和三个实际应用中实现与最先进的 MPI 实现相比的显著性能提升。&lt;/li>
&lt;/ol>
&lt;h2 id="2-pure-使用示例">2. Pure 使用示例&lt;/h2>
&lt;p>本节通过一个简单的 1-D Stencil 算法示例来阐释 Pure 的使用方法。该示例虽然简单，但能够清晰展示 Pure 的核心概念及其与 MPI 的相似之处，为开发者编写更复杂的应用程序奠定了基础。&lt;/p>
&lt;p>在 MPI 版本的实现代码 &lt;code>rand_stencil_mpi&lt;/code> 中，计算工作主要集中在函数 &lt;code>random_work&lt;/code> 中执行。简单来说，&lt;code>rand_stencil_mpi&lt;/code> 函数首先会进入一个循环，迭代次数为 &lt;code>iters&lt;/code> ，在数组 &lt;code>a&lt;/code> 的每个元素上计算 &lt;code>random_work&lt;/code> 。值得注意的是，&lt;code>random_work&lt;/code> 执行的时间长度是可变且未知的，因此会引入负载不平衡。此外，&lt;code>random_work&lt;/code> 不会修改数组 &lt;code>a&lt;/code> 的内容，而是接着通过对相邻元素求平均值更新数组 &lt;code>a&lt;/code> 。最后，程序利用 &lt;code>MPI_Send&lt;/code> 和 &lt;code>MPI_Recv&lt;/code> 交换 &lt;code>temp&lt;/code> 数组的首尾元素，以便计算数组 &lt;code>a&lt;/code> 的首尾元素。由于 &lt;code>random_work&lt;/code> 所需时间长短不一，某些处理单元会提前完成任务，有时会在等待发送方较慢的 &lt;code>MPI_Recv&lt;/code> 调用时陷入阻塞状态。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/1D_stencil-2024-03-14.webp"
alt="1D_stencil-2024-03-14" width="auto" loading="lazy">
&lt;/figure>
&lt;div class="notice notice-info" >
&lt;div class="notice-title">&lt;svg t="1705940100069" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6252" width="200" height="200">&lt;path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64z m32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272z m-32-344c-26.5 0-48-21.5-48-48s21.5-48 48-48 48 21.5 48 48-21.5 48-48 48z" p-id="6253" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;p>示例 1：1-D Stencil with Random Work, MPI Version&lt;/p>&lt;/div>
&lt;pre>&lt;code class="language-cpp">void rand_stencil_mpi(double* const a, size_t arr_sz, size_t iters, int my_rank,
int n_ranks) {
double temp[arr_sz];
for (auto it = 0; it &amp;lt; iters; ++it) {
for (auto i = 0; i &amp;lt; arr_sz; ++i) {
temp[i] = random_work(a[i]);
}
for (auto i = 1; i &amp;lt; arr_sz - 1; ++i) {
a[i] = (temp[i - 1] + temp[i] + temp[i + 1]) / 3.0;
}
if (my_rank &amp;gt; 0) {
MPI_Send(&amp;amp;temp[0], 1, MPI_DOUBLE, my_rank - 1, 0, MPI_COMM_WORLD);
double neighbor_hi_val;
MPI_Recv(&amp;amp;neighbor_hi_val, 1, MPI_DOUBLE, my_rank - 1, 0, MPI_COMM_WORLD,
MPI_STATUS_IGNORE);
a[0] = (neighbor_hi_val + temp[0] + temp[1]) / 3.0;
} // ends if not first rank
if (my_rank &amp;lt; n_ranks - 1) {
MPI_Send(&amp;amp;temp[arr_sz - 1], 1, MPI_DOUBLE, my_rank + 1, 0,
MPI_COMM_WORLD);
double neighbor_lo_val;
MPI_Recv(&amp;amp;neighbor_lo_val, 1, MPI_DOUBLE, my_rank + 1, 0, MPI_COMM_WORLD,
MPI_STATUS_IGNORE);
a[arr_sz - 1] =
(temp[arr_sz - 2] + temp[arr_sz - 1] + neighbor_lo_val) / 3.0;
} // ends if not last rank
} // ends for all iterations
}
&lt;/code>&lt;/pre>
&lt;p>示例 2 则展示了实现同样功能的 Pure 版本。其中存在一些关键差异。首先，消息调用函数接口不同，使用的是相应的 Pure 消息传递函数 &lt;code>pure_send_msg&lt;/code> 和 &lt;code>pure_recv_msg&lt;/code> ，而非 MPI 调用，但参数实质上与 MPI 对应函数基本相同。Pure 的消息传递语义类似于 MPI：发送端缓冲区被复制到接收端缓冲区。实现区别主要在于：Pure 在&lt;strong>节点内部采用了轻量级的消息传递方法&lt;/strong>，从而在节点内的消息传递比 MPI 的延迟更低。&lt;/p>
&lt;div class="notice notice-info" >
&lt;div class="notice-title">&lt;svg t="1705940100069" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6252" width="200" height="200">&lt;path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64z m32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272z m-32-344c-26.5 0-48-21.5-48-48s21.5-48 48-48 48 21.5 48 48-21.5 48-48 48z" p-id="6253" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;p>示例 2：Pure 版本&lt;/p>&lt;/div>
&lt;pre>&lt;code class="language-cpp">void rand_stencil_pure(double* a, const int arr_sz, const int n_iter,
const int my_rank, const int n_ranks) {
double temp[arr_sz];
PureTask rand_work_task = [a, temp, arr_sz, my_rank](
chunk_id_t start_chunk, chunk_id_t end_chunk,
std::optinal&amp;lt;void&amp;gt; cont_params) {
auto [min_idx, max_idx] =
pure_aligned_idx_range&amp;lt;double&amp;gt;(arr_sz, start_chunk, end_chunk);
for (auto i = min_idx; i &amp;lt; max_idx; i++) {
temp[i] = random_work(a[i]);
}
}; // ends definding the Pure Task for rand_work_task
for (auto it = 0; it &amp;lt; n_iter; it++) {
rand_work_task.execute(); // execute all chunks of rank_work_task
for (auto i = 1; i &amp;lt; arr_sz - 1; ++i) {
a[i] = (temp[i - 1] + temp[i] + temp[i + 1]) / 3.0;
}
if (my_rank &amp;gt; 0) {
pure_send_msg(&amp;amp;temp[0], 1, MPI_DOUBLE, my_rank - 1, 0, PURE_COMM_WORLD);
double neighbor_hi_val;
pure_recv_msg(&amp;amp;neighbor_hi_val, 1, MPI_DOUBLE, my_rank - 1, 0,
PURE_COMM_WORLD);
a[0] = (neighbor_hi_val + temp[0] + temp[1]) / 3.0;
} // ends if not first rank
if (my_rank &amp;lt; n_ranks - 1) {
pure_send_msg(&amp;amp;temp[arr_sz - 1], 1, MPI_DOUBLE, my_rank + 1, 0,
PURE_COMM_WORLD);
double neighbor_lo_val;
pure_recv_msg(&amp;amp;neighbor_lo_val, 1, MPI_DOUBLE, my_rank + 1, 0,
PURE_COMM_WORLD);
a[arr_sz - 1] =
(temp[arr_sz - 2] + temp[arr_sz - 1] + neighbor_lo_val) / 3.0;
} // ends if not last rank
} // ends definding the Pure Task for rand_work_task
}
&lt;/code>&lt;/pre>
&lt;p>更重要的差异在于 Pure 中增加的 &lt;strong>Pure Task&lt;/strong> ，用带有一组特定参数定义的 lambda 表达式，其利用 lambda 的捕获参数特性，允许外部于 lambda 体内的变量以值或引用形式被捕获并在 lambda 执行时使用。Pure Task 可以被视为由 Pure Runtime 运行时系统负责执行应用程序代码片段，可以通过多线程并发执行。因此，Pure 任务应结构化为类似数据并行的形式。此外，Pure Task 需要由程序员保证线程安全。&lt;/p>
&lt;p>在以上 Pure 实现中，程序员可以利用 chunk ranges 来描述并发性。这些子范围或 chunk 是通过 &lt;code>start_chunk&lt;/code> 和 &lt;code>end_chunk&lt;/code> 参数传递给 Pure Task 的，而它们是由 Pure Runtime 运行时系统提供。Pure Runtime 运行时系统负责确保所有工作顺利完成。由于可能涉及到不同的多个线程，Pure Runtime 运行时系统会通过追踪哪些 chunk 已分配和完成来实现这一点。&lt;/p>
&lt;p>其次，程序员需要将 Pure Runtime 运行时系统提供的 &lt;code>start_chunk&lt;/code> 和 &lt;code>end_chunk&lt;/code> 参数映射到与应用计算相关的具体内容上。在这里，代码使用了 &lt;code>pure_aligned_idx_range&lt;/code> 辅助函数将其转化为循环索引子范围。这个辅助函数考虑到了缓存行，所以有利于避免伪共享问题。&lt;/p>
&lt;p>由于 random_work 可能导致负载分布不均，某些 rank 可能会在等待消息时处于空闲状态。Pure 的任务调度器会自动利用这些空闲的 rank，以执行同一节点内其他待处理的 Pure 任务块。以下图中在同一节点内的三个 rank 为例：&lt;strong>rank 0&lt;/strong> 正在执行一个被划分为 6 个 chunks 的 Pure Task，而 &lt;strong>rank 1&lt;/strong> 和 &lt;strong>rank 2&lt;/strong> 因为接收消息而阻塞。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/timeline-2024-03-14.png"
alt="timeline-2024-03-14" width="auto" loading="lazy">&lt;figcaption>
&lt;h4>示例 Pure 代码的时间线示意图&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>从图中可以清晰地看到以下执行流程：&lt;/p>
&lt;ul>
&lt;li>rank 0 开始处理第一个 chunk（chunk 0） 。&lt;/li>
&lt;li>同时，rank 1 窃取并行执行第二个 chunk（chunk 1）。&lt;/li>
&lt;li>任务调度器随后为 rank 0 分配第三个 chunk（chunk 2），为 rank 1 分配第四个 chunk（chunk 3）。&lt;/li>
&lt;li>rank 2 尝试窃取一个任务，并成功执行第五个 chunk（chunk 4）。由于 &lt;code>random_work&lt;/code> 的执行随机性，chunk 2 和 chunk 4 可能是耗时较长的任务。&lt;/li>
&lt;li>rank 0 完成 chunk 5 的处理，这是一个较小的任务块，它在 rank 2 完成 chunk 4 之前就已经结束了。&lt;/li>
&lt;li>任务调度器确保在所有 chunks 完成之前，rank 0 不会结束执行。实际上，rank 0 要等到 chunk 4 完成后才能继续。&lt;/li>
&lt;li>在 rank 1 和 rank 2 等待消息的过程中，它们会尝试从其他任何可用的 rank 中窃取更多的 chunks。&lt;/li>
&lt;li>得益于 lambda 表达式的变量捕获功能，不同 rank 之间可以高效地共享上下文信息。&lt;/li>
&lt;/ul>
&lt;p>实验结果显示，在单节点上配置 32 个 rank 的 Pure 版本因为更快的消息传递和 Pure Task 的并行执行，相比于 MPI 版本，Pure 版本实现了 10% 的性能提升。在负载分布不均的情境下，Pure 的加速比甚至超过了 200%。这些性能提升的程度虽然受到负载不平衡的影响，但在实际应用场景中，Pure 仍展现出了显著的性能改进。这归功于 Pure Runtime 运行时系统的能力，它能够自动检测并高效利用未被充分利用的计算资源。&lt;/p>
&lt;h2 id="3-编程模型">3. 编程模型&lt;/h2>
&lt;p>Pure 的编程模型核心是“消息传递结合可选的任务并行性”。在语义上，Pure 的消息传递和集合通信操作与 MPI 等同，差异主要体现在语法上的一些细节。&lt;/p>
&lt;p>尽管 Pure 在节点内部采用线程，但其 rank 命名空间在整个集群中保持非层级结构。在 Pure 程序的执行周期内，rank 的数量保持不变。&lt;/p>
&lt;p>Pure 应用程序采用 C++ 编写，并通过 SPMD（单程序多数据）模式运行，实现了内部的多线程化。在同一个节点上，所有的 rank 都是通过内核线程实现的。&lt;/p>
&lt;p>&lt;strong>需要注意的是，Pure 应用程序并不支持全局变量&lt;/strong>。因此，开发者应当移除全局变量或者使用 &lt;code>thread_local&lt;/code> 关键字来限制变量的作用域，确保线程之间的安全性。&lt;/p>
&lt;p>对于存在负载不均衡问题的应用程序，开发者可以在满足以下特定条件的程序部分使用 Pure Task：&lt;/p>
&lt;ol>
&lt;li>计算密集型的热点区域。&lt;/li>
&lt;li>可以并发执行的任务。&lt;/li>
&lt;/ol>
&lt;h3 id="消息传递和集合通信操作">消息传递和集合通信操作&lt;/h3>
&lt;p>在 Pure 中，&lt;code>pure_send_msg&lt;/code> 和 &lt;code>pure_recv_msg&lt;/code> 函数在功能上与 MPI 的 &lt;code>MPI_Send&lt;/code> 和 &lt;code>MPI_Recv&lt;/code> 相对应，同时 Pure 也提供了相应的非阻塞版本。&lt;/p>
&lt;p>Pure Runtime 运行时系统确保所有消息都会被送达，并且按照发送的顺序进行交付。Pure 还实现了一系列的集合通信操作，包括：&lt;/p>
&lt;ul>
&lt;li>Reduce&lt;/li>
&lt;li>All-Reduce&lt;/li>
&lt;li>Barrier&lt;/li>
&lt;li>Broadcast&lt;/li>
&lt;/ul>
&lt;p>此外，Pure 引入了通信子（communication subgroup）的概念，允许开发者通过 &lt;code>pure_comm_split&lt;/code> 函数将一个通信子集进一步细分为更小的子集。&lt;/p>
&lt;p>为了使用 Pure，应用程序需要采用现代 C++ 标准进行编写，推荐使用 &lt;code>std=c++11&lt;/code> 或更高版本进行编译。Pure 提供了一个基于 Make 的构建系统，它会自动配置合适的编译器选项，并链接到 Pure Runtime 运行时系统（libpure），同时定义了一系列用于调试和性能分析的 target。&lt;/p>
&lt;h3 id="pure-task">Pure Task&lt;/h3>
&lt;p>Pure Task 允许开发者定义应用程序中的计算部分，并将其分解为可并行执行的 chunks。这些 chunks 可以由 Pure Runtime 运行时系统自动并发执行。&lt;/p>
&lt;p>然而，Pure Task 不是必需的，只有在任务可以划分为多个小块，并且这样做有助于缓解负载不均衡问题时，才推荐使用 Pure Task。&lt;/p>
&lt;p>Pure Task 通过 C++ Lambda 表达式实现，并在拥有该任务的 rank 调用 &lt;code>execute&lt;/code> 方法时同步执行。每个 rank 同一时间只能执行一个 Pure Task。Lambda 表达式的变量捕获功能使得不同 rank 在执行不同 chunks 时能够高效共享上下文信息。通常，一个 Pure Task 在应用程序的运行过程中会被定义一次，然后在每个时间步或其他迭代中多次执行。&lt;/p>
&lt;p>定义 Pure Task 时，需要指定 chunk 的数量和额外的应用程序参数。任务之间应避免相互依赖，不过因为它们会在 &lt;code>execute&lt;/code> 调用期间完全执行，所以它们不会与任务外部的代码发生冲突。&lt;/p>
&lt;p>Pure Task 包含一个 &lt;code>execute&lt;/code> 方法，该方法接受一个 &lt;code>optional&amp;lt;void*&amp;gt;&lt;/code> 类型的参数 &lt;code>per_exe_args&lt;/code> ，用于每次执行任务时传递额外的参数。这在任务主体的输入值在连续执行中发生变化时非常有用。例如，开发者可以将指向局部结构体的指针传递给 &lt;code>execute&lt;/code> 方法。&lt;/p>
&lt;p>Pure Task 的前两个参数 &lt;code>start_chunk&lt;/code> 和 &lt;code>end_chunk&lt;/code> 是无符号整数，用于指定要执行的 chunk 范围。这些 chunk 由 Pure Runtime 运行时系统分配，确保每个 chunk 只被执行一次，即使它们可能并发执行。&lt;/p>
&lt;p>Pure Task 使用 chunk 范围为调度器提供了灵活性，允许一次性分配多个 chunks。chunks 的数量由 Pure 任务调度器决定，但不会超过在 Makefile 文件中预定义的 &lt;code>PURE_MAX_TASK_CHUNKS&lt;/code> 。&lt;/p>
&lt;p>目前，Pure Task 的接口需要手动将 chunk 编号映射到数组索引，这在处理多维数组时可能比较繁琐。因此，未来的工作目标是扩展接口，提供类似于 TBB 的 &lt;code>parallel_for&lt;/code> 那样更简洁、更高级的接口。&lt;/p>
&lt;p>最后，开发者需要确保 Pure Task 内部的实现是线程安全的，以避免同一任务的多个并发执行的 chunks 之间的相互竞争。例如，在 CoMD 分子动力学 Benchmark 中，需要处理多个线程同时写入同一内存位置的问题，这时可以使用 &lt;code>std::atomic&lt;/code> 数组来替代普通 &lt;code>int&lt;/code> 数组。&lt;/p>
&lt;h2 id="4-运行时系统">4. 运行时系统&lt;/h2>
&lt;p>Pure 运行时系统是一个多线程和分布式运行时的动态库，用于支持 Pure 应用程序的开发。开发者在使用时需要包含 &lt;code>pure.h&lt;/code> 头文件，并使用 C++17 标准进行编译，同时链接到 &lt;code>libpure&lt;/code> 库。Pure 运行时系统能够自动地在计算和通信操作之间寻找并利用重叠执行的机会，尤其是在通信延迟较高的情况下。&lt;/p>
&lt;p>Pure 运行时系统的主要职能包括：&lt;/p>
&lt;ul>
&lt;li>初始化并配置必要的进程和线程，启动应用程序。&lt;/li>
&lt;li>管理节点内部的 rank 间通信和集合操作。&lt;/li>
&lt;li>管理内部的内存缓冲区和数据结构。&lt;/li>
&lt;li>如果应用程序中定义了 Pure Task，运行时系统还需负责这些任务的调度和执行。&lt;/li>
&lt;/ul>
&lt;h3 id="rank-初始化与映射">Rank 初始化与映射&lt;/h3>
&lt;p>Pure 中的 rank 实现为 MPI 进程的内核线程。在多节点应用中，Pure 运行 MPI 来处理跨节点通信，而在单节点应用中则不使用 MPI，尽管如此，Pure 应用程序并不直接调用 MPI 函数。通过 Makefile 配置，Pure 程序可以在一个节点或 NUMA 节点上启动一个 MPI 进程，并根据每个节点或 NUMA 节点的核心数来创建相应数量的线程。对于应用程序开发者而言，他们只需了解非层次化的 rank 命名空间，而节点、线程、MPI 进程和通信延迟等底层概念都被抽象化，对开发者透明。&lt;/p>
&lt;p>Pure 支持灵活的 rank 到节点的映射策略，并且默认采用 SMP 风格的分配策略。同时，Pure 也支持自定义的 rank 映射，包括使用 CrayPAT 的 rank 重排文件。虽然这些硬件相关的细节对开发者来说是不可见的，但 Pure 内部会利用这些信息来优化关键功能。&lt;/p>
&lt;p>在 Pure 应用程序启动时，不会直接执行应用程序的原始 &lt;code>main&lt;/code> 函数。相反，底层的 MPI 程序会调用 Pure 运行时系统中定义的 &lt;code>main&lt;/code> 函数，该函数负责初始化 Pure 的核心数据结构，然后创建并绑定线程，每个线程执行一个 &lt;code>original_main&lt;/code> 函数，这是从应用程序代码中的原始 &lt;code>main&lt;/code> 函数重命名而来的版本。应用程序执行完毕后，&lt;code>original_main&lt;/code> 函数返回到 Pure 运行时系统，后者负责完成 MPI 的清理和终止过程。&lt;/p>
&lt;h3 id="spin-steal-waiting-loop-ssw-loop">Spin-Steal Waiting Loop (SSW-Loop)&lt;/h3>
&lt;p>当 Pure 的 rank 遇到阻塞事件，如等待消息到达，它将执行一个称为 &lt;strong>自旋、窃取等待循环（SSW-Loop）&lt;/strong> 的机制，而不是简单地进入空闲状态。在此循环中，rank 会检查是否满足阻塞条件，例如是否有消息到达，如果没有，它会尝试从其他 rank 窃取任务。如果一个阻塞的 rank 能够协助其进程中正在并发执行的其他线程完成任务，它就会参与这种协助工作。&lt;/p>
&lt;p>由于线程是绑定到特定的 CPU 的，并且每个 rank 只运行一个应用程序，Pure 选择让 rank 主动自旋等待，而不是放弃 CPU。SSW-Loop 让计算中的 rank 具有“多态性”：它既可以作为主程序的计算节点，也可以协助其他 rank 执行窃取到的任务块，然后再返回检查自身的阻塞事件。&lt;/p>
&lt;p>Pure 遵循优先处理当前 rank 拥有的窃取任务负载的策略，坚持任务负载优先的调度原则。&lt;/p>
&lt;p>与那些使用辅助线程来实现工作负载窃取或通信的系统不同，Pure 的特点是允许应用级别的计算节点直接进行任务窃取操作。&lt;/p>
&lt;h3 id="实现说明">实现说明&lt;/h3>
&lt;p>Pure 是使用 C++17 标准库编写的。Pure 运行时系统由大约 21,000 行源代码构成，而 Pure 工具则包含了约 14,000 行源代码。Pure 已在多种环境下进行测试，包括笔记本电脑和集群，其运行仅需要一个支持 C++17 的编译器、类 Unix 操作系统以及 MPI 环境。Pure 的源代码可以在 GitHub 上公开获取，链接为： &lt;a class="link" href="https://github.com/psota/pure" target="_blank" rel="noopener" >https://github.com/psota/pure
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
。&lt;/p>
&lt;h3 id="点对点通信">点对点通信&lt;/h3>
&lt;p>Pure 提供了阻塞和非阻塞的点对点消息传递功能，其语义与 MPI 的消息传递相一致。&lt;/p>
&lt;p>Pure 内部采用三种不同的策略来进行消息传递，选择哪种策略取决于消息的大小以及发送方和接收方是否位于同一节点。&lt;/p>
&lt;p>Pure 在整个程序的生命周期中分配并复用一个持久的 Channel 对象，该对象存储于运行时系统中。内部的 Channel Manager 负责将消息参数映射到合适的数据结构，并根据需要创建这些结构。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/strategy-2024-03-15.webp"
alt="strategy-2024-03-15" width="auto" loading="lazy">&lt;figcaption>
&lt;h4>Pure 消息传递策略&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;ul>
&lt;li>&lt;strong>短消息（小于 8KB）&lt;/strong>：
&lt;ul>
&lt;li>采用无锁循环队列（PureBufferQueue，PBQ），具有 acquire-release 内存语义。发送线程在有可用空间时将消息复制到 PBQ，接收线程则在消息准备好时将其取出。
&lt;ul>
&lt;li>在短消息传递中，拷贝的开销相对较小，这样可以让发送方调用返回后立即执行执行其它有用的工作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>发送和接收线程都使用 SSW-Loop 进行等待，以尽可能地实现计算与通信的重叠执行。&lt;/li>
&lt;li>所有消息的 slot 存储在一个连续的缓冲区中，通过指针算术确保每个 slot 与缓存行边界对齐，避免发送和接收线程之间的伪共享。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>大消息（大于等于 8KB）&lt;/strong>：
&lt;ul>
&lt;li>类似于 PBQ 的策略，但使用直接从发送方到接收方的单次内存拷贝，灵感来自 MPI 的 rendezvous 模式。&lt;/li>
&lt;li>使用无锁的固定大小循环缓冲区来存储接收方的接收调用参数。&lt;/li>
&lt;li>发送方通过 SSW-Loop 等待元数据队列项，然后将消息内容直接复制到接收方的缓冲区。发送方通过在无锁队列中插入传输的字节数来通知接收方传输已完成。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>跨节点消息&lt;/strong>
&lt;ul>
&lt;li>透明地使用 MPI 接口进行消息传递。&lt;/li>
&lt;li>在 Pure 初始化期间，使用分布式一致性算法创建 &lt;code>thread-rank-process-node&lt;/code> 映射数据结构，将 Pure rank 映射到 MPI rank。&lt;/li>
&lt;li>为了确保在接收节点上正确的接收线程能够接收到消息，在 &lt;code>MPI_TAG&lt;/code> 中编码发送和接收线程的 ID，解决多线程路由问题。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="集合通信">集合通信&lt;/h3>
&lt;p>Pure 的集体通信操作在语义上与 MPI 相同，但在节点内部通过自下而上构建的数据结构来实现，这在单节点和多节点基准测试中都显示出了显著的性能提升，即使在跨节点通信时仍然依赖于 MPI 的集合操作。&lt;/p>
&lt;p>Pure 采用一个领导者线程来协调集体通信过程，其他线程则协助进行计算并按需调用 MPI 集合函数。&lt;/p>
&lt;ul>
&lt;li>Pure 使用静态领导者选举方法，这比基于比较和交换的“首先进入”方法更为高效。&lt;/li>
&lt;/ul>
&lt;p>以下仅以 All-Reduce 为例子，其它集合通信操作思想类似。&lt;/p>
&lt;p>对于小数据的 All-Reduce 操作，Pure 设计了名为 Sequenced Per-Thread Dropbox (SPTD) 的并发数据结构，提供了一种高效的无锁机制，用于在领导线程和其他非领导线程之间对偶同步和可选共享数据。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/SPTD-2024-03-15.webp"
alt="SPTD-2024-03-15" width="auto" loading="lazy">&lt;figcaption>
&lt;h4>Sequenced Per-Thread Dropbox (SPTD)&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>该方法借鉴了 flat-combinding 技术，将通信器中的线程 0 作为领导者线程。&lt;/p>
&lt;ul>
&lt;li>对于大小不超过 2KB 的小数组：
&lt;ul>
&lt;li>非领导者线程首先将数据复制到 SPTD，然后与领导者线程同步，表明输入数据已就绪（使用原子序列号而非共享原子计数器）。&lt;/li>
&lt;li>领导者线程执行所有输入数组的逐元素 Reduce 操作。&lt;/li>
&lt;li>每个节点的领导者线程使用 &lt;code>MPI_Allreduce&lt;/code> 对局部 Reduce 结果进行全局 Reduce。&lt;/li>
&lt;li>领导者线程同步，非领导者线程将最终的 Reduce 结果复制到私有缓冲区。&lt;/li>
&lt;li>所有线程在等待时执行 SSW-Loop。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对于超过 2KB 的大数组，Reduce 计算可能成为性能瓶颈，因此需要所有线程并发执行 Reduce 计算，并通过共享内存直接从每个线程的缓冲区中读取或写入数据。
&lt;ul>
&lt;li>Reduce 工作被划分为大小相等的块，避免伪共享并实现向量化计算。&lt;/li>
&lt;li>线程使用 SPTD 报告准备状态，并通过原子序列号标记计算完成。&lt;/li>
&lt;li>领导者线程调用 &lt;code>MPI_Allreduce&lt;/code> 执行跨节点的 All-Reduce 操作，并通过另一个原子序列号传播最终结果。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="任务调度器">任务调度器&lt;/h3>
&lt;p>Pure 运行时系统精心设计了一个任务调度器，它在共享内存中维护了一个名为 &lt;code>active_tasks&lt;/code> 的数组。这个数组存储了一系列原子指针，每个指针对应于一个正在执行的任务，并且为系统中的每个节点和每个 rank 分配了一个条目。这些条目最初被设置为 &lt;code>nullptr&lt;/code>，表示任务尚未分配。&lt;/p>
&lt;p>当一个任务被创建并准备执行时，系统会为其初始化状态，并通过原子操作更新 &lt;code>active_tasks&lt;/code> 数组中相应的条目，以反映该任务已被分配。这个更新过程确保了任务的执行状态对系统中的所有线程都是可见的，从而使得任务可以被其他线程“窃取”。&lt;/p>
&lt;p>在任务的执行过程中，拥有任务的 rank 会开始执行一系列的 chunk，这些是任务的细分工作单元。同时，其他线程会在它们的 SSL-Loop 期间不断检查 &lt;code>active_tasks&lt;/code> 数组，通过原子加载操作来寻找可执行的非空任务。&lt;/p>
&lt;p>任务的执行是由两个原子整数 &lt;code>curr_chunk&lt;/code> 和 &lt;code>chunks_done&lt;/code> 来协调的。拥有任务的 rank（owner rank）和可能的窃取者 rank（thief ranks）都会运行相同的并发执行函数。窃取者线程会执行一个 chunk 后返回，而拥有者线程则持续执行直到所有 chunk 完成。通过使用 &lt;code>fetch_add&lt;/code> 操作，线程可以确定自己应该执行哪个 chunk，如果 &lt;code>curr_chunk&lt;/code> 的值已经超过了总的 chunk 数量，线程则会停止执行。&lt;/p>
&lt;p>每当一个 chunk 被成功完成后，线程会原子性地增加 &lt;code>chunks_done&lt;/code> 的值。拥有者线程会更新其本地存储，以避免缓存未命中。最终，拥有者 rank 会等待，直到所有的 chunk 都执行完毕，确保任务的完整执行。&lt;/p>
&lt;p>值得注意的是，任务的 chunk 与应用程序的 rank 是在同一硬件线程上执行的。在 Pure 应用中，每个硬件线程都被分配给一个特定的 rank。尽管目前 Pure 还没有利用硬件加速器（如 GPU）来加速任务执行，但设计者相信 Pure 的架构完全有能力支持这种加速。&lt;/p>
&lt;p>Pure 的任务调度器提供了多种执行模式和窃取算法，以适应不同的执行需求。例如，作者实现了单 chunk 执行模式和一种引导式自调度模式，后者是一种工作划分算法，它优先分配较大的工作块，然后是较小的工作块。此外，调度器还包括 NUMA 感知窃取模式，它优先从同一 NUMA 节点上的线程窃取任务，以及一种“黏性”窃取模式，允许窃取者线程返回它们最近窃取且仍在活跃状态的任务。这些特性共同确保了任务调度的高效性和灵活性。&lt;/p>
&lt;h2 id="评估">评估&lt;/h2>
&lt;p>在伯克利 NERSC 的 Cori HPC 集群上进行了 Pure 的性能评估。该集群包含 2388 个节点，每个节点配置有 2 个插槽、16 个核心和 128GB 内存，通过 Cray Aires 进行节点间互联。实验配置启用了超线程，并采用 256 位向量宽度。每个节点上运行 2 个进程，共 32 个线程。评估使用 Intel 编译器，并将 Cray MPICH 作为性能基线。&lt;/p>
&lt;h3 id="nas-dt-基准测试结果">NAS DT 基准测试结果&lt;/h3>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/nasdt-2024-03-15.webp"
alt="nasdt-2024-03-15" width="auto" loading="lazy">
&lt;/figure>
&lt;ul>
&lt;li>仅通过优化消息传递机制，Pure 取得了 11% 至 25% 的性能加速。&lt;/li>
&lt;li>引入 Pure Tasks 后，性能加速比提升至 1.7 倍至 2.6 倍。&lt;/li>
&lt;li>辅助线程能小幅提高性能，不过仅限于剩余未使用的 CPU 核心才能使用。在这里，除了 80 个 rank 的情况下空闲了 24 个核心，其它情况下都充分利用了 CPU 核心。&lt;/li>
&lt;/ul>
&lt;h3 id="comd-和-miniamr-基准测试">CoMD 和 miniAMR 基准测试&lt;/h3>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/benchmark-pure-2024-03-15.webp"
alt="benchmark-pure-2024-03-15" width="auto" loading="lazy">
&lt;/figure>
&lt;p>-在 CoMD 分子动力学应用中，Pure 在所有 rank 数下的性能均优于仅使用 MPI 及 MPI+OpenMP 的性能，分别实现了 7% 至 25% 以及 35% 至 50% 的加速比，即使在没有负载不均衡的情况下。&lt;/p>
&lt;ul>
&lt;li>在 miniAMR 自适应网格细化应用中，Pure 至少实现了 20%，最多 50% 的性能加速。&lt;/li>
&lt;/ul>
&lt;h3 id="集合通信性能">集合通信性能&lt;/h3>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/benchmark-pure-msg-2024-03-15.webp"
alt="benchmark-pure-msg-2024-03-15" width="auto" loading="lazy">
&lt;/figure>
&lt;ul>
&lt;li>Pure 在集合通信操作中的性能表现突出，这些操作的内部优化机制和数据结构设计使得 Pure 在处理大规模并行计算任务时展现出显著的效率和优势。&lt;/li>
&lt;/ul>
&lt;h2 id="相关工作">相关工作&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">类别&lt;/th>
&lt;th style="text-align:left">相关工作&lt;/th>
&lt;th style="text-align:left">Pure 的优势&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">MPI&lt;/td>
&lt;td style="text-align:left">1. 利用多核节点内的共享内存提升性能；2. XPMEM 显著增强节点内通信效率；3. ch4 网络库优化了 MPI 的共享内存通信；4. 改进了 MPI 的集合通信算法；5. DMAPP 库针对特定集合通信进行了优化，但限制较多；6. 解决了大规模全对全集合通信的挑战；7. 单边消息 API 实现了解耦；8. 优化了数据移动与进程同步&lt;/td>
&lt;td style="text-align:left">1. Pure 在所有集合通信和负载大小上均展现出卓越的性能；2. 提供了高级的通信计算重叠机制，超越了传统的单边消息 API&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">MPI 多线程&lt;/td>
&lt;td style="text-align:left">1. 支持 MPI_THREAD_MULTIPLE 模式下的 rank 内多线程； 2. 多数 MPI 实现通过全局锁实现线程安全，导致性能瓶颈；3. MPI 4.0 引入 MPI+X 方法增强多线程支持；4. 引入了 MPI Fine-points 和 Endpoints 概念以支持线程&lt;/td>
&lt;td style="text-align:left">1. Pure 重视多线程代码中的 MPI 调用，强调其重要性；2. 提供了一种统一的编程模型，简化了并行任务的引入&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">AMPI&lt;/td>
&lt;td style="text-align:left">1. 基于 Charm++ 的 MPI 兼容库；2. 提供高级并行编程抽象；3. 通过最小化代码更改实现性能提升&lt;/td>
&lt;td style="text-align:left">1. Pure 在实际测试中表现优于 AMIP，得益于其优化的消息传递和集合通信，以及更精细和低开销的负载均衡策略；2. 相较于 AMIP SMP 基于线程的模型，Pure 提供了更高效的并行处理&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">PGAS 语言和并行框架&lt;/td>
&lt;td style="text-align:left">1. PGAS 语言提供了全局内存地址空间的抽象；2. Chapel 和 X10 扩展了 PGAS 方法，支持本地和远程异步任务；3. HPX 为现代 C++标准增加了分布式操作支持；4. Legion 作为数据中心并行编程系统；5. Kokkos, STAPL, BCL 等框架提供了应用程序与硬件间的抽象层&lt;/td>
&lt;td style="text-align:left">1. 类似于 Pure，PGAS 模型采用 SPMD 风格，通过局部性引用提高性能；2. 这些框架虽然利用了现代 C++特性，但通常需要对现有应用程序进行大量重写，而 Pure 则提供了更为直接的优化路径&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>数十年来，由于其相对的简单性和性能优势，消息传递一直被视为并行编程的标准模型。然而，本文表明，消息传递与共享内存并非不可兼容。实际上，通过设计合适的库，可以在不牺牲大多数消息传递优点的前提下充分利用共享内存。&lt;/p></description></item><item><title>科研图表绘制</title><link>https://cuterwrite.top/p/science-plot/</link><pubDate>Tue, 27 Feb 2024 00:14:00 +0000</pubDate><guid>https://cuterwrite.top/p/science-plot/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/crop_ee40c9cb9e33ffe888365e66e0a104dc195413-2024-02-28.webp" alt="Featured image of post 科研图表绘制" />&lt;h1 id="科研图表绘制">科研图表绘制&lt;/h1>
&lt;h2 id="前置知识">前置知识&lt;/h2>
&lt;h3 id="位图">位图&lt;/h3>
&lt;p>又称为点阵图像、像素图或栅格图像，由像素点组成。这些点可以进行不同的排列和染色以构成图像。&lt;/p>
&lt;p>&lt;strong>位图特点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>位图图像善于重现颜色的细微层次，能够制作出色彩和亮度变化丰富的图像，颜色逼真，文件庞大，不能随意缩放；&lt;/li>
&lt;li>图像尺寸越大，文件也就越大；图像色彩越丰富，文件也就越大。&lt;/li>
&lt;li>打印和输出的精度是有限的；&lt;/li>
&lt;li>&lt;strong>位图的文件格式&lt;/strong>：比如.tiff、.bmp、.gif、.jpg、.png、.psd 等。&lt;/li>
&lt;li>&lt;strong>常用的位图编辑软件&lt;/strong>：Photoshop 等。&lt;/li>
&lt;/ul>
&lt;h3 id="矢量图">矢量图&lt;/h3>
&lt;p>&lt;strong>矢量&lt;/strong>又称为“向量”，矢量图像中的图形元素（点和线段）称为对象，每个对象都是一个单独的个体，它具有大小、方向、轮廓、颜色和屏幕位置等属性。简单地说，矢量图形软件就是用数学的方法来绘制矩形等基本形状的。&lt;/p>
&lt;p>&lt;strong>矢量图特点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>可以无限放大，同时又不用担心失真；&lt;/li>
&lt;li>矢量图可以轻松地转化为位图，而位图转化为矢量图就需要通过图像临摹之类的方式，但完美转成矢量图还是有些难度。&lt;/li>
&lt;li>&lt;strong>矢量图的文件格式&lt;/strong> ：比如 Adobe Illustrator 的.AI、.EPS、.SVG，.PDF，AutoCAD 的.dwg 和.dxf，windows 标准图元文件*.wmf 和增强型图元文件*.emf 等。&lt;/li>
&lt;li>&lt;strong>常用的矢量图编辑软件&lt;/strong>：Illustrator、CorelDraw、AutoCAD 等。&lt;/li>
&lt;/ul>
&lt;h3 id="像素dpi-与打印尺寸之间的关系">像素、DPI 与打印尺寸之间的关系&lt;/h3>
&lt;p>图像分辨率，像素数和打印尺寸在数学上的关系为：像素=分辨率（DPI）× 打印尺寸（以英寸为单位）。&lt;/p>
&lt;p>其中，DPI 为每平方英寸像素数目，也就是图像细节程度的度量。理解了上述概念我们就可以通过上述概念推测出图像的尺寸大小，比如说，我想打印一副 8 英寸 * 10 英寸，300DPI 的图片，那么怎样设置图像的像素长宽度呢？你只要简单地把这两者相乘就可以了，$8 \times 300=2400$ ，$10 \times 300=3000$ ，所以这幅图像的像素尺寸就是 $2400 \times 3000$ 。&lt;/p>
&lt;h3 id="杂志要求">杂志要求&lt;/h3>
&lt;p>这里以著名出版商&lt;a class="link" href="https://www.elsevier.com/authors/author-schemas/artwork-and-media-instructions/artwork-sizing" target="_blank" rel="noopener" >艾斯维尔（Elsevier）的要求
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
为例：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">TARGET SIZE&lt;/th>
&lt;th style="text-align:center">Image Width&lt;/th>
&lt;th style="text-align:center">Pixels at 300 dpi&lt;/th>
&lt;th style="text-align:center">Pixels at 500 dpi&lt;/th>
&lt;th style="text-align:center">Pixels at 1000 dpi&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">Minimal size&lt;/td>
&lt;td style="text-align:center">30 mm (85 pt)&lt;/td>
&lt;td style="text-align:center">354&lt;/td>
&lt;td style="text-align:center">591&lt;/td>
&lt;td style="text-align:center">1181&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Single column&lt;/td>
&lt;td style="text-align:center">90 mm (255 pt)&lt;/td>
&lt;td style="text-align:center">1063&lt;/td>
&lt;td style="text-align:center">1772&lt;/td>
&lt;td style="text-align:center">3543&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">1.5 column&lt;/td>
&lt;td style="text-align:center">140 mm (397 pt)&lt;/td>
&lt;td style="text-align:center">1654&lt;/td>
&lt;td style="text-align:center">2756&lt;/td>
&lt;td style="text-align:center">5512&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Double column (full width)&lt;/td>
&lt;td style="text-align:center">190 mm (539 pt)&lt;/td>
&lt;td style="text-align:center">2244&lt;/td>
&lt;td style="text-align:center">3740&lt;/td>
&lt;td style="text-align:center">7480&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>通过学习上面图像尺寸的内容我们可以知道打印尺寸与像素和 dpi 之间的关系。例如，表格中红色要求图像最小尺寸为 $30 \mathrm{mm}$ ，我们可以通过公式验证一下在 300dpi 分辨率下 354 像素宽打印出来的尺寸是不是 $30 \mathrm{mm}$ ：$354 \div 300 \times 2.54 \times 10 = 29.97 \mathrm{mm}$ ， 最后相乘的两个数据是把英寸换算成毫米，正好是 $30 \mathrm{mm}$ 。所以知道了上述关系我们就可以利用 Photoshop 来编辑我们的图片了；&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/attachments-2018-07-4Fzft7fc5b5ace58ae9dd-2024-02-28.webp"
alt="attachments-2018-07-4Fzft7fc5b5ace58ae9dd-2024-02-28" width="auto" loading="lazy">
&lt;/figure>
&lt;p>例如一张图片，来自于 Mapman，用 Photoshop 打开，显示尺寸如下：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/attachments-2018-08-ZdVKUJMx5b63ec8d64919-2024-02-28.webp"
alt="attachments-2018-08-ZdVKUJMx5b63ec8d64919-2024-02-28" width="auto" loading="lazy">
&lt;/figure>
&lt;p>由于图片尺寸太大，宽度 $124.99 \mathrm{cm}$ ，而且分辨率是 $72$ ，不符合杂志要求。这里利用上面学到的知识在不损失图片像素的情况下调整一下图片尺寸；&lt;/p>
&lt;p>现在我们要把图片宽度调整到双栏的尺寸也就是 $19\mathrm{cm}$ ；通过公式：像素=分辨率（DPI）× 打印尺寸（以英寸为单位）&lt;/p>
&lt;p>在像素不变的情况下，我们要提高分辨率，来缩小图片的打印尺寸，根据比例计算应该提高到多少 dpi： $124.99 \div 19 \times 72=473.6 \mathrm{dpi}$ ；&lt;/p>
&lt;p>所以修改宽度和分辨率这两个数值就可以了，而且图片的像素数是不变的，达到了无损改变图片的大小；而且 473dpi 大于最小的 300dpi。&lt;/p>
&lt;h2 id="matplotlib-python-库">Matplotlib Python 库&lt;/h2>
&lt;p>作为 Python 生态中最基础且最广泛使用的数据可视化库，Matplotlib 提供了丰富的 2D 和 3D 图形绘制能力，尤其适合制作线图、柱状图、散点图等常见科研图表，并能高度定制化输出样式以符合各类学术期刊的标准。&lt;/p>
&lt;p>它可以用来绘制各种静态，动态，交互式的图表。我们可以使用该工具将很多数据通过图表的形式更直观的呈现出来，包括绘制线图、散点图、等高线图、条形图、柱状图、3D 图形、甚至是图形动画等等。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/matplotlib-graphs-2048x1153-2024-02-28.webp"
alt="matplotlib-graphs-2048x1153-2024-02-28" width="auto" loading="lazy">
&lt;/figure>
&lt;hr>
&lt;ul>
&lt;li>Matplitlib Cheat Sheet&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/cheatsheets-1-2024-02-28.webp"
alt="cheatsheets-1-2024-02-28" width="auto" loading="lazy">
&lt;/figure>
&lt;h2 id="seaborn-python-库">Seaborn Python 库&lt;/h2>
&lt;p>构建于 Matplotlib 之上，Seaborn 进一步强化了统计图表的功能，它内置了许多高级统计图表样式，如热力图、箱型图和时间序列分析图表，使复杂数据关系的展现更为直观易读。既然是基于 matplotlib，所以 seaborn 的很多图表接口和参数设置与其很是接近，使得作图更加方便快捷。即便是没有什么基础的人，也能通过极简的代码，做出具有分析价值而又十分美观的图形。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/Seaborn-gallery-2024-02-28.webp"
alt="Seaborn-gallery-2024-02-28" width="auto" loading="lazy">
&lt;/figure>
&lt;hr>
&lt;ul>
&lt;li>Seaborn Cheat Sheet
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/Python_Seaborn_Cheat_Sheet_q074wv-2024-02-28.webp"
alt="Python_Seaborn_Cheat_Sheet_q074wv-2024-02-28" width="auto" loading="lazy">
&lt;/figure>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ul>
&lt;li>优秀教程：&lt;a class="link" href="https://zhuanlan.zhihu.com/p/81553421" target="_blank" rel="noopener" >数据可视化，Seaborn 画图原来这么好看
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/li>
&lt;/ul>
&lt;h2 id="visio-矢量图软件框架流程绘制与算法结构">Visio 矢量图软件（框架流程绘制与算法结构）&lt;/h2>
&lt;p>对于非数据密集型但逻辑严密的图表设计，如实验流程图、系统架构图或算法流程图，Microsoft Visio 凭借其强大的矢量编辑能力和海量预设模板，成为了构建清晰、规范流程图的理想选择。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/data-graphics-2024-02-28.webp"
alt="data-graphics-2024-02-28" width="auto" loading="lazy">
&lt;/figure>
&lt;h2 id="origin-矢量图软件数学分析与函数绘制">Origin 矢量图软件（数学分析与函数绘制）&lt;/h2>
&lt;p>Origin 是由 OriginLab 公司开发的一个科学绘图、数据分析软件，支持在 Microsoft Windows 下运行。Origin 支持各种各样的 2D/3D 图形。Origin 中的数据分析功能包括统计，信号处理，曲线拟合以及峰值分析。Origin 中的曲线拟合是采用基于 Levernberg-Marquardt 算法（LMA）的非线性最小二乘法拟合。Origin 强大的数据导入功能，支持多种格式的数据，包括 ASCII、Excel、NI TDM、DIADem、NetCDF、SPC 等等。图形输出格式多样，例如 JPEG，GIF，EPS，TIFF 等。内置的查询工具可通过 ADO 访问数据库数据。&lt;/p>
&lt;p>在物理、化学、生物等领域享有盛誉，Origin 专为科研数据分析打造，以其强大的数学分析和函数绘制能力著称，特别适用于绘制精密的信号曲线、频谱分析图和其他复杂科研图形。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/Picture1_revised%20text-2024-02-28.webp"
alt="Picture1_revised text-2024-02-28" width="auto" loading="lazy">
&lt;/figure>
&lt;h2 id="aiadobe-illustrator矢量图软件">AI（Adobe Illustrator）矢量图软件&lt;/h2>
&lt;p>作为行业标准级矢量图形处理软件，Illustrator 不仅适用于高精度的出版级图表设计，还能创建高质量的科学插图，确保在任何尺寸下都能保持清晰细腻的效果。它是一种应用于出版、多媒体和在线图像的工业标准矢量插画的软件。该软件主要应用于印刷出版、海报书籍排版、专业插画、多媒体图像处理和互联网页面的制作等，也可以为线稿提供较高的精度和控制，适合生产任何小型设计到大型的复杂项目。&lt;/p>
&lt;p>在图表绘制中，主要应用在：直接绘图-计科和控制类的用的很少，有生化环材方向的同学利用 AI 实现细胞结构，心室高亮等操作；整合之前导出的单个矢量图；将非矢量图转化为矢量图&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/attachments-2018-07-NTyyj78C5b500737d0ac8-2024-02-28.webp"
alt="attachments-2018-07-NTyyj78C5b500737d0ac8-2024-02-28" width="auto" loading="lazy">
&lt;/figure>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/attachments-2018-07-Mz7UCtYZ5b500821eb556-2024-02-28.webp"
alt="attachments-2018-07-Mz7UCtYZ5b500821eb556-2024-02-28" width="auto" loading="lazy">
&lt;/figure>
&lt;h2 id="inkscape-矢量图软件">Inkscape 矢量图软件&lt;/h2>
&lt;p>AI 的平替版，优点在于&lt;strong>开源免费&lt;/strong>。 作为开源界的矢量图形编辑器翘楚，Inkscape 提供了一套完整的 SVG 编辑工具，科研人员可以免费使用它来创作复杂的矢量图表，并确保跨平台兼容性和无损缩放性。官方中文地址：&lt;a class="link" href="https://inkscape.org/zh-hans/" target="_blank" rel="noopener" >Inkscape
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/INKSCAPE-2024-02-28.webp"
alt="INKSCAPE-2024-02-28" width="auto" loading="lazy">
&lt;/figure>
&lt;hr>
&lt;ul>
&lt;li>
&lt;p>详细介绍：&lt;a class="link" href="https://zhuanlan.zhihu.com/p/642526806" target="_blank" rel="noopener" >Inkscape - 免费开源、跨平台的矢量图形设计软件，代替 Adobe Illustrator (AI) 和 CorelDRAW
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>推荐视频教程：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="video-wrapper">
&lt;iframe src="https://player.bilibili.com/player.html?autoplay=0&amp;as_wide=1&amp;amp;high_quality=1&amp;amp;page=1&amp;bvid=BV1mA411e7FM"
scrolling="no"
frameborder="no"
framespacing="0"
allowfullscreen="true"
>
&lt;/iframe>
&lt;/div></description></item><item><title>RDMA 基本服务类型</title><link>https://cuterwrite.top/p/rdma-service-types/</link><pubDate>Sun, 25 Feb 2024 22:04:01 +0000</pubDate><guid>https://cuterwrite.top/p/rdma-service-types/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/f71da3ec40dd74648e15471d47ba3b84195413_crop-2024-02-26.webp" alt="Featured image of post RDMA 基本服务类型" />&lt;h1 id="rdma-基本服务类型">RDMA 基本服务类型&lt;/h1>
&lt;p>&lt;strong>本文欢迎非商业转载，转载请注明出处。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>声明：仅用于收藏，便于阅读&lt;/p>&lt;span class="cite">&lt;span>― &lt;/span>&lt;span>Savir, &lt;/span>&lt;a href="https://zhuanlan.zhihu.com/p/144099636">&lt;cite>知乎专栏：5. RDMA 基本服务类型&lt;/cite>&lt;/a>&lt;/span>&lt;/blockquote>
&lt;p>我们在 &lt;a class="link" href="https://cuterwrite.top/p/rdma-element/" >“3. RDMA 基本元素”
&lt;/a>
一文中提到过，&lt;strong>RDMA 的基本通信单元是 QP&lt;/strong>，而基于 QP 的通信模型有很多种，我们在 RDMA 领域称其为“服务类型”。IB 协议中通过“可靠”和“连接”两个维度来描述一种服务类型。&lt;/p>
&lt;h2 id="可靠">可靠&lt;/h2>
&lt;p>通信中的可靠性指的是通过一些机制保证发出去的数据包都能够被正常接收。IB 协议中是这样描述可靠服务的：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Reliable Service&lt;/strong> provides a guarantee that messages are delivered from a requester to a responder at most once, in order and without corruption.&lt;/p>
&lt;/blockquote>
&lt;p>即“可靠服务在发送和接受者之间保证了信息最多只会传递一次，并且能够保证其按照发送顺序完整的被接收”。&lt;/p>
&lt;p>IB 通过以下三个机制来保证可靠性：&lt;/p>
&lt;h2 id="应答机制">应答机制&lt;/h2>
&lt;p>假设 A 给 B 发了一个数据包，A 怎样才能知道 B 收到了呢，自然是 B 回复一个“我收到了”消息给 A。在通信领域我们一般称这个回复为应答包或者 ACK（Acknowledge）。在 IB 协议的可靠服务类型中，使用了应答机制来保证数据包被对方收到。IB 的可靠服务类型中，接收方不是每一个包都必须回复，也可以一次回复多个包的 ACK，以后我们再展开讨论。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/ib_ack-2024-02-26.webp"
alt="ib_ack-2024-02-26" width="auto" loading="lazy">
&lt;/figure>
&lt;h2 id="数据校验机制">数据校验机制&lt;/h2>
&lt;p>这个比较好理解，发端会对 Header 和 Payload（有效载荷，也就是真正要收发的数据）通过一定的算法得到一个校验值放到数据包的末尾。对端收到数据包后，也会用相同的算法计算出校验值，然后与数据包中的校验值比对，如果不一致，说明数据中包含错误（一般是链路问题导致的），那么接收端就会丢弃这个数据包。IB 协议使用的 CRC 校验，本文对 CRC 不做展开介绍。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/crc-2024-02-26.png"
alt="crc-2024-02-26" width="auto" loading="lazy">
&lt;/figure>
&lt;h2 id="保序机制">保序机制&lt;/h2>
&lt;p>保序指的是，保证先被发送到物理链路上的数据包一定要先于后发送的数据包被接收方收到。有一些业务对数据包的先后顺序是有严格要求的，比如语音或者视频。IB 协议中有 PSN（Packet Sequence Number，包序号）的概念，即每个包都有一个递增的编号。PSN 可以用来检测是否丢包，比如收端收到了 1，但是在没收到 2 的情况下就收到了 3，那么其就会认为传输过程中发生了错误，之后会回复一个 NAK 给发端，让其重发丢失的包。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/psn-2024-02-26.webp"
alt="psn-2024-02-26" width="auto" loading="lazy">
&lt;/figure>
&lt;p>不可靠服务，没有上述这些机制来保证数据包被正确的接收，属于“发出去就行，我不关心有没有被收到”的服务类型。&lt;/p>
&lt;h2 id="连接与数据报">连接与数据报&lt;/h2>
&lt;p>&lt;strong>连接（Connection）&lt;/strong> 在这里指的是一个抽象的逻辑概念，需要区别于物理连接，熟悉 Socket 的读者一定对这个其不陌生。连接是一条通信的“管道”，一旦管道建立好了，管道这端发出的数据一定会沿着这条管道到达另一端。&lt;/p>
&lt;p>对于“连接”或者说“面向连接”的定义有很多种，有的侧重于保证消息顺序，有的侧重于消息的传递路径唯一，有的强调需要软硬件开销来维护连接，有的还和可靠性的概念有交集。本专栏既然是介绍 RDMA 技术，那么我们就看一下 IB 协议 3.2.2 节中对其的描述：&lt;/p>
&lt;blockquote>
&lt;p>IBA supports both connection oriented and datagram service. For connected service, each QP is associated with exactly one remote consumer. In this case the QP context is configured with the identity of the remote consumer’s queue pair. &amp;hellip; During the communication establishment process, this and other information is exchanged between the two nodes.&lt;/p>
&lt;/blockquote>
&lt;p>即“IBA 支持基于连接和数据报的服务。对于基于连接的服务来说，每个 QP 都和另一个远端节点相关联。在这种情况下，QP Context 中包含有远端节点的 QP 信息。在建立通信的过程中，两个节点会交换包括稍后用于通信的 QP 在内的对端信息&amp;quot;。&lt;/p>
&lt;p>上面这端描述中的 Context 一般被翻译成上下文，QP Context（简称 QPC）可以简单理解为是记录一个 QP 相关信息的表格。我们知道 QP 是两个队列，除了这两个队列之外，我们还需要把关于 QP 的信息记录到一张表里面，这些信息可能包括队列的深度，队列的编号等等，后面我们会展开讲。&lt;/p>
&lt;p>可能还是有点抽象，我们用图说话：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/QPC-2024-02-26.webp"
alt="QPC-2024-02-26" width="auto" loading="lazy">
&lt;/figure>
&lt;p>A、B 和 A、C 节点的网卡在物理上是连接在一起的，A 上面的 QP2 和 B 上面的 QP7、A 上面的 QP4 和 B 上面的 QP2 建立了逻辑上的连接，或者说“绑定到了一起”。&lt;strong>在连接服务类型中的每个 QP，都和唯一的另一个 QP 建立了连接，也就是说 QP 下发的每个 WQE 的目的地都是唯一的&lt;/strong>。拿上图来说，对于 A 的 QP2 下发的每个 WQE，硬件都可以通过 QPC 得知其目的为 B 的 QP7，就会把组装好的数据包发送给 B，然后 B 会根据 QP7 下发的 RQ WQE 来存放数据；同理，对于 A 的 QP4 下发的每个 WQE，A 的硬件都知道应该把数据发给 Node C 的 QP2。&lt;/p>
&lt;p>“连接”是如何维护的呢？其实就是在 QPC 里面的一个记录而已。如果 A 的 QP2 想断开与 B 的 QP7 的“连接”然后与其他 QP 相“连接”，只需要修改 QPC 就可以了。两个节点在建立连接的过程中，会交换稍后用于数据交互的 QP Number，然后分别记录在 QPC 中。&lt;/p>
&lt;p>&lt;strong>数据报（Datagram）&lt;/strong> 与连接相反，发端和收端间不需要“建立管道”的步骤，只要发端到收端物理上是可以到达的，那么我就可能从任何路径发给任意的收端节点。IB 协议对其的定义是这样的：&lt;/p>
&lt;blockquote>
&lt;p>For datagram service, a QP is not tied to a single remote consumer, but rather information in the WQE identifies the destination. A communication setup process similar to the connection setup process needs to occur with each destination to exchange that information.&lt;/p>
&lt;p>即“对于数据报服务来说，QP 不会跟一个唯一的远端节点绑定，而是通过 WQE 来指定目的节点。和连接类型的服务一样，建立通信的过程也需要两端交换对端信息，但是数据报服务对于每个目的节点都需要执行一次这个交换过程。”&lt;/p>
&lt;/blockquote>
&lt;p>我们举个例子：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/Datagram-2024-02-26.webp"
alt="Datagram-2024-02-26" width="auto" loading="lazy">
&lt;/figure>
&lt;p>在数据报类型的 QP 的 Context 中，不包含对端信息，即每个 QP 不跟另一个 QP 绑定。&lt;strong>QP 下发给硬件的每个 WQE 都可能指向不同的目的地&lt;/strong>。比如节点 A 的 QP2 下发的第一个 WQE，指示给节点 C 的 QP3 发数据；而下一个 WQE，可以指示硬件发给节点 B 的 QP7。&lt;/p>
&lt;p>与连接服务类型一样，本端 QP 可以和哪个对端 QP 发送数据，是在准备阶段提前通过某些方式相互告知的。这也是上文“数据报服务对于每个目的节点都需要执行一次这个交换过程”的含义。&lt;/p>
&lt;h2 id="服务类型">服务类型&lt;/h2>
&lt;p>上面介绍的两个维度两两组合就形成了 IB 的四种基本服务类型：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>可靠(Reliable)&lt;/th>
&lt;th>不可靠(Unreliable)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>连接(Connection)&lt;/td>
&lt;td>RC（Reliable Connection）&lt;/td>
&lt;td>UC（Unreliable Connection）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>数据报(Datagram)&lt;/td>
&lt;td>RD（Reliable Datagram）&lt;/td>
&lt;td>UD（Unreliable Datagram）&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>RC 和 UD 是应用最多也是最基础的两种服务类型，我们可以将他们分别类比成 TCP/IP 协议栈传输层的 TCP 和 UDP。&lt;/p>
&lt;p>RC 用于对数据完整性和可靠性要求较高的场景，跟 TCP 一样，因为需要各种机制来保证可靠，所以开销自然会大一些。另外由于 RC 服务类型和每个节点间需要各自维护一个 QP，假设有 N 个节点要相互通信，那么至少需要 &lt;strong>N * (N - 1)&lt;/strong> 个 QP，而 QP 和 QPC 本身是需要占用网卡资源或者内存的，当节点数很多时，存储资源消耗将会非常大。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/RC_Connect-2024-02-26.webp"
alt="RC_Connect-2024-02-26" width="auto" loading="lazy">
&lt;/figure>
&lt;p>UD 硬件开销小并且节省存储资源，比如 N 个节点需要相互通信，只需要创建 &lt;strong>N&lt;/strong> 个 QP 就可以了，但是可靠性跟 UDP 一样没法保证。用户如果想基于 UD 服务类型实现可靠性，那么需要自己基于 IB 传输层实现应用层的可靠传输机制。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/UD_Connect-2024-02-26.webp"
alt="UD_Connect-2024-02-26" width="auto" loading="lazy">
&lt;/figure>
&lt;p>除此之外，还有 RD 和 UC 类型，以及 XRC（Extended Reliable Connection），SRD（Scalable Reliable Datagram）等更复杂的服务类型，我们将在协议解析部分对其进行详细的描述。&lt;/p>
&lt;p>更多关于 QP 类型选择的信息可以参考 RDMAmojo 上的&lt;a class="link" href="https://www.rdmamojo.com/2013/06/01/which-queue-pair-type-to-use/" target="_blank" rel="noopener" >Which Queue Pair type to use?
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
这篇文章，感谢 &lt;a class="link" href="https://www.zhihu.com/people/fc04fe143ad43b66fabb7050dadef923" target="_blank" rel="noopener" >@sinkinben
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
同学在评论区指路。&lt;/p>
&lt;h2 id="代码示例">代码示例&lt;/h2>
&lt;p>在 RDMA 编程中，我们可以通过 &lt;code>ibv_create_qp&lt;/code> 函数来创建 QP，其中的 &lt;code>struct ibv_qp_init_attr&lt;/code> 结构体中的 &lt;code>qp_type&lt;/code> 字段就是用来指定 QP 的服务类型的。下面是一个简单的示例代码：&lt;/p>
&lt;pre>&lt;code class="language-c">struct ibv_qp_init_attr qp_init_attr;
qp_init_attr.qp_type = IBV_QPT_RC; // RC 类型
qp_init_attr.sq_sig_all = 1; // 1 表示 SQ 中的每个 WQE 都需要对应的接收一个 CQE
qp_init_attr.send_cq = cq; // 发送 CQ
qp_init_attr.recv_cq = cq; // 接收 CQ
qp_init_attr.cap.max_send_wr = 1024; // SQ 的深度
struct ibv_qp *qp = ibv_create_qp(pd, &amp;amp;qp_init_attr);
&lt;/code>&lt;/pre></description></item><item><title>RDMA 操作类型</title><link>https://cuterwrite.top/p/rdma-op/</link><pubDate>Sat, 24 Feb 2024 03:09:01 +0000</pubDate><guid>https://cuterwrite.top/p/rdma-op/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/bcb5351691a864a6827138cf4c2e0642195413_crop-2024-02-25.webp" alt="Featured image of post RDMA 操作类型" />&lt;h1 id="rdma-操作类型">RDMA 操作类型&lt;/h1>
&lt;p>&lt;strong>本文欢迎非商业转载，转载请注明出处。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>声明：仅用于收藏，便于阅读&lt;/p>&lt;span class="cite">&lt;span>― &lt;/span>&lt;span>Savir, &lt;/span>&lt;a href="https://zhuanlan.zhihu.com/p/142175657">&lt;cite>知乎专栏：4. RDMA 操作类型&lt;/cite>&lt;/a>&lt;/span>&lt;/blockquote>
&lt;p>前面几篇涉及 RDMA 的通信流程时一直在讲 SEND-RECV，然而它其实称不上是“RDMA”，只是一种加入了 0 拷贝和协议栈卸载的传统收发模型的“升级版”，这种操作类型没有完全发挥 RDMA 技术全部实力，常用于两端交换控制信息等场景。当涉及大量数据的收发时，更多使用的是两种 RDMA 独有的操作：WRITE 和 READ。&lt;/p>
&lt;p>我们先来复习下双端操作——SEND 和 RECV，然后再对比介绍单端操作——WRITE 和 READ。&lt;/p>
&lt;h2 id="send--recv">SEND &amp;amp; RECV&lt;/h2>
&lt;p>SEND 和 RECV 是两种不同的操作类型，但是因为如果一端进行 SEND 操作，对端必须进行 RECV 操作，所以通常都把他们放到一起描述。&lt;/p>
&lt;p>为什么称之为“双端操作”？因为&lt;strong>完成一次通信过程需要两端 CPU 的参与&lt;/strong>，并且收端需要提前显式的下发 WQE。下图是一次 SEND-RECV 操作的过程示意图。原图来自于[1]，我做了一些修改。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/rdma-op-1-2024-02-25.webp"
alt="rdma-op-1-2024-02-25" width="auto" loading="lazy">
&lt;/figure>
&lt;p>上一篇我们讲过，上层应用通过 WQE（WR）来给硬件下任务。在 SEND-RECV 操作中，不止发送端需要下发 WQE，接收端也需要下发 WQE 来告诉硬件收到的数据需要放到哪个地址。发送端并不知道发送的数据会放到哪里，每次发送数据，接收端都要提前准备好接收 Buffer，而接收端 CPU 自然会感知这一过程。&lt;/p>
&lt;p>为了下文对比 SEND/RECV 与 WRITE/READ 的异同，我们将上一篇的 SEND-RECV 流程中补充内存读写这一环节，即下图中的步骤④——发送端硬件根据 WQE 从内存中取出数据封装成可在链路上传输数据包和步骤⑦——接收端硬件将数据包解析后根据 WQE 将数据放到指定内存区域，其他步骤不再赘述。另外再次强调一下，收发端的步骤未必是图中这个顺序，比如步骤⑧⑪⑫和步骤⑨⑩的先后顺序就是不一定的。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/rdma-op-2-2024-02-25.webp"
alt="rdma-op-2-2024-02-25" width="auto" loading="lazy">
&lt;/figure>
&lt;p>下面将介绍 WRITE 操作，对比之后相信大家可以理解的更好。&lt;/p>
&lt;h2 id="write">WRITE&lt;/h2>
&lt;p>WRITE 全称是 RDMA WRITE 操作，是本端主动写入远端内存的行为，除了准备阶段，远端 CPU 不需要参与，也不感知何时有数据写入、数据在何时接收完毕。所以这是一种单端操作。&lt;/p>
&lt;p>通过下图我们对比一下 WRITE 和 SEND-RECV 操作的差异，本端在准备阶段通过数据交互，获取了对端某一片可用的内存的&lt;strong>地址&lt;/strong>和“&lt;strong>钥匙&lt;/strong>” ，相当于获得了这片远端内存的读写权限。拿到权限之后，本端就可以像访问自己的内存一样&lt;strong>直接对这一远端内存区域进行读写&lt;/strong>，这也是 RDMA——远程直接地址访问的内涵所在。&lt;/p>
&lt;p>WRITE/READ 操作中的目的地址和钥匙是如何获取的呢？通常可以通过我们刚刚讲过的 SEND-RECV 操作来完成，因为拿到钥匙这个过程总归是要由远端内存的控制者——CPU 允许的。虽然准备工作还比较复杂， 但是一旦完成准备工作，RDMA 就可以发挥其优势，对大量数据进行读写。一旦远端的 CPU 把内存授权给本端使用，它便不再会参与数据收发的过程，这就解放了远端 CPU，也降低了通信的时延。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/rdma-op-3-2024-02-25.webp"
alt="rdma-op-3-2024-02-25" width="auto" loading="lazy">
&lt;/figure>
&lt;p>需要注意的是，本端是通过&lt;strong>虚拟地址&lt;/strong>来读写远端内存的，上层应用可以非常方便的对其进行操作。实际的虚拟地址—物理地址的转换是由 RDMA 网卡完成的。具体是如何转换的，将在后面的文章介绍。&lt;/p>
&lt;p>忽略准备阶段 key 和 addr 的获取过程，下面我们描述一次 WRITE 操作的流程，此后我们不再将本端和对端称为“发送”和“接收”端，而是改为“请求”和“响应”端，这样对于描述 WRITE 和 READ 操作都更恰当一些，也不容易产生歧义。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/rdma-op-4-2024-02-25.webp"
alt="rdma-op-4-2024-02-25" width="auto" loading="lazy">
&lt;/figure>
&lt;ol>
&lt;li>请求端 APP 以 WQE（WR）的形式下发一次 WRITE 任务。&lt;/li>
&lt;li>请求端硬件从 SQ 中取出 WQE，解析信息。&lt;/li>
&lt;li>请求端网卡根据 WQE 中的虚拟地址，转换得到物理地址，然后从内存中拿到待发送数据，组装数据包。&lt;/li>
&lt;li>请求端网卡将数据包通过物理链路发送给响应端网卡。&lt;/li>
&lt;li>响应端收到数据包，解析目的虚拟地址，转换成本地物理地址，解析数据，将数据放置到指定内存区域。&lt;/li>
&lt;li>响应端回复 ACK 报文给请求端。&lt;/li>
&lt;li>请求端网卡收到 ACK 后，生成 CQE，放置到 CQ 中。&lt;/li>
&lt;li>请求端 APP 取得任务完成信息。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>注：严谨地说，第 6 步回复 ACK 之时，RDMA 网卡只能保证数据包中的 Payload 已经被”暂存“了下来，但不能保证一定已经把数据放到目的内存里面了。不过这一点不影响我们对整理流程的理解，感谢@nekomii 同学的提醒。&lt;/p>
&lt;p>IB Spec. 9.7.5.1.6 ACKNOWLEDGE MESSAGE SCHEDULING 原文：”For SEND or RDMA WRITE requests, an ACK may be scheduled before data is actually written into the responder’s memory. The ACK simply indicates that the data has successfully reached the fault domain of the responding node. That is, the data has been received by the channel adapter and the channel adapter will write that data to the memory system of the responding node, or the responding application will at least be informed of the failure.“&lt;/p>
&lt;/blockquote>
&lt;h2 id="read">READ&lt;/h2>
&lt;p>顾名思义，READ 跟 WRITE 是相反的过程，是本端主动读取远端内存的行为。同 WRITE 一样，远端 CPU 不需要参与，也不感知数据在内存中被读取的过程。&lt;/p>
&lt;p>获取 key 和虚拟地址的流程也跟 WRITE 没有区别，需要注意的是 &lt;strong>&amp;ldquo;读”这个动作所请求的数据&lt;/strong>，是在对端回复的报文中携带的。&lt;/p>
&lt;p>下面描述一次 READ 操作的流程，注意跟 WRITE 只是方向和步骤顺序的差别。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/rdma5-2024-02-25.webp"
alt="rdma5-2024-02-25" width="auto" loading="lazy">
&lt;/figure>
&lt;ol>
&lt;li>请求端 APP 以 WQE 的形式下发一次 READ 任务。&lt;/li>
&lt;li>请求端网卡从 SQ 中取出 WQE，解析信息。&lt;/li>
&lt;li>请求端网卡将 READ 请求包通过物理链路发送给响应端网卡。&lt;/li>
&lt;li>响应端收到数据包，解析目的虚拟地址，转换成本地物理地址，解析数据，从指定内存区域取出数据。&lt;/li>
&lt;li>响应端硬件将数据组装成回复数据包发送到物理链路。&lt;/li>
&lt;li>请求端硬件收到数据包，解析提取出数据后放到 READ WQE 指定的内存区域中。&lt;/li>
&lt;li>请求端网卡生成 CQE，放置到 CQ 中。&lt;/li>
&lt;li>请求端 APP 取得任务完成信息。&lt;/li>
&lt;/ol>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>我们忽略各种细节进行抽象，RDMA WRITE 和 READ 操作就是在利用网卡完成下面左图的内存拷贝操作而已，只不过复制的过程是由 RDMA 网卡通过网络链路完成的；而本地内存拷贝则如下面右图所示由 CPU 通过总线完成的：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/rdma-op-6-2024-02-25.webp"
alt="rdma-op-6-2024-02-25" width="auto" loading="lazy">
&lt;/figure>
&lt;p>RDMA 标准定义上述几种操作的时候使用的单词是非常贴切的，“收”和“发”是需要有对端主动参与的语义 ，而‘读“和”写“更像是本端对一个没有主动性的对端进行操作的语义。&lt;/p>
&lt;p>通过对比 SEND/RECV 和 WRITE/READ 操作，我们可以发现传输数据时不需要响应端 CPU 参与的 WRITE/READ 有更大的优势，缺点就是请求端需要在准备阶段获得响应端的一段内存的读写权限。但是实际数据传输时，这个准备阶段的功率和时间损耗都是可以忽略不计的，所以 RDMA WRITE/READ 才是大量传输数据时所应用的操作类型，SEND/RECV 通常只是用来传输一些控制信息。&lt;/p>
&lt;p>除了本文介绍的几种操作之外，还有 ATOMIC 等更复杂一些的操作类型，将在后面的协议解读部分详细分析。本篇就到这里，下一篇将介绍 RDMA 基本服务类型。&lt;/p>
&lt;h2 id="代码示例">代码示例&lt;/h2>
&lt;p>本文中的操作类型都是通过 WQE 来下发的，下面是一个简单的例子，展示了如何使用 libibverbs 来创建一个 QP，然后通过 WQE 来下发一个 WRITE 操作。&lt;/p>
&lt;pre>&lt;code class="language-c">#include &amp;lt;infiniband/verbs.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main() {
struct ibv_device **dev_list = ibv_get_device_list(NULL);
struct ibv_context *ctx = ibv_open_device(dev_list[0]);
struct ibv_pd *pd = ibv_alloc_pd(ctx);
struct ibv_cq *cq = ibv_create_cq(ctx, 10, NULL, NULL, 0);
struct ibv_qp *qp;
struct ibv_qp_init_attr qp_init_attr = {
.send_cq = cq,
.recv_cq = cq,
.qp_type = IBV_QPT_RC,
};
qp = ibv_create_qp(pd, &amp;amp;qp_init_attr);
struct ibv_mr *mr;
char *buf = malloc(1024);
mr = ibv_reg_mr(pd, buf, 1024, IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE);
struct ibv_sge sge = {
.addr = (uintptr_t)buf,
.length = 1024,
.lkey = mr-&amp;gt;lkey,
};
struct ibv_send_wr wr = {
.wr_id = 1,
.sg_list = &amp;amp;sge,
.num_sge = 1,
.opcode = IBV_WR_RDMA_WRITE,
.send_flags = IBV_SEND_SIGNALED,
};
struct ibv_send_wr *bad_wr;
ibv_post_send(qp, &amp;amp;wr, &amp;amp;bad_wr);
return 0;
}
&lt;/code>&lt;/pre>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;p>[1] part1-OFA_Training_Sept_2016.pdf&lt;/p></description></item><item><title>搭建玄铁 900 系列工具链与 xuantie-qemu 环境</title><link>https://cuterwrite.top/p/thead-tools/</link><pubDate>Tue, 20 Feb 2024 01:51:00 +0000</pubDate><guid>https://cuterwrite.top/p/thead-tools/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/59aa9fecb7e1a3a2b2c88811e6360647195413.jpg@1256w_774h_!web-article-pic-2024-02-20.webp" alt="Featured image of post 搭建玄铁 900 系列工具链与 xuantie-qemu 环境" />&lt;h1 id="搭建玄铁-900-系列工具链与-xuantie-qemu-环境">搭建玄铁 900 系列工具链与 xuantie-qemu 环境&lt;/h1>
&lt;h2 id="一搭建平台">一、搭建平台&lt;/h2>
&lt;ul>
&lt;li>Linux 发行版：CentOS Linux release 7.6.1810 (Core)&lt;/li>
&lt;li>内核版本：3.10.0-957.el7.x86_64&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-bash">$ cat /etc/centos-release
CentOS Linux release 7.6.1810 (Core)
$ uname -r
3.10.0-957.el7.x86_64
&lt;/code>&lt;/pre>
&lt;h2 id="二搭建玄铁-900-系列工具链环境">二、搭建玄铁 900 系列工具链环境&lt;/h2>
&lt;h3 id="1-下载玄铁-900-系列工具链">1. 下载玄铁 900 系列工具链&lt;/h3>
&lt;p>首先，我们需要下载适用于 RISC-V 架构的 Xuantie GNU 工具链。前往&lt;a class="link" href="https://www.xrvm.cn/" target="_blank" rel="noopener" >玄铁官网
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
获取最新版本的预编译包，并根据你的操作系统进行安装。在 Linux 系统中，通常解压后通过添加 &lt;code>bin&lt;/code> 路径到 &lt;code>$PATH&lt;/code> 环境变量即可。&lt;/p>
&lt;p>工具链安装包由于执行平台和目标程序平台的不同分为不同的版本，如 Xuantie-&lt;em>-elf-&lt;/em>-x86_64-V*-.tar.gz 是 64 位 linux 平台的 riscv 裸程序工具链套件。具体分类如下：&lt;/p>
&lt;ul>
&lt;li>根据执行平台
&lt;ul>
&lt;li>x86_64：64 位 linux 平台&lt;/li>
&lt;li>i386：32 位 linux 平台&lt;/li>
&lt;li>mingw：Windows Mingw 平台&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>根据目标程序平台
&lt;ul>
&lt;li>elf：裸程序编译套件&lt;/li>
&lt;li>linux：linux 应用程序编译套件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>这里我们下载最新的版本为 2.8.1 的适用于 64 位 linux 平台的 linux 应用程序编译套件，即 Xuantie-900-gcc-linux-5.10.4-glibc-x86_64 。&lt;/p>
&lt;pre>&lt;code class="language-bash">wget https://occ-oss-prod.oss-cn-hangzhou.aliyuncs.com/resource//1705395627867/Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.1-20240115.tar.gz
tar -xzvf Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.1-20240115.tar.gz
sudo mv Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.1-20240115 /opt
export PATH=/opt/Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.1-20240115/bin:$PATH
&lt;/code>&lt;/pre>
&lt;h3 id="2-验证工具链安装">2. 验证工具链安装&lt;/h3>
&lt;pre>&lt;code class="language-bash">$ riscv64-unknown-linux-gnu-gcc -v
Using built-in specs.
COLLECT_GCC=riscv64-unknown-linux-gnu-gcc
COLLECT_LTO_WRAPPER=/opt/Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.0/bin/../libexec/gcc/riscv64-unknown-linux-gnu/10.4.0/lto-wrapper
Target: riscv64-unknown-linux-gnu
Configured with: /mnt/ssd/jenkins_iotsw/slave/workspace/Toolchain/build-gnu-riscv_4/./source/riscv/riscv-gcc/configure --target=riscv64-unknown-linux-gnu --with-gmp=/mnt/ssd/jenkins_iotsw/slave/workspace/Toolchain/build-gnu-riscv_4/build-gcc-riscv64-unknown-linux-gnu/build-Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.0/lib-for-gcc-x86_64-linux --with-mpfr=/mnt/ssd/jenkins_iotsw/slave/workspace/Toolchain/build-gnu-riscv_4/build-gcc-riscv64-unknown-linux-gnu/build-Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.0/lib-for-gcc-x86_64-linux --with-mpc=/mnt/ssd/jenkins_iotsw/slave/workspace/Toolchain/build-gnu-riscv_4/build-gcc-riscv64-unknown-linux-gnu/build-Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.0/lib-for-gcc-x86_64-linux --with-libexpat-prefix=/mnt/ssd/jenkins_iotsw/slave/workspace/Toolchain/build-gnu-riscv_4/build-gcc-riscv64-unknown-linux-gnu/build-Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.0/lib-for-gcc-x86_64-linux --with-libmpfr-prefix=/mnt/ssd/jenkins_iotsw/slave/workspace/Toolchain/build-gnu-riscv_4/build-gcc-riscv64-unknown-linux-gnu/build-Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.0/lib-for-gcc-x86_64-linux --with-pkgversion='Xuantie-900 linux-5.10.4 glibc gcc Toolchain V2.8.0 B-20231018' CXXFLAGS='-g -O2 -DTHEAD_VERSION_NUMBER=2.8.0 ' --prefix=/mnt/ssd/jenkins_iotsw/slave/workspace/Toolchain/build-gnu-riscv_4/build-gcc-riscv64-unknown-linux-gnu/Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.0 --with-sysroot=/mnt/ssd/jenkins_iotsw/slave/workspace/Toolchain/build-gnu-riscv_4/build-gcc-riscv64-unknown-linux-gnu/Xuantie-900-gcc-linux-5.10.4-glibc-x86_64-V2.8.0/sysroot --with-system-zlib --enable-shared --enable-tls --enable-languages=c,c++,fortran --disable-libmudflap --disable-libssp --disable-libquadmath --enable-libsanitizer --disable-nls --disable-bootstrap --src=https://cuterwrite.top/mnt/ssd/jenkins_iotsw/slave/workspace/Toolchain/build-gnu-riscv_4/./source/riscv/riscv-gcc --enable-multilib --with-abi=lp64d --with-arch=rv64gc_zfh_xtheadc 'CFLAGS_FOR_TARGET=-O2 -mcmodel=medany' 'CXXFLAGS_FOR_TARGET=-O2 -mcmodel=medany'
Thread model: posix
Supported LTO compression algorithms: zlib
gcc version 10.4.0 (Xuantie-900 linux-5.10.4 glibc gcc Toolchain V2.8.0 B-20231018)
&lt;/code>&lt;/pre>
&lt;p>可以看到输出了 gcc 的版本信息，说明工具链安装成功。&lt;/p>
&lt;h2 id="三搭建-xuantie-qemu-环境">三、搭建 xuantie-qemu 环境&lt;/h2>
&lt;h3 id="1-前提条件">1. 前提条件&lt;/h3>
&lt;p>在安装 xuantie-qemu 之前，需要确保系统含有以下工具或库。&lt;/p>
&lt;ul>
&lt;li>gcc 编译器&lt;/li>
&lt;li>automake&lt;/li>
&lt;li>autoconf&lt;/li>
&lt;li>libtool&lt;/li>
&lt;li>glib2 库&lt;/li>
&lt;li>其它&amp;hellip;..&lt;/li>
&lt;/ul>
&lt;p>通过以下命令安装上述工具或库。&lt;/p>
&lt;pre>&lt;code class="language-bash">sudo yum update -y
sudo yum install -y autoconf automake libtool make gcc gcc-c++ gawk bison flex texinfo gperf patchutils bc \
zlib-devel mpfr-devel gmp-devel curl-devel expat-devel git \
glib2-devel libfdt-devel pixman-devel ncurses-devel ncurses-compat-libs
&lt;/code>&lt;/pre>
&lt;p>如果是 Ubuntu/Dedian 系统，可以使用以下命令安装。&lt;/p>
&lt;pre>&lt;code class="language-bash">sudo apt-get update
sudo apt-get install -y autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \
gawk build-essential bison flex texinfo gperf libtool patchutils bc \
zlib1g-dev libexpat-dev git \
libglib2.0-dev libfdt-dev libpixman-1-dev \
libncurses5-dev libncursesw5-dev
&lt;/code>&lt;/pre>
&lt;h3 id="2-下载并安装-xuantie-qemu">2. 下载并安装 xuantie-qemu&lt;/h3>
&lt;p>访问 &lt;a class="link" href="https://github.com/T-head-Semi/qemu.git" target="_blank" rel="noopener" >Xuantie QEMU 官方仓库
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
，获取适用于玄铁 900 系列芯片的 xuantie-qemu 源代码，然后按照常规步骤编译安装：&lt;/p>
&lt;pre>&lt;code class="language-bash">git clone https://github.com/T-head-Semi/qemu.git
git checkout xuantie-qemu-6.1.0
&lt;/code>&lt;/pre>
&lt;h3 id="3-编译安装-xuantie-qemu">3. 编译安装 xuantie-qemu&lt;/h3>
&lt;pre>&lt;code class="language-bash">cd qemu
mkdir build
cd build
../configure --target-list=riscv64-softmmu,riscv64-linux-user --prefix=/opt/qemu/6.1.0-xuantie
make -j $(nproc)
sudo make install
export PATH=/opt/qemu/6.1.0-xuantie/bin:$PATH
&lt;/code>&lt;/pre>
&lt;h3 id="4-验证-xuantie-qemu-安装">4. 验证 xuantie-qemu 安装&lt;/h3>
&lt;p>安装完毕后如果执行如下命令后能够查看到 qemu 的具体版本，则说明安装成功&lt;/p>
&lt;pre>&lt;code class="language-bash">$ qemu-riscv64 --version
qemu-riscv64 version 6.0.94 (v6.1.0-12-g03813c9)
Copyright (c) 2003-2021 Fabrice Bellard and the QEMU Project developers
&lt;/code>&lt;/pre>
&lt;p>编写一段 C 语言程序，如下所示：&lt;/p>
&lt;pre>&lt;code class="language-c">#include &amp;lt;stdio.h&amp;gt;
int main() {
printf(&amp;quot;Hello RISC-V \n&amp;quot;);
return 0;
}
&lt;/code>&lt;/pre>
&lt;p>使用 Xuantie 900 系列工具链编译该程序，并使用用户模式的 xuantie-qemu 运行程序。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ riscv64-unknown-linux-gnu-gcc -static -o hello hello.c
$ qemu-riscv64 ./hello
Hello RISC-V
&lt;/code>&lt;/pre>
&lt;p>再写一段 RVV 向量化的 C 语言程序，如下所示：&lt;/p>
&lt;details>
&lt;summary>&lt;strong>RVV 向量化 C 语言程序&lt;/strong>&lt;/summary>
&lt;pre>&lt;code class="language-c">#include &amp;lt;riscv_vector.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#define N 15
float vsum(float* v, int n) {
vfloat32m1_t vs, vv, vtmp;
float s = 0.0;
int i;
int vlmax;
vlmax = vsetvlmax_e32m1();
printf(&amp;quot;vlmax:%d\n&amp;quot;, vlmax);
vs = vfmv_v_f_f32m1(0.0, vlmax);
vtmp = vfmv_v_f_f32m1(0.0, vlmax);
for (i = 0; i &amp;lt; n - vlmax; i += vlmax) {
vv = vle32_v_f32m1(&amp;amp;v[i], vlmax);
vtmp = vfadd_vv_f32m1(vtmp, vv, vlmax);
}
vs = vfredusum_vs_f32m1_f32m1(vs, vtmp, vs, vlmax);
s = vfmv_f_s_f32m1_f32(vs);
for (; i &amp;lt; n; i++) {
s += v[i];
}
return s;
}
float vsum1(float* v, int n) {
vfloat32m1_t vs, vv;
float s;
int i;
int vl, vlmax;
vlmax = vsetvlmax_e32m1();
vs = vfmv_v_f_f32m1(0.0, vlmax);
for (i = 0; n &amp;gt; 0; i += vl, n -= vl) {
vl = vsetvl_e32m1(n);
printf(&amp;quot;vl:%d\n&amp;quot;, vl);
vv = vle32_v_f32m1(&amp;amp;v[i], vl);
vs = vfredusum_vs_f32m1_f32m1(vs, vv, vs, vl);
}
s = vfmv_f_s_f32m1_f32(vs);
return s;
}
float vsum2(float* v, int n) {
vfloat32m2_t vv;
vfloat32m1_t vs;
float s;
int i;
int vl, vlmax;
vlmax = vsetvlmax_e32m1();
vs = vfmv_v_f_f32m1(0.0, vlmax);
for (i = 0; n &amp;gt; 0; i += vl, n -= vl) {
vl = vsetvl_e32m2(n);
printf(&amp;quot;vl:%d\n&amp;quot;, vl);
vv = vle32_v_f32m2(&amp;amp;v[i], vl);
vs = vfredusum_vs_f32m2_f32m1(vs, vv, vs, vl);
}
s = vfmv_f_s_f32m1_f32(vs);
return s;
}
int main() {
int i;
float v[N], sum = 0.0;
printf(&amp;quot;Hello RISC-V!\n&amp;quot;);
for (i = 0; i &amp;lt; N; i++) {
v[i] = i;
}
sum = vsum(v, N);
printf(&amp;quot;%f\n&amp;quot;, sum);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/details>
&lt;p>编译并运行该程序（这时需要指定 &lt;code>-cpu&lt;/code> ，否则会报非法指定的异常，即 Illegal instruction (core dumped)）：&lt;/p>
&lt;pre>&lt;code class="language-bash">$ riscv64-unknown-linux-gnu-gcc -static -O3 -march=rv64imafdcv0p7_zfh_xtheadc -o test_vec test_vec.c
$ qemu-riscv64 -cpu c920 ./test_vec
Hello RISC-V!
vlmax:4
105.000000
&lt;/code>&lt;/pre>
&lt;h2 id="四在-qemu-上运行-risc-v-64-位-linux-系统">四、在 QEMU 上运行 RISC-V 64 位 Linux 系统&lt;/h2>
&lt;h3 id="1-制作内核">1. 制作内核&lt;/h3>
&lt;h4 id="11-下载内核源码">1.1 下载内核源码&lt;/h4>
&lt;pre>&lt;code class="language-bash">$ wget https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.10.42.tar.gz
$ tar -xzvf linux-5.10.42.tar.gz
&lt;/code>&lt;/pre>
&lt;p>下载后进入内核源码目录&lt;/p>
&lt;pre>&lt;code class="language-bash">$ cd linux-5.10.42
&lt;/code>&lt;/pre>
&lt;h4 id="12-配置和编译内核">1.2 配置和编译内核&lt;/h4>
&lt;pre>&lt;code class="language-bash">$ make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- defconfig
$ make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- -j $(nproc)
...
AR drivers/built-in.a
GEN .version
CHK include/generated/compile.h
LD vmlinux.o
MODPOST vmlinux.symvers
MODINFO modules.builtin.modinfo
GEN modules.builtin
LD .tmp_vmlinux.kallsyms1
KSYMS .tmp_vmlinux.kallsyms1.S
AS .tmp_vmlinux.kallsyms1.S
LD .tmp_vmlinux.kallsyms2
KSYMS .tmp_vmlinux.kallsyms2.S
AS .tmp_vmlinux.kallsyms2.S
LD vmlinux
SYSMAP System.map
MODPOST modules-only.symvers
GEN Module.symvers
CC [M] fs/efivarfs/efivarfs.mod.o
OBJCOPY arch/riscv/boot/Image
GZIP arch/riscv/boot/Image.gz
LD [M] fs/efivarfs/efivarfs.ko
Kernel: arch/riscv/boot/Image.gz is ready
&lt;/code>&lt;/pre>
&lt;h3 id="2-制作-rootfs">2. 制作 rootfs&lt;/h3>
&lt;h4 id="21-下载-busybox-源码">2.1 下载 busybox 源码&lt;/h4>
&lt;pre>&lt;code class="language-bash">$ wget https://busybox.net/downloads/busybox-1.33.1.tar.bz2
&lt;/code>&lt;/pre>
&lt;p>下载完后进入 busybox 源码目录&lt;/p>
&lt;pre>&lt;code class="language-bash">cd busybox-1.33.1
&lt;/code>&lt;/pre>
&lt;h4 id="22-配置-busybox">2.2 配置 busybox&lt;/h4>
&lt;pre>&lt;code class="language-bash">$ make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- defconfig
$ make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- menuconfig
&lt;/code>&lt;/pre>
&lt;p>打开配置菜单后进入第一行的 &amp;ldquo;Settings&amp;rdquo;，在 &amp;ldquo;Build Options&amp;rdquo; 节中，选中 “Build static binary (no shared libs)”，设置好后退出保存配置。&lt;/p>
&lt;p>检查 &lt;code>.config&lt;/code> 文件中是否有 &lt;code>CONFIG_STATIC=y&lt;/code> ，如果没有则手动添加。&lt;/p>
&lt;h4 id="23-编译和安装-busybox">2.3 编译和安装 busybox&lt;/h4>
&lt;pre>&lt;code class="language-bash">$ make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- -j $(nproc)
$ make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- install
&lt;/code>&lt;/pre>
&lt;p>此时源码目录 busyboxsource 下会新出现一个 &lt;code>_install&lt;/code> 目录 ，可以看到生成的东西。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ ls _install
bin linuxrc sbin usr
&lt;/code>&lt;/pre>
&lt;p>进入 &lt;code>_install&lt;/code> 目录，创建以下目录&lt;/p>
&lt;pre>&lt;code class="language-bash">$ cd _install
$ mkdir proc sys dev etc etc/init.d
$ ls
bin dev etc linuxrc proc sbin sys usr
&lt;/code>&lt;/pre>
&lt;p>然后另外再新建一个最简单的 init 的 RC 文件：&lt;/p>
&lt;pre>&lt;code class="language-bash">$ cd etc/init.d/
$ touch rcS
$ vim rcS
&lt;/code>&lt;/pre>
&lt;p>编辑该文件内容为：&lt;/p>
&lt;pre>&lt;code class="language-bash">#!/bin/sh
mount -t proc none /proc
mount -t sysfs none /sys
/sbin/mdev -s
&lt;/code>&lt;/pre>
&lt;p>然后修改 rcS 文件权限，加上可执行权限&lt;/p>
&lt;pre>&lt;code class="language-bash">$ chmod +x rcS
&lt;/code>&lt;/pre>
&lt;h4 id="24-制作文件系统">2.4 制作文件系统&lt;/h4>
&lt;p>继续在 &lt;code>_install&lt;/code> 目录下执行如下命令：&lt;/p>
&lt;pre>&lt;code class="language-bash">$ find -print0 | cpio -0oH newc | gzip -9 &amp;gt; ../rootfs.img
3276 blocks
&lt;/code>&lt;/pre>
&lt;h3 id="3-启动运行">3. 启动运行&lt;/h3>
&lt;p>创建一个新的目录，将编译好的内核 &lt;code>Image&lt;/code> 和制作好的 &lt;code>rootfs.img&lt;/code> 移动到该目录下。&lt;/p>
&lt;pre>&lt;code class="language-bash">$ mkdir riscv64-linux
$ cd riscv64-linux
$ cp ../linux-5.10.42/arch/riscv/boot/Image .
$ cp ../busybox-1.33.1/rootfs.img .
&lt;/code>&lt;/pre>
&lt;p>执行如下命令：&lt;/p>
&lt;pre>&lt;code class="language-bash">$ qemu-system-riscv64 \
-nographic -machine virt \
-kernel Image \
-initrd rootfs.img \
-append &amp;quot;root=/dev/ram rdinit=/sbin/init&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>将显示 Linux Kernel 启动流程：&lt;/p>
&lt;details>
&lt;summary>&lt;strong>点击展开&lt;/strong>&lt;/summary>
&lt;pre>&lt;code class="language-bash">OpenSBI v0.9
____ _____ ____ _____
/ __ \ / ____| _ \_ _|
| | | |_ __ ___ _ __ | (___ | |_) || |
| | | | '_ \ / _ \ '_ \ \___ \| _ &amp;lt; | |
| |__| | |_) | __/ | | |____) | |_) || |_
\____/| .__/ \___|_| |_|_____/|____/_____|
| |
|_|
Platform Name : riscv-virtio,qemu
Platform Features : timer,mfdeleg
Platform HART Count : 1
Firmware Base : 0x80000000
Firmware Size : 100 KB
Runtime SBI Version : 0.2
Domain0 Name : root
Domain0 Boot HART : 0
Domain0 HARTs : 0*
Domain0 Region00 : 0x0000000080000000-0x000000008001ffff ()
Domain0 Region01 : 0x0000000000000000-0xffffffffffffffff (R,W,X)
Domain0 Next Address : 0x0000000080200000
Domain0 Next Arg1 : 0x0000000087000000
Domain0 Next Mode : S-mode
Domain0 SysReset : yes
Boot HART ID : 0
Boot HART Domain : root
Boot HART ISA : rv64imafdcvsu
Boot HART Features : scounteren,mcounteren,time
Boot HART PMP Count : 16
Boot HART PMP Granularity : 4
Boot HART PMP Address Bits: 54
Boot HART MHPM Count : 0
Boot HART MHPM Count : 0
Boot HART MIDELEG : 0x0000000000000222
Boot HART MEDELEG : 0x000000000000b109
[ 0.000000] Linux version 5.10.42 (root@centos) (riscv64-unknown-linux-gnu-gcc (Xuantie-900 linux-5.10.4 glibc gcc Toolchain V2.8.0 B-20231018) 10.4.0, GNU ld (GNU Binutils) 2.35) #1 SMP Wed Feb 21 02:07:46 CST 2024
[ 0.000000] OF: fdt: Ignoring memory range 0x80000000 - 0x80200000
[ 0.000000] efi: UEFI not found.
[ 0.000000] Initial ramdisk at: 0x(____ptrval____) (1085440 bytes)
[ 0.000000] Zone ranges:
[ 0.000000] DMA32 [mem 0x0000000080200000-0x0000000087ffffff]
[ 0.000000] Normal empty
[ 0.000000] Movable zone start for each node
[ 0.000000] Early memory node ranges
[ 0.000000] node 0: [mem 0x0000000080200000-0x0000000087ffffff]
[ 0.000000] Initmem setup node 0 [mem 0x0000000080200000-0x0000000087ffffff]
[ 0.000000] software IO TLB: Cannot allocate buffer
[ 0.000000] SBI specification v0.2 detected
[ 0.000000] SBI implementation ID=0x1 Version=0x9
[ 0.000000] SBI v0.2 TIME extension detected
[ 0.000000] SBI v0.2 IPI extension detected
[ 0.000000] SBI v0.2 RFENCE extension detected
[ 0.000000] SBI v0.2 HSM extension detected
[ 0.000000] riscv: ISA extensions acdfimsuv
[ 0.000000] riscv: ELF capabilities acdfim
[ 0.000000] percpu: Embedded 17 pages/cpu s32360 r8192 d29080 u69632
[ 0.000000] Built 1 zonelists, mobility grouping on. Total pages: 31815
[ 0.000000] Kernel command line: root=/dev/ram rdinit=/sbin/init
[ 0.000000] Dentry cache hash table entries: 16384 (order: 5, 131072 bytes, linear)
[ 0.000000] Inode-cache hash table entries: 8192 (order: 4, 65536 bytes, linear)
[ 0.000000] Sorting __ex_table...
[ 0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off
[ 0.000000] Memory: 108240K/129024K available (7084K kernel code, 3993K rwdata, 4096K rodata, 223K init, 342K bss, 20784K reserved, 0K cma-reserved)
[ 0.000000] Virtual kernel memory layout:
[ 0.000000] fixmap : 0xffffffcefee00000 - 0xffffffceff000000 (2048 kB)
[ 0.000000] pci io : 0xffffffceff000000 - 0xffffffcf00000000 ( 16 MB)
[ 0.000000] vmemmap : 0xffffffcf00000000 - 0xffffffcfffffffff (4095 MB)
[ 0.000000] vmalloc : 0xffffffd000000000 - 0xffffffdfffffffff (65535 MB)
[ 0.000000] lowmem : 0xffffffe000000000 - 0xffffffe007e00000 ( 126 MB)
[ 0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
[ 0.000000] rcu: Hierarchical RCU implementation.
[ 0.000000] rcu: RCU restricting CPUs from NR_CPUS=8 to nr_cpu_ids=1.
[ 0.000000] rcu: RCU debug extended QS entry/exit.
[ 0.000000] Tracing variant of Tasks RCU enabled.
[ 0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 jiffies.
[ 0.000000] rcu: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=1
[ 0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0
[ 0.000000] riscv-intc: 64 local interrupts mapped
[ 0.000000] plic: plic@c000000: mapped 53 interrupts with 1 handlers for 2 contexts.
[ 0.000000] random: get_random_bytes called from start_kernel+0x31a/0x48c with crng_init=0
[ 0.000000] riscv_timer_init_dt: Registering clocksource cpuid [0] hartid [0]
[ 0.000000] clocksource: riscv_clocksource: mask: 0xffffffffffffffff max_cycles: 0x24e6a1710, max_idle_ns: 440795202120 ns
[ 0.000150] sched_clock: 64 bits at 10MHz, resolution 100ns, wraps every 4398046511100ns
[ 0.003557] Console: colour dummy device 80x25
[ 0.008887] printk: console [tty0] enabled
[ 0.012368] Calibrating delay loop (skipped), value calculated using timer frequency.. 20.00 BogoMIPS (lpj=40000)
[ 0.012666] pid_max: default: 32768 minimum: 301
[ 0.014227] Mount-cache hash table entries: 512 (order: 0, 4096 bytes, linear)
[ 0.014306] Mountpoint-cache hash table entries: 512 (order: 0, 4096 bytes, linear)
[ 0.040922] rcu: Hierarchical SRCU implementation.
[ 0.042741] EFI services will not be available.
[ 0.044926] smp: Bringing up secondary CPUs ...
[ 0.045062] smp: Brought up 1 node, 1 CPU
[ 0.054128] devtmpfs: initialized
[ 0.061463] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns
[ 0.061753] futex hash table entries: 256 (order: 2, 16384 bytes, linear)
[ 0.067460] NET: Registered protocol family 16
[ 0.131233] vgaarb: loaded
[ 0.132530] SCSI subsystem initialized
[ 0.134485] usbcore: registered new interface driver usbfs
[ 0.134834] usbcore: registered new interface driver hub
[ 0.135035] usbcore: registered new device driver usb
[ 0.150024] clocksource: Switched to clocksource riscv_clocksource
[ 0.167109] NET: Registered protocol family 2
[ 0.168330] IP idents hash table entries: 2048 (order: 2, 16384 bytes, linear)
[ 0.172076] tcp_listen_portaddr_hash hash table entries: 128 (order: 0, 5120 bytes, linear)
[ 0.172242] TCP established hash table entries: 1024 (order: 1, 8192 bytes, linear)
[ 0.172480] TCP bind hash table entries: 1024 (order: 3, 32768 bytes, linear)
[ 0.172690] TCP: Hash tables configured (established 1024 bind 1024)
[ 0.173861] UDP hash table entries: 256 (order: 2, 24576 bytes, linear)
[ 0.174481] UDP-Lite hash table entries: 256 (order: 2, 24576 bytes, linear)
[ 0.175963] NET: Registered protocol family 1
[ 0.179024] RPC: Registered named UNIX socket transport module.
[ 0.179111] RPC: Registered udp transport module.
[ 0.179150] RPC: Registered tcp transport module.
[ 0.179186] RPC: Registered tcp NFSv4.1 backchannel transport module.
[ 0.179332] PCI: CLS 0 bytes, default 64
[ 0.182716] Unpacking initramfs...
[ 0.263706] Freeing initrd memory: 1056K
[ 0.265678] workingset: timestamp_bits=62 max_order=15 bucket_order=0
[ 0.281052] NFS: Registering the id_resolver key type
[ 0.282003] Key type id_resolver registered
[ 0.282074] Key type id_legacy registered
[ 0.282505] nfs4filelayout_init: NFSv4 File Layout Driver Registering...
[ 0.282631] nfs4flexfilelayout_init: NFSv4 Flexfile Layout Driver Registering...
[ 0.283481] 9p: Installing v9fs 9p2000 file system support
[ 0.284918] NET: Registered protocol family 38
[ 0.285416] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 251)
[ 0.285593] io scheduler mq-deadline registered
[ 0.285692] io scheduler kyber registered
[ 0.295484] pci-host-generic 30000000.pci: host bridge /soc/pci@30000000 ranges:
[ 0.296336] pci-host-generic 30000000.pci: IO 0x0003000000..0x000300ffff -&amp;gt; 0x0000000000
[ 0.296861] pci-host-generic 30000000.pci: MEM 0x0040000000..0x007fffffff -&amp;gt; 0x0040000000
[ 0.296961] pci-host-generic 30000000.pci: MEM 0x0400000000..0x07ffffffff -&amp;gt; 0x0400000000
[ 0.299940] pci-host-generic 30000000.pci: ECAM at [mem 0x30000000-0x3fffffff] for [bus 00-ff]
[ 0.301083] pci-host-generic 30000000.pci: PCI host bridge to bus 0000:00
[ 0.301328] pci_bus 0000:00: root bus resource [bus 00-ff]
[ 0.301486] pci_bus 0000:00: root bus resource [io 0x0000-0xffff]
[ 0.301528] pci_bus 0000:00: root bus resource [mem 0x40000000-0x7fffffff]
[ 0.301568] pci_bus 0000:00: root bus resource [mem 0x400000000-0x7ffffffff]
[ 0.302864] pci 0000:00:00.0: [1b36:0008] type 00 class 0x060000
[ 0.377412] Serial: 8250/16550 driver, 4 ports, IRQ sharing disabled
[ 0.389894] 10000000.uart: ttyS0 at MMIO 0x10000000 (irq = 2, base_baud = 230400) is a 16550A
[ 0.428017] printk: console [ttyS0] enabled
[ 0.430410] [drm] radeon kernel modesetting enabled.
[ 0.457312] loop: module loaded
[ 0.460726] libphy: Fixed MDIO Bus: probed
[ 0.464996] e1000e: Intel(R) PRO/1000 Network Driver
[ 0.465383] e1000e: Copyright(c) 1999 - 2015 Intel Corporation.
[ 0.466272] ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver
[ 0.466724] ehci-pci: EHCI PCI platform driver
[ 0.467203] ehci-platform: EHCI generic platform driver
[ 0.467683] ohci_hcd: USB 1.1 'Open' Host Controller (OHCI) Driver
[ 0.468129] ohci-pci: OHCI PCI platform driver
[ 0.468593] ohci-platform: OHCI generic platform driver
[ 0.469968] usbcore: registered new interface driver uas
[ 0.470477] usbcore: registered new interface driver usb-storage
[ 0.471603] mousedev: PS/2 mouse device common for all mice
[ 0.475055] goldfish_rtc 101000.rtc: registered as rtc0
[ 0.476070] goldfish_rtc 101000.rtc: setting system clock to 2024-02-20T19:37:51 UTC (1708457871)
[ 0.478889] syscon-poweroff soc:poweroff: pm_power_off already claimed (____ptrval____) sbi_shutdown
[ 0.479494] syscon-poweroff: probe of soc:poweroff failed with error -16
[ 0.480977] usbcore: registered new interface driver usbhid
[ 0.481324] usbhid: USB HID core driver
[ 0.483516] NET: Registered protocol family 10
[ 0.491589] Segment Routing with IPv6
[ 0.492256] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver
[ 0.495528] NET: Registered protocol family 17
[ 0.497086] 9pnet: Installing 9P2000 support
[ 0.497667] Key type dns_resolver registered
[ 0.498706] debug_vm_pgtable: [debug_vm_pgtable ]: Validating architecture page table helpers
[ 0.533266] Freeing unused kernel memory: 220K
[ 0.539682] Run /sbin/init as init process
Please press Enter to activate this console.
&lt;/code>&lt;/pre>
&lt;/details>
&lt;p>见到 &lt;code>&amp;quot;Please press Enter to activate this console.&amp;quot;&lt;/code> 提示后直接回车，无需密码就进入系统了。&lt;/p>
&lt;p>执行几个常用命令测试一下，都能正常工作：&lt;/p>
&lt;pre>&lt;code class="language-bash">/ # ls
bin etc proc sbin usr
dev linuxrc root sys
/ # pwd
/
/ # cd bin
/bin #
/ # ls
arch dumpkmap kill netstat setarch
ash echo link nice setpriv
base32 ed linux32 nuke setserial
base64 egrep linux64 pidof sh
busybox false ln ping sleep
cat fatattr login ping6 stat
chattr fdflush ls pipe_progress stty
chgrp fgrep lsattr printenv su
chmod fsync lzop ps sync
chown getopt makemime pwd tar
conspy grep mkdir reformime touch
cp gunzip mknod resume true
cpio gzip mktemp rev umount
cttyhack hostname more rm uname
date hush mount rmdir usleep
dd ionice mountpoint rpm vi
df iostat mpstat run-parts watch
dmesg ipcalc mt scriptreplay zcat
dnsdomainname kbd_mode mv sed
/bin #
&lt;/code>&lt;/pre>
&lt;p>退出 QEMU 的方法是按下 &lt;code>Ctrl + A&lt;/code> ，松开后再按下 &lt;code>x&lt;/code> 键即可退出 QEMU 。&lt;/p>
&lt;p>如果想要往 QEMU 里面传输文件，可以使用挂载的方式，如下所示：&lt;/p>
&lt;pre>&lt;code class="language-bash">$ mkdir rootfs
$ sudo mount -o loop rootfs.img rootfs
$ cp [-r] [file] ./rootfs/
$ sudo umount rootfs
&lt;/code>&lt;/pre>
&lt;h2 id="五总结">五、总结&lt;/h2>
&lt;p>至此，我们已经成功搭建了玄铁 900 系列的工具链环境以及 xuantie-qemu 仿真环境，这为后续的开发、编译、链接以及运行和调试基于玄铁 900 系列芯片的 RISC-V 应用程序奠定了基础。&lt;/p></description></item></channel></rss>