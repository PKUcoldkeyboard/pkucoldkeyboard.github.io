<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on cuterwrite (Pang S.Z)</title>
    <link>https://cuterwrite.top/post/</link>
    <description>Recent content in Posts on cuterwrite (Pang S.Z)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 27 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cuterwrite.top/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HashMap源码分析</title>
      <link>https://cuterwrite.top/p/hashmap/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/hashmap/</guid>
      <description>HashMap源码分析 属性   初始化容量
static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4;   最大容量
static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;   负载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;   红黑树阈值
static final int TREEIFY_THRESHOLD = 8;   链表阈值
static final int UNTREEIFY_THRESHOLD = 6;   红黑树桶阈值
static final int MIN_TREEIFY_CAPACITY = 64;   table数组，用来初始化
transient Node&amp;lt;K,V&amp;gt;[] table;   entrySet存放缓存
transient Set&amp;lt;Map.</description>
    </item>
    
    <item>
      <title>前端开发知识点复习</title>
      <link>https://cuterwrite.top/p/web-development/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/web-development/</guid>
      <description>前端开发知识点 1 Cookie、Session、SessionStorage和LocalStorage Cookie：服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地的一种纯文本文件，当下一次有同源的请求时，将保存的Cookie数据添加到请求头部，发送给服务端。可以用来实现记录用户登录状态等功能。
Session：服务器为了保存用户状态而创建的一个特殊的对象。在浏览器第一次访问服务器时，服务器会创建一个session对象,该对象有一个唯一的id,即sessionid，服务器会把sessionid以cookie的形式发送给浏览器,当浏览器再次访问服务器时,会携带cookie在请求头,可以通过cookie中的sessionid来访问session对象，可以实现在http无状态基础上实现用户状态管理。
Cookie的特点：
 Cookie数据存放在客户端上。 Cookie是非安全的，由于存在本地，有被盗取的可能。 Cookie保存的数据不能超过4K。 Cookie始终在同源的HTTP请求中携带。  如何设置Cookie：
 服务端：使用Set-Cookie的响应头部，包含5个属性值expires、 domain、path、secure和httponly，分别代表过期时间、域名、路径、安全传输、是否禁用客户端js脚本访问。 客户端：通过JS脚本，例如document.cookie  Cookie和Session和区别：
 Cookie存放在客户端，Session存放在服务端。 Cookie是非安全的，考虑安全应该使用Session 访问增多时，服务器压力比较大，考虑使用Cookie 单个Cookie保存的数据不能超过4K  Cookie、SessionStorage和LocalStorage的区别：
 Cookie始终在同源的HTTP请求中携带。（即使不需要） Cookie可以限制可访问的path 存储大小：Cookie存放数据不能超过4k，WebStorage可以达到5M或更大。 有效期不同：SessionStorage只在当前浏览器窗口关闭前有效，LocalStorage始终有效，用作持久化，Cookie在设置的过期时间之前一直有效。  Cookie常用场景：
 保持用户登录状态 跟踪用户行为，记录用户选项  2 Http和Https的区别 HTTPS基本原理：客户端使用HTTPS URL访问服务端，要去服务端建立SSL连接，服务端接收到客户端请求后，会将网站的证书（携带公钥）返回给客户端，客户端和服务端开始协商SSL连接的安全等级，也就是加密等级，然后两者通过协商一致的安全等级，建立会话密钥，然后客户端通过网站的公钥来加密会话密钥，传给网站，服务端通过自己的私钥解密出会话密钥，通过会话密钥加密与客户端的通信。
 安全性：HTTPS是安全超文本协议，在HTTP基础上有更强的安全性，简单来说，HTTPS是使用了TLS/SSL加密的HTTP协议。 申请证书：HTTPS需要使用CA证书。 传输协议：HTTP以明文形式传输数据，HTTPS以加密形式传输数据。 端口号不同：一般来说，HTTP协议的端口为80，HTTPS的端口为443 连接方式：HTTP的连接简单，是无状态的，HTTPS在HTTP的基础上使用了SSL协议进行加密传输。  3 Http2.0的特性  提升了访问速度 允许多路复用：允许同时通过单一的HTTP/2连接发送多重请求-响应信息。 二进制分帧：将所有的传输数据分割为更小的数据帧，并对它们进行二进制编码。 首部压缩 服务器端推送  4 OSI七层模型  应用层：文件传输，常用协议HTTP、STMP、FTP 表示层：数据格式化、代码转换、数据加密 会话层：建立和解除会话 传输层：提供端对端的接口，TCP/UDP 网络层：为数据包选择路由，IP/ICMP 数据链路层：传输带有地址的帧。 物理层：二进制的数据形式在物理媒体上传输数据。  5 TCP和UDP的区别  TCP是面向连接的，UDP是无连接的，即发送数据前不需要先建立连接。 TCP提供可靠的服务，无差错、不丢失、不重复、按序到达，UDP尽最大努力交付。（大数据量使用TCP） TCP面向字节流，UDP面向报文。（UDP无拥塞控制，可能出现丢包） TCP只能1对1，UDP支持1对1和1对多。 TCP首部较大为20字节，UDP只有8字节。  6 TCP三次握手和四次挥手 TCP三次握手：（A为客户端，B为服务端）</description>
    </item>
    
    <item>
      <title>计算机基础知识点总结</title>
      <link>https://cuterwrite.top/p/interview-help/</link>
      <pubDate>Thu, 22 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/interview-help/</guid>
      <description>一、操作系统 1、进程与线程的区别   进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；
  线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的 实时性，实现进程内部的并发；
  一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；
  进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。
  2、进程间的通信的几种方式  管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信； 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生； 消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息； 共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等； 信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段； 套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。  3、线程同步的方式  互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问 信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作  4、进程同步的方式  临界区：对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。 同步与互斥 信号量 管程：有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。  5、死锁 1、死锁的定义 在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。
2、死锁必要条件  互斥：每个资源要么已经分配给了一个进程，要么就是可用的。 占有和等待：已经得到了某个资源的进程可以再请求新的资源。 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。  3、死锁处理   鸵鸟策略：把头埋在沙子里，假装根本没发生问题。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。
  死锁检测与死锁恢复：不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。
 每种类型一个资源的死锁检测：通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。 每种类型多个资源的死锁检测：每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。  寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。 如果没有这样一个进程，算法终止。      死锁恢复：在程序运行之前预防发生死锁。</description>
    </item>
    
    <item>
      <title>自动上传脚本测试</title>
      <link>https://cuterwrite.top/p/update-util/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/update-util/</guid>
      <description>测试</description>
    </item>
    
    <item>
      <title>Redis入门</title>
      <link>https://cuterwrite.top/p/redis-1/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/redis-1/</guid>
      <description>1、命令返回值 2、多数据库 3、命令大全  1、通用命令  keys pattern exists key del key type key   2、字符串类型  简介 set key value / get key incr key incrby key increment decr key decrby key decrement incrbyfloat key increment append key value strlen key mget key / mset key1 value1 &amp;hellip; 位操作 使用场景   3、hash类型  简介 hset key field value hget key field hmset key field value hmget key field hgetall key hexists key field hsetnx key field value hincrby key field increment hdel key field 其他命令 使用场景   4、list类型  简介 lpush key value1&amp;hellip; rpush key value1&amp;hellip; lpop key rpop key llen key lrange key start stop lrem key count value lindex key index lset key index value ltrim key start end linsert key before|after pivot value rpoplpush source destination 使用场景   5、set类型  简介 sadd key member srem key member smembers sismember key member sdiff key1 key2 &amp;hellip; sinter key1 key2&amp;hellip; sunion key1 key2&amp;hellip; scard key sdiffstore/sinterstore/sunionstore destination key1 key2&amp;hellip; srandmember key count spop 使用场景   6、zset类型  简介 zadd key score member zscore key member zrange key start stop [withscores] zrangebyscore key min max [withscores] limit offset count zrevrangebyscore key max min [withscores] limit offset count zincrby key increment member zcard key zcount key min max zrem key member1 &amp;hellip; zremrangebyranke key start stop zremrangebyscore key min max zrank key member zrevrank key member      1、命令返回值  状态回复  OK：成功 PONG：响应PING   错误回复：命令不存在或者命令格式有误  Error Unknown command   整数回复：  INCR命令：返回递增后的键值 DBSIZE命令：返回键的数量   字符串回复：  请求键的值或者请求一个其他类型键中的某个元素   多行字符串回复：  请求非字符串类型键的元素列表 Keys (Pattern)：返回数据库中符合指定规则的键名    2、多数据库  一个Redis实例提供了多个用来存储数据的字典，客户端可以指定数据存储在哪个字典中。 数据库默认从0开始递增命名，默认支持16个数据库（DB0，DB1，&amp;hellip;，DB15） 不支持自定义数据库名字，也不支持单独设置访问密码  3、命令大全 1、通用命令 keys pattern 获得符合规则的键名列表，支持？、*、[]、\x四种通配符</description>
    </item>
    
    <item>
      <title>Spring Cloud Alibaba笔记</title>
      <link>https://cuterwrite.top/p/spring-cloud-alibaba-1/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/spring-cloud-alibaba-1/</guid>
      <description>Spring Cloud alibaba笔记  SOA与微服务的区别： Spring Cloud Alibaba与Spring Cloud Netflix的对比 什么是Spring Boot？ IOC/DI（控制反转与依赖注入） Spring发展过程 自动装配的实现 手写实现一个Starter  1 Starter的功能 2 Starter的命名规范 3 实现基于Redis的Starter   Apache Dubbo Zookeeper Dubbo集成Zookeeper  1 需要解决的问题 2 实现步骤 3 原理 4 实战Dubbo Spring Cloud   Dubbo的高级应用  1 集群容错 2 负载均衡 3 服务降级   主机绑定规则 Dubbo源码分析  1 核心点 2 生成IDE工程的命令 3 SPI(Service Provider Interface) 4 Dubbo中的SPI思想 5 Dubbo中的SPI原理 6 自适应扩展点 7 Protocol自适应扩展点源码 8 IOC 9 AOP 10 Dubbo集成Spring机制（略）   什么是Nacos？  1 关键特性 2 Nacos集群   搭建Nacos注册中心的注意点 Nacos实现原理  1 模块组成 2 注册中心的原理 3 Nacos源码（略）   Nacos实现统一配置管理  1 Nacos集成Spring Boot 2 Nacos集成Spring Cloud 3 动态更新配置 4 基于DataID配置yaml的文件扩展名 5 不同环境的配置切换 6 自定义Namespace和Group   Nacos Config实现原理（略） Spring Cloud加载配置的原理（略） Nacos源码（略） Sentinel限流及熔断  1 服务限流的作用及实现 2 服务熔断和降级 3 Sentinel的特性 4 Sentinel的组成： 5 Sentinel基本应用： 6 Sentinel资源保护规则  1 QPS流量控制行为   7 Sentinel实现服务熔断   Sentinel集成Spring Cloud 基于Sentinel Dashboard来实现流控配置 Sentinel自定义URL限流异常 Sentinel对URL资源清洗 Sentinel集成Nacos实现动态流控规则 Sentinel集成Nacos实现规则同步  1 Sentinel Dashboard源码修改： 2 Sentinel Dashboard规则同步   Sentinel集成Dubbo实现限流  1 Dubbo服务接入Sentinel Dashboard 2 Dubbo服务限流规则   Sentinel热点限流  1 热点参数限流的使用 2 @SentinelResource 3 热点参数规则说明   Sentinel的工作原理（略） Spring Cloud Sentinel工作原理（略） Sentinel核心源码分析（略）  1 限流的源码实现 2 实时指标数据统计 3 服务降级的实现原理   什么是分布式事务？  1 分布式事务问题的理论模型  1 X/Open分布式模型 2 两阶段提交协议 3 三阶段提交协议 4 CAP定理和BASE理论   2 分布式事务问题的常见解决方案  1 TCC补偿性方案 2 基于可靠性消息的最终一致性方案 3 最大努力通知型   3 分布式事务框架Seata  1 AT模式 2 Saga模式        Spring Cloud alibaba笔记 SOA与微服务的区别：  SOA关注的是服务的重用性及解决信息孤岛问题 微服务关注的是解耦，虽然解耦和可重用性从特定的角度来看是一样的，但本质上是有区别的，解耦是降低业务之间的耦合度，而重用性关注的是服务的复用。 微服务会更多地关注在DevOps的持续交付上，因为服务粒度细化之后使得开发运维变得更加重要，因此微服务与容器化技术的结合更加紧密。  Spring Cloud Alibaba与Spring Cloud Netflix的对比  Alibaba开源组件在没有织入Spring Cloud生态之前，已经在各大公司广泛应用，所以容易实现技术整合及迁移。 Alibaba开源组件在服务治理上和处理高并发的能力上有天然的优势。  什么是Spring Boot？ 帮助开发者快速构建一个基于Spring Framework及Spring生态体系的应用解决方案，也是对于“约定优于配置”理念的最佳实践。</description>
    </item>
    
  </channel>
</rss>
