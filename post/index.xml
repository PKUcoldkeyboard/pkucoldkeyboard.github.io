<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on cuterwrite (Pang S.Z)</title>
    <link>https://cuterwrite.top/post/</link>
    <description>Recent content in Posts on cuterwrite (Pang S.Z)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 31 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cuterwrite.top/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>路径规划算法之A* 与D* Lite原理详解</title>
      <link>https://cuterwrite.top/p/route-planning-alogrithm/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/route-planning-alogrithm/</guid>
      <description>Table of Contents generated with DocToc
 路径规划算法之A* 与D* Lite原理详解  问题描述 基础算法介绍 广度优先搜索 最佳优先算法 Dijkstra算法 A* 算法 A* 算法变种 D* Lite算法 参考文献    路径规划算法之A* 与D* Lite原理详解 问题描述 如何在一个网格地图中找到两点之间的最短路径
基础算法介绍 如果要在一个网格地图中找到两点之间的最短路径，很容易想到的广度优先算法（Breadth First）、最佳优先算法和Dijkstra算法。
广度优先搜索 广度优先搜索算法如其名称所示以广度做为优先级进行搜索。
从起点开始，首先遍历起点周围邻近的点，然后再遍历已经遍历过的点邻近的点，逐步的向外扩散，直到找到终点。
这种算法就像洪水（Flood fill）一样向外扩张，算法的过程如下图所示：
广度优先算法的优点是一定可以找到两点间的最优路径，但是代价就是需要搜索的点非常多，速度会比较慢。
最佳优先算法 在一些情况下，如果我们可以预先计算出每个节点到终点的距离，则我们可以利用这个信息更快的到达终点。
最佳优先算法和广度优先算法不同，它需要使用一个优先队列，用每个节点到终点的距离作为优先级每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点，直到到达终点。这种算法称之为最佳优先（Best First）算法。和广度优先相比，最佳优先所需要搜索的点要少很多，可以大大加快路径的搜索速度，如下图所示：
但最佳优先算法的缺点就是，当起点和终点有障碍物时，可能最佳优先算法找到的路径并不是最佳的路径，下图描述了这种情况：
Dijkstra算法 Dijkstra算法是由计算机科学家Edsger W. Dijkstra在1956年提出的
Dijkstra算法用来寻找图形中节点之间的最短路径。
考虑这样一种场景，在一些情况下，图形中相邻节点之间的移动代价并不相等。例如，游戏中的一幅图，既有平地也有山脉，那么游戏中的角色在平地和山脉中移动的速度通常是不相等的。
在Dijkstra算法中，需要计算每一个节点距离起点的总移动代价。同时，还需要一个优先队列结构。对于所有待遍历的节点，放入优先队列中会按照代价进行排序。
在算法运行的过程中，每次都从优先队列中选出代价最小的作为下一个遍历的节点。直到到达终点为止。
下面对比了不考虑节点移动代价差异的广度优先搜索与考虑移动代价的Dijkstra算法的运算结果：
 当图形为网格图，并且每个节点之间的移动代价是相等的，那么Dijkstra算法将和广度优先算法变得一样。
 A* 算法 A* 算法最初发表于1968年，由Stanford研究院的Peter Hart, Nils Nilsson以及Bertram Raphael发表。它可以被认为是Dijkstra算法的扩展。
由于借助启发函数的引导，A*算法通常拥有更好的性能。
A* 算法通过下面这个函数来计算每个节点的优先级。 $$ f(n) = g(n) + h(n) $$ 其中：</description>
    </item>
    
    <item>
      <title>聊聊前缀树Trie</title>
      <link>https://cuterwrite.top/p/trie/</link>
      <pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/trie/</guid>
      <description>Table of Contents generated with DocToc
 聊聊前缀树Trie  Trie树简介 Trie树特点  Trie树的插入操作 Trie树的查询操作 Trie树的删除操作   Trie树应用与实现  前缀匹配/自动补全 字符串检索 动态路由   Trie树的局限性    聊聊前缀树Trie Trie树简介 Trie 树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。
此外 Trie 树也称前缀树（因为某节点的后代存在共同的前缀，比如pan是panda的前缀）。
它的key都为字符串，能做到高效查询和插入，时间复杂度为O(k)，k为字符串长度，缺点是如果大量字符串没有共同前缀时很耗内存。
它的核心思想就是通过最大限度地减少无谓的字符串比较，使得查询高效率，即「用空间换时间」，再利用共同前缀来提高查询效率。
Trie树特点 假设有 5 个字符串，它们分别是：code，cook，five，file，fat。现在需要在里面多次查找某个字符串是否存在。常见的方案有：①如果每次查找，都是拿要查找的字符串跟这 5 个字符串依次进行字符串匹配，时间复杂度为O(n)。②将字符串存入HashSet中，查找的时候时间复杂度为O(1)，但是缺点是空间复杂度高，假如有大量的字符串（比如10亿条）则会浪费大量的空间。
Trie树则通过空间换时间的方式，将字符串组织成下图的结构：
通过上图，可以发现 Trie树 的三个特点：
 根节点不包含字符，除根节点外每一个节点都只包含一个字符 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串 每个节点的所有子节点包含的字符都不相同  Trie树的插入操作 Trie树的插入操作很简单，其实就是将单词的每个字母逐一插入 Trie树。插入前先看字母对应的节点是否存在，存在则共享该节点，不存在则创建对应的节点。比如要插入新单词cook，就有下面几步：
 插入第一个字母 c，发现 root 节点下方存在子节点 c，则共享节点 c 插入第二个字母 o，发现 c 节点下方存在子节点 o，则共享节点 o 插入第三个字母 o，发现 o 节点下方不存在子节点 o，则创建子节点 o 插入第三个字母 k，发现 o 节点下方不存在子节点 k，则创建子节点 k 至此，单词 cook 中所有字母已被插入 Trie树 中，然后设置节点 k 中的标志位，标记路径 root-&amp;gt;c-&amp;gt;o-&amp;gt;o-&amp;gt;k这条路径上所有节点的字符可以组成一个单词cook  Trie树的查询操作 在 Trie 树中查找一个字符串的时候，比如查找字符串 code，可以将要查找的字符串分割成单个的字符 c，o，d，e，然后从 Trie 树的根节点开始匹配。如图所示，绿色的路径就是在 Trie 树中匹配的路径</description>
    </item>
    
    <item>
      <title>Spring Cloud OAuth2从零开始实现用户认证和单点登录</title>
      <link>https://cuterwrite.top/p/oauth2-guide/</link>
      <pubDate>Thu, 15 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/oauth2-guide/</guid>
      <description>Table of Contents generated with DocToc
 Spring Cloud OAuth2从零开始实现用户认证和单点登录  OAuth2 是什么 OAuth2的使用场景 OAuth2实现统一认证功能  创建并配置认证服务端auth-server  1、引入需要的Maven包 2、配置bootstrap.yml和Nacos配置 3、配置Spring Security 4、实现UserDetailsService 5、配置OAuth2 6、配置JWTTokenStore 7、启动auth-server        Spring Cloud OAuth2从零开始实现用户认证和单点登录 OAuth2 是什么 OAuth2 其实是一个关于授权的网络标准，它制定了设计思路和运行流程，利用这个标准我们其实是可以自己实现 OAuth2 的认证过程的。 spring-cloud-starter-oauth2 是 Spring Cloud 按照 OAuth2 的标准并结合 spring-security 封装好的一个具体实现。
OAuth 2 有四种授权模式，分别是授权码模式（authorization code）、简化模式（implicit）、密码模式（resource owner password credentials）、客户端模式（client credentials），具体 OAuth2 是什么，可以参考这篇文章（http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html）。
OAuth2的使用场景  典型的OAuth2使用场景：微信登录、QQ登录、微博登录、Google帐号登录、Github帐号登录等。第一次使用就无需注册，直接通过第三方平台授权登录即可，大大提高了使用效率。此外，服务不需要存储用户的密码，只需要存储认证平台返回的唯一ID和用户信息即可。 不使用OAuth2的场景：用户需要先完成注册，然后用注册号的帐号密码或者用手机验证码登录。  OAuth2实现统一认证功能 创建并配置认证服务端auth-server 认证服务端负责验证帐号、密码、存储Token、检查Token、刷新Token等。
1、引入需要的Maven包 2、配置bootstrap.</description>
    </item>
    
    <item>
      <title>机器学习重要术语词汇表</title>
      <link>https://cuterwrite.top/p/machine-learning-terms/</link>
      <pubDate>Thu, 15 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/machine-learning-terms/</guid>
      <description>Table of Contents generated with DocToc
 机器学习重要术语词汇表  精确度Accuracy 曲线下面积 (AUC) 二元分类 校准 分类 决定系数 特征工程 F-score 超参数 Label 对数损失 损失函数 平均绝对误差 (MAE) 多类分类 N 元语法 标准化 管道 Precision Recall 正则化 回归 相对绝对误差 相对平方误差 均方误差根 (RMSE)    机器学习重要术语词汇表 精确度Accuracy 在分类中，准确性是正确分类的项数目除以测试集内的项总数。 范围从 0（最不准确）到 1（最准确）。 准确性是模型性能的评估指标之一。 将其与Precision、Recall和F-score结合考虑。
曲线下面积 (AUC) 二元分类的一项评估指标，即曲线下面积值，它绘制真阳性率（y 轴）与误报率（x 轴）进行对照。 范围从 0.5（最差）到 1（最佳）。 也称为 ROC 曲线下面积。
二元分类 一个分类任务，其中标签仅为两个类中的一个。
校准 校准是将原始分数映射到类成员身份的过程，用于二元和多类分类。
分类 当使用这些数据来预测某一类别，有监督学习任务被称为“分类”。 二分类指的是仅预测两个类别（例如，将图像划分为“猫”或“狗”图片）。 多分类指的是预测多个类别（例如，当将图像划分为特定品种狗的图片）。
决定系数 回归中的一项评估指标，表明数据与模型的匹配程度。 范围从 0 到 1。 值 0 表示数据是随机的，否则就无法与模型相匹配。 1 表示模型与数据完全匹配。 这通常称 r 平方值。</description>
    </item>
    
    <item>
      <title>Java-Stream常见用法</title>
      <link>https://cuterwrite.top/p/java-stream/</link>
      <pubDate>Tue, 11 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/java-stream/</guid>
      <description>Table of Contents generated with DocToc
 Stream常见用法  1 Stream概述 2 Stream创建  2.1 Collection.stream() 2.2 Arrays.stream(T[] array) 2.3 Stream.of / iterate / generate   3 Stream使用  3.1 Optional 3.2 遍历 forEach/find/match 3.3 筛选 filter 3.4 聚合 max/min/count 3.5 映射 map/flatMap 3.6 规约 reduce 3.7 收集 collect 3.8 分组 groupingBy/partitioningBy 3.9 连接 joining 3.10 排序 sorted       Stream常见用法 1 Stream概述 Stream将要处理的元素集合看作一种流，在流的过程中，借助Stream API对流中的元素进行操作，比如：筛选、排序、聚合等。</description>
    </item>
    
    <item>
      <title>JavaSE知识点笔记</title>
      <link>https://cuterwrite.top/p/java-se/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/java-se/</guid>
      <description>Table of Contents generated with DocToc
 JavaSE知识点笔记  1 数据类型  1.1 基本类型 1.2 包装类型 1.3 缓存池   2 String  2.1 概述 2.2 不可变的优点  2.2.1 可以缓存hash值 2.2.2 String Pool 2.2.3 安全性 2.2.4 线程安全   2.3 String、StringBuilder和StringBuffer  2.3.1 可变性 2.3.2 线程安全   2.4 String Pool 2.5 new String（“abc”）   3 运算  3.1 参数传递 3.2 float与double 3.3 隐式类型转换   4 关键字  4.</description>
    </item>
    
    <item>
      <title>Java容器知识点笔记</title>
      <link>https://cuterwrite.top/p/java-collection/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/java-collection/</guid>
      <description>Table of Contents generated with DocToc
 Java容器知识点笔记  1 概述  1.1 Collection  1.1.1 Set 1.1.2 List 1.1.3 Queue     2 源码分析  2.1 ArrayList  2.1.1 概述 2.1.2 扩容 2.1.3 删除元素 2.1.4 序列化 2.1.5 Fail-fast   2.2 Vector  2.2.1 同步 2.2.2 扩容 2.2.3 与ArrayList的比较 2.2.4 替代方案   2.3 CopyOnWriteArrayList  2.3.1 读写分离 2.3.2 适用场景   2.4 LinkedList  2.4.1 概述 2.</description>
    </item>
    
    <item>
      <title>Java并发知识点笔记</title>
      <link>https://cuterwrite.top/p/java-concurrent/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/java-concurrent/</guid>
      <description>Table of Contents generated with DocToc
 Java并发知识点笔记  1 使用线程的方法 2 基础线程机制  2.1 Executor 2.2 Daemon 2.3 sleep() 2.4 yield()   3 线程中断  3.1 InterruptedException 3.2 interrupted() 3.3 Executor 的中断操作   4 互斥锁  4.1 synchronized 4.2 ReentrantLock 4.3 比较 4.4 选择   5 线程协作  5.1 join 5.2 wait/notify 5.3 await/signal   6 线程状态 7 JUC包/AQS  7.1 CountDownLatch 7.2 CyclicBarrier 7.3 Semaphore   8 JUC包其它组件  8.</description>
    </item>
    
    <item>
      <title>JVM知识点笔记</title>
      <link>https://cuterwrite.top/p/jvm/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/jvm/</guid>
      <description>Table of Contents generated with DocToc
 JVM知识点笔记  1 运行时数据区域  1.1 程序计数器 1.2 Java虚拟机栈 1.3 本地方法栈 1.4 堆 1.5 方法区 1.6 运行时常量池 1.7 直接内存   2 垃圾收集  2.1 判断一个对象是否可回收  2.1.1 引用计数算法 2.1.2 可达性分析算法 2.1.3 方法区的回收 2.1.4 finalize()   2.2 引用类型  2.2.1 强引用 2.2.2 软引用 2.2.3 弱引用 2.2.4 虚引用   2.3 垃圾收集算法  2.3.1 标记 - 清除 2.3.2 标记-整理 2.3.3 复制 2.3.4 分代收集   2.</description>
    </item>
    
    <item>
      <title>Socket与IO模型</title>
      <link>https://cuterwrite.top/p/io-model/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/io-model/</guid>
      <description>Table of Contents generated with DocToc
 Socket与IO模型  1 IO模型  1.1 阻塞式IO 1.2 非阻塞式IO 1.3 IO复用 1.4 信号驱动IO 1.5 异步IO 1.6 IO模型对比   2 IO复用  2.1 select 2.2 poll 2.3 epoll 2.4 LT与ET 2.5 select、poll、epoll对比      Socket与IO模型 1 IO模型 1.1 阻塞式IO 应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。
应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。
1.2 非阻塞式IO 应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。
由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。
1.3 IO复用 使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</description>
    </item>
    
    <item>
      <title>计算机基础知识点总结（数据库系统 &#43; MySQL &#43; Redis）</title>
      <link>https://cuterwrite.top/p/database-system/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/database-system/</guid>
      <description>Table of Contents generated with DocToc
 一、数据库系统原理  1 事务  1.1 概念 1.2 ACID 1.3 AUTOCOMMIT   2 并发一致性问题  2.1 丢失修改 2.2 读脏数据 2.3 不可重复读 2.4 幻影读   3 封锁  3.1 封锁粒度 3.2 封锁类型  3.2.1 读写锁 3.2.2 意向锁   3.3 封锁协议  3.3.1 三级封锁协议 3.3.2 二段锁协议   3.4 MySQL隐式与显示锁定   4 隔离级别  4.1 未提交读 4.2 提交读 4.3 可重复读 4.4 可串行化   5 多版本并发控制  5.</description>
    </item>
    
    <item>
      <title>ArrayList源码分析</title>
      <link>https://cuterwrite.top/p/arraylist-source-code/</link>
      <pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/arraylist-source-code/</guid>
      <description>Table of Contents generated with DocToc
 ArrayList源码分析  1 简介  1.1 ArrayList和Vector的区别 1.2 ArrayList和LinkedList的区别   2 核心源码分析  2.1 属性 2.2 构造函数 2.3 扩容机制  2.3.1 add方法 2.3.2 ensureCapacityInternal方法 2.3.3 ensureExplicitCapacity 2.3.4 grow方法 2.3.5 hugeCapacity方法   2.4 拷贝机制 2.5 ensureCapacity方法      ArrayList源码分析 1 简介 底层：Object[]，容量能动态增长。在添加大量元素前，会先调用ensureCapacity来增加ArrayList的容量，可以减少递增再分配的次数。
ArrayList继承了AbstractList，实现了List，RandomAccess，Cloneable，Serializable等接口。
 RandomAccess：标志接口，接口体是空的，只是用来表明ArrayList是支持快速随机访问的。 Cloneable：能被克隆 Serializable：可序列化  1.1 ArrayList和Vector的区别 底层都是Object[]，但是ArrayList线程不安全，Vector线程安全。
1.2 ArrayList和LinkedList的区别  线程安全：ArrayList和LinkedList都是线程不安全的。 底层数据结构：ArrayList是Object[]，LinkedList底层是双向链表。 插入和删除：ArrayList插入和删除元素的时间复杂度受元素位置的影响，为O(n - i)；LinkedList的插入和删除元素的时间复杂度不受插入元素位置的影响，都近似于O(1)，但如果在指定位置插入和删除，需要先移动到指定位置再执行操作，时间复杂度近似于O(n)。 是否支持快速随机访问：ArrayList支持，LinkedList不支持。 内存空间占用：ArrayList需要在列表末尾预留一定的容量空间，LinkedList的每一个元素都需要多消耗pre和next指针的空间。  2 核心源码分析 2.</description>
    </item>
    
    <item>
      <title>实用工具和网址</title>
      <link>https://cuterwrite.top/p/useful-tool/</link>
      <pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/useful-tool/</guid>
      <description>实用工具和网址 万能工具箱  CyberChef：https://gchq.github.io/CyberChef/  在线画图工具  ProcessOn：https://www.processon.com/ Figma：https://www.figma.com/  在线解编码工具  BASE64：https://base64.supfree.net/ MD5：https://www.zxgj.cn/g/md5 AES/DES：http://www.fly63.com/tool/cipher/ JWT：http://jwt.calebb.net/ ASCII：https://www.matools.com/code-convert-ascii Unicode：https://www.zxgj.cn/g/unicode UTF8：https://www.zxgj.cn/g/utf8 字符串：https://www.zxgj.cn/g/enstring URL：http://tool.chinaz.com/tools/urlencode.aspx?jdfwkey=lbixzl  在线转换工具  在线ACSII对照表：http://www.fly63.com/tool/ascii/ 通用进制转换工具：https://www.zxgj.cn/g/jinzhi 在线浮点数十进制转换：http://www.binaryconvert.com/ RGB：https://www.zxgj.cn/g/yansezhi 时间戳：https://www.zxgj.cn/g/unix 计量单位换算：http://www.fly63.com/tool/unitable/ 在线JSON解析：http://www.json.cn/ 在线JS代码格式化工具：https://prettier.io/playground/ SQL压缩/格式化工具：https://www.zxgj.cn/g/sqlformat JSON和YAML在线转换：http://www.fly63.com/tool/jsonyaml/ JSON和XML在线转换:https://www.zxgj.cn/g/jsonxml 人民币大小写转换：http://www.fly63.com/tool/renmingbi/  正则表达式工具  正则表达式调试工具：https://regexr.com/ 正则表达式可视化工具：https://jex.im/regulex/  网络工具  IP地址归属地查询：https://www.ip138.com/ IP地址查询：https://www.ipip.net/ip.html/ HTTP在线接口测试工具：http://www.fly63.com/php/http/  在线编译运行工具  C#在线编译运行（不支持input）：https://rextester.com/ C/C++在线编译：https://www.onlinegdb.com/ 在线编译工具套装：https://c.runoob.com/  在线生成器  UUID：https://www.zxgj.cn/g/uuid 随机数：https://www.zxgj.cn/g/suijishu  其它常用开发工具  在线Nginx配置工具：https://nginxconfig.io/ 在线对比工具：http://www.fly63.com/tool/textdiff/ 在线Chrome浏览器插件：https://www.crx4chrome.com/ 变量命名神器：https://unbug.github.io/codelf/ 文本处理工具大全：https://gitee.com/wwwlib/funNLP?_from=gitee_search#https://github.com/wainshine/Company-Names-Corpus  在线素材网站  阿里巴巴矢量图标库：https://www.iconfont.cn/ 表情包在线网站：https://fabiaoqing.</description>
    </item>
    
    <item>
      <title>HashMap源码分析</title>
      <link>https://cuterwrite.top/p/hashmap/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/hashmap/</guid>
      <description>Table of Contents generated with DocToc
 HashMap源码分析  1 属性 2 构造方法 3 增加元素 4 读取元素 5 删除元素 6 底层数据结构分析  6.1 JDK1.8之前 6.2 JDK1.8之后      HashMap源码分析 1 属性   初始化容量
static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4;   最大容量
static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;   负载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;   红黑树阈值
static final int TREEIFY_THRESHOLD = 8;   链表阈值</description>
    </item>
    
    <item>
      <title>前端开发知识点复习-基础篇</title>
      <link>https://cuterwrite.top/p/web-development-1/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/web-development-1/</guid>
      <description>Table of Contents generated with DocToc
 前端开发知识点-基础篇  1 Cookie、Session、SessionStorage和LocalStorage 2 Http和Https的区别 3 Http2.0的特性 4 OSI七层模型 5 TCP和UDP的区别 6 TCP三次握手和四次挥手 7 HTTP状态码 8 HTTP缓存机制 9 XSS攻击和CSRF攻击 10 HTTP常见请求头 11 HTTP常见请求方法 12 输入URL到显示页面的过程 13 Websocket 14 BOM对象 15 CORS跨域请求的方式 16 CSS盒模型 17 link标签和import标签的区别 18 transition和animation的区别 19 Flex布局 20 BFC 21 块元素和行元素 22 HTML5和CSS3的新元素 23 重绘和重排 24 闭包 25 类的创建和继承 26 promise、generator、async/await 27 事件流 28 事件委托（代理） 29 事件循环 30 图片懒加载和预加载 31 new操作符 32 bind、apply、call的区别 33 节流和防抖 34 深拷贝 35 对象属性改变监听-Proxy 36 变量提升和暂时性死区 37 箭头函数 38 原型链 39 ES6新特性 40 垂直居中的方法 41 前端性能优化 42 get和post的区别 43 web worker 44 浮动清除 45 CSS选择器    前端开发知识点-基础篇 1 Cookie、Session、SessionStorage和LocalStorage Cookie：服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地的一种纯文本文件，当下一次有同源的请求时，将保存的Cookie数据添加到请求头部，发送给服务端。可以用来实现记录用户登录状态等功能。</description>
    </item>
    
    <item>
      <title>计算机基础知识点总结（操作系统&#43;计算机网络）</title>
      <link>https://cuterwrite.top/p/interview-help/</link>
      <pubDate>Thu, 22 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/interview-help/</guid>
      <description>Table of Contents generated with DocToc
 一、操作系统  1、进程与线程的区别 2、进程间的通信的几种方式 3、线程同步的方式 4、进程同步的方式 5、死锁  5.1、死锁的定义 5.2、死锁必要条件 5.3、死锁处理   6、进程的状态 7、进程调度算法 8、虚拟内存 9、页面置换算法 10、分页与分段的区别   二、计算机网络  1、计算机网络体系结构  1.1、五层协议 1.2、OSI七层协议   2、UDP和TCP的特点 3、UDP首部格式 4、TCP首部格式 5、TCP三次握手 6、TCP四次挥手 7、TCP可靠传输 8、TCP滑动窗口 9、TCP 流量控制 10、TCP 拥塞控制 11、域名系统 12、FTP协议 13、DHCP协议 14、SSH协议 15、SMTP协议 16、Web页面请求过程  16.1. DHCP 配置主机信息 16.2. ARP 解析 MAC 地址 16.3. DNS 解析域名 16.4. HTTP 请求页面      一、操作系统 1、进程与线程的区别   进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</description>
    </item>
    
    <item>
      <title>Redis入门</title>
      <link>https://cuterwrite.top/p/redis-1/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/redis-1/</guid>
      <description>Table of Contents generated with DocToc
 1、命令返回值 2、多数据库 3、命令大全  1、通用命令  keys pattern exists key del key type key   2、字符串类型  简介 set key value / get key incr key incrby key increment decr key decrby key decrement incrbyfloat key increment append key value strlen key mget key / mset key1 value1 &amp;hellip; 位操作 使用场景   3、hash类型  简介 hset key field value hget key field hmset key field value hmget key field hgetall key hexists key field hsetnx key field value hincrby key field increment hdel key field 其他命令 使用场景   4、list类型  简介 lpush key value1&amp;hellip; rpush key value1&amp;hellip; lpop key rpop key llen key lrange key start stop lrem key count value lindex key index lset key index value ltrim key start end linsert key before|after pivot value rpoplpush source destination 使用场景   5、set类型  简介 sadd key member srem key member smembers sismember key member sdiff key1 key2 &amp;hellip; sinter key1 key2&amp;hellip; sunion key1 key2&amp;hellip; scard key sdiffstore/sinterstore/sunionstore destination key1 key2&amp;hellip; srandmember key count spop 使用场景   6、zset类型  简介 zadd key score member zscore key member zrange key start stop [withscores] zrangebyscore key min max [withscores] limit offset count zrevrangebyscore key max min [withscores] limit offset count zincrby key increment member zcard key zcount key min max zrem key member1 &amp;hellip; zremrangebyranke key start stop zremrangebyscore key min max zrank key member zrevrank key member      1、命令返回值  状态回复  OK：成功 PONG：响应PING   错误回复：命令不存在或者命令格式有误  Error Unknown command   整数回复：  INCR命令：返回递增后的键值 DBSIZE命令：返回键的数量   字符串回复：  请求键的值或者请求一个其他类型键中的某个元素   多行字符串回复：  请求非字符串类型键的元素列表 Keys (Pattern)：返回数据库中符合指定规则的键名    2、多数据库  一个Redis实例提供了多个用来存储数据的字典，客户端可以指定数据存储在哪个字典中。 数据库默认从0开始递增命名，默认支持16个数据库（DB0，DB1，&amp;hellip;，DB15） 不支持自定义数据库名字，也不支持单独设置访问密码  3、命令大全 1、通用命令 keys pattern 获得符合规则的键名列表，支持？、*、[]、\x四种通配符</description>
    </item>
    
    <item>
      <title>Spring Cloud Alibaba笔记</title>
      <link>https://cuterwrite.top/p/spring-cloud-alibaba-1/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/spring-cloud-alibaba-1/</guid>
      <description>Table of Contents generated with DocToc
 Spring Cloud alibaba笔记  SOA与微服务的区别： Spring Cloud Alibaba与Spring Cloud Netflix的对比 什么是Spring Boot？ IOC/DI（控制反转与依赖注入） Spring发展过程 自动装配的实现 手写实现一个Starter  1 Starter的功能 2 Starter的命名规范 3 实现基于Redis的Starter   Apache Dubbo Zookeeper Dubbo集成Zookeeper  1 需要解决的问题 2 实现步骤 3 原理 4 实战Dubbo Spring Cloud   Dubbo的高级应用  1 集群容错 2 负载均衡 3 服务降级   主机绑定规则 Dubbo源码分析  1 核心点 2 生成IDE工程的命令 3 SPI(Service Provider Interface) 4 Dubbo中的SPI思想 5 Dubbo中的SPI原理 6 自适应扩展点 7 Protocol自适应扩展点源码 8 IOC 9 AOP 10 Dubbo集成Spring机制（略）   什么是Nacos？  1 关键特性 2 Nacos集群   搭建Nacos注册中心的注意点 Nacos实现原理  1 模块组成 2 注册中心的原理 3 Nacos源码（略）   Nacos实现统一配置管理  1 Nacos集成Spring Boot 2 Nacos集成Spring Cloud 3 动态更新配置 4 基于DataID配置yaml的文件扩展名 5 不同环境的配置切换 6 自定义Namespace和Group   Nacos Config实现原理（略） Spring Cloud加载配置的原理（略） Nacos源码（略） Sentinel限流及熔断  1 服务限流的作用及实现 2 服务熔断和降级 3 Sentinel的特性 4 Sentinel的组成： 5 Sentinel基本应用： 6 Sentinel资源保护规则  1 QPS流量控制行为   7 Sentinel实现服务熔断   Sentinel集成Spring Cloud 基于Sentinel Dashboard来实现流控配置 Sentinel自定义URL限流异常 Sentinel对URL资源清洗 Sentinel集成Nacos实现动态流控规则 Sentinel集成Nacos实现规则同步  1 Sentinel Dashboard源码修改： 2 Sentinel Dashboard规则同步   Sentinel集成Dubbo实现限流  * 1 Dubbo服务接入Sentinel Dashboard 2 Dubbo服务限流规则   Sentinel热点限流  1 热点参数限流的使用 2 @SentinelResource 3 热点参数规则说明   Sentinel的工作原理（略） Spring Cloud Sentinel工作原理（略） Sentinel核心源码分析（略）  1 限流的源码实现 2 实时指标数据统计 3 服务降级的实现原理   什么是分布式事务？  1 分布式事务问题的理论模型  1 X/Open分布式模型 2 两阶段提交协议 3 三阶段提交协议 4 CAP定理和BASE理论   2 分布式事务问题的常见解决方案  1 TCC补偿性方案 2 基于可靠性消息的最终一致性方案 3 最大努力通知型   3 分布式事务框架Seata  1 AT模式 2 Saga模式        Spring Cloud alibaba笔记 SOA与微服务的区别：  SOA关注的是服务的重用性及解决信息孤岛问题 微服务关注的是解耦，虽然解耦和可重用性从特定的角度来看是一样的，但本质上是有区别的，解耦是降低业务之间的耦合度，而重用性关注的是服务的复用。 微服务会更多地关注在DevOps的持续交付上，因为服务粒度细化之后使得开发运维变得更加重要，因此微服务与容器化技术的结合更加紧密。  Spring Cloud Alibaba与Spring Cloud Netflix的对比  Alibaba开源组件在没有织入Spring Cloud生态之前，已经在各大公司广泛应用，所以容易实现技术整合及迁移。 Alibaba开源组件在服务治理上和处理高并发的能力上有天然的优势。  什么是Spring Boot？ 帮助开发者快速构建一个基于Spring Framework及Spring生态体系的应用解决方案，也是对于“约定优于配置”理念的最佳实践。</description>
    </item>
    
  </channel>
</rss>
