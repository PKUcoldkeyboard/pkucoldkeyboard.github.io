<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="This article introduces Arm's Scalable Vector Extension (SVE) and its enhanced version SVE2. They significantly improve the performance of data-intensive applications (such as HPC and ML) by providing variable-length vector registers, flexible per-lane predication, and a rich instruction set, and ensure portability across different hardware platforms through software binary compatibility. Additionally, SVE provides ACLE (ARM C Language Extensions) to assist developers in programming, allowing SVE instructions to be used directly in C/C++ code by calling intrinsic functions in the arm_sve.h header file for efficient vectorized operations."><title>Arm Performance Optimization: Scalable Vector Extension SVE</title>
<link rel=canonical href=https://cuterwrite.top/en/p/arm-sve-for-performance/><link rel=stylesheet href=/scss/style.min.9e9a820f30d9af5db6f416de7ab0f7a731a8bcab6669edcbd5a489a07906aa5d.css><meta property='og:title' content="Arm Performance Optimization: Scalable Vector Extension SVE"><meta property='og:description' content="This article introduces Arm's Scalable Vector Extension (SVE) and its enhanced version SVE2. They significantly improve the performance of data-intensive applications (such as HPC and ML) by providing variable-length vector registers, flexible per-lane predication, and a rich instruction set, and ensure portability across different hardware platforms through software binary compatibility. Additionally, SVE provides ACLE (ARM C Language Extensions) to assist developers in programming, allowing SVE instructions to be used directly in C/C++ code by calling intrinsic functions in the arm_sve.h header file for efficient vectorized operations."><meta property='og:url' content='https://cuterwrite.top/en/p/arm-sve-for-performance/'><meta property='og:site_name' content="Cuterwrite's Blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='SIMD'><meta property='article:tag' content='ÂêëÈáèÂåñÁºñÁ®ã'><meta property='article:tag' content='Âπ∂Ë°åËÆ°ÁÆó'><meta property='article:published_time' content='2024-08-11T02:13:00+00:00'><meta property='article:modified_time' content='2024-08-11T02:13:00+00:00'><meta property='og:image' content='https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-29_117622464_p0_master1200.webp'><meta name=twitter:title content="Arm Performance Optimization: Scalable Vector Extension SVE"><meta name=twitter:description content="This article introduces Arm's Scalable Vector Extension (SVE) and its enhanced version SVE2. They significantly improve the performance of data-intensive applications (such as HPC and ML) by providing variable-length vector registers, flexible per-lane predication, and a rich instruction set, and ensure portability across different hardware platforms through software binary compatibility. Additionally, SVE provides ACLE (ARM C Language Extensions) to assist developers in programming, allowing SVE instructions to be used directly in C/C++ code by calling intrinsic functions in the arm_sve.h header file for efficient vectorized operations."><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-29_117622464_p0_master1200.webp'><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><script async src=https://analytics.cuterwrite.top/uma.js data-website-id=b13594a2-4d15-4a4e-a020-5e3cc1d88c12 data-domains=cuterwrite.top></script><link rel=manifest href=/manifest.json></head><body class="article-page
line-numbers"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/en/><img src=/img/avatar_hue4d14694a57c01a222a16c47db12c89c_369633_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>üòâ</span></figure><div class=site-meta><h1 class=site-name><a href=/en>Cuterwrite's Blog</a></h1><h2 class=site-description>Cuterwrite's tech blog, focusing on in-depth exploration and experience sharing in areas such as high-performance computing, operating systems, full-stack development, and artificial intelligence.</h2></div></header><ol class=menu-social><li><a href=https://analytics.cuterwrite.top/share/Ji0gm9OaLDk8gco7 target=_blank title=Analytics rel=me><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 5H7A2 2 0 005 7v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"/><rect x="9" y="3" width="6" height="4" rx="2"/><path d="M9 17v-5"/><path d="M12 17v-1"/><path d="M15 17v-3"/></svg></a></li><li><a href=https://stats.uptimerobot.com/6NVhRHkSAQ target=_blank title=Uptime rel=me><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-chart-line"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 19h16"/><path d="M4 15l4-6 4 2 4-5 4 4"/></svg></a></li><li><a href=/index.xml target=_blank title=RSS rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li><li><a href=https://github.com/PKUcoldkeyboard target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.zhihu.com/people/kong-tiao-cheng-tai-lang-30-57 target=_blank title=zhihu rel=me><svg t="1705591931290" class="icon" viewBox="0 0 1280 1024" xmlns="http://www.w3.org/2000/svg" p-id="21048" width="32" height="32"><path d="M341.08 296.26v435.08l46.86.02 15.42 52.74 84.02-52.74h99.06V296.26H341.08zm195.5 387.86H480.7l-55.8 35.02-10.16-34.94-23.8-.08V343.5h145.64v340.62zM299.66 495.34H195c3.48-54.2 4.4-103.18 4.4-146.92h102.32s3.94-45.12-17.16-44.62h-177c6.98-26.24 15.74-53.32 26.24-81.34.0.0-48.14.0-64.54 43.14-6.78 17.8-26.42 86.28-61.4 156.24 11.78-1.28 50.74-2.36 73.68-44.42 4.22-11.78 5.02-13.32 10.28-29.06h57.74c0 21-2.4 133.76-3.36 146.88H41.66c-23.48.0-31.12 47.24-31.12 47.24H141.7C132.9 642.2 85.66 726.24.0 792.68c40.98 11.7 81.82-1.86 102-19.8.0.0 45.96-41.8 71.18-138.5L281.1 764.26s15.82-53.78-2.48-79.98c-15.16-17.84-56.12-66.12-73.58-83.62L175.8 623.9c8.72-27.96 13.98-55.1 15.74-81.34h123.3s-.18-47.24-15.18-47.24v.02zm824.04-3.2c41.66-51.28 89.96-117.14 89.96-117.14s-37.3-29.6-54.76-8.12c-12 16.3-73.66 96.4-73.66 96.4l38.46 28.86zM823.52 373.96c-18.02-16.5-51.82 4.26-51.82 4.26s79.04 110.08 82.24 114.9l38.92-27.46s-51.34-75.22-69.32-91.72h-.02zM1280 516.7c-39.56.0-261.82 1.86-262.12 1.86v-202c9.62.0 24.84-.8 45.7-2.4 81.76-4.82 140.26-8 175.54-9.62.0.0 24.44-54.38-1.18-66.88-6.14-2.36-46.34 9.16-46.34 9.16s-330.44 32.98-464.72 36.1c3.2 17.64 15.24 34.16 31.56 39.1 26.62 6.96 45.38 3.4 98.3 1.78 49.66-3.2 87.36-4.86 113.02-4.86v199.62H702.82s5.64 44.62 51.02 45.7h215.88V706.1c0 27.94-22.38 43.98-48.96 42.24-28.16.22-52.16-2.3-83.38-3.62 3.98 7.94 12.66 28.78 38.62 43.68 19.76 9.62 32.34 13.14 52.04 13.14 59.12.0 91.34-34.56 89.78-90.62V564.28h244.72c19.36.0 17.4-47.56 17.4-47.56l.06-.02z" fill="#707070" p-id="21049"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/en/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>‰∏ªÈ°µ | Home</span></a></li><li><a href=/en/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>ÂÖ≥‰∫é | About</span></a></li><li><a href=/en/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>ÂΩíÊ°£ | Archives</span></a></li><li><a href=/en/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>ÊêúÁ¥¢ | Search</span></a></li><li><a href=https://cuterwrite.top/image-hosting target=_blank><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-album"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 4m0 2a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2z"/><path d="M12 4v7l2-2 2 2V4"/></svg>
<span>ÂõæÂÜå | Gallery</span></a></li><li><a href=https://draw.cuterwrite.top target=_blank><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-artboard"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M8 8m0 1a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H9a1 1 0 01-1-1z"/><path d="M3 8h1"/><path d="M3 16h1"/><path d="M8 3v1"/><path d="M16 3v1"/><path d="M20 8h1"/><path d="M20 16h1"/><path d="M8 20v1"/><path d="M16 20v1"/></svg>
<span>ÁîªÊùø | Canvas</span></a></li><li><a href=https://it-tools.tech target=_blank><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-tools"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 21h4L20 8a1.5 1.5.0 00-4-4L3 17v4"/><path d="M14.5 5.5l4 4"/><path d="M12 8 7 3 3 7l5 5"/><path d="M7 8 5.5 9.5"/><path d="M16 12l5 5-4 4-5-5"/><path d="M16 17l-1.5 1.5"/></svg>
<span>Â∑•ÂÖ∑ | Tools</span></a></li><li class=menu-bottom-section><ol class=menu><li id=i18n-switch><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language title=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://cuterwrite.top/>‰∏≠Êñá</option><option value=https://cuterwrite.top/en/ selected>English</option></select></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ul><li><a href=#1-sve-introduction>1. SVE Introduction</a></li><li><a href=#2-sve-architecture-basics>2. SVE Architecture Basics</a><ul><li><a href=#21-scalable-vector-registers>2.1 Scalable Vector Registers</a></li><li><a href=#22-scalable-predicate-register>2.2 Scalable Predicate Register</a></li><li><a href=#23-scalable-vector-system-control-register>2.3 Scalable Vector System Control Register</a></li><li><a href=#24-sve-assembly-syntax>2.4 SVE Assembly Syntax</a></li><li><a href=#25-sve-architecture-features>2.5 SVE Architecture Features</a></li></ul></li><li><a href=#3-new-features-of-sve2>3. New Features of SVE2</a></li><li><a href=#4-using-sve-programming>4. Using SVE programming</a><ul><li><a href=#41-software-and-library-support>4.1 Software and Library Support</a></li><li><a href=#42-how-to-program-using-sve2>4.2 How to Program Using SVE2</a><ul><li><a href=#421-write-sve-assembly-code>4.2.1 Write SVE assembly code</a></li><li><a href=#422-using-sve-instruction-functions-intrinsics>4.2.2 Using SVE Instruction Functions (Intrinsics)</a></li><li><a href=#423-automatic-vectorization>4.2.3 Automatic Vectorization</a></li><li><a href=#424-using-svesve2-to-optimize-libraries>4.2.4 Using SVE/SVE2 to Optimize Libraries</a></li></ul></li><li><a href=#43-how-to-run-svesve2-programs>4.3 How to run SVE/SVE2 programs</a></li></ul></li><li><a href=#5-acle-intrinsics>5. ACLE Intrinsics</a><ul><li><a href=#51-acle-introduction>5.1 ACLE Introduction</a></li><li><a href=#52-how-to-use-acle>5.2 How to use ACLE</a></li><li><a href=#53-sve-acle>5.3 SVE ACLE</a></li><li><a href=#54-common-sve-intrinsics>5.4 Common SVE Intrinsics</a></li><li><a href=#55-sve-structure-intrinsics>5.5 SVE Structure Intrinsics</a></li><li><a href=#56-sve-condition-selection>5.6 SVE Condition Selection</a></li><li><a href=#57-sve-vectorized-loop-interleaving>5.7 SVE Vectorized Loop Interleaving</a></li></ul></li><li><a href=#references>References</a></li></ul></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/en/p/arm-sve-for-performance/><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-29_117622464_p0_master1200.webp loading=lazy alt="Featured image of post Arm Performance Optimization: Scalable Vector Extension SVE"></a></div><div class=article-details><header class=article-category><a href=/en/categories/hpc/ style=background-color:#ffb900;color:#fff>High Performance Computing</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/en/p/arm-sve-for-performance/>Arm Performance Optimization: Scalable Vector Extension SVE</a></h2><h3 class=article-subtitle>This article introduces Arm's Scalable Vector Extension (SVE) and its enhanced version SVE2. They significantly improve the performance of data-intensive applications (such as HPC and ML) by providing variable-length vector registers, flexible per-lane predication, and a rich instruction set, and ensure portability across different hardware platforms through software binary compatibility. Additionally, SVE provides ACLE (ARM C Language Extensions) to assist developers in programming, allowing SVE instructions to be used directly in C/C++ code by calling intrinsic functions in the arm_sve.h header file for efficient vectorized operations.</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2024-08-11</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>10 minute read</time></div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-keyboard"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M2 6m0 2a2 2 0 012-2h16a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2z"/><path d="M6 10v.01"/><path d="M10 10v.01"/><path d="M14 10v.01"/><path d="M18 10v.01"/><path d="M6 14v.01"/><path d="M18 14v.01"/><path d="M10 14l4 .01"/></svg>
<time class=article-time--wordcount>4617 words</time></div></footer><footer class=article-translations><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg><div><a href=https://cuterwrite.top/p/arm-sve-for-performance/ class=link>‰∏≠Êñá</a></div></footer></div></header><section class=article-content><h1 id=arm-performance-optimization-scalable-vector-extension-sve><a href=#arm-performance-optimization-scalable-vector-extension-sve class=header-anchor>#</a>
ARM Performance Optimization: Scalable Vector Extension SVE</h1><h2 id=1-sve-introduction><a href=#1-sve-introduction class=header-anchor>#</a>
1. SVE Introduction</h2><p>After the Neon architecture extension with a fixed 128-bit vector length instruction set, Arm designed the Scalable Vector Extension (SVE) as the next-generation SIMD extension for AArch64. SVE introduces the scalable concept, allowing flexible vector length implementations and providing a range of possible values in CPU implementations. The vector length can vary from a minimum of 128 bits to a maximum of 2048 bits, in increments of 128 bits. <strong>The SVE design ensures that the same application can run on different SVE-supporting implementations without recompiling the code</strong>. SVE enhances the architecture&rsquo;s applicability to high-performance computing (HPC) and machine learning (ML) applications, which require very large amounts of data processing. SVE2 is a superset of SVE and Neon. SVE2 allows the use of more functional domains in data-level parallelism. SVE2 inherits the concepts, vector registers, and operation principles of SVE. SVE and SVE2 define 32 scalable vector registers. Chip partners can choose an appropriate vector length design implementation, with hardware varying between 128 bits and 2048 bits (in increments of 128 bits). The advantage of SVE and SVE2 is that only one vector instruction set uses scalable variables.</p><p>The SVE design philosophy allows developers to write and build software once, and then run the same binary on different AArch64 hardware with various SVE vector length implementations. The portability of the binary means developers do not need to know the vector length implementation of their system. This eliminates the need to rebuild the binary, making the software easier to port. In addition to scalable vectors, SVE and SVE2 also include:</p><ul><li>per-lane predication</li><li>Gather Load/Scatter Store</li><li>Speculative Vectorization</li></ul><p>These features help vectorize and optimize loops when dealing with large datasets.</p><p>The main difference between SVE2 and SVE lies in the functional coverage of the instruction set. SVE is specifically designed for HPC and ML applications. SVE2 extends the SVE instruction set to enable accelerated data processing in areas beyond HPC and ML. The SVE2 instruction set can also accelerate common algorithms used in the following applications:</p><ul><li>Computer Vision</li><li>Multimedia</li><li>LTE Basic Processing</li><li>Genomics</li><li>In-memory database</li><li>Web Service</li><li>General software</li></ul><p>SVE and SVE2 both support collecting and processing large amounts of data. SVE and SVE2 are not extensions of the Neon instruction set. Instead, SVE and SVE2 are redesigned to offer better data parallelism than Neon. However, the hardware logic of SVE and SVE2 covers the implementation of Neon hardware. When a microarchitecture supports SVE or SVE2, it also supports Neon. To use SVE and SVE2, the software running on that microarchitecture must first support Neon.</p><h2 id=2-sve-architecture-basics><a href=#2-sve-architecture-basics class=header-anchor>#</a>
2. SVE Architecture Basics</h2><p>This section introduces the basic architectural features shared by SVE and SVE2. Like SVE, SVE2 is also based on scalable vectors. In addition to the existing register file provided by Neon, SVE and SVE2 add the following registers:</p><ul><li>32 scalable vector registers, <code>Z0-Z31</code></li><li>16 scalable Predicate registers, <code>P0-P15</code><ul><li>1 First Fault Predicate register, <code>FFR</code></li></ul></li><li>Scalable Vector System Control Register, <code>ZCR_ELx</code></li></ul><h3 id=21-scalable-vector-registers><a href=#21-scalable-vector-registers class=header-anchor>#</a>
2.1 Scalable Vector Registers</h3><p>Scalable vector registers <code>Z0-Z31</code> can be implemented in microarchitecture as 128-2048 bits. The lowest 128 bits are shared with Neon&rsquo;s fixed 128-bit vectors <code>V0-V31</code>.</p><p>The image below shows scalable vector registers <code>Z0-Z31</code>:</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_Z-register.webp alt="Z Registers-2024-08-13" width=auto loading=lazy><figcaption><h4>Scalable Vector Registers Z0-Z31</h4></figcaption></figure><p>Scalable Vector:</p><ul><li>Can accommodate 64, 32, 16, and 8-bit elements</li><li>Supports integer, double precision, single precision, and half precision floating-point elements</li><li>The vector length can be configured for each exception level (EL)</li></ul><h3 id=22-scalable-predicate-register><a href=#22-scalable-predicate-register class=header-anchor>#</a>
2.2 Scalable Predicate Register</h3><p>In order to control which active elements participate in operations, Predicate registers (abbreviated as P registers) are used as masks in many SVE instructions, which also provides flexibility for vector operations. The figure below shows the scalable Predicate registers <code>P0-P15</code>:</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_Predicate-register.webp alt="P Register-2024-08-12" width=auto loading=lazy><figcaption><h4>Scalable Predicate Registers P0-P15</h4></figcaption></figure><p>The P register is typically used as a bitmask for data manipulation:</p><ul><li>Each P register is 1/8 the length of a Z register</li><li><code>P0-P7</code> are used for loading, storing, and arithmetic operations</li><li><code>P8-P15</code> used for loop management</li><li>FFR is a special P register set by the first-fault vector load and store instructions, used to indicate the success of load and store operations for each element. FFR is designed to support speculative memory access, making vectorization easier and safer in many cases.</li></ul><h3 id=23-scalable-vector-system-control-register><a href=#23-scalable-vector-system-control-register class=header-anchor>#</a>
2.3 Scalable Vector System Control Register</h3><p>The figure below shows the Scalable Vector System Control Register <code>ZCR_ELx</code>:</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_ZCR_Elx.webp alt=ZCR_Elx-2024-08-12 width=auto loading=lazy><figcaption><h4>Scalable Vector System Control Register ZCR_Elx</h4></figcaption></figure><p>Scalable Vector System Control Register indicates SVE implementation features:</p><ul><li><code>ZCR_Elx.LEN</code> field is used for the vector length of the current and lower anomaly levels.</li><li>Most bits are currently reserved for future use.</li></ul><h3 id=24-sve-assembly-syntax><a href=#24-sve-assembly-syntax class=header-anchor>#</a>
2.4 SVE Assembly Syntax</h3><p>The SVE assembly syntax format consists of an opcode, destination register, P register (if the instruction supports a Predicate mask), and input operands. The following instruction example will detail this format.</p><p>Example 1:</p><pre><code class=language-armasm>LDFF1D {&lt;Zt&gt;.D}, &lt;Pg&gt;/Z, [&lt;Xn|SP&gt;, &lt;Zm&gt;.D, LSL #3]
</code></pre><p>Among them:</p><ul><li><code>&lt;Zt></code> is the Z register, <code>Z0-Z31</code></li><li><code>&lt;Zt></code>.D and <code>&lt;Zm></code>.D specify the element type of the target and operand vectors, without needing to specify the number of elements.</li><li><code>&lt;Pg></code> is the P register, <code>P0-P15</code></li><li><code>&lt;Pg>/Z</code> is to zero the P register.</li><li><code>&lt;Zm></code> specifies the offset for the Gather Load address mode.</li></ul><p>Example 2:</p><pre><code class=language-armasm>ADD &lt;Zdn&gt;.&lt;T&gt;, &lt;Pg&gt;/M, &lt;Zdn&gt;.&lt;T&gt;, &lt;Zm&gt;.&lt;T&gt;
</code></pre><p>Among them:</p><ul><li><code>&lt;Pg>/M</code> is the merge P register.</li><li><code>&lt;Zdn></code> is both the destination register and one of the input operands. The instruction syntax shows <code>&lt;Zdn></code> in both places for convenience. In the assembly encoding, for simplification, they are only encoded once.</li></ul><p>Example 3:</p><pre><code class=language-armasm>ORRS &lt;Pd&gt;.B, &lt;Pg&gt;.Z, &lt;Pn&gt;.B, &lt;Pm&gt;.B
</code></pre><ul><li><code>S</code> is the new interpretation of the P register condition flags <code>NZCV</code>.</li><li><code>&lt;Pg></code> controls the P register to act as a bitmask in the example operation.</li></ul><h3 id=25-sve-architecture-features><a href=#25-sve-architecture-features class=header-anchor>#</a>
2.5 SVE Architecture Features</h3><p>SVE includes the following key architectural features:</p><ul><li>per-lane predication</li></ul><p>In order to allow flexible operations on selected elements, SVE introduces 16 P registers, <code>P0-P15</code>, to indicate valid operations on vector active channels. For example:</p><pre><code class=language-armasm>ADD Z0.D, P0/M, Z0.D, Z1.D
</code></pre><p>Add the active elements <code>Z0</code> and <code>Z1</code> and place the result in <code>Z0</code>. <code>P0</code> indicates which elements of the operands are active and inactive. The <strong>M</strong> following <code>P0</code> stands for Merging, meaning the inactive elements of <code>Z0</code> will retain their initial values after the <code>ADD</code> operation. If <strong>Z</strong> follows <code>P0</code>, the inactive elements will be zeroed, and the inactive elements of the destination register will be zeroed after the operation.</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_Per-lane_Predication.webp alt=Per-lane_Predication-2024-08-13 width=auto loading=lazy><figcaption><h4>Per-lane predication merging</h4></figcaption></figure><p>If <strong>\Z</strong> is used, the inactive elements will be zeroed, and the inactive elements of the target register will be zeroed after the operation. For example</p><pre><code class=language-armasm>CPY Z0.B, P0/Z, #0xFF
</code></pre><p>Indicates that the signed integer 0xFF will be copied to the active channel of <code>Z0</code>, while the inactive channels will be cleared.</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_Per-lane_Predicate_Zeroing.webp alt=Per-lane_Predicate_Zeroing-2024-08-13 width=auto loading=lazy><figcaption><h4>Per-lane predication zeroing</h4></figcaption></figure><div class="notice notice-note"><div class=notice-title><svg t="1705946198814" class="icon notice-icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="23141" width="200" height="200"><path d="M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667L423.381333 264.576C281.088 341.546667 253.269333 441.429333 242.176 504.405333c22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864A149.333333 149.333333.0 01312.789333 789.333333a165.162667 165.162667.0 01-117.248-50.304zm426.666667.0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667L850.048 264.576c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864A149.333333 149.333333.0 01739.456 789.333333a165.162667 165.162667.0 01-117.248-50.304z" p-id="23142" fill="#fff"/></svg></div><p>Not all instructions have the Predicate option. Additionally, not all Predicate operations have both merge and zeroing options. You must refer to the <a class=link href=https://developer.arm.com/documentation/ddi0487/latest/t target=_blank rel=noopener>AArch64 SVE Supplement
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span>
</a>to understand the specification details of each instruction.</p></div><ul><li>Gather Load and Scatter Store</li></ul><p>The addressing modes in SVE allow vectors to be used as base addresses and offsets in Gather Load and Scatter Store instructions, which enables access to non-contiguous memory locations. For example:</p><pre><code class=language-armasm>LD1SB Z0.S, P0/Z, [Z1.S] // Gather Load signed bytes from memory addresses generated by the 32-bit vector base address Z1 into the active 32-bit elements of Z0.

LD1SB Z0.D, P0/Z, [X0, Z1.D] // Gather Load signed bytes from memory addresses generated by the 64-bit scalar base address X0 plus the vector index in Z1.D into the active elements of Z0.
</code></pre><p>The following example shows the load operation <code>LD1SB Z0.S, P0/Z, [Z1.S]</code>, where <code>P0</code> contains all true elements, and <code>Z1</code> contains scattered addresses. After loading, the least significant byte of each element in <code>Z0.S</code> will be updated with data fetched from scattered memory locations.</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_gather-load_and_scatter_store_example.webp alt=gather-load_and_scatter_store_example-2024-08-13 width=auto loading=lazy><figcaption><h4>Gather-load and Scatter-store Example</h4></figcaption></figure><ul><li>Loop control and management of the P register driver</li></ul><p>As a key feature of SVE, the P register not only flexibly controls individual elements of vector operations but also enables P register-driven loop control. P register-driven loop control and management make loop control efficient and flexible. This feature eliminates the overhead of extra loop heads and tails for processing partial vectors by registering active and inactive element indices in the P register. P register-driven loop control and management mean that in the subsequent loop iterations, only active elements will perform the intended operations. For example:</p><pre><code class=language-armasm>WHILEL0 P0.S, x8, x9  // Generate a predicate in P0, starting from the lowest numbered element, true when the incremented value of the first unsigned scalar operand X8 is less than the second scalar operand X9, then false until the highest numbered element.

B.FIRST Loop_start     // B.FIRST (equivalent to B.MI) or B.NFRST (equivalent to B.PL) is usually used to branch based on the test result of the above instruction, determining whether the first element of P0 is true or false as the condition to end or continue the loop.
</code></pre><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_Predicate-driver_loop_control_and_management_example.webp alt=Predicate-driver_loop_control_and_management_example-2024-08-13 width=auto loading=lazy><figcaption><h4>Example of loop control and management driven by P register</h4></figcaption></figure><ul><li>Vector partitioning for speculation in software management</li></ul><p>Speculative loading can pose challenges for memory reading of traditional vectors, <strong>if errors occur in certain elements during the reading process, it is difficult to reverse the load operation and track which elements failed to load</strong>. Neon does not allow speculative loading. To allow speculative loading of vectors (e.g., LDRFF), SVE introduces the first-fault vector load instruction. To allow vector access across invalid pages, SVE also introduces the FFR register. <strong>When using the first-fault vector load instruction to load into an SVE vector, the FFR register updates with the success or failure result of each element&rsquo;s load</strong>. When a load error occurs, FFR immediately registers the corresponding element, registers the remaining elements as 0 or false, and does not trigger an exception. Typically, the RDFFR instruction is used to read the FFR status. The RDFFR instruction ends iteration when the first element is false. If the first element is true, the RDFFR instruction continues iteration. The length of FFR is the same as the P vector. This value can be initialized using the SETFFR instruction. The following example uses LDFF1D to read data from memory, and FFR is updated accordingly:</p><pre><code class=language-armasm>LDFF1D Z0.D, P0/Z, [Z1.D, #0] // Use the first-fault behavior to gather doublewords from the memory address generated by vector base address Z1 plus 0, loading into the active elements of Z0. Inactive elements do not read device memory or trigger a fault, and are set to zero in the destination vector. A successful load from valid memory sets the corresponding element in the FFR to true. The first-fault load sets the corresponding element and the remaining elements in the FFR to false or 0.
</code></pre><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_Vector-partioning-for-software-managed-speculation-example.webp alt=Vector-partioning-for-software-managed-speculation-example-2024-08-13 width=auto loading=lazy><figcaption><h4>Example of Vector Partitioning for Software-Managed Speculation</h4></figcaption></figure><ul><li>Extended floating point and horizontal reduction</li></ul><p>In order to allow efficient reduction operations in vectors and meet different precision requirements, SVE enhances floating-point and horizontal reduction operations. These instructions may have a sequential (low to high) or tree-based (pairwise) floating-point reduction order, where the order of operations may lead to different rounding results. These operations require a trade-off between reproducibility and performance. For example:</p><pre><code class=language-armasm>FADDA D0, P0/M, D1, Z2.D // Perform a floating-point addition strict-order reduction from the low to high elements of the source vector, accumulating the result into the SIMD&amp;FP scalar register. This example instruction adds D1 to all active elements of Z2.D and stores the result into scalar register D0. Vector elements are processed in strict order from low to high, with scalar source D1 providing the initial value. Inactive elements in the source vector are ignored. FADDV performs a recursive pairwise reduction and stores the result into the scalar register.
</code></pre><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_Extended_Floating-poing-and-horizontal-reductions-example.webp alt=Extended_Floating-poing-and-horizontal-reductions-example-2024-08-13 width=auto loading=lazy><figcaption><h4>Extended Floating-point and Horizontal Reductions Example</h4></figcaption></figure><h2 id=3-new-features-of-sve2><a href=#3-new-features-of-sve2 class=header-anchor>#</a>
3. New Features of SVE2</h2><p>This section introduces the features added by SVE2 to the Arm AArch64 architecture. To achieve scalable performance, SVE2 is built on SVE, allowing vectors to reach up to 2048 bits.</p><p>In SVE2, many instructions that replicate existing instructions in Neon have been added, including:</p><ul><li>Converted Neon integer operations, for example, Signed Absolute Difference Accumulate (SAB) and Signed Halving Add (SHADD).</li><li>Converted Neon extensions, narrowing and paired operations, for example, Unsigned Add Long - Bottom (UADDLB) and Unsigned Add Long - Top (UADDLT).</li></ul><p>The order of element processing has changed. SVE2 processes interleaved even and odd elements, while Neon processes the low half and high half elements of narrow or wide operations. The diagram below illustrates the difference between Neon and SVE2 processing:</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_transformed_neon_widen_narraow_pairwise_operations.webp alt=transformed_neon_widen_narraow_pairwise_operations-2024-08-13 width=auto loading=lazy><figcaption><h4>Comparison of Transformed Neon Narrow or Wide Operations</h4></figcaption></figure><ul><li>Complex number operations, such as complex integer multiplication-accumulation with rotation (CMLA).</li><li>Multi-precision arithmetic, used for large integer arithmetic and cryptography, for example, carry-in long addition - bottom (ADCLB), carry-in long addition - top (ADCLT) and SM4 encryption and decryption (SM4E).</li></ul><p>For backward compatibility, the latest architecture requires Neon and VFP. Although SVE2 includes some features of SVE and Neon, SVE2 does not preclude the presence of Neon on the chip.</p><p>SVE2 supports optimization for emerging applications beyond the HPC market, such as in machine learning (ML) (UDOT instructions), computer vision (TBL and TBX instructions), baseband networks (CADD and CMLA instructions), genomics (BDEP and BEXT instructions), and servers (MATCH and NMATCH instructions).</p><p>SVE2 enhances the overall performance of general-purpose processors in handling large volumes of data, without the need for additional off-chip accelerators.</p><h2 id=4-using-sve-programming><a href=#4-using-sve-programming class=header-anchor>#</a>
4. Using SVE programming</h2><p>This section introduces software tools and libraries that support SVE2 application development. This section also explains how to develop applications for targets that support SVE2, run the application on hardware that supports SVE2, and simulate the application on any Armv8-A hardware.</p><h3 id=41-software-and-library-support><a href=#41-software-and-library-support class=header-anchor>#</a>
4.1 Software and Library Support</h3><p>To build SVE or SVE2 applications, you must choose a compiler that supports SVE and SVE2 features.</p><ul><li>GNU tools version 8.0+ supports SVE.</li><li><a class=link href=https://developer.arm.com/tools-and-software/server-and-hpc/compile/arm-compiler-for-linux target=_blank rel=noopener>Arm Compiler for Linux
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span>
</a>Version 18.0+ supports SVE, Version 20.0+ supports SVE and SVE2.</li><li>Both GNU and Arm Compiler for Linux compilers support optimizing C/C++/Fortran code.</li><li>LLVM (open-source Clang) version 5 and above includes support for SVE, and version 9 and above includes support for SVE2. To find out which SVE or SVE2 features are supported by each version of the LLVM tools, please refer to the <a class=link href=https://developer.arm.com/tools-and-software/open-source-software/developer-tools/llvm-toolchain/sve-support target=_blank rel=noopener>LLVM toolchain SVE support page
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span>
</a>.</li></ul><p><a class=link href=https://developer.arm.com/Tools%20and%20Software/Arm%20Performance%20Libraries target=_blank rel=noopener>Arm Performance Libraries
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span>
</a>are highly optimized for mathematical routines and can be linked to your applications. Arm Performance Libraries version 19.3+ supports SVE&rsquo;s math library.</p><p>Arm Compiler for Linux is part of Arm Allinea Studio, including Arm C/C++ Compiler, Arm Fortran Compiler, and Arm Performance Libraries.</p><h3 id=42-how-to-program-using-sve2><a href=#42-how-to-program-using-sve2 class=header-anchor>#</a>
4.2 How to Program Using SVE2</h3><p>There are several methods to write or generate SVE and SVE2 code. In this section, we will explore some of these methods.</p><p>To write or generate SVE and SVE2 code, you can:</p><ul><li>Write SVE assembly code</li><li>Programming with SVE intrinsics</li><li>Automatic vectorization</li><li>Use SVE optimization library</li></ul><p>Let&rsquo;s take a closer look at these four options.</p><h4 id=421-write-sve-assembly-code><a href=#421-write-sve-assembly-code class=header-anchor>#</a>
4.2.1 Write SVE assembly code</h4><p>You can write SVE instructions as inline assembly in C/C++ code, or as a complete function in assembly source code. For example:</p><pre><code class=language-armasm>```assembly
    .globl subtract_arrays // -- Begin function
    .p2align 2
    .type subtract_arrays, @function
    subtract_arrays: // @subtract_arrays
    .cfi_startproc
// %bb.0:
    orr w9, wzr, #0x400
    mov x8, xzr
    whilelo p0.s, xzr, x9
.LBB0_1: // =&gt;This Inner Loop Header: Depth=1
    ld1w { z0.s }, p0/z, [x1, x8, lsl #2]
    ld1w { z1.s }, p0/z, [x2, x8, lsl #2]
    sub z0.s, z0.s, z1.s
    st1w { z0.s }, p0, [x0, x8, lsl #2]
    incw x8
    whilelo p0.s, x8, x9
    b.mi .LBB0_1
// %bb.2:
    ret
.Lfunc_end0:
    .size subtract_arrays, .Lfunc_end0-subtract_arrays
    .cfi_endproc
</code></pre><p>If you write functions that mix high-level language and assembly language, you must be familiar with the <a class=link href=https://developer.arm.com/documentation/ihi0036/latest/ target=_blank rel=noopener>Application Binary Interface (ABI)
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span>
</a>standards updated for SVE. The <a class=link href=https://developer.arm.com/documentation/ihi0055/latest target=_blank rel=noopener>Arm Architecture Procedure Call Standard (AAPCS)
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span>
</a>specifies data types and register allocation, and is most relevant to assembly programming. AAPCS requires:</p><ul><li><code>Z0-Z7</code> and <code>P0-P3</code> are used to pass scalable vector parameters and results.</li><li><code>Z8-Z15</code> and <code>P4-P15</code> are callee-saved.</li><li>All other vector registers (<code>Z16-Z31</code>) may be corrupted by the called function, and the calling function is responsible for backing up and restoring them when necessary.</li></ul><h4 id=422-using-sve-instruction-functions-intrinsics><a href=#422-using-sve-instruction-functions-intrinsics class=header-anchor>#</a>
4.2.2 Using SVE Instruction Functions (Intrinsics)</h4><p>SVE intrinsic functions are functions supported by the compiler that can be replaced with corresponding instructions. Programmers can directly call instruction functions in high-level languages such as C and C++. The ACLE (Arm C Language Extensions) for SVE defines which SVE intrinsic functions are available, their parameters, and their functionality. A compiler that supports ACLE can replace intrinsics with mapped SVE instructions during compilation. To use ACLE intrinsics, you must include the header file <code>arm_sve.h</code>, which contains a list of vector types and intrinsic functions (for SVE) that can be used in C/C++. Each data type describes the size and data type of the elements in the vector:</p><ul><li><code>svint8_t svuint8_t</code></li><li><code>svint16_t svuint16_t svfloat16_t</code></li><li><code>svint32_t svuint32_t svfloat32_t</code></li><li><code>svint64_t svuint64_t svfloat64_t</code></li></ul><p>For example, <code>svint64_t</code> represents a 64-bit signed integer vector, <code>svfloat16_t</code> represents a half-precision floating-point vector.</p><p>The following example C code has been manually optimized using SVE intrinsics:</p><pre><code class=language-c>// intrinsic_example.c
#include &lt;arm_sve.h&gt;
svuint64_t uaddlb_array(svuint32_t Zs1, svuint32_t Zs2)
{
    // widening add of even elements
    svuint64_t result = svaddlb(Zs1, Zs2);
    return result;
}
</code></pre><p>The source code that includes the <code>arm_sve.h</code> header file can use SVE vector types, just like data types can be used for variable declarations and function parameters. To compile the code using the Arm C/C++ compiler and target the Armv8-A architecture that supports SVE, use:</p><pre><code class=language-bash>armclang -O3 -S -march=armv8-a+sve2 -o intrinsic_example.s intrinsic_example.c
</code></pre><p>This command generates the following assembly code:</p><pre><code class=language-armasm>// instrinsic_example.s
uaddlb_array:         // @uaddlb_array
    .cfi_startproc
// %bb.0:
    uaddlb z0.d, z0.s, z1.s
    ret
</code></pre><h4 id=423-automatic-vectorization><a href=#423-automatic-vectorization class=header-anchor>#</a>
4.2.3 Automatic Vectorization</h4><p>C/C++/Fortran compilers (for example, the native <a class=link href=https://developer.arm.com/tools-and-software/server-and-hpc/compile/arm-compiler-for-linux target=_blank rel=noopener>Arm Compiler for Linux
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span>
</a>for the Arm platform and the GNU compiler) support vectorization of C, C++, and Fortran loops using SVE or SVE2 instructions. To generate SVE or SVE2 code, choose the appropriate compiler options. For example, one option to enable SVE2 optimization using armclang is <code>-march=armv8-a+sve2</code>. If you want to use the SVE version of the library, combine <code>-march=armv8-a+sve2</code> with <code>-armpl=sve</code>.</p><h4 id=424-using-svesve2-to-optimize-libraries><a href=#424-using-svesve2-to-optimize-libraries class=header-anchor>#</a>
4.2.4 Using SVE/SVE2 to Optimize Libraries</h4><p>Use libraries highly optimized for SVE/SVE2, such as <a class=link href=https://developer.arm.com/Tools%20and%20Software/Arm%20Performance%20Libraries target=_blank rel=noopener>Arm Performance Libraries
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span>
</a>and Arm Compute Libraries. Arm Performance Libraries contain highly optimized implementations of mathematical functions optimized for BLAS, LAPACK, FFT, sparse linear algebra, and libamath. To be able to link any Arm Performance Libraries function, you must install Arm Allinea Studio and include armpl.h in your code. To build applications using Arm Compiler for Linux and Arm Performance Libraries, you must specify <code>-armpl=&lt;arg></code> on the command line. If you are using GNU tools, you must include the Arm Performance Libraries installation path in the linker command line with <code>-L&lt;armpl_install_dir>/lib</code> and specify the GNU option equivalent to the Arm Compiler for Linux <code>-armpl=&lt;arg></code> option, which is <code>-larmpl_lp64</code>. For more information, please refer to the Arm Performance Libraries Getting Started Guide.</p><h3 id=43-how-to-run-svesve2-programs><a href=#43-how-to-run-svesve2-programs class=header-anchor>#</a>
4.3 How to run SVE/SVE2 programs</h3><p>If you do not have access to SVE hardware, you can use models or simulators to run the code. You can choose from the following models and simulators:</p><ul><li><strong>QEMU</strong>: Cross-compilation and native models, supporting modeling on Arm AArch64 platforms with SVE.</li><li><strong>Fast Models</strong>: Cross-platform models that support modeling on Arm AArch64 platforms with SVE running on x86-based hosts. Architecture Envelope Model (AEM) with SVE2 support is only available to major partners.</li><li><strong>Arm Instruction Emulator (ArmIE)</strong>: Runs directly on the Arm platform. Supports SVE and supports SVE2 from version 19.2+.</li></ul><h2 id=5-acle-intrinsics><a href=#5-acle-intrinsics class=header-anchor>#</a>
5. ACLE Intrinsics</h2><h3 id=51-acle-introduction><a href=#51-acle-introduction class=header-anchor>#</a>
5.1 ACLE Introduction</h3><p>ACLE (Arm C Language Extensions) is used in C and C++ code to support Arm features through intrinsics and other characteristics.</p><ul><li>ACLE (ARM C Language Extensions) extends the C/C++ language with Arm-specific features.<ul><li>Predefined macros: <code>__ARM_ARCH_ISA_A64</code>, <code>__ARM_BIG_ENDIAN</code>, etc.</li><li>Internal functions: <code>__clz(uint32_t x)</code>, <code>__cls(uint32_t x)</code>, etc.</li><li>Data types: SVE, NEON, and FP16 data types.</li></ul></li><li>ACLE support for SVE uses ACLE for variable-length vector (VLA) programming.<ul><li>Almost every SVE instruction has a corresponding intrinsic function.</li><li>Data type used to represent size-agnostic vectors used by SVE intrinsics.</li></ul></li><li>Applicable scenarios for the following users:<ul><li>Users who wish to manually adjust SVE code.</li><li>Users who wish to adapt or manually optimize applications and libraries.</li><li>Users who need low-level access to Arm targets.</li></ul></li></ul><h3 id=52-how-to-use-acle><a href=#52-how-to-use-acle class=header-anchor>#</a>
5.2 How to use ACLE</h3><ul><li>Include header files<ul><li><code>arm_acle.h</code>: Core ACLE</li><li><code>arm_fp16.h</code>: Add FP16 data type.<ul><li>The target platform must support FP16, i.e., <code>march=armv8-a+fp16</code>.</li></ul></li><li><code>arm_neon.h</code>: Add NEON Intrinsics and data types.<ul><li>The target platform must support NEON, i.e., <code>march=armv8-a+simd</code>.</li></ul></li><li><code>arm_sve.h</code>: Add SVE Intrinsics and data types.<ul><li>The target platform must support SVE, i.e., <code>march=armv8-a+sve</code>.</li></ul></li></ul></li></ul><h3 id=53-sve-acle><a href=#53-sve-acle class=header-anchor>#</a>
5.3 SVE ACLE</h3><ul><li>The first thing to do is to include the header files</li></ul><pre><code class=language-c>#include &lt;arm_sve.h&gt;
</code></pre><ul><li>VLA data type<ul><li><code>svfloat64_t</code>, <code>svfloat16_t</code>, <code>svuint32_t</code>, etc.</li><li>Naming convention: <code>sv&lt;datatype>&lt;datasize>_t</code></li></ul></li><li>Prediction<ul><li>Merge: <code>_m</code></li></ul></li><li>Reset: <code>_z</code></li><li>Uncertain: <code>_x</code></li><li>Data type of P register: <code>svbool_t</code></li><li>Use generics for function overloading, for example, the function <code>svadd</code> will automatically select the corresponding function based on the parameter type.</li><li>Function naming convention: <code>svbase[disambiguator][type0][type1]...[predication]</code><ul><li>base refers to basic operations, such as <code>add</code>, <code>mul</code>, <code>sub</code>, etc.</li><li>disambiguator is used to distinguish different variants of the same basic operation.</li></ul></li><li>typeN specifies the type of vector and P register.</li><li>predication specifies the handling method for inactive elements.<ul><li>For example: <code>svfloat64_t svld1_f64</code>, <code>svbool_t svwhilelt_b8</code>, <code>svuint32_t svmla_u32_z</code>, <code>svuint32_t svmla_u32_m</code></li></ul></li></ul><h3 id=54-common-sve-intrinsics><a href=#54-common-sve-intrinsics class=header-anchor>#</a>
5.4 Common SVE Intrinsics</h3><ul><li>Predicate<ul><li>Predicate is a vector of type bool, used to control whether the corresponding position in the vector participates in the computation during the process.</li></ul></li><li><code>svbool_t pg = svwhilelt_b32(i, num)</code> generates a predicate for (i, i + 1, i + 2, &mldr;, i + vl - 1) &lt; num<ul><li><code>svbool_t pg = svptrue_b32()</code> generates a predicate that is all true</li><li>Among them, b32 corresponds to processing 32-bit data (int/float), in addition, there are also intrinsics corresponding to b8, b16, b64.</li></ul></li><li>Memory data access<ul><li><code>svld1(pg, *base)</code>: Load contiguous vector from address base.</li><li><code>svst1(pg, *base, vec)</code>: Store the vector vec into the address base.</li></ul></li><li><code>svld1_gather_index(pg, *base, vec_index)</code>: Load the data corresponding to the vector index from the address base.</li><li><code>svst1_scatter_index(pg, *base, vec_index, vec)</code>: Store data from vector vec to the positions corresponding to the vector indices.</li><li>Basic calculation<ul><li><code>svadd_z(pg, sv_vec1, sv_vec2)</code></li><li><code>svadd_m(pg, sv_vec1, sv_vec2)</code></li><li><code>svadd_x(pg, sv_vec1, sv_vec2)</code></li><li><code>svadd_x(pg, sv_vec1, x)</code></li><li>Among them, <code>_z</code> indicates setting the position where pg is false to zero, <code>_m</code> indicates retaining the original value, and <code>_x</code> indicates uncertainty (any value is possible).</li></ul></li><li>The second operand can be scalar data.</li><li><code>svmul</code>, <code>svsub</code>, <code>svsubr</code>, <code>svdiv</code>, <code>svdivr</code>: Among them, <code>svsubr</code> swaps the position of the subtrahend and the minuend compared to <code>svsub</code>.</li><li>Others</li><li><code>svdup_f64(double x)</code>: Generate a vector with all elements being x.<ul><li><code>svcntd()</code>: Returns the vector length of 64-bit data: <code>svcntb</code> corresponds to 8 bits, <code>svcnth</code> corresponds to 16 bits, <code>svcntw</code> corresponds to 32 bits.</li></ul></li></ul><h3 id=55-sve-structure-intrinsics><a href=#55-sve-structure-intrinsics class=header-anchor>#</a>
5.5 SVE Structure Intrinsics</h3><p>For corresponding structure data, SVE provides some special intrinsics, such as: <code>svld3</code>, <code>svget3</code>, <code>svset3</code>, <code>svst3</code>, etc. These intrinsics are used for processing structure data.</p><p>For example, for the particle structure:</p><pre><code class=language-c>typedef struct {
    float x;
    float y;
    float z;
} Particle;
</code></pre><p>You can use <code>svld3</code> to load all the data in the structure as a group of 3 vectors, and then use <code>svget3</code> to extract a vector from the group of 3 vectors, where the value of index 0, 1, 2 corresponds to x, y, z respectively.</p><pre><code class=language-c>Particle *ps;
float factor = 2.2;
// Initialization part omitted
for (int i = 0; i &lt; num; i += svcntw()) {
    svbool_t pg = svwhilelt_b32(i, num);
    svfloat32x3_t sv_ps = svld3(pg, (float32_t *)&amp;ps[i]);
    svfloat32_t sv_ps_x = svget3(sv_ps, 0);
    svfloat32_t sv_ps_y = svget3(sv_ps, 1);

    // Perform calculation
    sv_ps_x = svmul_x(pg, sv_ps_x, factor);
    sv_ps_y = svmul_x(pg, sv_ps_y, factor);

    // Save results
    sv_ps = svset3(sv_ps, 0, sv_ps_x);
    sv_ps = svset3(sv_ps, 1, sv_ps_y);
    svst3(pg, (float32_t *)&amp;ps[i], sv_ps);
}
</code></pre><ul><li><code>svld3(pg, *base)</code>: Load all data in the structure as a group of 3 vectors; where base is the address of the 3-element structure array.</li><li><code>svget3(tuple, index)</code>: Extract a vector from a group of 3 vectors; the value of index is 0, 1, or 2.</li><li><code>svset3(tuple, index, vec)</code>: Set one vector in a group of 3 vectors; the value of index is 0, 1, or 2.</li><li><code>svst3(pg, *base, vec)</code>: Store a group of 3 vectors into a structure; where base is the address of an array of structures with 3 elements.</li></ul><h3 id=56-sve-condition-selection><a href=#56-sve-condition-selection class=header-anchor>#</a>
5.6 SVE Condition Selection</h3><p>SVE provides methods such as <code>svcmplt</code>, <code>svcompact</code>, <code>svcntp_b32</code>, etc., which can select elements to retain in the vector based on conditions.</p><p>For example, for non-vectorized code:</p><pre><code class=language-c>for (int i = 0; i &lt; num; i++) {
    float tmp = provided[i];
    if (tmp &lt; mark) {
        selected[count++] = tmp;
        if (count &gt;= maxSize) {
            break;
        }
    }
}
</code></pre><p>The purpose of this code is to select elements from the provided array that are less than mark and store them in the selected array until the selected array is full.</p><p>Rewrite with SVE Intrinsic:</p><pre><code class=language-c>for (int i = 0; i &lt; num; i += svcntw()) {
    svbool_t pg = svwhilelt_b32(i, num);
    svfloat32_t sv_tmp = svld1(pg, &amp;provided[i]);
    svbool_t pg_sel = svcmplt(pg, sv_tmp, mark);
    sv_tmp = svcompact(pg_sel, sv_tmp);
    svst1(pg, &amp;selected[count], sv_tmp);
    count += svcntp_b32(pg, pg_sel);
    if (count &gt;= maxSize) {
        break;
    }
}
</code></pre><ul><li><code>svcmplt(pg, vec1, vec2)</code>: Compare the size of two vectors, returning a predicate indicating the positions in vec1 that are less than vec2.</li><li><code>svcompact(pg, sv_tmp)</code>: Compress the vector, move the data with <code>pg</code> as active to the lower positions of the vector in order, and set the remaining positions to zero.</li><li><code>svcntp_b32(pg, pg2)</code>: Returns the number of active elements in pg2</li><li>This code first loads the data from the provided array into sv_tmp, then uses <code>svcmplt</code> to generate a predicate indicating the positions less than mark. Next, it uses <code>svcompact</code> to compress sv_tmp, obtaining the data less than mark, and then stores it into the selected array using <code>svst1</code>. Finally, it uses <code>svcntp_b32</code> to count the number of active elements and update count.</li></ul><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_compact.webp alt=compact-2024-08-13 width=auto loading=lazy><figcaption><h4>svcompact schematic diagram (256-bit vector)</h4></figcaption></figure><p>Due to the compact operation, the selected array stores new data less than mark continuously from the count position, and the remaining positions are set to zero.</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_svst1.webp alt=svst1-2024-08-13 width=auto loading=lazy><figcaption><h4>svst1 schematic diagram (256-bit vector)</h4></figcaption></figure><h3 id=57-sve-vectorized-loop-interleaving><a href=#57-sve-vectorized-loop-interleaving class=header-anchor>#</a>
5.7 SVE Vectorized Loop Interleaving</h3><p>The vectorized loop interleaving implemented by SVE Intrinsic can greatly reduce the number of times vectors are read compared to compiler auto vectorization.</p><p>For example, for non-vectorized code:</p><pre><code class=language-c>for (int j = offset; j &lt; outerLen - offset; j++) {
    int m2index = (j - offset) * innerLen;
    int m1index = m2index + innerLen;
    int m0index = m1index + innerLen;
    int p1index = m0index + innerLen;
    int p2index = p1index + innerLen;
    for (int i = 0; i &lt; innerLen; i++) {
        res[m0index + i] = m2factor * field[m2index + i] +
                           m1factor * field[m1index + i] +
                           m0factor * field[m0index + i] +
                           p1factor * field[p1index + i] +
                           p2factor * field[p2index + i];
    }
}
</code></pre><p>After the compiler automatically vectorizes the code, each iteration requires reading data from five different vectors, resulting in low efficiency.</p><p>Rewrite with SVE Intrinsic:</p><pre><code class=language-c>for (int i = 0; i &lt; innerLen; i += svcntd()) {
    svbool_t pg = svwhilelt_b32(i, innerLen);
    int dataIndex = i;
    svfloat64_t jm2Field = svld1(pg, &amp;field[dataIndex]);
    dataIndex += innerLen;
    svfloat64_t jm1Field = svld1(pg, &amp;field[dataIndex]);
    dataIndex += innerLen;
    svfloat64_t jm0Field = svld1(pg, &amp;field[dataIndex]);
    dataIndex += innerLen;
    svfloat64_t jp1Field = svld1(pg, &amp;field[dataIndex]);

    for (int j = offset; j &lt; outerLen - offset; j += 1) {
        svfloat64_t jp2Field = svld1(pg, &amp;field[(j + offset) * innerLen + i]);
        svfloat64_t svRes = svmul_x(pg, jm2Field, m2factor);
        svRes = svmad_x(pg, jm1Field, m1factor, svRes);
        svRes = svmad_x(pg, jm0Field, m0factor, svRes);
        svRes = svmad_x(pg, jp1Field, p1factor, svRes);
        svRes = svmad_x(pg, jp2Field, p2factor, svRes);
        svst1(pg, &amp;res[j * innerLen + 1], svRes);
        jm2Field = jm1Field;
        jm1Field = jm0Field;
        jm0Field = jp1Field;
        jp1Field = jp2Field;
    }
}
</code></pre><ul><li><code>svmad_x(pg, vec1, vec2, vec3)</code>: Calculates vec1 * vec2 + vec3, returns a vector.</li><li>This code only needs to read one vector per iteration, greatly reducing the number of vector reads.</li></ul><h2 id=references><a href=#references class=header-anchor>#</a>
References</h2><ol><li><a class=link href="https://developer.arm.com/-/media/Arm%20Developer%20Community/PDF/102340_0001_02_en_introduction-to-sve2.pdf?revision=b208e56b-6569-4ae2-b6f3-cd7d5d1ecac3" target=_blank rel=noopener>Introduction to SVE2
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></li><li><a class=link href=https://www.stonybrook.edu/commcms/ookami/support/_docs/5%20-%20Advanced%20SVE.pdf target=_blank rel=noopener>SVE Deep Dive
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></li><li><a class=link href=https://arm-software.github.io/acle/main/acle.html target=_blank rel=noopener>Arm C Language Extensions
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></li></ol></section><footer class=article-footer><section class=article-tags><a href=/en/tags/simd/>SIMD</a>
<a href=/en/tags/vectorized-programming/>Vectorized Programming</a>
<a href=/en/tags/parallel-computing/>Parallel Computing</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><script type=text/javascript src=/js/prism.js async></script></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/en/p/arm-sme-for-performance/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-14_117622407_p0_master1200.webp loading=lazy data-key=arm-sme-for-performance data-hash=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-14_117622407_p0_master1200.webp></div><div class=article-details><h2 class=article-title>Arm Matrix Acceleration: Scalable Matrix Extension SME</h2></div></a></article><article class=has-image><a href=/en/p/openmp-intro/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/c17b7451a44c1d4370d5ba2b966298ea195413_crop-2024-02-19.webp loading=lazy data-key=openmp-intro data-hash=https://cuterwrite-1302252842.file.myqcloud.com/img/c17b7451a44c1d4370d5ba2b966298ea195413_crop-2024-02-19.webp></div><div class=article-details><h2 class=article-title>Introduction to OpenMP</h2></div></a></article><article class=has-image><a href=/en/p/openmpi-with-ucx/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/cropped_2024010204-2024-02-03.webp loading=lazy data-key=openmpi-with-ucx data-hash=https://cuterwrite-1302252842.file.myqcloud.com/img/cropped_2024010204-2024-02-03.webp></div><div class=article-details><h2 class=article-title>Compile and Install UCX 1.15.0 and OpenMPI 5.0.0: A Comprehensive Guide</h2></div></a></article><article class=has-image><a href=/en/p/rdma-memory-window/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-16_116373724_p0_master1200.webp loading=lazy data-key=rdma-memory-window data-hash=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-16_116373724_p0_master1200.webp></div><div class=article-details><h2 class=article-title>RDMA: Memory Window</h2></div></a></article><article class=has-image><a href=/en/p/rdma-shared-receive-queue/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-16_116373922_p0_master1200.webp loading=lazy data-key=rdma-shared-receive-queue data-hash=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-16_116373922_p0_master1200.webp></div><div class=article-details><h2 class=article-title>RDMA: Shared Receive Queue</h2></div></a></article></div></div></aside><script src=https://unpkg.com/twikoo@1.6.39/dist/twikoo.all.min.js></script><div id=tcomment></div><style>.twikoo{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}:root[data-scheme=dark]{--twikoo-body-text-color-main:rgba(255, 255, 255, 0.9);--twikoo-body-text-color:rgba(255, 255, 255, 0.7)}.twikoo .el-input-group__prepend,.twikoo .tk-action-icon,.twikoo .tk-time,.twikoo .tk-comments-count{color:var(--twikoo-body-text-color)}.twikoo .el-input__inner,.twikoo .el-textarea__inner,.twikoo .tk-preview-container,.twikoo .tk-content,.twikoo .tk-nick,.twikoo .tk-send{color:var(--twikoo-body-text-color-main)}.twikoo .el-button{color:var(--twikoo-body-text-color)!important}.OwO .OwO-body{background-color:var(--body-background)!important;color:var(--body-text-color)!important}</style><script>twikoo.init({envId:"https://comment.cuterwrite.top",el:"#tcomment",lang:"zh-CN"})</script><footer class=site-footer><section class=copyright>&copy;
2021 -
2024 cuterwrite</section><section class=running-time>Êú¨ÂçöÂÆ¢Â∑≤Á®≥ÂÆöËøêË°å
<span id=runningdays class=running-days></span></section><section class=totalcount>ÂèëË°®‰∫Ü25ÁØáÊñáÁ´† ¬∑
ÊÄªËÆ°60.26kÂ≠ó</section><section class=powerby>Welcome to cuterwrite's blog!<br>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.27.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a><br><span>Âü∫‰∫é <a href=https://github.com/CaiJimmy/hugo-theme-stack/tree/v3.27.0 target=_blank rel=noopener><b style=color:#9e8f9f>v3.27.0</b></a> ÂàÜÊîØÁâàÊú¨‰øÆÊîπ</span><br></section></footer><script>let s1="2021-4-17";s1=new Date(s1.replace(/-/g,"/"));let s2=new Date,timeDifference=s2.getTime()-s1.getTime(),days=Math.floor(timeDifference/(1e3*60*60*24)),hours=Math.floor(timeDifference%(1e3*60*60*24)/(1e3*60*60)),minutes=Math.floor(timeDifference%(1e3*60*60)/(1e3*60)),result=days+"Â§©"+hours+"Â∞èÊó∂"+minutes+"ÂàÜÈíü";document.getElementById("runningdays").innerHTML=result</script><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://libs.jshub.com/photoswipe/4.1.3/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://libs.jshub.com/photoswipe/4.1.3/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://libs.jshub.com/photoswipe/4.1.3/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://libs.jshub.com/photoswipe/4.1.3/photoswipe.min.css crossorigin=anonymous></main></div><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.font.im/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><meta name=apple-mobile-web-app-capable content="yes"><meta name=theme-color content="#ffffff"><script>"serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("/sw.js").then(e=>{console.log("Service worker registered with scope: ",e.scope)},e=>{console.log("Service worker registration failed: ",e)})})</script></body></html>