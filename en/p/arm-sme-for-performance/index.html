<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="This article introduces the Scalable Matrix Extension (SME) in the Arm architecture, focusing on its efficient matrix computation capabilities in the Streaming SVE mode, and the mechanism of using the ZA array for large-scale data storage and flexible access, providing powerful hardware acceleration support for high-performance computing applications."><title>Arm Matrix Acceleration: Scalable Matrix Extension SME</title>
<link rel=canonical href=https://cuterwrite.top/en/p/arm-sme-for-performance/><link rel=stylesheet href=/scss/style.min.e82b84120b43b340665e4b3c6b625144c63ea87ec3a8572acc62bbd314e4204b.css><meta property='og:title' content="Arm Matrix Acceleration: Scalable Matrix Extension SME"><meta property='og:description' content="This article introduces the Scalable Matrix Extension (SME) in the Arm architecture, focusing on its efficient matrix computation capabilities in the Streaming SVE mode, and the mechanism of using the ZA array for large-scale data storage and flexible access, providing powerful hardware acceleration support for high-performance computing applications."><meta property='og:url' content='https://cuterwrite.top/en/p/arm-sme-for-performance/'><meta property='og:site_name' content="Cuterwrite's Blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='SIMD'><meta property='article:tag' content='向量化编程'><meta property='article:tag' content='并行计算'><meta property='article:published_time' content='2024-08-13T22:44:00+00:00'><meta property='article:modified_time' content='2024-08-13T22:44:00+00:00'><meta property='og:image' content='https://cloud.cuterwrite.fun/img/2024-08-14_117622407_p0_master1200.webp'><meta name=twitter:title content="Arm Matrix Acceleration: Scalable Matrix Extension SME"><meta name=twitter:description content="This article introduces the Scalable Matrix Extension (SME) in the Arm architecture, focusing on its efficient matrix computation capabilities in the Streaming SVE mode, and the mechanism of using the ZA array for large-scale data storage and flexible access, providing powerful hardware acceleration support for high-performance computing applications."><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://cloud.cuterwrite.fun/img/2024-08-14_117622407_p0_master1200.webp'><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><script async src=https://analytics.cuterwrite.top/uma.js data-website-id=b13594a2-4d15-4a4e-a020-5e3cc1d88c12 data-domains=cuterwrite.top></script><link rel=manifest href=/manifest.json></head><body class="article-page
line-numbers"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/en/><img src=/img/avatar_hu7627246953874065940.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>😉</span></figure><div class=site-meta><h1 class=site-name><a href=/en>Cuterwrite's Blog</a></h1><h2 class=site-description>Cuterwrite's tech blog, focusing on in-depth exploration and experience sharing in areas such as high-performance computing, operating systems, full-stack development, and artificial intelligence.</h2></div></header><ol class=menu-social><li><a href=https://analytics.cuterwrite.top/share/Ji0gm9OaLDk8gco7 target=_blank title=Analytics rel=me><svg width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 5H7A2 2 0 005 7v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"/><rect x="9" y="3" width="6" height="4" rx="2"/><path d="M9 17v-5"/><path d="M12 17v-1"/><path d="M15 17v-3"/></svg></a></li><li><a href=https://stats.uptimerobot.com/6NVhRHkSAQ target=_blank title=Uptime rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-chart-line"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 19h16"/><path d="M4 15l4-6 4 2 4-5 4 4"/></svg></a></li><li><a href=/index.xml target=_blank title=RSS rel=me><svg class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li><li><a href=https://github.com/PKUcoldkeyboard target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.zhihu.com/people/kong-tiao-cheng-tai-lang-30-57 target=_blank title=zhihu rel=me><svg t="1705591931290" class="icon" viewBox="0 0 1280 1024" p-id="21048" width="32" height="32"><path d="M341.08 296.26v435.08l46.86.02 15.42 52.74 84.02-52.74h99.06V296.26H341.08zm195.5 387.86H480.7l-55.8 35.02-10.16-34.94-23.8-.08V343.5h145.64v340.62zM299.66 495.34H195c3.48-54.2 4.4-103.18 4.4-146.92h102.32s3.94-45.12-17.16-44.62h-177c6.98-26.24 15.74-53.32 26.24-81.34.0.0-48.14.0-64.54 43.14-6.78 17.8-26.42 86.28-61.4 156.24 11.78-1.28 50.74-2.36 73.68-44.42 4.22-11.78 5.02-13.32 10.28-29.06h57.74c0 21-2.4 133.76-3.36 146.88H41.66c-23.48.0-31.12 47.24-31.12 47.24H141.7C132.9 642.2 85.66 726.24.0 792.68c40.98 11.7 81.82-1.86 102-19.8.0.0 45.96-41.8 71.18-138.5L281.1 764.26s15.82-53.78-2.48-79.98c-15.16-17.84-56.12-66.12-73.58-83.62L175.8 623.9c8.72-27.96 13.98-55.1 15.74-81.34h123.3s-.18-47.24-15.18-47.24v.02zm824.04-3.2c41.66-51.28 89.96-117.14 89.96-117.14s-37.3-29.6-54.76-8.12c-12 16.3-73.66 96.4-73.66 96.4l38.46 28.86zM823.52 373.96c-18.02-16.5-51.82 4.26-51.82 4.26s79.04 110.08 82.24 114.9l38.92-27.46s-51.34-75.22-69.32-91.72h-.02zM1280 516.7c-39.56.0-261.82 1.86-262.12 1.86v-202c9.62.0 24.84-.8 45.7-2.4 81.76-4.82 140.26-8 175.54-9.62.0.0 24.44-54.38-1.18-66.88-6.14-2.36-46.34 9.16-46.34 9.16s-330.44 32.98-464.72 36.1c3.2 17.64 15.24 34.16 31.56 39.1 26.62 6.96 45.38 3.4 98.3 1.78 49.66-3.2 87.36-4.86 113.02-4.86v199.62H702.82s5.64 44.62 51.02 45.7h215.88V706.1c0 27.94-22.38 43.98-48.96 42.24-28.16.22-52.16-2.3-83.38-3.62 3.98 7.94 12.66 28.78 38.62 43.68 19.76 9.62 32.34 13.14 52.04 13.14 59.12.0 91.34-34.56 89.78-90.62V564.28h244.72c19.36.0 17.4-47.56 17.4-47.56l.06-.02z" fill="#707070" p-id="21049"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/en/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页 | Home</span></a></li><li><a href=/en/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于 | About</span></a></li><li><a href=/en/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档 | Archives</span></a></li><li><a href=/en/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索 | Search</span></a></li><li><a href=https://gallery.cuterwrite.top target=_blank><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-album"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 4m0 2a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2z"/><path d="M12 4v7l2-2 2 2V4"/></svg>
<span>图册 | Gallery</span></a></li><li><a href=https://draw.cuterwrite.top target=_blank><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-artboard"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M8 8m0 1a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H9a1 1 0 01-1-1z"/><path d="M3 8h1"/><path d="M3 16h1"/><path d="M8 3v1"/><path d="M16 3v1"/><path d="M20 8h1"/><path d="M20 16h1"/><path d="M8 20v1"/><path d="M16 20v1"/></svg>
<span>画板 | Canvas</span></a></li><li><a href=https://it-tools.tech target=_blank><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-tools"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 21h4L20 8a1.5 1.5.0 00-4-4L3 17v4"/><path d="M14.5 5.5l4 4"/><path d="M12 8 7 3 3 7l5 5"/><path d="M7 8 5.5 9.5"/><path d="M16 12l5 5-4 4-5-5"/><path d="M16 17l-1.5 1.5"/></svg>
<span>工具 | Tools</span></a></li><li class=menu-bottom-section><ol class=menu><li id=i18n-switch><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language title=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://cuterwrite.top/>中文</option><option value=https://cuterwrite.top/en/ selected>English</option></select></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ul><li><a href=#1-sme-introduction>1. SME Introduction</a></li><li><a href=#2-streaming-sve-mode>2. Streaming SVE mode</a></li><li><a href=#3-switch-between-non-streaming-and-streaming-sve-modes>3. Switch between Non-streaming and Streaming SVE modes</a></li><li><a href=#4-sme-architecture-status>4. SME Architecture Status</a></li><li><a href=#5-za-array>5. ZA array</a><ul><li><a href=#51-za-array-vector-access>5.1 ZA array vector access</a></li><li><a href=#52-za-tiles>5.2 ZA tiles</a></li><li><a href=#53-za-tile-slices>5.3 ZA tile slices</a></li></ul></li><li><a href=#6-instructions-supported-in-steaming-sve-mode>6. Instructions supported in Steaming SVE mode</a></li><li><a href=#7-sme-directive>7. SME Directive</a><ul><li><a href=#71-outer-product-and-accumulate-or-subtract-instructions>7.1 Outer Product and Accumulate or Subtract Instructions</a><ul><li><a href=#711-fp32-fp64-outer-product-and-accumulate-or-subtract-instructions>7.1.1 FP32, FP64 outer product and accumulate or subtract instructions</a></li><li><a href=#712-fp16-bf16-int16-int8-i16i64-type-outer-product-and-accumulate-or-subtract-instructions>7.1.2 FP16, BF16, INT16, INT8, I16I64 type outer product and accumulate or subtract instructions</a></li></ul></li><li><a href=#72-sme-instructions-with-predication>7.2 SME Instructions with Predication</a></li><li><a href=#73-za-tile-and-addition-operation-with-a-z-vector>7.3 ZA tile and addition operation with a Z vector</a></li><li><a href=#74-tile-load-store-move-instructions>7.4 Tile load, store, move instructions</a><ul><li><a href=#741-tile-slice-load-and-store-instructions>7.4.1 Tile slice load and store instructions</a></li><li><a href=#742-tile-slice-move-instruction>7.4.2 Tile slice move instruction</a></li></ul></li><li><a href=#75-za-array-vector-loadstore-instructions>7.5 ZA array vector load/store instructions</a></li><li><a href=#76-za-tile-clear-instruction>7.6 ZA tile clear instruction</a></li><li><a href=#77-new-sve2-instructions>7.7 New SVE2 Instructions</a><ul><li><a href=#771-psel-instruction>7.7.1 PSEL Instruction</a></li></ul></li></ul></li><li><a href=#references>References</a></li></ul></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/en/p/arm-sme-for-performance/><img src=https://cloud.cuterwrite.fun/img/2024-08-14_117622407_p0_master1200.webp loading=lazy alt="Featured image of post Arm Matrix Acceleration: Scalable Matrix Extension SME"></a></div><div class=article-details><header class=article-category><a href=/en/categories/hpc/ style=background-color:#ffb900;color:#fff>High Performance Computing</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/en/p/arm-sme-for-performance/>Arm Matrix Acceleration: Scalable Matrix Extension SME</a></h2><h3 class=article-subtitle>This article introduces the Scalable Matrix Extension (SME) in the Arm architecture, focusing on its efficient matrix computation capabilities in the Streaming SVE mode, and the mechanism of using the ZA array for large-scale data storage and flexible access, providing powerful hardware acceleration support for high-performance computing applications.</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2024-08-13</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>10 minute read</time></div><div><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-keyboard"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M2 6m0 2a2 2 0 012-2h16a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2z"/><path d="M6 10v.01"/><path d="M10 10v.01"/><path d="M14 10v.01"/><path d="M18 10v.01"/><path d="M6 14v.01"/><path d="M18 14v.01"/><path d="M10 14l4 .01"/></svg>
<time class=article-time--wordcount>4581 words</time></div></footer><footer class=article-translations><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg><div><a href=https://cuterwrite.top/p/arm-sme-for-performance/ class=link>中文</a></div></footer></div></header><section class=article-content><h1 id=arm-matrix-acceleration-scalable-matrix-extension-sme><a href=#arm-matrix-acceleration-scalable-matrix-extension-sme class=header-anchor>#</a>
Arm Matrix Acceleration: Scalable Matrix Extension SME</h1><h2 id=1-sme-introduction><a href=#1-sme-introduction class=header-anchor>#</a>
1. SME Introduction</h2><p>Scalable Matrix Extension SME is built on the basis of Scalable Vector Extensions (SVE and SVE2) and adds the capability to efficiently handle matrices. The main features include:</p><ul><li>Calculate the SVE vector&rsquo;s outer product</li><li>Matrix tile storage</li><li>Loading, storing, inserting, and extracting tile vectors (including dynamic transposition)</li><li>Streaming SVE mode</li></ul><p>The table below summarizes the main features of SME, SVE, and SVE2:</p><div class=table-wrapper><table><thead><tr><th style=text-align:left>SME</th><th style=text-align:left>SVE</th><th style=text-align:left>SVE2</th></tr></thead><tbody><tr><td style=text-align:left>Streaming SVE Mode</td><td style=text-align:left>NEON DSP++</td><td style=text-align:left>Scalable Vector</td></tr><tr><td style=text-align:left>Dynamic Matrix Transpose</td><td style=text-align:left>Multi-Precision Arithmetic</td><td style=text-align:left>Per-Lane Predication</td></tr><tr><td style=text-align:left>Vector Cross Product</td><td style=text-align:left>Match Detection and Histogram</td><td style=text-align:left>Gather-load and Scatter-store</td></tr><tr><td style=text-align:left>Load, store, insert, and extract matrix vectors</td><td style=text-align:left>Non-temporal scatter/gather</td><td style=text-align:left>Predict vectorization</td></tr><tr><td style=text-align:left></td><td style=text-align:left>Bitwise Permute</td><td style=text-align:left>ML Extension (FP16 + DOT)</td></tr><tr><td style=text-align:left></td><td style=text-align:left>AE, SHA3, SM4, Crypto</td><td style=text-align:left>V8.6 BF16, FP and Int8 support</td></tr></tbody></table></div><p>SME has defined the following new features:</p><ul><li>New architecture state, can be used to store two-dimensional matrix tile</li><li>Streaming SVE mode, supports SVE2 instructions where the execution vector length matches the tile length.</li><li>New instruction to accumulate (or decrement) the outer product of two vectors into a matrix tile.</li><li>New load, store, and move instructions: Vectors can be written to a row or column of a matrix tile, or a row or column of a matrix tile can be read into a vector.</li></ul><p>Similar to SVE2, SME is also an extension that supports scalable vector length, enabling vector length agnosticism (VLA), per-lane predication, predication-driven loop control, and management functions.</p><h2 id=2-streaming-sve-mode><a href=#2-streaming-sve-mode class=header-anchor>#</a>
2. Streaming SVE mode</h2><p>SME introduced the Streaming SVE mode, which implements a subset of the SVE2 instruction set and adds new SME-specific instructions.</p><p>Streaming SVE mode supports high-throughput streaming data processing for large datasets, and streaming data usually has simple loop control flow and limited conditionality.</p><p>In Non-streaming SVE mode, the complete SVE2 instruction set is supported, typically handling complex data structures and complex judgments.</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-14_3443.webp alt="Streaming SVE Mode and Non-streaming SVE Mode" width=80% loading=lazy><figcaption><h4>Streaming SVE Mode and Non-streaming SVE Mode</h4></figcaption></figure><p>Most SME instructions are only available in Streaming SVE mode. The streaming vector length (SVL) in Streaming SVE mode may differ from the non-streaming vector length (NSVL).</p><p>The expectation is: SVL should be longer than or equal to NSVL, that is, SVL >= NSVL. For example, the length of NSVL can be 128-bit, while the length of SVL can be 512-bit.</p><p>The SVL of SME can be 128-bit, 256-bit, 512-bit, 1024-bit, or 2048-bit. SVL needs to be a power of 2, and NSVL needs to be a multiple of 128.</p><p>Similar to SVE2, the software can control the <code>SMCR_ELx.LEN</code> register bit to set the effective SVL length that EL1, EL2, EL3 want to use (it can be set shorter than the SVL supported by the hardware).</p><p>For more information on the Streaming SVE mode, refer to section B1.4.6 of the Arm Architecture Reference Manual (A-profile architecture).</p><h2 id=3-switch-between-non-streaming-and-streaming-sve-modes><a href=#3-switch-between-non-streaming-and-streaming-sve-modes class=header-anchor>#</a>
3. Switch between Non-streaming and Streaming SVE modes</h2><p>If the CPU hardware implementation supports both Streaming SVE mode of SME and Non-streaming SVE mode of SVE2, applications can dynamically switch between these two operation modes based on their needs.</p><p>Provide an independent operating mode for SME, allowing CPU hardware implementations to offer different vector lengths for the same application. For example, a CPU hardware implementation can choose to support a longer Streaming SVE mode vector length and optimize the hardware for stream operations suitable for high throughput.</p><p>Applications can easily switch dynamically between Streaming SVE mode and Non-streaming SVE mode. The <code>PSTATE.{SM, ZA}</code> bits introduced by SME can enable and disable Streaming SVE mode and SME ZA storage:</p><ul><li>SM: Enable and disable Streaming SVE mode</li><li>ZA: Enable and disable ZA storage access</li></ul><p>You can use the <code>MSR/MRS</code> instructions to operate the Streaming Vector Control Register (SVCR) to set and read the <code>PSTATE.{SM, ZA}</code> bits, with specific operations as follows:</p><ul><li><code>MSR SVCRSM, #&lt;imm> MSR SVCRSM, #</code></li><li><code>MSR SVCRZA, #&lt;imm></code></li><li><code>MSR SVCRSMZA, #&lt;imm></code></li></ul><p>The SMSTART instruction is an alias for the <code>MSR</code> instruction that sets <code>PSTATE.SM</code> and <code>PSTATE.ZA</code>.</p><ul><li><code>SMSTART</code>: Simultaneously enable Streaming SVE mode and ZA storage access</li><li><code>SMSTART SM</code>: Enable Streaming SVE mode</li><li><code>SMSTART ZA</code>: Enable ZA storage access</li></ul><p>The SMSTOP instruction is an alias for the <code>MSR</code> instruction that clears <code>PSTATE.SM</code> and <code>PSTATE.ZA</code>.</p><ul><li><code>SMSTOP</code>: Simultaneously disable Streaming SVE mode and ZA storage access</li><li><code>SMSTOP SM</code>: Disable Streaming SVE mode</li><li><code>SMSTOP ZA</code>: Disable ZA storage access</li></ul><p>The diagram below shows how the application switches between Streaming SVE mode and Non-streaming SVE mode:</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-15_Scalable_Matrix_p1.webp alt="Application switching Streaming SVE mode and Non-streaming SVE mode" width=50% loading=lazy><figcaption><h4>Application switching Streaming SVE mode and Non-streaming SVE mode</h4></figcaption></figure><p>For more information on switching between Streaming SVE mode and Non-Streaming SVE mode using SMSTART and SMSTOP, please refer to sections C6.2.327 and C6.2.328 of the Arm Architecture Reference Manual on A-profile architecture.</p><h2 id=4-sme-architecture-status><a href=#4-sme-architecture-status class=header-anchor>#</a>
4. SME Architecture Status</h2><p>Similar to SVE2, in Streaming SVE mode, it has <code>Z0-Z31</code> vector registers and <code>P0-P15</code> predicate registers.</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-15_4130_ARM2799_3_Scalable_Matrix_p1.webp alt="Streaming mode registers" width=70% loading=lazy></figure><p>The lowest numbered SVE vector register <code>Zn</code> also holds fixed-length <code>Vn</code>, <code>Qn</code>, <code>Dn</code>, <code>Sn</code>, <code>Hn</code>, and <code>Bn</code> registers.</p><p>When entering Streaming SVE mode (<code>PSTATE.SM</code> changes from 0 to 1) or exiting Streaming SVE mode (<code>PSTATE.SM</code> changes from 1 to 0), all these registers will be zeroed.</p><p>Most non-streaming SVE2 instructions can be used in Streaming SVE mode, but <strong>may use different vector lengths</strong> (streaming mode uses VSL length, non-streaming mode uses NVSL length). The <code>RDSVL</code> instruction can be used to read the current effective vector length VL.</p><pre><code class=language-armasm>// Read multiple of Streaming SVE vector register size to Xd

RDSVL &lt;Xd&gt;, #&lt;imm&gt;
</code></pre><blockquote class="alert-blockquote alert-note"><p class=alert-heading><svg viewBox="0 0 16 16" width="16" height="16"><path d="M0 8a8 8 0 1116 0A8 8 0 010 8zm8-6.5a6.5 6.5.0 100 13 6.5 6.5.0 000-13zM6.5 7.75A.75.75.0 017.25 7h1a.75.75.0 01.75.75v2.75h.25a.75.75.0 010 1.5h-2a.75.75.0 010-1.5h.25v-2h-.25a.75.75.0 01-.75-.75zM8 6a1 1 0 110-2 1 1 0 010 2z"/></svg>
<span>Note</span></p><p>Because SME supports Vector Length Agnostic (VLA), in Streaming SVE mode, software rarely needs to explicitly read the SVL vector length. In Non-streaming SVE mode, the RDSVL instruction is usually used to determine the value of SVL.</p></blockquote><h2 id=5-za-array><a href=#5-za-array class=header-anchor>#</a>
5. ZA array</h2><p>The newly introduced ZA (Z Array, ZA Storage) in SME is a two-dimensional (2D) square array with a size of SVL x SVL. It is called Z Array because the length of its rows and columns is consistent with the Zn registers in Streaming SVE mode.</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-15_4314_ARM2799_4_Scalable_Matrix_p1.webp alt="ZA array" width=50% loading=lazy><figcaption><h4>ZA array</h4></figcaption></figure><p>For example: If the vector length in Streaming SVE mode is 256-bit, i.e., the length of the Zn register is 256-bit, then the size of ZA is 256/8 bytes x 256/8 bytes.</p><p>The ZA array can be accessed in the following way:</p><ul><li>ZA array vector access</li><li>ZA tiles</li><li>ZA tile slices</li></ul><h3 id=51-za-array-vector-access><a href=#51-za-array-vector-access class=header-anchor>#</a>
5.1 ZA array vector access</h3><p>A row of the ZA array can be accessed as a vector of SVL length, and this vector can contain elements with data type lengths of 8-bit, 16-bit, 32-bit, 64-bit, or 128-bit, such as 32-bit fp32 floating-point numbers.</p><pre><code class=language-c>ZA.B[N], ZA.H[N], ZA.S[N], ZA.D[N], ZA.Q[N]
</code></pre><p>Among them, <code>B, H, S, D, Q</code> represent 8-bit, 16-bit, 32-bit, 64-bit, 128-bit, respectively.</p><p>The number of ZA array vectors is the same as the number of bytes in SVL. For example, if SLV is 256-bit, then the number of ZA array vectors is 32, and the range of N is from 0 to 31.</p><p>To support context switching, SME introduces new <code>LDR</code> and <code>STR</code> instructions for loading and storing a ZA array vector from memory.</p><pre><code class=language-armasm>LDR ZA[&lt;Wv&gt;, &lt;imm&gt;], [&lt;Xn|SP&gt;{, #&lt;imm&gt;, MUL VL}]
STR ZA[&lt;Wv&gt;, &lt;imm&gt;], [&lt;Xn|SP&gt;{, #&lt;imm&gt;, MUL VL}]
</code></pre><h3 id=52-za-tiles><a href=#52-za-tiles class=header-anchor>#</a>
5.2 ZA tiles</h3><p>ZA tile is a square two-dimensional submatrix within ZA. The width of a ZA tile is always SVL, which is the same as the width of the ZA array.</p><p>How many usable ZA tiles ZA can be divided into is determined by the size of the data type of the elements:</p><div class=table-wrapper><table><thead><tr><th style=text-align:left>Element Data Type Size</th><th style=text-align:left>Tile Quantity</th><th style=text-align:left>Tile Name</th></tr></thead><tbody><tr><td style=text-align:left>8-bit</td><td style=text-align:left>1</td><td style=text-align:left>ZA0.B</td></tr><tr><td style=text-align:left>16-bit</td><td style=text-align:left>2</td><td style=text-align:left>ZA0.H-ZA1.H</td></tr><tr><td style=text-align:left>32-bit</td><td style=text-align:left>4</td><td style=text-align:left>ZA0.S-ZA3.S</td></tr><tr><td style=text-align:left>64-bit</td><td style=text-align:left>8</td><td style=text-align:left>ZA0.D-ZA7.D</td></tr><tr><td style=text-align:left>128-bit</td><td style=text-align:left>16</td><td style=text-align:left>ZA0.Q-ZA15.Q</td></tr></tbody></table></div><ul><li>When the element data type is 8-bit, ZA can only be accessed as a ZA tile (ZA0.B).</li><li>When the element data type is 16-bit, ZA can be accessed as 2 ZA tiles (ZA0.H and ZA1.H).</li><li>When the element data type is 32-bit, ZA can be accessed as 4 ZA tiles (ZA0.S to ZA3.S).</li><li>When the element data type is 64-bit, ZA can be accessed as 8 ZA tiles (ZA0.D to ZA7.D).</li><li>When the element data type is 128-bit, ZA can be accessed as 16 ZA tiles (ZA0.Q to ZA15.Q).</li></ul><p>For example, if SVL is 256-bit and the element data type size is 8-bit, then ZA can be considered as ZA0.B, or it can be seen as 32 vectors (32 rows, each row size is 32 x 8-bit, i.e., 32 elements per row).</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-15_ZA0B.webp alt=ZA0.B width=50% loading=lazy></figure><p>If SVL is 256-bit and the element data type size is 16-bit, then ZA can be considered as 2 ZA tiles (ZA0.H and ZA1.H), with each tile considered as 16 vectors (16 rows, each row size is 16 x 16-bit, i.e., 16 elements per row).</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-15_ZA0H_ZA1H.webp alt="ZA0.H and ZA1.H" width=40% loading=lazy></figure><p>The advantage of doing this is to fully utilize ZA storage. In practical applications, for example, when the SVL is 256-bit, the element data type size is 32-bit, and the size of ZA is 256-bit x 256-bit, <strong>to perform an outer product operation on vectors in two Z registers</strong>, the outer product result is a 2D array of 8 x 8 floating-point numbers. This outer product only requires 1/4 of the storage space of ZA. By dividing ZA into 4 ZA tiles, ZA storage can be fully utilized.</p><h3 id=53-za-tile-slices><a href=#53-za-tile-slices class=header-anchor>#</a>
5.3 ZA tile slices</h3><p>A ZA tile can be accessed as a whole or in the form of individual ZA tile slices.</p><p>When accessed as a whole, instructions can be accessed using the name of the tile:</p><pre><code class=language-text>ZA0.B, ZA0.H-ZA1.H, ZA0.S-ZA3.S, ZA0.D-ZA7.D or ZA0.Q-ZA15.Q
</code></pre><p>A ZA tile slice is a one-dimensional array composed of <strong>continuous elements in the horizontal or vertical direction of its ZA tile</strong>, that is, a row or a column in the ZA tile.</p><p>Accessing a vector of a ZA tile is reading and writing a ZA tile slice:</p><ul><li>Horizontal or vertical ZA tile slice access is indicated by the <code>H</code> or <code>V</code> suffix following the ZA tile name.</li><li>A specific ZA tile slice is represented by an index, indicated by the slice index <code>[N]</code> following the ZA tile name.</li></ul><p>For example, if the SVL is 128 bits and the element data type size is 8-bit, then its horizontal and vertical ZA tile slice can be represented as shown in the figure below:</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-15_6724_ARM2799_7_Scalable_Matrix_p1.webp alt="ZA tile slices" width=50% loading=lazy></figure><p>For example, if the SVL is 128 bits and the element data type size is 16-bit, then its horizontal and vertical ZA tile slice can be represented as shown in the figure below:</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-15_6888_ARM2799_8_Scalable_Matrix_p1.webp alt="ZA tile slices" width=50% loading=lazy></figure><p>In order to improve the efficiency of hardware access to ZA tile and ZA tile slices, the ZA tile slices of a ZA tile are interleaved.</p><p>The image below shows an example of this interleaved arrangement. In this example, SVL is 256 bits, and the element data type size is 16 bits. This means that ZA can be viewed as two ZA tiles (ZA0H and ZA1H) and has interleaved horizontal tile slices:</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-15_4885_SME_interleave.webp alt="ZA tile slices" width=auto loading=lazy></figure><p>The figure below shows a mixed view of the horizontal and vertical ZA tile slice sizes for different element data types:</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-15_7673_SME_V_H.webp alt="ZA tile slices" width=auto loading=lazy></figure><p>The left columns show the different processing methods for each row of the ZA memory.</p><p>Set SIZE as the size of vector elements, where SIZE is 1, 2, 4, 8, 16, representing data types B, H, S, D, or Q, respectively.</p><p>Set NUM_OF_ELEMENTS as the number of elements in the vector, i.e., bytes_of(SVL)/SIZE.</p><p>Horizontal tile slice, <code>ZAnH.&lt;B|H|S|D|Q>[m]</code> accesses a vector that contains a whole row (m x SIZE + n) in ZA storage. The vector contains elements of data type B, H, S, D, or Q.</p><p>Vertical tile slice, <code>ZAnV.&lt;B|H|S|D|Q>[m] </code>accesses a vector that contains the entire column (m x SIZE) in ZA storage. This vector contains elements of data type B, H, S, D, or Q.</p><p><code>ZAnV.[m]</code> accesses a vector containing column (m x SIZE) and row elements (i x SIZE + n), where i ranges from 0 to NUM_OF_ELEMENTS-1. This vector contains elements of data types B, H, S, D, or Q.</p><p>Be careful with overlapping when applying mixed element data type sizes and horizontal and vertical tile slices.</p><p>For more information on ZA Array, ZA array vectors, tile, and tile slices, refer to sections B1.4.8 to B1.4.12 of the Arm Architecture Reference Manual for the A-profile architecture.</p><h2 id=6-instructions-supported-in-steaming-sve-mode><a href=#6-instructions-supported-in-steaming-sve-mode class=header-anchor>#</a>
6. Instructions supported in Steaming SVE mode</h2><p>Some instructions have limitations in Streaming SVE mode:</p><ul><li>Some SVE/SVE2 instructions become illegal to execute<ul><li>Gather-load and Scatter-store instructions</li><li>Use the SVE2 instruction of the First Fault register</li></ul></li><li>Most NEON instructions become UNDEFINED</li></ul><p>For more information about instructions affected by the Streaming SVE mode, please refer to the document &ldquo;Arm Architecture Reference Manual.&rdquo;</p><p>SME has added several new instructions, including:</p><ul><li>Matrix outer product and accumulate or subtract instructions, including FMOPA, UMOPA, and BFMOPA.<ul><li>SVE2 vector registers (Z0-Z31) serve as the row and column inputs for outer product operations.</li></ul></li><li>ZA storage stores the output results of the two-dimensional matrix tile.</li><li>Instructions for performing addition operations with the SVE2 Z vector and the rows or columns of ZA</li><li>Instruction for clearing ZA tiles</li><li>Added some instructions that can be used in both Streaming and Non-streaming modes.</li></ul><h2 id=7-sme-directive><a href=#7-sme-directive class=header-anchor>#</a>
7. SME Directive</h2><p>The main SME commands for operating ZA storage include:</p><ul><li>Calculate the cross product of two vectors, and then accumulate or decrement, and place the result into an instruction of a ZA tile.</li><li>Instructions to store or load SVE vectors (Z registers) into or from rows or columns of the ZA tile</li><li>In the horizontal or vertical direction, an SVE vector and ZA tile addition instruction</li><li>An instruction to add a multiple of the vector length in Streaming SVE mode to a scalar register</li></ul><h3 id=71-outer-product-and-accumulate-or-subtract-instructions><a href=#71-outer-product-and-accumulate-or-subtract-instructions class=header-anchor>#</a>
7.1 Outer Product and Accumulate or Subtract Instructions</h3><p>In order to help understand outer product and accumulate or subtract instructions, let&rsquo;s see how to use the outer product operation to perform matrix multiplication.</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-16_2313_Picture1_png-1280x960.webp alt="Outer product" width=auto loading=lazy></figure><p>Calculating the outer product of two vectors a and b will yield a result matrix C containing the outer product:</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-16_1665_Picture2_png-1280x960.webp alt="Outer product" width=auto loading=lazy></figure><p>Now consider the matrix multiplication operation of two matrices a and b:</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-16_8117_Picture3_png-1280x960.webp alt="Matrix multiplication" width=auto loading=lazy></figure><p>This matrix multiplication can be achieved by calculating two outer product operations and accumulating the two resulting matrices (which is the commonly used handwritten calculation method), as shown in the diagram below:</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-16_3731_Picture4_png-1280x960.webp alt="Matrix multiplication with outer product" width=auto loading=lazy></figure><p>SME introduced efficient outer product and accumulate or subtract instructions for the following data types:</p><ul><li>8-bit, 16-bit integers</li><li>FP16, BF16, FP32, and FP64 floating point numbers</li></ul><p>These instructions calculate the outer product of two vectors in two Z vector registers (Zn and Zm), accumulate or subtract the resulting array with the existing data in a ZA tile (ZAda), and store the result in the same ZA tile (ZAda). Each source vector is independently predicated by the corresponding control predicate registers (Pn and Pm).</p><div class=table-wrapper><table><thead><tr><th style=text-align:left>Output Array</th><th style=text-align:left>Input Vector</th><th style=text-align:left>Description</th><th style=text-align:left>Example</th></tr></thead><tbody><tr><td style=text-align:left>INT32</td><td style=text-align:left>INT8, INT8</td><td style=text-align:left>Store the sum of the outer products of four INT8s into each INT32 element</td><td style=text-align:left>SMOPA or SMOPS or UMOPA or UMOPS: Signed or unsigned integer outer product sum, and accumulate or subtract. For example: <code>UMOPS &lt;ZAda>.S, &lt;Pn>/M, &lt;Pm>/M, &lt;Zn>.B, &lt;Zm>.B</code></td></tr><tr><td style=text-align:left>INT32</td><td style=text-align:left>INT16, INT16</td><td style=text-align:left>Store the sum of the outer product of two INT16 in each INT32 element</td><td style=text-align:left>SMOPA or SMOPS or UMOPA or UMOPS: Signed or unsigned integer outer product sum, and accumulate or subtract. For example: <code>UMOPS &lt;ZAda>.S, &lt;Pn>/M, &lt;Pm>/M, &lt;Zn>.H, &lt;Zm>.H</code></td></tr><tr><td style=text-align:left>INT64</td><td style=text-align:left>INT16, INT16</td><td style=text-align:left>If FEAT_SME_I16I64 is implemented, the sum of the outer products of four INT16s is stored in each INT64 element</td><td style=text-align:left>SMOPA or SMOPS or UMOPA or UMOPS: signed or unsigned integer outer product sum, and accumulate or subtract. For example: <code>UMOPS &lt;ZAda>.D, &lt;Pn>/M, &lt;Pm>/M, &lt;Zn>.H, &lt;Zm>.H</code></td></tr><tr><td style=text-align:left>FP32</td><td style=text-align:left>BF16, BF16</td><td style=text-align:left>Store the sum of two BF16 outer products into each FP32 element</td><td style=text-align:left>BFMOPA or BFMOPS: BFloat16 outer product sum, with accumulation or subtraction. For example: <code>BFMOPS &lt;ZAda>.S, &lt;Pn>/M, &lt;Pm>/M, &lt;Zn>.H, &lt;Zm>.H</code></td></tr><tr><td style=text-align:left>FP32</td><td style=text-align:left>FP16, FP16</td><td style=text-align:left>Store the sum of two FP16 outer products into each FP32 element</td><td style=text-align:left>FMOPA or FMOPS: Half-precision floating-point outer product sum, and accumulate or subtract. For example: <code>FMOPS &lt;ZAda>.S, &lt;Pn>/M, &lt;Pm>/M, &lt;Zn>.H, &lt;Zm>.H</code></td></tr><tr><td style=text-align:left>FP32</td><td style=text-align:left>FP32, FP32</td><td style=text-align:left>Simple FP32 outer product</td><td style=text-align:left>FMOPA or FMOPS: Floating-point outer product and accumulate or subtract. For example: <code>FMOPS &lt;ZAda>.S, &lt;Pn>/M, &lt;Pm>/M, &lt;Zn>.S, &lt;Zm>.S</code></td></tr><tr><td style=text-align:left>FP64</td><td style=text-align:left>FP64, FP64</td><td style=text-align:left>If FEAT_SME_F64F64 is implemented, perform a simple FP64 outer product</td><td style=text-align:left>FMOPA or FMOPS: Floating point outer product and accumulate or subtract. For example: <code>FMOPS &lt;ZAda>.D, &lt;Pn>/M, &lt;Pm>/M, &lt;Zn>.D, &lt;Zm>.D</code></td></tr></tbody></table></div><h4 id=711-fp32-fp64-outer-product-and-accumulate-or-subtract-instructions><a href=#711-fp32-fp64-outer-product-and-accumulate-or-subtract-instructions class=header-anchor>#</a>
7.1.1 FP32, FP64 outer product and accumulate or subtract instructions</h4><p>Instructions where the input vectors and output arrays have the same data type (FP32, FP64) are relatively simple.</p><p>The following example demonstrates FP32 type outer product with accumulation or subtraction instructions.</p><pre><code class=language-armasm>FMOPA &lt;ZAda&gt;.S, &lt;Pn&gt;/M, &lt;Pm&gt;/M, &lt;Zn&gt;.S, &lt;Zm&gt;.S
FMOPS &lt;ZAda&gt;.S, &lt;Pn&gt;/M, &lt;Pm&gt;/M, &lt;Zn&gt;.S, &lt;Zm&gt;.S
</code></pre><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-16_3613751670-667e5f923c64.webp alt="FMOPA and FMOPS" width=auto loading=lazy></figure><p>In this example, assuming the SVL vector length is 128, <code>Zn.S</code> and <code>Zm.S</code> contain vectors composed of 4 FP32 numbers, this instruction calculates the outer product of <code>Zn.S</code> and <code>Zm.S</code>, the result of the outer product is the gray matrix in the figure, then accumulates or subtracts this outer product result with the existing values in the ZA tile <code>ZAda.S</code>, and stores the result in the same ZA tile.</p><h4 id=712-fp16-bf16-int16-int8-i16i64-type-outer-product-and-accumulate-or-subtract-instructions><a href=#712-fp16-bf16-int16-int8-i16i64-type-outer-product-and-accumulate-or-subtract-instructions class=header-anchor>#</a>
7.1.2 FP16, BF16, INT16, INT8, I16I64 type outer product and accumulate or subtract instructions</h4><p>Because these instructions will expand the data type of the calculation results, these operations are not as straightforward as the previous FP32 and FP64 type instructions.</p><ul><li>BF16 instruction calculates the outer product of two BF16s, expands the result type to FP32, and then destructively adds or subtracts the result with the target tile.</li><li>INT8 instructions compute the sum of the outer product of four INT8s, expanding the result type to INT32, and then perform destructive addition or subtraction of the result with the target tile.</li><li>INT16 instruction calculates the outer product sum of two INT16s, expands the result type to INT32, and then performs a destructive add or subtract with the target tile.</li><li>FP16 instructions calculate the sum of the outer product of two FP16s, expand the result type to FP32, and then perform destructive addition or subtraction of the result with the target tile.</li><li>If FEAT_SME_I16I64 is implemented, the I16I64 instruction calculates the sum of the outer products of four INT16s, expands the result type to INT64, and then destructively adds or subtracts the result with the target tile.</li></ul><p>The following example demonstrates the operation of the INT8 UMOPA instruction with an SVL vector length of 128:</p><pre><code class=language-armasm>UMOPA &lt;ZAda&gt;.S, &lt;Pn&gt;/M, &lt;Pm&gt;/M, &lt;Zn&gt;.B, &lt;Zm&gt;.B
</code></pre><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-16_1030_Picture6_png-1280x960.webp alt="INT8 UMOPA" width=auto loading=lazy></figure><p>Each input register (<code>Zn.B</code>, <code>Zm.B</code>) is treated as a matrix containing 4x4 elements, which can be seen as blocks composed of 4 consecutive elements (as marked by the red lines in the diagram) that have been transposed.</p><p>In this example, because the SVL vector length is 128-bit:</p><ul><li>The first source vector <code>Zn.B</code> contains a 4x4 submatrix of unsigned 8-bit integers.</li><li>The second source vector <code>Zm.B</code>, contains a 4x4 submatrix of unsigned 8-bit integers.</li><li>UMOPA instruction calculates the sum of the 4x4 expanded 32-bit integer outer product, then destructively accumulates the integers in the target tile (ZAda).</li></ul><p>More generally, the UMOPA instruction multiplies submatrices from the first source vector with submatrices from the second source vector. Each source vector contains a submatrix of unsigned 8-bit integers of size (SVL/32) x 4. The resulting (SVL/32) x (SVL/32) expanded 32-bit integer outer product is then destructively added to a 32-bit integer target tile.</p><p>The following example demonstrates the operation of a BF16 BFMOPA with an SVL of 128-bit:</p><pre><code class=language-armasm>BFMOPA &lt;ZAda&gt;.S, &lt;Pn&gt;/M, &lt;Pm&gt;/M, &lt;Zn&gt;.H, &lt;Zm&gt;.H
</code></pre><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-16_6545_Picture7_png-1280x960.webp alt="BF16 BFMOPA" width=auto loading=lazy></figure><p>In this example, because the SVL vector length is 128-bit:</p><ul><li>The first source vector <code>Zn.H</code>, contains a 4x2 submatrix of BF16 integers, which is expanded into single-precision floating-point numbers.</li><li>The second source vector <code>Zm.H</code>, contains a 2x4 submatrix of a BF16 integer, which is expanded into a single-precision floating-point number.</li><li>BMOPA instruction calculates the sum of a 4x4 single-precision outer product, and then destructively accumulates it with the single-precision floating-point numbers in the target tile (ZAda).</li></ul><p>More generally speaking, the BFMOPA instruction expands the type of the (SVL/32) x2 BF16 submatrix stored in the first source vector to single precision, expands the type of the 2x (SVL/32) BF16 submatrix stored in the second source vector to single precision, and multiplies these two submatrices. Then, the resulting (SVL/32) x (SVL/32) single-precision outer product is destructively added to a single-precision target tile.</p><p>The following table shows the number of MACs (Multiply-Accumulate) for the corresponding data type performed by an outer product and accumulate or subtract instruction for several data types and SVL lengths:</p><div class=table-wrapper><table><thead><tr><th style=text-align:left></th><th style=text-align:left>128-bit</th><th style=text-align:left>256-bit</th><th style=text-align:left>512-bit</th></tr></thead><tbody><tr><td style=text-align:left>FP32</td><td style=text-align:left>16</td><td style=text-align:left>64</td><td style=text-align:left>256</td></tr><tr><td style=text-align:left>FP64</td><td style=text-align:left>4</td><td style=text-align:left>16</td><td style=text-align:left>64</td></tr><tr><td style=text-align:left>INT8</td><td style=text-align:left>64</td><td style=text-align:left>256</td><td style=text-align:left>1024</td></tr><tr><td style=text-align:left>INT16</td><td style=text-align:left>32</td><td style=text-align:left>128</td><td style=text-align:left>512</td></tr><tr><td style=text-align:left>BF16</td><td style=text-align:left>32</td><td style=text-align:left>128</td><td style=text-align:left>512</td></tr><tr><td style=text-align:left>FP16</td><td style=text-align:left>32</td><td style=text-align:left>128</td><td style=text-align:left>512</td></tr></tbody></table></div><h3 id=72-sme-instructions-with-predication><a href=#72-sme-instructions-with-predication class=header-anchor>#</a>
7.2 SME Instructions with Predication</h3><p>Each source vector can be independently predicated by its corresponding control predicate register:</p><ul><li>Outer product and accumulate or subtract instructions use Pn/M and Pn/M (without /Z form): Inactive source elements are treated as having a value of 0.</li><li>Slice move command uses Pg/M: The Inactive elements in the target slice remain unchanged.</li><li>Tile slice load instruction uses Pg/Z: Inactive elements in the target tile slice are set to 0.</li><li>Tile slice store instruction uses Pg: Inactive elements that will not be written to memory.</li></ul><p>Predication makes it easier to handle cases where the dimensions of the matrix are not a multiple of SVL.</p><p>For example, the instructions in the image below:</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-16_2656_Picture12_png-600x0.webp alt="SME prediction" width=auto loading=lazy></figure><p>The input vector <code>Z0</code> is predicated by <code>P0</code>, <code>Z1</code> is predicated by <code>P1</code>.</p><p>In this example:</p><ul><li>SVL vector length is 512-bit.</li><li>The Z register contains a vector of 16 FP32 numbers.</li><li>The last two elements in <code>P0</code> are inactive.</li><li>The last element in <code>P1</code> is inactive.</li></ul><p>This instruction updates (16-2) x (16-1) FP32 elements in <code>ZA0.S</code>, because <code>Pn/M</code> is used, the remaining elements in <code>ZA0.S</code> remain unchanged.</p><p>The figure below shows more examples of predicated outer products with accumulation or subtraction. The underlined text in the figure indicates the parts of the calculation affected by inactive predicate elements.</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-16_2072_Picture14_png-1280x960.webp alt="SME prediction FMOPA" width=auto loading=lazy></figure><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-16_3513_Picture16_png-1280x960.webp alt="SME prediction UMOPA" width=auto loading=lazy></figure><h3 id=73-za-tile-and-addition-operation-with-a-z-vector><a href=#73-za-tile-and-addition-operation-with-a-z-vector class=header-anchor>#</a>
7.3 ZA tile and addition operation with a Z vector</h3><p>SME includes instructions to add a vector to the rows or columns of a ZA tile, and these instructions also support predication.</p><div class=table-wrapper><table><thead><tr><th style=text-align:left>Instruction</th><th style=text-align:left>Description</th></tr></thead><tbody><tr><td style=text-align:left>ADDHA</td><td style=text-align:left>Add the source vector to each horizontal slice of the ZA tile</td></tr><tr><td style=text-align:left>ADDVA</td><td style=text-align:left>Add the source vector to each vertical slice of the ZA tile</td></tr></tbody></table></div><p>For example:</p><pre><code class=language-armasm>ADDHA ZA0.S, P0/M, P1/M, Z1.S
</code></pre><p>Will perform the following actions:</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-16_ARM2799_9_Scalable_Matrix_p2_png-1200x0.webp alt="SME ADDHA" width=auto loading=lazy></figure><p>This ADDHA instruction adds each element of the source vector Z1 to the corresponding active element of each horizontal slice of the ZA0.S tile.</p><p>Elements in a Tile are predicated by a pair of governing predicates. An element in a horizontal slice can be considered active under the following conditions:</p><ul><li>It is TRUE for the element corresponding to the second governing predicate, and</li><li>It corresponds to TRUE at the row number of the first governing predicate&rsquo;s horizontal slice, and the inactive elements in the target tile remain unchanged.</li></ul><h3 id=74-tile-load-store-move-instructions><a href=#74-tile-load-store-move-instructions class=header-anchor>#</a>
7.4 Tile load, store, move instructions</h3><p>SME tile load, store, move instructions can:</p><ul><li>Read data from memory and place it into a row or column of the ZA tile</li><li>Write the row or column of the ZA tile into memory</li><li>Move the row of the ZA tile to the SVE Z vector register</li><li>Move the SVE Z vector register to a ZA tile row or column</li></ul><h4 id=741-tile-slice-load-and-store-instructions><a href=#741-tile-slice-load-and-store-instructions class=header-anchor>#</a>
7.4.1 Tile slice load and store instructions</h4><p>The LD1B, LD1H, LD1S, LD1D, and LD1Q instructions load consecutive memory values into a ZA tile slice with 8-bit, 16-bit, 32-bit, 64-bit, or 128-bit elements, respectively.</p><p>The ST1B, ST1H, ST1S, ST1D, and ST1Q instructions store a ZA tile slice containing 8-bit, 16-bit, 32-bit, 64-bit, or 128-bit elements, respectively, into contiguous memory.</p><p>These instructions also support predication, for example:</p><pre><code class=language-armasm>LD1B ZA0H.B[W0, #imm], P0/Z, [X1, X2]
</code></pre><p>This LD1B instruction performs a predicated continuous byte read, reading data from memory at address (X1+X2) into the horizontal tile slice in ZA0 at row number (W0+imm). Inactive elements in the target tile slice are set to 0.</p><pre><code class=language-armasm>ST1H ZA1V.H[W0, #imm], P2, [X1, X2, LSL #1]
</code></pre><p>This ST1H instruction executes a predicated continuous halfword store operation, storing the vertical tile slice in ZA1 with the column number (W0+imm) to the memory address (X1+X2*2), and elements that are inactive in the tile slice are not written to memory.</p><h4 id=742-tile-slice-move-instruction><a href=#742-tile-slice-move-instruction class=header-anchor>#</a>
7.4.2 Tile slice move instruction</h4><p>The MOV instruction (alias for the MOVA instruction) moves the value of a Z vector register to a ZA tile slice, or moves the value from a ZA tile slice to a Z vector register. This instruction operates on a single horizontal or vertical tile slice of a ZA tile with a specified element size. The row number/column number of the slice is specified by the slice&rsquo;s retrieval register plus an immediate offset. Inactive elements in the target slice remain unchanged.</p><p>For example:</p><pre><code class=language-armasm>MOV     ZA0H.B[W0, #imm],  P0/M, Z0.B
</code></pre><p>Or</p><pre><code class=language-armasm>MOVA  ZA0H.B[W0, #imm],  P0/M, Z0.B
</code></pre><p>This instruction moves the values in vector register <code>Z0.B</code> to the horizontal ZA tile slice <code>ZA0H.B[W0,#imm]</code>, using <code>P0</code> as the predication register. Inactive elements in the target tile slice remain unchanged.</p><h3 id=75-za-array-vector-loadstore-instructions><a href=#75-za-array-vector-loadstore-instructions class=header-anchor>#</a>
7.5 ZA array vector load/store instructions</h3><p>SME LDR instruction reads data from memory into a ZA array vector, SME STR instruction stores the values from a ZA array vector into memory.
These instructions do not have predication functionality. They are primarily for saving/restoring ZA storage during software context switching. SME LDR/STR instructions can also be used in Non-streaming SVE mode when PSTATE.ZA is enabled.
For example, the ZA array vector in the following STR instruction is specified by a vector selection register Wv (scalar register W) plus an optional immediate number (Wv+Imm). The address for accessing memory is: a scalar register as the base, plus the same optional immediate offset multiplied by the current vector length in bytes.</p><pre><code class=language-armasm>STR ZA[&lt;Wv&gt;, &lt;imm&gt;], [&lt;Xn|SP&gt;{, #&lt;imm&gt;, MUL VL}]
</code></pre><h3 id=76-za-tile-clear-instruction><a href=#76-za-tile-clear-instruction class=header-anchor>#</a>
7.6 ZA tile clear instruction</h3><p>SME ZERO instruction can clear a group of 64-bit ZA tile:</p><pre><code class=language-armasm>ZERO { &lt;mask&gt;}
</code></pre><p>The ZERO instruction can zero out up to 8 ZA tiles named <code>ZA0.D</code> to <code>ZA8.D</code>. The tiles to be zeroed are specified by the mask in the instruction, while the remaining tiles remain unchanged.</p><p>This instruction can also be used in Non-streaming SVE mode when <code>PSTATE.ZA</code> is enabled.</p><p>If you want to clear the entire ZA array, you can use an instruction alias, <code>ZERO {ZA}</code>.</p><h3 id=77-new-sve2-instructions><a href=#77-new-sve2-instructions class=header-anchor>#</a>
7.7 New SVE2 Instructions</h3><p>The SME architecture extension has added some new SVE2 instructions, which can also be used in PE that implements SVE2 when in Non-streaming SVE mode. These instructions include:</p><ul><li>Select a predicate register or an all-false Predicate select instruction</li><li>Reverse 64-bit double word element instruction</li><li>Signed/Unsigned clamp to smaller/larger value vector instructions</li></ul><p>The following introduces the Predicate select instruction.</p><h4 id=771-psel-instruction><a href=#771-psel-instruction class=header-anchor>#</a>
7.7.1 PSEL Instruction</h4><p>PSEL instruction selects a predicate register or all-false to the target predicate register, as follows:</p><pre><code class=language-armasm>PSEL &lt;Pd&gt;, &lt;Pn&gt;, &lt;Pm&gt;.&lt;T&gt;[&lt;Wv&gt;, &lt;imm&gt;]
</code></pre><p>If the element specified in the second source predicate register (Pm) is True, this instruction places the content of the first source predicate register (Pn) into the destination predicate register (Pd), otherwise, it sets the value of the destination predicate register to all false.
For example, the following instruction, assuming the value of W12 is 0:</p><pre><code class=language-armasm>PSEL P0, P1, P2.B[W12, #0]
</code></pre><p>The [0]th element of the second source predicate register [W12+0] is False, so the target register P0 is set to all 0 (all-false), as shown in the figure below:</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-16_4401_Picture10_png-1280x960.webp alt="SME PSEL" width=auto loading=lazy></figure><p>Now look at the following instruction, still assuming the value of W12 is 0, but this time the immediate offset is 1:</p><pre><code class=language-armasm>PSEL P0, P1, P2.B[W12, #1]
</code></pre><p>The [1] element of the second source predicate register [W12+1] is True, therefore select the value of the first source predicate register to the destination register P0, as shown in the diagram below:</p><figure><img src=https://cloud.cuterwrite.fun/img/2024-08-16_0116_Picture11_png-1280x960.webp alt="SME PSEL" width=auto loading=lazy></figure><h2 id=references><a href=#references class=header-anchor>#</a>
References</h2><ul><li><a class=link href=https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/arm-scalable-matrix-extension-introduction target=_blank rel=noopener>Arm Scalable Matrix Extension (SME) Introduction
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></li><li><a class=link href=https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/arm-scalable-matrix-extension-introduction-p2 target=_blank rel=noopener>Arm Scalable Matrix Extension (SME) Instructions
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></li></ul></section><footer class=article-footer><section class=article-tags><a href=/en/tags/simd/>SIMD</a>
<a href=/en/tags/vectorized-programming/>Vectorized Programming</a>
<a href=/en/tags/parallel-computing/>Parallel Computing</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><script type=text/javascript src=/js/prism.js async></script></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/en/p/arm-sve-for-performance/><div class=article-image><img src=https://cloud.cuterwrite.fun/img/2024-06-29_117622464_p0_master1200.webp loading=lazy data-key=arm-sve-for-performance data-hash=https://cloud.cuterwrite.fun/img/2024-06-29_117622464_p0_master1200.webp></div><div class=article-details><h2 class=article-title>Arm Performance Optimization: Scalable Vector Extension SVE</h2></div></a></article><article class=has-image><a href=/en/p/openmp-intro/><div class=article-image><img src=https://cloud.cuterwrite.fun/img/c17b7451a44c1d4370d5ba2b966298ea195413_crop-2024-02-19.webp loading=lazy data-key=openmp-intro data-hash=https://cloud.cuterwrite.fun/img/c17b7451a44c1d4370d5ba2b966298ea195413_crop-2024-02-19.webp></div><div class=article-details><h2 class=article-title>Introduction to OpenMP</h2></div></a></article><article class=has-image><a href=/en/p/openmpi-with-ucx/><div class=article-image><img src=https://cloud.cuterwrite.fun/img/cropped_2024010204-2024-02-03.webp loading=lazy data-key=openmpi-with-ucx data-hash=https://cloud.cuterwrite.fun/img/cropped_2024010204-2024-02-03.webp></div><div class=article-details><h2 class=article-title>Compile and Install UCX 1.15.0 and OpenMPI 5.0.0: A Comprehensive Guide</h2></div></a></article><article class=has-image><a href=/en/p/rdma-memory-window/><div class=article-image><img src=https://cloud.cuterwrite.fun/img/2024-06-16_116373724_p0_master1200.webp loading=lazy data-key=rdma-memory-window data-hash=https://cloud.cuterwrite.fun/img/2024-06-16_116373724_p0_master1200.webp></div><div class=article-details><h2 class=article-title>RDMA: Memory Window</h2></div></a></article><article class=has-image><a href=/en/p/rdma-shared-receive-queue/><div class=article-image><img src=https://cloud.cuterwrite.fun/img/2024-06-16_116373922_p0_master1200.webp loading=lazy data-key=rdma-shared-receive-queue data-hash=https://cloud.cuterwrite.fun/img/2024-06-16_116373922_p0_master1200.webp></div><div class=article-details><h2 class=article-title>RDMA: Shared Receive Queue</h2></div></a></article></div></div></aside><script src=https://unpkg.com/twikoo@1.6.39/dist/twikoo.all.min.js></script><div id=tcomment></div><style>.twikoo{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}:root[data-scheme=dark]{--twikoo-body-text-color-main:rgba(255, 255, 255, 0.9);--twikoo-body-text-color:rgba(255, 255, 255, 0.7)}.twikoo .el-input-group__prepend,.twikoo .tk-action-icon,.twikoo .tk-time,.twikoo .tk-comments-count{color:var(--twikoo-body-text-color)}.twikoo .el-input__inner,.twikoo .el-textarea__inner,.twikoo .tk-preview-container,.twikoo .tk-content,.twikoo .tk-nick,.twikoo .tk-send{color:var(--twikoo-body-text-color-main)}.twikoo .el-button{color:var(--twikoo-body-text-color)!important}.OwO .OwO-body{background-color:var(--body-background)!important;color:var(--body-text-color)!important}</style><script>twikoo.init({envId:"https://comment.cuterwrite.top",el:"#tcomment",lang:"zh-CN"})</script><footer class=site-footer><section class=copyright>&copy;
2021 -
2024 cuterwrite</section><section class=running-time>本博客已稳定运行
<span id=runningdays class=running-days></span><br>总访客数：
<span id=busuanzi_value_site_uv class=running-days>Loading</span><br>总访问量：
<span id=busuanzi_value_site_pv class=running-days>Loading</span></section><section class=totalcount>发表了
<span class=running-days>25</span> 篇文章 ·
总计
<span class=running-days>60.67k</span> 字</section><section class=powerby><hr>Built with <b><a style=color:#9e8f9f href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a></b><br>Theme <b><a style=color:#9e8f9f href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.27.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a><br><span>基于 <a href=https://github.com/CaiJimmy/hugo-theme-stack/tree/v3.27.0 target=_blank rel=noopener><b style=color:#9e8f9f>v3.27.0</b></a> 分支版本修改</span><br></section></footer><script>let s1="2021-4-17";s1=new Date(s1.replace(/-/g,"/"));let s2=new Date,timeDifference=s2.getTime()-s1.getTime(),days=Math.floor(timeDifference/(1e3*60*60*24)),hours=Math.floor(timeDifference%(1e3*60*60*24)/(1e3*60*60)),minutes=Math.floor(timeDifference%(1e3*60*60)/(1e3*60)),result=days+"天"+hours+"小时"+minutes+"分钟";document.getElementById("runningdays").innerHTML=result</script><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://libs.jshub.com/photoswipe/4.1.3/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://libs.jshub.com/photoswipe/4.1.3/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://libs.jshub.com/photoswipe/4.1.3/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://libs.jshub.com/photoswipe/4.1.3/photoswipe.min.css crossorigin=anonymous></main></div><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.font.im/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><meta name=apple-mobile-web-app-capable content="yes"><meta name=theme-color content="#ffffff"><script>"serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("/sw.js").then(e=>{console.log("Service worker registered with scope: ",e.scope)},e=>{console.log("Service worker registration failed: ",e)})})</script><script defer src=https://cn.vercount.one/js></script></body></html>