<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>debug on Cuterwrite's Blog</title><link>https://cuterwrite.top/tags/debug/</link><description>Recent content in debug on Cuterwrite's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>cuterwrite</copyright><lastBuildDate>Wed, 02 Aug 2023 01:00:00 +0000</lastBuildDate><atom:link href="https://cuterwrite.top/tags/debug/index.xml" rel="self" type="application/rss+xml"/><item><title>程序调试与优化分析工具</title><link>https://cuterwrite.top/p/debug-and-optimize/</link><pubDate>Wed, 02 Aug 2023 01:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/debug-and-optimize/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/1c86d46879544786889dcdbaa1cf158f1fb36107.jpg@1256w_1774h_!web-article-pic.webp" alt="Featured image of post 程序调试与优化分析工具" />&lt;h1 id="程序调试与优化分析工具">程序调试与优化分析工具&lt;/h1>
&lt;h2 id="一概述">一、概述&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>在编程中我们通常会遇到如下问题：&lt;/p>
&lt;ol>
&lt;li>程序运行慢，效率低&lt;/li>
&lt;li>消耗了大量的内存&lt;/li>
&lt;li>segmentation fault&lt;/li>
&lt;li>程序崩溃&lt;/li>
&lt;li>程序运行结果不正确&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>随着处理器复杂度的增加&lt;/p>
&lt;ul>
&lt;li>我们不再能够轻松地跟踪代码段的执行
&lt;ul>
&lt;li>静态/动态分支预测、预取、顺序调度&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>仅使用墙钟时间来衡量代码性能是不够的。&lt;/li>
&lt;li>我们还需要了解到底发生了什么&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>对于性能评估，有直接和间接两种方法&lt;/p>
&lt;ul>
&lt;li>直接方法：需要某些形式的显示插装
&lt;ul>
&lt;li>追踪
&lt;ul>
&lt;li>为每个测量事件生成记录&lt;/li>
&lt;li>只有在产生大量数据情况下，出现的性能异常数据才有用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>聚合
&lt;ul>
&lt;li>减少数据在运行时平均/最小/最大测量&lt;/li>
&lt;li>适用于应用程序和体系结构和描述和优化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>间接方法：不需要插装，可不修改应用程序&lt;/li>
&lt;li>事实上，直接和间接方法的界限有些模糊
&lt;ul>
&lt;li>聚合：如 gprof，可以不修改程序，但是需要重新编译链接&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>实际编程中，常见的分析工具如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">类型&lt;/th>
&lt;th style="text-align:center">工具&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">程序调试&lt;/td>
&lt;td style="text-align:center">gdb&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">程序调试&lt;/td>
&lt;td style="text-align:center">valgrind&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">程序优化&lt;/td>
&lt;td style="text-align:center">gprof&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">程序优化&lt;/td>
&lt;td style="text-align:center">perf&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">程序优化&lt;/td>
&lt;td style="text-align:center">Intel VTune Amplifier&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;h2 id="二程序调试分析工具简介">二、程序调试分析工具简介&lt;/h2>
&lt;ul>
&lt;li>程序中的错误按其性质可以分为三种：
&lt;ul>
&lt;li>&lt;strong>编译错误&lt;/strong> ：即语法错误，主要是程序代码中有不符合所用编程语言语法规则的错误。&lt;/li>
&lt;li>&lt;strong>运行时错误&lt;/strong> ：如对负数开平方、除数为 0、循环终止条件永远不能达到等。&lt;/li>
&lt;li>&lt;strong>逻辑错误&lt;/strong> ：这类错误往往是编程前对求解的问题理解不正确或算法不正确引起的，它们很难查找（数组越界、空指针）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>程序调试就是查找程序中的错误，诊断其准确位置，并予以改正。&lt;/li>
&lt;/ul>
&lt;h3 id="1-gdb">1. gdb&lt;/h3>
&lt;ul>
&lt;li>GDB 是 GNU 开源组织发布的一个强大的 UNIX 下的程序调试工具&lt;/li>
&lt;li>GDB 具备如下 4 个方面的功能：
&lt;ul>
&lt;li>启动程序，可以按用户要求影响程序的运行行为&lt;/li>
&lt;li>可以让被调试的程序在用户所指定的断点处暂停（断点可以是条件表达式）&lt;/li>
&lt;li>当程序被暂停时，可以检查此时用户程序中所发生的事情&lt;/li>
&lt;li>动态改变用户程序的执行环境，这样就可以先纠正一个错误的影响，然后再纠正其他错误&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>为了发挥 GDB 的全部功能，需要在编译源程序时使用&lt;code>-g&lt;/code> 选项&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gcc -g test.c -o proc
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>启动 GDB，以参数形式将可执行程序传递给 GDB&lt;/p>
&lt;ul>
&lt;li>gdb program&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gdb ./proc
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>gdb -p pid&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gdb -p `pidof proc`
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>gdb program core&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gdb ./proc core.xxx
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>gdb attach pid&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gdb attach 2313
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>启动 gdb 后就显示其提示符：（gdb），并等待用户输入相应的内部命令&lt;/p>
&lt;ul>
&lt;li>设置断点、设置运行参数和环境变量、跟踪调试命令、查看栈信息……&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>用户可以利用命令 quit 终止其执行，退出 gdb 环境&lt;/p>
&lt;/li>
&lt;li>
&lt;p>gdb 常用命令列表如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>命令&lt;/th>
&lt;th>解释&lt;/th>
&lt;th>简写&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>file&lt;/td>
&lt;td>装入想要调试的可执行文件&lt;/td>
&lt;td>无&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>list&lt;/td>
&lt;td>列出产生执行文件源代码的一部分&lt;/td>
&lt;td>l&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>next&lt;/td>
&lt;td>执行一行源代码但不进入函数内部&lt;/td>
&lt;td>n&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>step&lt;/td>
&lt;td>执行一行源代码而且进入函数内部&lt;/td>
&lt;td>s&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>run&lt;/td>
&lt;td>执行当前被调试的程序&lt;/td>
&lt;td>r&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>continue&lt;/td>
&lt;td>继续执行程序&lt;/td>
&lt;td>c&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>quit&lt;/td>
&lt;td>终止 GDB&lt;/td>
&lt;td>q&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>print&lt;/td>
&lt;td>输出当前指定变量的值&lt;/td>
&lt;td>p&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>break&lt;/td>
&lt;td>在代码里设置断点&lt;/td>
&lt;td>b&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>info break&lt;/td>
&lt;td>查看设置断点的信息&lt;/td>
&lt;td>ib&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>delete&lt;/td>
&lt;td>删除设置的断点&lt;/td>
&lt;td>d&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>watch&lt;/td>
&lt;td>监视一个变量的值，一旦值有变化，程序停住&lt;/td>
&lt;td>wa&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>help&lt;/td>
&lt;td>GDB 中的帮助命令&lt;/td>
&lt;td>h&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>设置断点：&lt;/p>
&lt;ul>
&lt;li>编译源程序时需要使用&lt;code>-g&lt;/code> 选项&lt;/li>
&lt;li>在 GDB 中用 break 命令（其缩写形式为 b）设置断点：
&lt;ul>
&lt;li>break linenum 在当前文件指定行 linenum 处设置断点，停在该行开头&lt;/li>
&lt;li>break linenum if condition 在当前文件指定行 linenum 处设置断点，但仅在条件表达式 condition 成立时才停止程序执行&lt;/li>
&lt;li>break function 在当前文件函数 function 的入口处设置断点&lt;/li>
&lt;li>break file:linenum 在源文件 file 的 linenum 行上设置断点&lt;/li>
&lt;li>break file:function 在源文件 file 的函数 function 的入口处设置断点&lt;/li>
&lt;li>break *address 运行程序在指定的内存地址 address 处停止&lt;/li>
&lt;li>break 不带任何参数，则表示在下一条指令处停止&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>断点应设置在可执行的行上，不应是变量定义之类的语句&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>删除断点：&lt;/p>
&lt;ul>
&lt;li>delete [bkptnums]&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>显示断点：&lt;/p>
&lt;ul>
&lt;li>info breakpoints [num]&lt;/li>
&lt;li>info break [num]&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>运行程序：&lt;/p>
&lt;ul>
&lt;li>run [args]&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>程序的单步跟踪和&lt;/p>
&lt;ul>
&lt;li>step [N] 参数 N 表示每步执行的语句行数，进入被调用函数内部执行&lt;/li>
&lt;li>next [N] 参数 N 表示每步执行的语句行数，被调用函数被当做一条指令执行&lt;/li>
&lt;li>stepi（缩写为 si）或 nexti（缩写为 ni）命令一条一条地执行机器指令&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>程序的连续执行&lt;/p>
&lt;ul>
&lt;li>利用 continue，c 或 fg 命令连续执行到下一个断点&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>显示源文件命令 list （l）&lt;/p>
&lt;ul>
&lt;li>list：没有参数，显示当前行之后或周围的 10 多行&lt;/li>
&lt;li>list -：显示之前的 10 行&lt;/li>
&lt;li>list [file]:num：显示源文件 file 中给定行号 num 周围的 10 行。如果缺少 file，则默认为当前文件。例如，list 100&lt;/li>
&lt;li>list start, end：显示从行号 start 至 end 之间的代码行。例如，list 20,38&lt;/li>
&lt;li>list [file:]fun：显示源文件 file 中指定函数 function 的代码行。如果缺少 file，则默认为当前文件。例如，list meng1.c:square&lt;/li>
&lt;li>set listsize linenum : 可以使用该命令设置一次显示的行数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>查看运行时数据命令 print （p）&lt;/p>
&lt;ul>
&lt;li>当被调试的程序停止时，可以用 print 命令或同义命令 inspect 来查看当前程序中运行的数据&lt;/li>
&lt;li>print 命令的一般使用格式：print [/fmt] exp
&lt;ul>
&lt;li>print i （或 p i） 显示当前变量 i 的值&lt;/li>
&lt;li>print i*j (或 p i*j) 将根据程序当前运行的实际情况显示出 i*j 的值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>print 所支持的运算符：
&lt;ul>
&lt;li>取地址&amp;amp;符号&lt;/li>
&lt;li>@ 是一个与数组有关的双目运算符，使用形式如
&lt;ul>
&lt;li>print array@10 打印从 array（数组名，即数组的基地址）开始的 10 个值&lt;/li>
&lt;li>print array[3]@5 打印从 array 第三个元素开始的 5 个数组元素的数值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>file::i 或 function ::i 表示文件或者函数中 i 的值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="notice notice-note" >
&lt;div class="notice-title">&lt;svg t="1705946198814" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23141" width="200" height="200">&lt;path d="M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864a149.333333 149.333333 0 0 1-149.333334 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z m426.666667 0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864a149.333333 149.333333 0 0 1-149.333333 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z" p-id="23142" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;p>GDB 使用示例&lt;/p>&lt;/div>
&lt;pre>&lt;code class="language-c">// test.c
#include &amp;lt;stdio.h&amp;gt;
int sum(int n);
int main(int argc, char **argv)
{
int i, result = 0;
for (i = 1; i &amp;lt;= 50; i++)
{
result += i;
}
printf(&amp;quot;result[1-50]=%d\n&amp;quot;, result);
printf(&amp;quot;result[1-100]=%d\n&amp;quot;, sum(100));
}
int sum(int n)
{
int i, sum;
for (i = 1; i &amp;lt;= n; i++)
{
sum += i;
}
return sum;
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>编译带调试信息的可执行文件&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gcc -g test.c -o test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>启动 GDB&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gdb test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>调试结果&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &amp;quot;show copying&amp;quot; and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;x86_64-linux-gnu&amp;quot;.
Type &amp;quot;show configuration&amp;quot; for configuration details.
For bug reporting instructions, please see:
&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;.
Find the GDB manual and other documentation resources online at:
&amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;.
For help, type &amp;quot;help&amp;quot;.
Type &amp;quot;apropos word&amp;quot; to search for commands related to &amp;quot;word&amp;quot;...
Reading symbols from test...
(gdb) list
1 #include &amp;lt;stdio.h&amp;gt;
2
3 int sum(int n);
4
5 int main(int argc, char **argv)
6 {
7 int i, result = 0;
8 for (i = 1; i &amp;lt;= 50; i++)
9 {
10 result += i;
(gdb)
11 }
12 printf(&amp;quot;result[1-50]=%d\n&amp;quot;, result);
13 printf(&amp;quot;result[1-100]=%d\n&amp;quot;, sum(100));
14 }
15
16 int sum(int n)
17 {
18 int i, sum;
19 for (i = 1; i &amp;lt;= n; i++)
20 {
(gdb)
21 sum += i;
22 }
23 return sum;
24 }
(gdb) b 8
Breakpoint 1 at 0x1163: file test.c, line 8.
(gdb) info b
Num Type Disp Enb Address What
1 breakpoint keep y 0x0000000000001163 in main at test.c:8
(gdb) r
Starting program: /root/workspace/test
Breakpoint 1, main (argc=1, argv=0x7fffffffe2d8) at test.c:8
8 for (i = 1; i &amp;lt;= 50; i++)
(gdb) p i
$1 = 0
(gdb) p result
$2 = 0
(gdb) n
10 result += i;
(gdb) n
8 for (i = 1; i &amp;lt;= 50; i++)
(gdb) p i
$3 = 1
(gdb) p result
$4 = 1
(gdb) d 1
(gdb) info b
No breakpoints or watchpoints.
(gdb) c
Continuing.
result[1-50]=1275
result[1-100]=26895
[Inferior 1 (process 286758) exited normally]
(gdb) q
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>总的来说，GDB 调试的过程为：
&lt;ul>
&lt;li>编译带调试信息的可执行文件&lt;/li>
&lt;li>启动 GDB，开始调试&lt;/li>
&lt;li>GDB 中查看文件&lt;/li>
&lt;li>设置断点&lt;/li>
&lt;li>查看断点情况&lt;/li>
&lt;li>运行代码&lt;/li>
&lt;li>跟踪变量值&lt;/li>
&lt;li>删除所设断点&lt;/li>
&lt;li>恢复程序运行&lt;/li>
&lt;li>退出 GDB&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="2-valgrind">2. Valgrind&lt;/h3>
&lt;ul>
&lt;li>Valgrind 是一个 Linux 下灵活的调试和剖析工具&lt;/li>
&lt;li>收集各种有用的运行时信息，可以帮助找到程序中潜在的 bug 和性能瓶颈&lt;/li>
&lt;li>Valgrind 包含多个工具：&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>工具&lt;/th>
&lt;th>功能&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Memcheck&lt;/td>
&lt;td>这是 valgrind 应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存、使用已经释放了的内存、内存访问越界等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Callgrind&lt;/td>
&lt;td>主要用来检查程序中函数调用过程中出现的问题&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Cachegrind&lt;/td>
&lt;td>主要用来检查程序中缓存使用出现的问题&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Helgrind&lt;/td>
&lt;td>主要用来检查多线程程序中出现的竞争问题&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Massif&lt;/td>
&lt;td>主要用来检查程序中堆栈使用中出现的问题&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Extensio&lt;/td>
&lt;td>可以利用 core 提供的功能，自己编写特定的内存调试工具&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>Valgrind 使用需要先进行安装，在 ubuntu 下可以使用 apt-get 进行安装&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">sudo apt-get install valgrind
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>为了使 Valgrind 发现的错误更精确，建议在编译时加上&lt;code>-g&lt;/code> 参数，编译优化选择&lt;code>O0&lt;/code>，即：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gcc -g -O0 test.c -o test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>valgrind 命令格式为: &lt;code>valgrind [options] prog-and-args [options]&lt;/code>&lt;/p>
&lt;ul>
&lt;li>[options]: 常用选项，适用于所有 Valgrind 工具&lt;/li>
&lt;li>&amp;ndash;tool=&amp;lt;name&amp;gt;： 最常用的选项，运行 valgrind 中名为 toolname 的工具，默认 memcheck&lt;/li>
&lt;li>-h|&amp;ndash;help：显示帮助信息&lt;/li>
&lt;li>&amp;ndash;version：显示 valgrind 内核的版本，每个工具都有各自的版本&lt;/li>
&lt;li>-q|&amp;ndash;quiet：安静地运行，只打印错误信息&lt;/li>
&lt;li>-v|&amp;ndash;verbose：更详细的信息，增加错误数统计&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Memcheck 内存错误检查：&lt;/p>
&lt;ul>
&lt;li>可以检查出下列几种错误
&lt;ul>
&lt;li>使用已经释放的内存&lt;/li>
&lt;li>内存块越界&lt;/li>
&lt;li>使用未初始化的变量&lt;/li>
&lt;li>内存泄漏&lt;/li>
&lt;li>同一个内存块释放多次&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Memcheck 命令行选项：
&lt;ul>
&lt;li>&amp;ndash;leak-check=&amp;lt;no|summary|yes|full&amp;gt; [default: summary]
&lt;ul>
&lt;li>summary 是给出最后 leak 的汇总，yes 或者 full 将会给出比较详细的 leak 信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&amp;ndash;leak-resolution=&amp;lt;low|med|high&amp;gt; [default: high]
&lt;ul>
&lt;li>用于合并 leak 信息来源的 backtraces，low 是有两层匹配的时候就可以合并，med 是四层，high 必须完全比配。该选项不影响查找 leak 的能力，只影响结果的显示方式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Cachegrind 缓存检查&lt;/p>
&lt;ul>
&lt;li>通过模拟 cpu 的 1,3 级缓存，收集应用程序运行时关于 cpu 的一些统计数据，最后在将明细数据和汇总信息打印出来&lt;/li>
&lt;li>执行方式：
&lt;ul>
&lt;li>$ valgrind &amp;ndash;tool=cachegrind your_application
&lt;ul>
&lt;li>cachegrind 的结果也会以输出文件的方式输出更多的细节，输出文件的缺省文件名是 cachegrind.out.&lt;!-- raw HTML omitted -->，其中&lt;!-- raw HTML omitted -->是当前进程的 pid。该文件名可以通过&amp;ndash;cachegrind-out-file 选择指定更可读的文件名，这个文件将会成为 cg_annotate 的输入&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Cachegrind 命令行选项：
&lt;ul>
&lt;li>&amp;ndash;cache-sim=no|yes [yes]
&lt;ul>
&lt;li>指定是否收集 cache accesses 和 miss counts&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&amp;ndash;branch-sim=no|yes [no]
&lt;ul>
&lt;li>指定是否收集 branch instruction 和 misprediction counts&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Callgrind 函数调用分析&lt;/p>
&lt;ul>
&lt;li>Callgrind 收集程序运行时的一些数据，建立函数调用关系图，还可以有选择地进行 cache 模拟。被分析的程序编译时要加&lt;code>-g&lt;/code>，编译优化选项建议选择&lt;code>-O2&lt;/code>&lt;/li>
&lt;li>执行方式：
&lt;ul>
&lt;li>$ valgrind &amp;ndash;tool=callgrind your_application
&lt;ul>
&lt;li>输出文件的缺省文件名是 callgrind.out.&lt;!-- raw HTML omitted --> ，其中&lt;!-- raw HTML omitted -->是当前进程的 pid&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Cachegrind 命令行选项：
&lt;ul>
&lt;li>&amp;ndash;callgrind-out-file=&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>指定 profile data 的输出文件，而不是缺省命名规则生成的文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&amp;ndash;dump-line=&amp;lt;no|yes&amp;gt; [default: yes]
&lt;ul>
&lt;li>事件计数将以 source line 作为统计的粒度，但是源程序在编译的时候加入&lt;code>-g&lt;/code> 选项&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Helgrind 多线程分析器&lt;/p>
&lt;ul>
&lt;li>主要用来检查多线程程序中出现的竞争问题&lt;/li>
&lt;li>执行方式：
&lt;ul>
&lt;li>$ valgrind &amp;ndash;tool=helgrind your_application&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Massif 堆栈分析&lt;/p>
&lt;ul>
&lt;li>堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。Massif 能帮助我们减少内存的使用&lt;/li>
&lt;li>执行方式：
&lt;ul>
&lt;li>$ valgrind &amp;ndash;tool=massif your_application
&lt;ul>
&lt;li>输出文件：massif.&lt;!-- raw HTML omitted -->.ps massif. &lt;!-- raw HTML omitted -->.txt，其中&lt;!-- raw HTML omitted -->是当前进程的 pid&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="notice notice-note" >
&lt;div class="notice-title">&lt;svg t="1705946198814" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23141" width="200" height="200">&lt;path d="M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864a149.333333 149.333333 0 0 1-149.333334 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z m426.666667 0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864a149.333333 149.333333 0 0 1-149.333333 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z" p-id="23142" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;p>Valgrind 使用示例 1：内存检查&lt;/p>&lt;/div>
&lt;pre>&lt;code class="language-c">// test.c
#include &amp;lt;stdlib.h&amp;gt;
void f(void)
{
int* x = malloc(10 * sizeof(int));
x[10] = 0; // 问题 1：数组下标越界
// 问题 2：内存泄漏，没有 free(x)
}
int main(int argc, char** argv)
{
f();
return 0;
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>编译并运行：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gcc -g -O0 test.c -o test
valgrind --tool=memcheck --leak-check=full ./test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>输出结果：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-text">==292701== Memcheck, a memory error detector
==292701== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==292701== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==292701== Command: ./test
==292701==
==292701== Invalid write of size 4
==292701== at 0x10916B: f (test.c:6)
==292701== by 0x10918B: main (test.c:12)
==292701== Address 0x4a4b068 is 0 bytes after a block of size 40 alloc'd
==292701== at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==292701== by 0x10915E: f (test.c:5)
==292701== by 0x10918B: main (test.c:12)
==292701==
==292701==
==292701== HEAP SUMMARY:
==292701== in use at exit: 40 bytes in 1 blocks
==292701== total heap usage: 1 allocs, 0 frees, 40 bytes allocated
==292701==
==292701== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1
==292701== at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==292701== by 0x10915E: f (test.c:5)
==292701== by 0x10918B: main (test.c:12)
==292701==
==292701== LEAK SUMMARY:
==292701== definitely lost: 40 bytes in 1 blocks
==292701== indirectly lost: 0 bytes in 0 blocks
==292701== possibly lost: 0 bytes in 0 blocks
==292701== still reachable: 0 bytes in 0 blocks
==292701== suppressed: 0 bytes in 0 blocks
==292701==
==292701== For lists of detected and suppressed errors, rerun with: -s
==292701== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>可以看到：valgrind 检测到了两个错误，一个是内存越界，一个是内存泄漏
&lt;ul>
&lt;li>Invalid write of size 4：提示了内存越界的错误&lt;/li>
&lt;li>40 bytes in 1 blocks are definitely lost in loss record 1 of 1：提示了内存泄漏的错误&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="notice notice-note" >
&lt;div class="notice-title">&lt;svg t="1705946198814" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23141" width="200" height="200">&lt;path d="M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864a149.333333 149.333333 0 0 1-149.333334 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z m426.666667 0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864a149.333333 149.333333 0 0 1-149.333333 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z" p-id="23142" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;p>Valgrind 使用示例 2：Cachegrind 缓存检查&lt;/p>&lt;/div>
&lt;pre>&lt;code class="language-c">// test.c
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(void)
{
char *arr = malloc(4);
int *arr2 = malloc(sizeof(int));
strcpy(arr, &amp;quot;1234&amp;quot;);
exit(arr2[0]);
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>编译并运行：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gcc -g -O0 test.c -o test
valgrind --tool=cachegrind ./test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>当前目录下会生成一个 cachegrind.out.&lt;!-- raw HTML omitted -->文件，其中&lt;!-- raw HTML omitted -->是当前进程的 pid，使用&lt;code>ls&lt;/code> 命令查看：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">$ ls
cachegrind.out.293847 test test.c
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>使用&lt;code>cg_annnotate&lt;/code> 命令查看 cachegrind.out.&lt;!-- raw HTML omitted -->文件的内容：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">$ cg_annotate cachegrind.out.293847
--------------------------------------------------------------------------------
I1 cache: 32768 B, 64 B, 8-way associative
D1 cache: 32768 B, 64 B, 8-way associative
LL cache: 31457280 B, 64 B, 15-way associative
Command: ./test
Data file: cachegrind.out.293847
Events recorded: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds: 0.1 100 100 100 100 100 100 100 100
Include dirs:
User annotated:
Auto-annotation: off
/* 以下内容省略 */
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>可以看到，cachegrind.out.&lt;!-- raw HTML omitted -->文件中记录了程序运行时的缓存信息，包括 I1 cache，D1 cache，LL cache 等，这些信息可以帮助我们分析程序的缓存使用情况&lt;/li>
&lt;li>cachegrind 输出的信息中，我们比较关注的是：
&lt;ul>
&lt;li>Ir: 指令读取次数&lt;/li>
&lt;li>I1mr：指令读取 miss 次数&lt;/li>
&lt;li>ILmr：指令读取 miss 次数&lt;/li>
&lt;li>Dr：数据读取次数&lt;/li>
&lt;li>D1mr：数据读取 miss 次数&lt;/li>
&lt;li>DLmr：数据读取 miss 次数&lt;/li>
&lt;li>Dw：数据写入次数&lt;/li>
&lt;li>D1mw：数据写入 miss 次数&lt;/li>
&lt;li>DLmw：数据写入 miss 次数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="notice notice-note" >
&lt;div class="notice-title">&lt;svg t="1705946198814" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23141" width="200" height="200">&lt;path d="M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864a149.333333 149.333333 0 0 1-149.333334 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z m426.666667 0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864a149.333333 149.333333 0 0 1-149.333333 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z" p-id="23142" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;p>Valgrind 使用示例 3：Callgrind 调用图检查&lt;/p>&lt;/div>
&lt;pre>&lt;code class="language-c">// test.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
void f(void)
{
int *x = malloc(10 * sizeof(int));
x[10] = 0; // 问题 1: 数组下标越界
} //问题 2: 内存没有释放
int main(void)
{
int i;
f();
printf(&amp;quot;i=%d\n&amp;quot;, i); // 问题 3：变量没有赋初值
return 0;
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>编译并运行：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gcc -g -O2 test.c -o test
valgrind --tool=callgrind ./test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>当前目录下会生成一个 callgrind.out.&lt;!-- raw HTML omitted -->文件，其中&lt;!-- raw HTML omitted -->是当前进程的 pid，使用&lt;code>ls&lt;/code> 命令查看：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">$ ls
callgrind.out.295036 test test.c
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>使用&lt;code>callgrind_annotate&lt;/code> 命令查看 callgrind.out.&lt;!-- raw HTML omitted -->文件的内容：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">$ callgrind_annotate callgrind.out.295036
--------------------------------------------------------------------------------
Profile data file 'callgrind.out.295036' (creator: callgrind-3.15.0)
--------------------------------------------------------------------------------
I1 cache:
D1 cache:
LL cache:
Timerange: Basic block 0 - 43734
Trigger: Program termination
Profiled target: ./test (PID 295036, part 1)
Events recorded: Ir
Events shown: Ir
Event sort order: Ir
Thresholds: 99
Include dirs:
User annotated:
Auto-annotation: off
--------------------------------------------------------------------------------
Ir
--------------------------------------------------------------------------------
193,311 PROGRAM TOTALS
--------------------------------------------------------------------------------
Ir file:function
--------------------------------------------------------------------------------
71,545 /build/glibc-SzIz7B/glibc-2.31/elf/dl-addr.c:_dl_addr [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
/* 以下内容省略 */
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>可以看到，callgrind.out.&lt;!-- raw HTML omitted -->文件中记录了程序运行时的调用图信息，包括函数调用次数，函数调用路径等，这些信息可以帮助我们分析程序的调用图使用情况&lt;/li>
&lt;li>callgrind 输出的信息中，我们比较关注的是：
&lt;ul>
&lt;li>Ir：指令读取次数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="三程序优化分析工具简介">三、程序优化分析工具简介&lt;/h2>
&lt;ul>
&lt;li>运行缓慢的代码将消耗大量的 CPU 时间, 因此，我们必需评估代码的运行效率, 在整个代码的设计和实现周期里都需考虑性能。&lt;/li>
&lt;li>Amdahl 定律：在一个系统中，如果某部分的执行时间占总执行时间的比例为 p，那么优化这部分的执行时间，系统的整体执行时间至少降低 p 倍。&lt;/li>
&lt;/ul>
&lt;p>$$
\begin{array}{c}T_{new} = T_{old} \times (1-p) + \frac{T_{old} \times p}{k} \ = T_{old} \times (1-p + \frac{p}{k})\end{array}
$$&lt;/p>
&lt;ul>
&lt;li>根据 Amdahl 定律，对热点部分进行性能优化能够获得最大收益&lt;/li>
&lt;li>常见的程序优化分析工具有：
&lt;ul>
&lt;li>gprof&lt;/li>
&lt;li>perf&lt;/li>
&lt;li>Vtune&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="1-gprof">1. gprof&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Gprof，又称 GNU profiler，是 Linux/Unix 系统上的性能 profiling 软件，其功能是获得程序各个函数运行时间，帮助找出耗时最多的函数，以及显示函数调用关系，包括调用次数，帮助分析程序运行流程。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基本原理为：&lt;/p>
&lt;ul>
&lt;li>编译链接程序时，编译器在程序的每个函数中都加入了一个函数，程序里的每一个函数都会调用该函数, 该函数 会在内存中保存一张函数调用图，并通过函数调用堆栈的形式查找子函数和父函数的地址&lt;/li>
&lt;li>调用图也保存了所有与函数相关的调用时间，调用次数等信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Gprof 需要先使用&lt;code>-pg&lt;/code> 编译和链接应用程序&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">ifort -pg -O3 -o prog prog.f90
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>执行应用程序使之生成供 gprof 分析的数据，生成 gmon.out&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">./prog
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>使用 gprof 程序分析应用程序生成的数据&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gprof prog gmon.out &amp;gt; gprof.out
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>gprof 的输出信息包括：&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>序号&lt;/th>
&lt;th>列名&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>time&lt;/td>
&lt;td>函数执行时间占总执行时间的百分比&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>cumulative seconds&lt;/td>
&lt;td>函数和上列函数累计执行的时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>self seconds&lt;/td>
&lt;td>函数本身所执行的时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>calls&lt;/td>
&lt;td>函数被调用次数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>self ms/call&lt;/td>
&lt;td>每一次调用花费在函数的时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>total ms/call&lt;/td>
&lt;td>每一次调用，花费在函数及其衍生函数的平均时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7&lt;/td>
&lt;td>name&lt;/td>
&lt;td>函数名&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>gprof 常用的命令选项有：&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>选项&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>-b&lt;/td>
&lt;td>不再输出统计图表中每个字段的详细描述&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-p&lt;/td>
&lt;td>只输出函数的调用图&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-q&lt;/td>
&lt;td>只输出函数的时间消耗列表&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-e Name&lt;/td>
&lt;td>不再输出函数 Name 及其子函数的调用图&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-E Name&lt;/td>
&lt;td>不再输出函数 Name 及其子函数的调用图，在总时间和百分比时间计算中排除了由函数 Name 及其子函数所用的时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-f Name&lt;/td>
&lt;td>输出函数 Name 及其子函数的调用图&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-F Name&lt;/td>
&lt;td>输出函数 Name 及其子函数的调用图，类似于-f，但它在总时间和百分比时间计算中仅使用所打印的例程的时间&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>对于由多个源文件组成的程序，编译时需要在生成每个.o 文件的时候加上&lt;code>-pg&lt;/code> 参数，同时在链接的时候也要加上&lt;code>-pg&lt;/code> 参数&lt;/li>
&lt;li>&lt;code>-pg&lt;/code> 参数只能记录源代码中各个函数的调用关系，而不能记录库函数的调用情况&lt;/li>
&lt;li>要想记录每个库函数（如 memcpy、memset、sprintf 等函数）的调用情况，链接的时候必须指定库函数的动态（或者静态）链接库 libc_p.a，即加上-lc_p，而不是-lc
&lt;ul>
&lt;li>$ gcc example1.c –pg -lc_p -o example1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>若只有部分代码在编译时指定了&lt;code>-pg&lt;/code> 参数，则生成的 gmon.out 文件中将缺少部分函数，也没有这些函数的调用关系，但是并不影响 gprof 对其它函数进行记录&lt;/li>
&lt;/ul>
&lt;div class="notice notice-note" >
&lt;div class="notice-title">&lt;svg t="1705946198814" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23141" width="200" height="200">&lt;path d="M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864a149.333333 149.333333 0 0 1-149.333334 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z m426.666667 0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864a149.333333 149.333333 0 0 1-149.333333 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z" p-id="23142" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;p>gprof 使用示例&lt;/p>&lt;/div>
&lt;pre>&lt;code class="language-c">// test.c
#include &amp;lt;stdio.h&amp;gt;
int fast_multiply(int x, int y)
{
return x * y;
}
int slow_multiply(int x, int y)
{
int i, j, z;
for (i = 0, z = 0; i &amp;lt; x; i++)
z = z + y;
return z;
}
int main(int argc, char *argv[])
{
int i, j;
int x, y;
for (i = 0; i &amp;lt; 200; i++)
{
for (j = 0; j &amp;lt; 30; j++)
{
x = fast_multiply(i, j);
y = slow_multiply(i, j);
}
}
printf(&amp;quot;x=%d, y=%d\n&amp;quot;, x, y);
return 0;
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>编译链接并运行程序&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gcc -pg -o test test.c
./test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>在当前目录下生成 gmon.out 文件，使用 gprof 分析&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">gprof -b test gmon.out &amp;gt; gprof.out
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>gprof.out 文件内容如下&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-text">Flat profile:
Each sample counts as 0.01 seconds.
no time accumulated
% cumulative self self total
time seconds seconds calls Ts/call Ts/call name
0.00 0.00 0.00 6000 0.00 0.00 fast_multiply
0.00 0.00 0.00 6000 0.00 0.00 slow_multiply
Call graph
granularity: each sample hit covers 2 byte(s) no time propagated
index % time self children called name
0.00 0.00 6000/6000 main [8]
[1] 0.0 0.00 0.00 6000 fast_multiply [1]
-----------------------------------------------
0.00 0.00 6000/6000 main [8]
[2] 0.0 0.00 0.00 6000 slow_multiply [2]
-----------------------------------------------
Index by function name
[1] fast_multiply [2] slow_multiply
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>可以看到：程序中只有两个函数，fast_multiply 和 slow_multiply，gprof 分析结果中也只有这两个函数，但是这两个函数的调用次数都是 6000 次，这是因为 gprof 默认的采样周期是 0.01 秒，而程序运行时间很短，所以两个函数的调用次数都是 6000 次，如果程序运行时间更长，那么两个函数的调用次数就会不一样了。&lt;/li>
&lt;/ul>
&lt;h3 id="2-perf">2. perf&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Perf 是内置于 Linux 内核源码树中的性能剖析(profiling)工具，基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析，常用于性能瓶颈的查找与热点代码的定位。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Perf 包含 22 种子工具的工具集，以下是最常用的 5 种：&lt;/p>
&lt;ul>
&lt;li>perf list：列出当前系统支持的所有性能事件。包括硬件性能事件、软件性能事件以及检查点&lt;/li>
&lt;li>perf top：类似于 Linux 的 top 命令，对系统性能进行实时分析&lt;/li>
&lt;li>perf stat：剖析某个特定进程的性能概况，包括 CPI、Cache 丢失率等&lt;/li>
&lt;li>perf record：收集采样信息，并将其记录在数据文件中&lt;/li>
&lt;li>perf report：读取 perf record 创建的数据文件，并给出热点分析结果&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>perf list&lt;/p>
&lt;ul>
&lt;li>查看当前软硬件平台支持的性能事件列表&lt;/li>
&lt;li>事件分为以下三种：
&lt;ul>
&lt;li>&lt;strong>Hardware Event&lt;/strong>: 由 PMU 硬件产生的事件，比如 cache 命中，当要了解程序对硬件特性的使用情况时，便需要对这些事件进行采样&lt;/li>
&lt;li>&lt;strong>Software Event&lt;/strong>: 内核软件产生的事件，比如进程切换、tick 数等&lt;/li>
&lt;li>&lt;strong>Tracepoint event&lt;/strong>: 内核中的静态 tracepoint 所触发的事件，这些 tracepoint 用来判断程序运行期间内核的行为细节，比如 slab 分配器的分配次数等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>命令格式：&lt;code>perf list [hw | sw | cache | tracepoint]&lt;/code>&lt;/li>
&lt;li>perf list 工具仅列出了具有字符描述的硬件性能事件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>perf top&lt;/p>
&lt;ul>
&lt;li>主要用于实时分析各个函数在某个性能事件上的热度，能够快速的定位热点函数，包括应用程序函数、模块函数与内核函数，甚至能够定位到热点指令，默认的性能事件为 cpu cycles&lt;/li>
&lt;li>命令格式： &lt;code>perf top [&amp;lt;options&amp;gt;]&lt;/code>&lt;/li>
&lt;li>常用命令行参数
&lt;ul>
&lt;li>-e &lt;!-- raw HTML omitted -->：指明要分析的性能事件&lt;/li>
&lt;li>-p &lt;!-- raw HTML omitted -->：仅分析目标进程及其创建的线程&lt;/li>
&lt;li>-k &lt;!-- raw HTML omitted -->：带符号表的内核映像所在的路径&lt;/li>
&lt;li>-K：不显示属于内核或模块的符号&lt;/li>
&lt;li>-U：不显示属于用户态程序的符号&lt;/li>
&lt;li>-d &lt;!-- raw HTML omitted -->：界面的刷新周期，默认为 2s&lt;/li>
&lt;li>-G：得到函数的调用关系图&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>perf stat&lt;/p>
&lt;ul>
&lt;li>用于分析指定程序的性能概况&lt;/li>
&lt;li>命令格式：&lt;code>perf stat [&amp;lt;options&amp;gt;] [&amp;lt;command&amp;gt;]&lt;/code>&lt;/li>
&lt;li>常用命令行参数
&lt;ul>
&lt;li>-p &lt;!-- raw HTML omitted -->：仅分析目标进程及其创建的线程&lt;/li>
&lt;li>-a：从所有 CPU 上收集性能数据&lt;/li>
&lt;li>-r &lt;!-- raw HTML omitted -->：重复执行命令求平均&lt;/li>
&lt;li>-C &lt;!-- raw HTML omitted -->：从指定 CPU 上收集性能数据&lt;/li>
&lt;li>-v：显示更多性能数据&lt;/li>
&lt;li>-n：只显示任务的执行时间&lt;/li>
&lt;li>-x &lt;!-- raw HTML omitted -->：指定输出列的分隔符&lt;/li>
&lt;li>-o &lt;!-- raw HTML omitted -->：指定输出文件。&amp;ndash;append 指定追加模式，&amp;ndash;pre &lt;!-- raw HTML omitted -->执行目标程序前先执行的程序，&amp;ndash;post &lt;!-- raw HTML omitted -->执行目标程序后再执行的程序&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>perf record&lt;/p>
&lt;ul>
&lt;li>收集采样信息，并将其记录在数据文件中&lt;/li>
&lt;li>随后可以通过其它工具(perf report)对数据文件进行分析，结果类似于 perf top&lt;/li>
&lt;li>命令格式：&lt;code>perf record [&amp;lt;options&amp;gt;] [&amp;lt;command&amp;gt;]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>perf report&lt;/p>
&lt;ul>
&lt;li>读取 perf record 创建的数据文件，并给出热点分析结果&lt;/li>
&lt;li>命令格式：&lt;code>perf report [&amp;lt;options&amp;gt;] [&amp;lt;datafile&amp;gt;]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="notice notice-note" >
&lt;div class="notice-title">&lt;svg t="1705946198814" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23141" width="200" height="200">&lt;path d="M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864a149.333333 149.333333 0 0 1-149.333334 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z m426.666667 0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864a149.333333 149.333333 0 0 1-149.333333 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z" p-id="23142" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;p>perf 使用示例&lt;/p>&lt;/div>
&lt;ul>
&lt;li>apt-get 安装 perf&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">sudo apt-get install linux-tools-common linux-tools-generic linux-tools-`uname -r`
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>使用 perf list 查看当前系统支持的性能事件&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">perf list
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>perf list 结果：&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230803181340.webp"
alt="20230803181340" width="90%" loading="lazy"/>
&lt;/figure>
&lt;ul>
&lt;li>使用 perf top 查看当前系统的热点函数&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">perf top
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>perf top 结果：&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230803181307.webp"
alt="20230803181307" width="90%" loading="lazy"/>
&lt;/figure>
&lt;ul>
&lt;li>
&lt;p>使用 perf stat 查看测试程序的性能概况&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用在 gprof 时的程序代码 test.c&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行 perf stat&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">perf stat ./test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>perf stat 结果：&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230803182003.webp"
alt="20230803182003" width="90%" loading="lazy"/>
&lt;/figure>
&lt;ul>
&lt;li>使用 perf record 和 perf report 查看热点函数&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">perf record ./test
perf report
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>perf report 结果：&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230803182110.webp"
alt="20230803182110" width="90%" loading="lazy"/>
&lt;/figure>
&lt;ul>
&lt;li>
&lt;p>进阶：火炬图 FlameGraph：基于 perf record 和 perf report 的结果绘制火炬图&lt;/p>
&lt;ul>
&lt;li>
&lt;p>下载 FlameGraph 工具：&lt;/p>
&lt;pre>&lt;code class="language-shell">git clone https://github.com/brendangregg/FlameGraph.git
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>收集性能数据：&lt;/p>
&lt;pre>&lt;code class="language-shell">perf record -g ./test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>对可执行文件 test 进行采样，每秒 99 次，采样结果保存在 perf.data 文件中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>使用 FlameGraph 生成火炬图：运行以下命令使用 FlameGraph 生成火炬图：&lt;/p>
&lt;pre>&lt;code class="language-shell">perf script | ./FlameGraph/stackcollapse-perf.pl &amp;gt; out.perf-folded
./FlameGraph/flamegraph.pl out.perf-folded &amp;gt; perf.svg
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>FlameGrpah 绘制结果：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230803191123.webp"
alt="20230803191123" width="90%" loading="lazy"/>
&lt;/figure>
&lt;h3 id="3-vtune">3. Vtune&lt;/h3>
&lt;ul>
&lt;li>Intel VTune Amplifier XE 是 Intel 针对其处理器的性能测试分析工具，支持 Windows/Linux，提供图形用户界面和命令行接口，支持 C、C++、Fortran、C#、Java、.NET 等多种语言。&lt;/li>
&lt;li>Vtune 基于硬件性能监视部件(PMU)性能测试，获得微体系结构级数据
&lt;ul>
&lt;li>指令类型与数目&lt;/li>
&lt;li>存储访问事件&lt;/li>
&lt;li>指令流水线事件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Vtune 性能分析粒度包括：进程、线程、子程序、代码行&lt;/li>
&lt;li>Vtune 可以帮助用户分析算法选择，标识出应用程序怎样更好的利用可用的硬件资源，可以帮助用户如下性能方面问题：
&lt;ul>
&lt;li>程序中或者整个系统中时间消耗最多的函数&lt;/li>
&lt;li>没有有效利用处理器时间的代码片段&lt;/li>
&lt;li>优化串行和线程化性能的最好代码片段&lt;/li>
&lt;li>影响程序性能的同步对象&lt;/li>
&lt;li>程序的 I/O 操作是否花费很多时间，以及在哪里、为什么花费时间&lt;/li>
&lt;li>不同的同步方法，不同的线程数量或者不同算法对于性能的影响&lt;/li>
&lt;li>线程活跃性和变迁&lt;/li>
&lt;li>代码中硬件相关的瓶颈&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Vtune 还可以提供寻找热点、分析锁和等待以及标识硬件问题等功能&lt;/li>
&lt;li>Vtune 命令格式为：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">amplxe-cl &amp;lt;-action&amp;gt; [-action-option] [-global-option] [[--] &amp;lt;target&amp;gt; [target-options]]
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>amplxe-cl：VTune Amplifier 命令行工具名称&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&amp;lt;-action&amp;gt; ：要执行的操作，如 collect 或 report。每个命令必须只有一个操作。如，一个命令中不能同时有收集数据和生成报表&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[-action-option] ：操作选项，用于修改特定操作的行为。每个操作可以有多个操作选项，操作选项使用不当会导致使用错误&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[-global-option] ：全局选项，用于以相同的方式修改所有操作的行为。每个操作可以有多个全局选项&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[&amp;ndash;] &lt;!-- raw HTML omitted --> ：要分析的目标程序&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[target-options] ：目标程序参数选项&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Actions：amplxe-cl 支持不同的命令选项&lt;/p>
&lt;ul>
&lt;li>collect：运行指定的分析类型并将数据收集到结果中&lt;/li>
&lt;li>collect-with：运行用户设置的基于事件的硬件采样或用户模式采样，并跟踪收集&lt;/li>
&lt;li>command：向正在运行的收集操作发出命令&lt;/li>
&lt;li>finalize：执行符号解析以完成或重新获得结果&lt;/li>
&lt;li>help： 显示命令行参数的简短解释&lt;/li>
&lt;li>import：导入一个或多个收集数据文件/目录&lt;/li>
&lt;li>report：从分析结果中生成指定类型的报表&lt;/li>
&lt;li>version：显示 amplxe-cl 版本信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Action Options&lt;/p>
&lt;ul>
&lt;li>定义适用于指定操作的行为，如“-result-dir”选项是指定收集操作结果的目录路径&lt;/li>
&lt;li>若要访问操作的可用操作选项列表，请使用命令“amplxe-cl –help&lt;!-- raw HTML omitted -->” ，其中 &lt;!-- raw HTML omitted --> 是可用操作之一；要查看所有可用的操作, 请使用命令“amplxe-cl –help”&lt;/li>
&lt;li>如果在同一命令行上使用了相反的操作选项，则将应用最后的操作选项&lt;/li>
&lt;li>忽略上下文中冗余或没有意义的操作选项&lt;/li>
&lt;li>使用不适当的操作选项，会导致意外行为返回使用错误&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Global Options&lt;/p>
&lt;ul>
&lt;li>定义适用于所有操作的行为，如“-quiet”选项会取消所有操作的非必需消息。每个命令可能有一个或多个全局选项&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="notice notice-note" >
&lt;div class="notice-title">&lt;svg t="1705946198814" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23141" width="200" height="200">&lt;path d="M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864a149.333333 149.333333 0 0 1-149.333334 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z m426.666667 0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864a149.333333 149.333333 0 0 1-149.333333 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z" p-id="23142" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;p>Vtune 使用示例：&lt;/p>&lt;/div>
&lt;ul>
&lt;li>
&lt;p>同样使用在 gprof 时的程序代码 test.c，但是需要使用 icc 编译器编译，因为 Vtune 只支持 icc 编译器编译的程序&lt;/p>
&lt;/li>
&lt;li>
&lt;p>安装 icc 编译器：&lt;a class="link" href="https://software.intel.com/content/www/us/en/develop/tools/oneapi/components/dpc-compiler.html" target="_blank" rel="noopener" >Intel C++ Compiler
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;ul>
&lt;li>注：icc 编译器是收费的，需要购买或者申请学生许可&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>安装 Vtune：&lt;a class="link" href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/vtune-profiler-download.html?operatingsystem=linux&amp;amp;distributions=online" target="_blank" rel="noopener" >Intel Vtune
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Ubuntu 下 apt 安装 Vtune&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">wget -O- https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB \
| gpg --dearmor | sudo tee /usr/share/keyrings/oneapi-archive-keyring.gpg &amp;gt; /dev/null
echo &amp;quot;deb [signed-by=/usr/share/keyrings/oneapi-archive-keyring.gpg] https://apt.repos.intel.com/oneapi all main&amp;quot; | sudo tee /etc/apt/sources.list.d/oneAPI.list
sudo apt update
sudo apt install intel-oneapi-vtune
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>编译程序：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">icc test.c -o test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>激活 vtune 环境：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">source /opt/intel/oneapi/vtune/latest/amplxe-vars.sh
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>收集 hosspot 数据：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">ampxel-cl -collect hotspots -result-dir res ./test
&lt;/code>&lt;/pre>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本文介绍了几种常用的程序调试与优化分析工具，这些工具在软件开发过程中发挥着重要的作用。调试工具如 gdb 和 Valgrind 帮助开发人员快速定位和解决程序中的错误和问题，保障了代码的质量和稳定性。而优化分析工具，如 gprof、perf 和 Vtune，则专注于提升程序性能，帮助开发人员找到性能瓶颈并进行优化。&lt;/p>
&lt;p>通过合理使用这些工具，开发人员可以更高效地开发和维护代码，减少调试时间，提高软件性能，并且为用户提供更好的使用体验。在今后的软件开发过程中，了解和掌握这些工具将是提高开发技能和水平的重要一步。同时，不断了解新的调试与优化工具也是跟上技术发展的必要途径。&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;p>[1] &lt;a class="link" href="https://www.gnu.org/software/gdb/" target="_blank" rel="noopener" >gdb 官方网站
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;p>[2] &lt;a class="link" href="https://www.valgrind.org/" target="_blank" rel="noopener" >valgrind 官方网站
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;p>[3] &lt;a class="link" href="https://sourceware.org/binutils/docs/gprof/" target="_blank" rel="noopener" >gprof 官方文档
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;p>[4] &lt;a class="link" href="https://perf.wiki.kernel.org/index.php/Main_Page" target="_blank" rel="noopener" >perf 文档
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;p>[5] &lt;a class="link" href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/vtune-profiler.html" target="_blank" rel="noopener" >Intel Vtune Profiler
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p></description></item></channel></rss>