<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Cuterwrite's Blog</title><link>https://cuterwrite.top/tags/java/</link><description>Recent content in Java on Cuterwrite's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>cuterwrite</copyright><lastBuildDate>Thu, 15 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cuterwrite.top/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring Cloud OAuth2 从零开始实现用户认证和单点登录</title><link>https://cuterwrite.top/p/oauth2-guide/</link><pubDate>Thu, 15 Jul 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/oauth2-guide/</guid><description>&lt;img src="https://cloud.cuterwrite.fun/blog/image.rglemef8w74.webp" alt="Featured image of post Spring Cloud OAuth2 从零开始实现用户认证和单点登录" />&lt;h1 id="spring-cloud-oauth2-从零开始实现用户认证和单点登录">
&lt;a href="#spring-cloud-oauth2-%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e7%94%a8%e6%88%b7%e8%ae%a4%e8%af%81%e5%92%8c%e5%8d%95%e7%82%b9%e7%99%bb%e5%bd%95" class="header-anchor">#&lt;/a>
Spring Cloud OAuth2 从零开始实现用户认证和单点登录
&lt;/h1>
&lt;h2 id="oauth2-是什么">
&lt;a href="#oauth2-%e6%98%af%e4%bb%80%e4%b9%88" class="header-anchor">#&lt;/a>
OAuth2 是什么
&lt;/h2>
&lt;p>OAuth2 其实是一个关于授权的网络标准，它制定了设计思路和运行流程，利用这个标准我们其实是可以自己实现 OAuth2 的认证过程的。 spring-cloud-starter-oauth2 是 Spring Cloud 按照 OAuth2 的标准并结合 spring-security 封装好的一个具体实现。&lt;/p>
&lt;p>OAuth 2 有四种授权模式，分别是授权码模式（authorization code）、简化模式（implicit）、密码模式（resource owner password credentials）、客户端模式（client credentials），具体 OAuth2 是什么，可以参考这篇文章（&lt;a class="link" href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener" >http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
）。&lt;/p>
&lt;h2 id="oauth2-的使用场景">
&lt;a href="#oauth2-%e7%9a%84%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af" class="header-anchor">#&lt;/a>
OAuth2 的使用场景
&lt;/h2>
&lt;ul>
&lt;li>典型的 OAuth2 使用场景：微信登录、QQ 登录、微博登录、Google 帐号登录、Github 帐号登录等。第一次使用就无需注册，直接通过第三方平台授权登录即可，大大提高了使用效率。此外，服务不需要存储用户的密码，只需要存储认证平台返回的唯一 ID 和用户信息即可。&lt;/li>
&lt;li>不使用 OAuth2 的场景：用户需要先完成注册，然后用注册号的帐号密码或者用手机验证码登录。&lt;/li>
&lt;/ul>
&lt;h2 id="oauth2-实现统一认证功能">
&lt;a href="#oauth2-%e5%ae%9e%e7%8e%b0%e7%bb%9f%e4%b8%80%e8%ae%a4%e8%af%81%e5%8a%9f%e8%83%bd" class="header-anchor">#&lt;/a>
OAuth2 实现统一认证功能
&lt;/h2>
&lt;h3 id="创建并配置认证服务端-auth-server">
&lt;a href="#%e5%88%9b%e5%bb%ba%e5%b9%b6%e9%85%8d%e7%bd%ae%e8%ae%a4%e8%af%81%e6%9c%8d%e5%8a%a1%e7%ab%af-auth-server" class="header-anchor">#&lt;/a>
创建并配置认证服务端 auth-server
&lt;/h3>
&lt;p>认证服务端负责验证帐号、密码、存储 Token、检查 Token、刷新 Token 等。&lt;/p>
&lt;h4 id="1引入需要的-maven-包">
&lt;a href="#1%e5%bc%95%e5%85%a5%e9%9c%80%e8%a6%81%e7%9a%84-maven-%e5%8c%85" class="header-anchor">#&lt;/a>
1、引入需要的 Maven 包
&lt;/h4>
&lt;pre>&lt;code class="language-xml">&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;spring-boot-starter-oauth2&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code>&lt;/pre>
&lt;h4 id="2配置-bootstrapyml-和-nacos-配置">
&lt;a href="#2%e9%85%8d%e7%bd%ae-bootstrapyml-%e5%92%8c-nacos-%e9%85%8d%e7%bd%ae" class="header-anchor">#&lt;/a>
2、配置 bootstrap.yml 和 Nacos 配置
&lt;/h4>
&lt;p>认证服务器采用 Nacos Config 方案，将配置放在 Nacos 注册中心上&lt;/p>
&lt;ul>
&lt;li>bootstrap.yml 配置&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-yaml">spring:
application:
name: auth-server
cloud:
nacos:
config:
prefix: auth-server-config
server-addr: xxxx
file-extension: yaml
group: refactored-spring-cloud
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>auth-server-config 配置&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-yaml">server:
port: 18003
spring:
datasource:
url: jdbc:mysql://xxxx:3306/spring?useUnicode=true&amp;amp;&amp;amp;characterEncoding=UTF-8&amp;amp;&amp;amp;serverTimezone=Asia/Shanghai
username: xxxx
password: xxxx
jpa:
show-sql: true
generate-ddl: true
database-platform: org.hibernate.dialect.MYSQL5InnoDBDialect
database: mysql
application:
name: auth-server
cloud:
nacos:
discovery:
server-addr: xxxx:8848
group: refactored-spring-cloud
inetutils:
ignored-interfaces: eth.*
preferred-networks: xxxx
redis:
host: xxxx
port: 6379
management:
endpoint:
health:
enabled: true
dubbo:
protocol:
name: dubbo
port: -1
registry:
address: spring-cloud://xxxx
consumer:
timeout: 3000
&lt;/code>&lt;/pre>
&lt;h4 id="3配置-spring-security">
&lt;a href="#3%e9%85%8d%e7%bd%ae-spring-security" class="header-anchor">#&lt;/a>
3、配置 Spring Security
&lt;/h4>
&lt;pre>&lt;code class="language-java">public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
@Bean
public PasswordEncoder passwordEncoder() {
return new BCryptPasswordEncoder();
}
@Bean
@Override
public AuthenticationManager authenticationManager() throws Exception {
return super.authenticationManager();
}
/**
* 开放所有接口
*/
@Override
protected void configure(HttpSecurity http) throws Exception {
http.authorizeRequests()
.antMatchers(&amp;quot;/**&amp;quot;)
.permitAll();
}
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>PasswordEncoder：采用 BCrypt 加密算法&lt;/li>
&lt;li>AuthenticationManager：OAuth2 密码模式必须制定的授权管理，用默认的即可&lt;/li>
&lt;li>configure：配置拦截器，使用通配符开放所有接口访问权限&lt;/li>
&lt;/ul>
&lt;h4 id="4实现-userdetailsservice">
&lt;a href="#4%e5%ae%9e%e7%8e%b0-userdetailsservice" class="header-anchor">#&lt;/a>
4、实现 UserDetailsService
&lt;/h4>
&lt;pre>&lt;code class="language-java">@Slf4j
@Commponent(value = &amp;quot;kiteUserDetailService&amp;quot;)
public class KiteUserDetailService implements UserDetailService {
@DubboReference
IUserService service;
@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
log.info(&amp;quot;username is: &amp;quot; + username);
// 查询用户
if (user == null) {
throw new UsernameNotFoundException(&amp;quot;The user is not found&amp;quot;);
} else {
// 查询角色
List&amp;lt;SysRole&amp;gt; roles = user.getRoles();
List&amp;lt;SimpleGrantedAuthority&amp;gt; authorities = new ArrayList&amp;lt;&amp;gt;();
for (SysRole role : roles) {
authorities.add(new SimpleGrantedAuthority(role.getRoleName()));
}
// 查询密码
String password = user.getPassword();
return new User(username, password, authorities);
}
}
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>loadUserByUsername：首先利用用户微服务接口通过 username 查询用户、角色以及密码，然后返回&lt;code>org.springframework.security.core.userdetails.User&lt;/code> 即可。&lt;/li>
&lt;/ul>
&lt;h4 id="5配置-oauth2">
&lt;a href="#5%e9%85%8d%e7%bd%ae-oauth2" class="header-anchor">#&lt;/a>
5、配置 OAuth2
&lt;/h4>
&lt;pre>&lt;code class="language-java">@Configuration
@EnableAuthorizationServer
public class OAuth2Config extends AuthorizationServerConfigurerAdapter {
@Autowired
public PasswordEncoder passwordEncoder;
@Autowired
public UserDetailsService kiteUserDetailsService;
@Autowired
private TokenStore jwtTokenStore;
@Autowired
private JwtAccessTokenConverter jwtAccessTokenConverter;
@Autowired
private DataSource dataSource;
@Override
public void configure(final AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
// Redis token 方式
endpoints.authenticaionManager(authenticationManager)
.userDetailsService(kiteUserDetailsService)
.accessTokenConverter(jwtAccessTokenConverter)
.tokenStore(jwtTokenStore);
}
@Override
public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
JdbcClientDetailsServiceBuilder builder = clients.jdbc(dataSource);
builder.passwordEncoder(passwordEncoder);
}
@Override
public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
security.allowFromAuthenticationForClients();
security.checkTokenAccess(&amp;quot;isAuthenticated&amp;quot;);
security.tokenKeyAccess(&amp;quot;isAuthenticated&amp;quot;);
}
}
&lt;/code>&lt;/pre>
&lt;p>有三个 configure 方法的重写&lt;/p>
&lt;ul>
&lt;li>
&lt;p>AuthorizationServerEndpointConfigurer 参数的重写&lt;/p>
&lt;ul>
&lt;li>authenticationManager：用于支持 password 模式&lt;/li>
&lt;li>userDetailsService：设置用户验证服务&lt;/li>
&lt;li>tokenStore：制定 token 的存储方式&lt;/li>
&lt;li>accessTokenConverter：开启 json web token 模式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ClientDetailsServiceConfigure 参数的重写：采用数据库配置的方式，预先定义好 oauth2_client_details 表，如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>参数说明：&lt;/p>
&lt;ul>
&lt;li>clientId、client_secret：这两个参数对应请求端定义的 cleint-id 和 client-secret&lt;/li>
&lt;li>authorized_grant_types：包括 authorization_code（授权码模式）、password（密码模式）、implicit（隐式授权类型）、client_credentials、refresh_token 这五种中的一种或多种。&lt;/li>
&lt;li>access_token_validity：token 的有效期&lt;/li>
&lt;li>scopes：用来限定客户端访问的权限，只有在 scopes 定义内的，才可以正常换取 token。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-sql">create table oauth_client_details (
client_id VARCHAR(256) PRIMARY KEY,
resource_ids VARCHAR(256),
client_secret VARCHAR(256),
scope VARCHAR(256),
authorized_grant_types VARCHAR(256),
web_server_redirect_uri VARCHAR(256),
authorities VARCHAR(256),
access_token_validity INTEGER,
refresh_token_validity INTEGER,
additional_information VARCHAR(4096),
autoapprove VARCHAR(256)
);
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>AuthorizationServerSecurityConfigurer 参数的重写：限制客户端访问认证接口的权限&lt;/p>
&lt;ul>
&lt;li>allowFormAuthenticationForClients()：允许客户端访问 OAuth2 授权接口，否则返回 401&lt;/li>
&lt;li>checkTokenAccess ：允许已授权用户访问 checkToken 接口。&lt;/li>
&lt;li>tokenKeyAccess：允许已授权用户访问获取 token 接口。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="6配置-jwttokenstore">
&lt;a href="#6%e9%85%8d%e7%bd%ae-jwttokenstore" class="header-anchor">#&lt;/a>
6、配置 JWTTokenStore
&lt;/h4>
&lt;pre>&lt;code class="language-java">@Configuration
public class JWTTokenStore {
@Bean
public TokenStore jwtTokenStore() {
return new JwtTokenStore(jwtAccessTokenConverter());
}
@Bean
public JwtAccessTokenConverter jwtAccessTokenConverter() {
JwtAccessTokenConverter accessTokenConverter = new JwtAccessTokenConverter();
accessTokenConverter.setSigningKey(&amp;quot;dev&amp;quot;);
return accessTokenConverter;
}
}
&lt;/code>&lt;/pre>
&lt;h4 id="7启动-auth-server">
&lt;a href="#7%e5%90%af%e5%8a%a8-auth-server" class="header-anchor">#&lt;/a>
7、启动 auth-server
&lt;/h4>
&lt;p>现在已经可以访问 OAuth2 相关的 Restful 接口：&lt;/p>
&lt;ul>
&lt;li>POST /oauth/authorize 授权码模式认证授权接口&lt;/li>
&lt;li>GET/POST /oauth/token 获取 token 的接口&lt;/li>
&lt;li>POST /oauth/check_token 检查 token 合法性接口&lt;/li>
&lt;/ul></description></item><item><title>Java-Stream 常见用法</title><link>https://cuterwrite.top/p/java-stream/</link><pubDate>Tue, 11 May 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/java-stream/</guid><description>&lt;img src="https://cloud.cuterwrite.fun/blog/bridge-5621201_1920.6p53ez4buso0.webp" alt="Featured image of post Java-Stream 常见用法" />&lt;hr>
&lt;h1 id="stream-常见用法">
&lt;a href="#stream-%e5%b8%b8%e8%a7%81%e7%94%a8%e6%b3%95" class="header-anchor">#&lt;/a>
Stream 常见用法
&lt;/h1>
&lt;h2 id="1-stream-概述">
&lt;a href="#1-stream-%e6%a6%82%e8%bf%b0" class="header-anchor">#&lt;/a>
1 Stream 概述
&lt;/h2>
&lt;p>&lt;code>Stream&lt;/code> 将要处理的元素集合看作一种流，在流的过程中，借助&lt;code>Stream API&lt;/code> 对流中的元素进行操作，比如：筛选、排序、聚合等。&lt;/p>
&lt;p>&lt;code>Stream&lt;/code> 可以由数组或集合创建，对流的操作分为两种：&lt;/p>
&lt;ol>
&lt;li>中间操作，每次返回一个新的流，可以有多个。&lt;/li>
&lt;li>终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值。&lt;/li>
&lt;/ol>
&lt;p>另外，&lt;code>Stream&lt;/code> 有几个特性：&lt;/p>
&lt;ol>
&lt;li>stream 不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。&lt;/li>
&lt;li>stream 不会改变数据源，通常情况下会产生一个新的集合或一个值。&lt;/li>
&lt;li>stream 具有延迟执行特性，只有调用终端操作时，中间操作才会执行。&lt;/li>
&lt;/ol>
&lt;h2 id="2-stream-创建">
&lt;a href="#2-stream-%e5%88%9b%e5%bb%ba" class="header-anchor">#&lt;/a>
2 Stream 创建
&lt;/h2>
&lt;h3 id="21-collectionstream">
&lt;a href="#21-collectionstream" class="header-anchor">#&lt;/a>
2.1 Collection.stream()
&lt;/h3>
&lt;pre>&lt;code class="language-java">List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
Stream&amp;lt;Integer&amp;gt; stream = list.stream();
//并行流
Stream&amp;lt;Integer&amp;gt; parallelStream = list.parallelStream();
&lt;/code>&lt;/pre>
&lt;h3 id="22-arraysstreamt-array">
&lt;a href="#22-arraysstreamt-array" class="header-anchor">#&lt;/a>
2.2 Arrays.stream(T[] array)
&lt;/h3>
&lt;pre>&lt;code class="language-java">int[] array = new int[]{1, 2, 3, 4, 5};
IntStream stream = Arrays.stream(array)
&lt;/code>&lt;/pre>
&lt;h3 id="23-streamof--iterate--generate">
&lt;a href="#23-streamof--iterate--generate" class="header-anchor">#&lt;/a>
2.3 Stream.of / iterate / generate
&lt;/h3>
&lt;pre>&lt;code>Stream&amp;lt;Integer&amp;gt; stream = Stream.of(1, 2, 3, 4, 5, 6);
//创建从 0 开始，间距为 3 的 stream（个数为 4）
Stream&amp;lt;Integer&amp;gt; stream2 = Stream.iterate(0, x -&amp;gt; x + 3).limit(4);
&lt;/code>&lt;/pre>
&lt;h2 id="3-stream-使用">
&lt;a href="#3-stream-%e4%bd%bf%e7%94%a8" class="header-anchor">#&lt;/a>
3 Stream 使用
&lt;/h2>
&lt;h3 id="31-optional">
&lt;a href="#31-optional" class="header-anchor">#&lt;/a>
3.1 Optional
&lt;/h3>
&lt;p>&lt;code>Optional&lt;/code> 类是一个可以为&lt;code>null&lt;/code> 的容器对象。如果值存在则&lt;code>isPresent()&lt;/code>方法会返回&lt;code>true&lt;/code>，调用&lt;code>get()&lt;/code>方法会返回该对象。&lt;/p>
&lt;h3 id="32-遍历-foreachfindmatch">
&lt;a href="#32-%e9%81%8d%e5%8e%86-foreachfindmatch" class="header-anchor">#&lt;/a>
3.2 遍历 forEach/find/match
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>遍历输出符合条件的元素&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().filter(x -&amp;gt; x &amp;gt; 6).forEach(System.out::println);
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>遍历对元素执行某个方法&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().forEach(methodName);
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>匹配一个&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().filter(x -&amp;gt; x &amp;gt; 6).findFirst();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>是否包含特定条件的元素&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().anyMatch(x -&amp;gt; x &amp;lt; 6);
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>所有元素满足条件&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().allMatch(x -&amp;gt; x == 1);
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h3 id="33-筛选-filter">
&lt;a href="#33-%e7%ad%9b%e9%80%89-filter" class="header-anchor">#&lt;/a>
3.3 筛选 filter
&lt;/h3>
&lt;p>同上，直接在 stream 对象上使用就行&lt;/p>
&lt;h3 id="34-聚合-maxmincount">
&lt;a href="#34-%e8%81%9a%e5%90%88-maxmincount" class="header-anchor">#&lt;/a>
3.4 聚合 max/min/count
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>获取 int 数组中中的最大值&lt;/p>
&lt;pre>&lt;code class="language-java">Arrays.stream(array).max().getAsInt();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>获取 Integer 列表中的最大值，需要传入一个 Comparator 对象&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().max(Integer::compareTo).get();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>获取 String 列里中长度最长的元素&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().max(Comparator.comparing(String::length)).get();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>获取员工列表工资最高的员工&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().max(Comparator.comparing(Person::getSalary)).get();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>计算 Integer 集合中大于 6 的元素的个数&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().filter(x -&amp;gt; x &amp;gt; 6).count();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h3 id="35-映射-mapflatmap">
&lt;a href="#35-%e6%98%a0%e5%b0%84-mapflatmap" class="header-anchor">#&lt;/a>
3.5 映射 map/flatMap
&lt;/h3>
&lt;p>映射，可以将一个流的元素按照一定的映射规则映射到另一个流中。分为&lt;code>map&lt;/code> 和&lt;code>flatMap&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>&lt;code>map&lt;/code>：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。&lt;/li>
&lt;li>&lt;code>flatMap&lt;/code>：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ul>
&lt;li>
&lt;p>将字符串数组的元素全部改成大写&lt;/p>
&lt;pre>&lt;code class="language-java">Arrays.stream(array).map(String::toUpperCase).collect(Collectors.toList());
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>将员工薪资全部增加 1000&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().map(person -&amp;gt; {
person.setSalary(person.getSalary() + 1000);
return person;
}).collect(Collectors.toList());
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h3 id="36-规约-reduce">
&lt;a href="#36-%e8%a7%84%e7%ba%a6-reduce" class="header-anchor">#&lt;/a>
3.6 规约 reduce
&lt;/h3>
&lt;p>将一个流缩减为一个值，能实现集合求和，求乘积和求最值操作等。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>求 Integer 列表的元素之和，乘积和最大值&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().reduce(Integer::sum).get();
list.stream().reduce((x,y) -&amp;gt; x + y).get();
list.stream().reduce((x,y) -&amp;gt; x * y).get();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h3 id="37-收集-collect">
&lt;a href="#37-%e6%94%b6%e9%9b%86-collect" class="header-anchor">#&lt;/a>
3.7 收集 collect
&lt;/h3>
&lt;p>就是把一个流收集起来，最终可以是收集成一个值也可以收集成一个新的集合。&lt;/p>
&lt;p>&lt;code>collect&lt;/code> 主要依赖&lt;code>java.util.stream.Collectors&lt;/code> 类内置的静态方法。&lt;/p>
&lt;ul>
&lt;li>归集：toList()，toSet()，toMap()&lt;/li>
&lt;li>统计：counting、averagingInt、averagingLong、averagingDouble、maxBy、minBy、summingInt、summingLong、summingDouble、sumarizingInt、sumarizingLong、sumarizingDouble&lt;/li>
&lt;/ul>
&lt;h3 id="38-分组-groupingbypartitioningby">
&lt;a href="#38-%e5%88%86%e7%bb%84-groupingbypartitioningby" class="header-anchor">#&lt;/a>
3.8 分组 groupingBy/partitioningBy
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>将员工按薪资是否高于 8000 分组&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().collect(Collectors.groupingBy(x -&amp;gt; x.getSalary() &amp;gt; 8000))
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>将员工按性别分组&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().collect(Collectors.groupingBy(Person::getSex));
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h3 id="39-连接-joining">
&lt;a href="#39-%e8%bf%9e%e6%8e%a5-joining" class="header-anchor">#&lt;/a>
3.9 连接 joining
&lt;/h3>
&lt;p>将 stream 中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().collect(Collectors.joining(&amp;quot;,&amp;quot;));
&lt;/code>&lt;/pre>
&lt;h3 id="310-排序-sorted">
&lt;a href="#310-%e6%8e%92%e5%ba%8f-sorted" class="header-anchor">#&lt;/a>
3.10 排序 sorted
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>按工资升序排序&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().sorted(Compartor.comparing(Person::getSalary));
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>按工资倒序排序&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().sorted(Compartor.comparing(Person::getSalary)).reversed();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>多列排序&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().sorted(Compartor.comparing(Person::getSalary).thenComparing(Person::getAge));
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul></description></item><item><title>Java 并发知识点笔记</title><link>https://cuterwrite.top/p/java-concurrent/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/java-concurrent/</guid><description>&lt;img src="https://cloud.cuterwrite.fun/blog/santorini-1578440_1920.3ldusy6rm1k0.webp" alt="Featured image of post Java 并发知识点笔记" />&lt;h1 id="java-并发知识点笔记">
&lt;a href="#java-%e5%b9%b6%e5%8f%91%e7%9f%a5%e8%af%86%e7%82%b9%e7%ac%94%e8%ae%b0" class="header-anchor">#&lt;/a>
Java 并发知识点笔记
&lt;/h1>
&lt;h2 id="1-使用线程的方法">
&lt;a href="#1-%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%96%b9%e6%b3%95" class="header-anchor">#&lt;/a>
1 使用线程的方法
&lt;/h2>
&lt;ul>
&lt;li>实现 Runnable 接口；&lt;/li>
&lt;li>实现 Callable 接口；&lt;/li>
&lt;li>继承 Thread 类。&lt;/li>
&lt;/ul>
&lt;h2 id="2-基础线程机制">
&lt;a href="#2-%e5%9f%ba%e7%a1%80%e7%ba%bf%e7%a8%8b%e6%9c%ba%e5%88%b6" class="header-anchor">#&lt;/a>
2 基础线程机制
&lt;/h2>
&lt;h3 id="21-executor">
&lt;a href="#21-executor" class="header-anchor">#&lt;/a>
2.1 Executor
&lt;/h3>
&lt;p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。&lt;/p>
&lt;p>主要有三种 Executor：&lt;/p>
&lt;ul>
&lt;li>CachedThreadPool：一个任务创建一个线程；&lt;/li>
&lt;li>FixedThreadPool：所有任务只能使用固定大小的线程；&lt;/li>
&lt;li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。&lt;/li>
&lt;/ul>
&lt;h3 id="22-daemon">
&lt;a href="#22-daemon" class="header-anchor">#&lt;/a>
2.2 Daemon
&lt;/h3>
&lt;p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。&lt;/p>
&lt;p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。&lt;/p>
&lt;p>main() 属于非守护线程。&lt;/p>
&lt;p>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。&lt;/p>
&lt;h3 id="23-sleep">
&lt;a href="#23-sleep" class="header-anchor">#&lt;/a>
2.3 sleep()
&lt;/h3>
&lt;p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。&lt;/p>
&lt;p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。&lt;/p>
&lt;h3 id="24-yield">
&lt;a href="#24-yield" class="header-anchor">#&lt;/a>
2.4 yield()
&lt;/h3>
&lt;p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。&lt;/p>
&lt;h2 id="3-线程中断">
&lt;a href="#3-%e7%ba%bf%e7%a8%8b%e4%b8%ad%e6%96%ad" class="header-anchor">#&lt;/a>
3 线程中断
&lt;/h2>
&lt;p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。&lt;/p>
&lt;h3 id="31-interruptedexception">
&lt;a href="#31-interruptedexception" class="header-anchor">#&lt;/a>
3.1 InterruptedException
&lt;/h3>
&lt;p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。&lt;/p>
&lt;h3 id="32-interrupted">
&lt;a href="#32-interrupted" class="header-anchor">#&lt;/a>
3.2 interrupted()
&lt;/h3>
&lt;p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。&lt;/p>
&lt;p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。&lt;/p>
&lt;h3 id="33-executor-的中断操作">
&lt;a href="#33-executor-%e7%9a%84%e4%b8%ad%e6%96%ad%e6%93%8d%e4%bd%9c" class="header-anchor">#&lt;/a>
3.3 Executor 的中断操作
&lt;/h3>
&lt;p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。&lt;/p>
&lt;h2 id="4-互斥锁">
&lt;a href="#4-%e4%ba%92%e6%96%a5%e9%94%81" class="header-anchor">#&lt;/a>
4 互斥锁
&lt;/h2>
&lt;p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。&lt;/p>
&lt;h3 id="41-synchronized">
&lt;a href="#41-synchronized" class="header-anchor">#&lt;/a>
4.1 synchronized
&lt;/h3>
&lt;ul>
&lt;li>同步代码块：锁对象&lt;/li>
&lt;li>同步一个方法：锁对象&lt;/li>
&lt;li>同步一个类：锁整个类&lt;/li>
&lt;li>同步一个静态方法：锁整个类&lt;/li>
&lt;/ul>
&lt;h3 id="42-reentrantlock">
&lt;a href="#42-reentrantlock" class="header-anchor">#&lt;/a>
4.2 ReentrantLock
&lt;/h3>
&lt;p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。&lt;/p>
&lt;p>通过 lock 和 unlock 操作&lt;/p>
&lt;h3 id="43-比较">
&lt;a href="#43-%e6%af%94%e8%be%83" class="header-anchor">#&lt;/a>
4.3 比较
&lt;/h3>
&lt;p>&lt;strong>1. 锁的实现&lt;/strong>&lt;/p>
&lt;p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。&lt;/p>
&lt;p>&lt;strong>2. 性能&lt;/strong>&lt;/p>
&lt;p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。&lt;/p>
&lt;p>&lt;strong>3. 等待可中断&lt;/strong>&lt;/p>
&lt;p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。&lt;/p>
&lt;p>ReentrantLock 可中断，而 synchronized 不行。&lt;/p>
&lt;p>&lt;strong>4. 公平锁&lt;/strong>&lt;/p>
&lt;p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。&lt;/p>
&lt;p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。&lt;/p>
&lt;p>&lt;strong>5. 锁绑定多个条件&lt;/strong>&lt;/p>
&lt;p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。&lt;/p>
&lt;h3 id="44-选择">
&lt;a href="#44-%e9%80%89%e6%8b%a9" class="header-anchor">#&lt;/a>
4.4 选择
&lt;/h3>
&lt;p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。&lt;/p>
&lt;h2 id="5-线程协作">
&lt;a href="#5-%e7%ba%bf%e7%a8%8b%e5%8d%8f%e4%bd%9c" class="header-anchor">#&lt;/a>
5 线程协作
&lt;/h2>
&lt;h3 id="51-join">
&lt;a href="#51-join" class="header-anchor">#&lt;/a>
5.1 join
&lt;/h3>
&lt;p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。&lt;/p>
&lt;h3 id="52-waitnotify">
&lt;a href="#52-waitnotify" class="header-anchor">#&lt;/a>
5.2 wait/notify
&lt;/h3>
&lt;p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。&lt;/p>
&lt;p>它们都属于 Object 的一部分，而不属于 Thread。&lt;/p>
&lt;p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。&lt;/p>
&lt;p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁&lt;/p>
&lt;p>&lt;strong>wait() 和 sleep() 的区别&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；&lt;/li>
&lt;li>wait() 会释放锁，sleep() 不会。&lt;/li>
&lt;/ul>
&lt;h3 id="53-awaitsignal">
&lt;a href="#53-awaitsignal" class="header-anchor">#&lt;/a>
5.3 await/signal
&lt;/h3>
&lt;p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。&lt;/p>
&lt;p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。&lt;/p>
&lt;p>使用 Lock 来获取一个 Condition 对象。&lt;/p>
&lt;h2 id="6-线程状态">
&lt;a href="#6-%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81" class="header-anchor">#&lt;/a>
6 线程状态
&lt;/h2>
&lt;ul>
&lt;li>new&lt;/li>
&lt;li>runable&lt;/li>
&lt;li>blocked&lt;/li>
&lt;li>waiting&lt;/li>
&lt;li>timed_waiting&lt;/li>
&lt;li>terminated&lt;/li>
&lt;/ul>
&lt;h2 id="7-juc-包aqs">
&lt;a href="#7-juc-%e5%8c%85aqs" class="header-anchor">#&lt;/a>
7 JUC 包/AQS
&lt;/h2>
&lt;h3 id="71-countdownlatch">
&lt;a href="#71-countdownlatch" class="header-anchor">#&lt;/a>
7.1 CountDownLatch
&lt;/h3>
&lt;p>用来控制一个或者多个线程等待多个线程。&lt;/p>
&lt;p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="72-cyclicbarrier">
&lt;a href="#72-cyclicbarrier" class="header-anchor">#&lt;/a>
7.2 CyclicBarrier
&lt;/h3>
&lt;p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。&lt;/p>
&lt;p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。&lt;/p>
&lt;p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。&lt;/p>
&lt;p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png" width="90%" loading="lazy">
&lt;/figure>
&lt;h3 id="73-semaphore">
&lt;a href="#73-semaphore" class="header-anchor">#&lt;/a>
7.3 Semaphore
&lt;/h3>
&lt;p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。&lt;/p>
&lt;h2 id="8-juc-包其它组件">
&lt;a href="#8-juc-%e5%8c%85%e5%85%b6%e5%ae%83%e7%bb%84%e4%bb%b6" class="header-anchor">#&lt;/a>
8 JUC 包其它组件
&lt;/h2>
&lt;h3 id="81-futuretask">
&lt;a href="#81-futuretask" class="header-anchor">#&lt;/a>
8.1 FutureTask
&lt;/h3>
&lt;p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future&amp;lt;V&amp;gt; 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future&amp;lt;V&amp;gt; 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。&lt;/p>
&lt;p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。&lt;/p>
&lt;h3 id="82-blockingqueue">
&lt;a href="#82-blockingqueue" class="header-anchor">#&lt;/a>
8.2 BlockingQueue
&lt;/h3>
&lt;p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>FIFO 队列&lt;/strong> ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）&lt;/li>
&lt;li>&lt;strong>优先级队列&lt;/strong> ：PriorityBlockingQueue&lt;/li>
&lt;/ul>
&lt;p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。&lt;/p>
&lt;h3 id="83-forkjoin">
&lt;a href="#83-forkjoin" class="header-anchor">#&lt;/a>
8.3 ForkJoin
&lt;/h3>
&lt;p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。&lt;/p>
&lt;p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。&lt;/p>
&lt;h2 id="9-内存模型">
&lt;a href="#9-%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b" class="header-anchor">#&lt;/a>
9 内存模型
&lt;/h2>
&lt;p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。&lt;/p>
&lt;h3 id="91-主内存与工作内存">
&lt;a href="#91-%e4%b8%bb%e5%86%85%e5%ad%98%e4%b8%8e%e5%b7%a5%e4%bd%9c%e5%86%85%e5%ad%98" class="header-anchor">#&lt;/a>
9.1 主内存与工作内存
&lt;/h3>
&lt;p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。&lt;/p>
&lt;p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942ca0d2-9d5c-45a4-89cb-5fd89b61913f.png" width="90%" loading="lazy">
&lt;/figure>
&lt;p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。&lt;/p>
&lt;p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15851555-5abc-497d-ad34-efed10f43a6b.png" width="90%" loading="lazy">
&lt;/figure>
&lt;h3 id="92-内存间交互操作">
&lt;a href="#92-%e5%86%85%e5%ad%98%e9%97%b4%e4%ba%a4%e4%ba%92%e6%93%8d%e4%bd%9c" class="header-anchor">#&lt;/a>
9.2 内存间交互操作
&lt;/h3>
&lt;p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8b7ebbad-9604-4375-84e3-f412099d170c.png" width="90%" loading="lazy">
&lt;/figure>
&lt;ul>
&lt;li>read：把一个变量的值从主内存传输到工作内存中&lt;/li>
&lt;li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中&lt;/li>
&lt;li>use：把工作内存中一个变量的值传递给执行引擎&lt;/li>
&lt;li>assign：把一个从执行引擎接收到的值赋给工作内存的变量&lt;/li>
&lt;li>store：把工作内存的一个变量的值传送到主内存中&lt;/li>
&lt;li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中&lt;/li>
&lt;li>lock：作用于主内存的变量&lt;/li>
&lt;li>unlock&lt;/li>
&lt;/ul>
&lt;h3 id="93-内存模型三大特性">
&lt;a href="#93-%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e4%b8%89%e5%a4%a7%e7%89%b9%e6%80%a7" class="header-anchor">#&lt;/a>
9.3 内存模型三大特性
&lt;/h3>
&lt;h4 id="931-原子性">
&lt;a href="#931-%e5%8e%9f%e5%ad%90%e6%80%a7" class="header-anchor">#&lt;/a>
9.3.1. 原子性
&lt;/h4>
&lt;p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。&lt;/p>
&lt;p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。&lt;/p>
&lt;p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。&lt;/p>
&lt;p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2797a609-68db-4d7b-8701-41ac9a34b14f.jpg" width="90%" loading="lazy">
&lt;/figure>
&lt;p>AtomicInteger 能保证多个线程修改的原子性。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dd563037-fcaa-4bd8-83b6-b39d93a12c77.jpg" width="90%" loading="lazy">
&lt;/figure>
&lt;p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。&lt;/p>
&lt;h4 id="932-可见性">
&lt;a href="#932-%e5%8f%af%e8%a7%81%e6%80%a7" class="header-anchor">#&lt;/a>
9.3.2. 可见性
&lt;/h4>
&lt;p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。&lt;/p>
&lt;p>主要有三种实现可见性的方式：&lt;/p>
&lt;ul>
&lt;li>volatile&lt;/li>
&lt;li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。&lt;/li>
&lt;li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。&lt;/li>
&lt;/ul>
&lt;p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。&lt;/p>
&lt;h4 id="933-有序性">
&lt;a href="#933-%e6%9c%89%e5%ba%8f%e6%80%a7" class="header-anchor">#&lt;/a>
9.3.3. 有序性
&lt;/h4>
&lt;p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。&lt;/p>
&lt;p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。&lt;/p>
&lt;p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。&lt;/p>
&lt;h3 id="94-先行发生原则">
&lt;a href="#94-%e5%85%88%e8%a1%8c%e5%8f%91%e7%94%9f%e5%8e%9f%e5%88%99" class="header-anchor">#&lt;/a>
9.4 先行发生原则
&lt;/h3>
&lt;p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。&lt;/p>
&lt;ol>
&lt;li>单一线程原则：在一个线程内，在程序前面的操作先行发生于后面的操作。&lt;/li>
&lt;li>管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。&lt;/li>
&lt;li>volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。&lt;/li>
&lt;li>线程启动规则：Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。&lt;/li>
&lt;li>线程加入规则：Thread 对象的结束先行发生于 join() 方法返回。&lt;/li>
&lt;li>线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。&lt;/li>
&lt;li>对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。&lt;/li>
&lt;li>传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。&lt;/li>
&lt;/ol>
&lt;h2 id="10-线程安全策略">
&lt;a href="#10-%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%ad%96%e7%95%a5" class="header-anchor">#&lt;/a>
10 线程安全策略
&lt;/h2>
&lt;h3 id="101-不可变">
&lt;a href="#101-%e4%b8%8d%e5%8f%af%e5%8f%98" class="header-anchor">#&lt;/a>
10.1 不可变
&lt;/h3>
&lt;p>不可变的类型：&lt;/p>
&lt;ul>
&lt;li>final 关键字修饰的基本数据类型&lt;/li>
&lt;li>String&lt;/li>
&lt;li>枚举类型&lt;/li>
&lt;li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。&lt;/li>
&lt;/ul>
&lt;p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。&lt;/p>
&lt;h3 id="102-互斥同步">
&lt;a href="#102-%e4%ba%92%e6%96%a5%e5%90%8c%e6%ad%a5" class="header-anchor">#&lt;/a>
10.2 互斥同步
&lt;/h3>
&lt;p>synchronized 和 ReentrantLock。&lt;/p>
&lt;h3 id="103-非阻塞同步">
&lt;a href="#103-%e9%9d%9e%e9%98%bb%e5%a1%9e%e5%90%8c%e6%ad%a5" class="header-anchor">#&lt;/a>
10.3 非阻塞同步
&lt;/h3>
&lt;ul>
&lt;li>CAS&lt;/li>
&lt;li>AtomicInteger&lt;/li>
&lt;/ul>
&lt;p>ABA 问题：如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。&lt;/p>
&lt;p>解决方法：J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。&lt;/p>
&lt;h3 id="104-无同步">
&lt;a href="#104-%e6%97%a0%e5%90%8c%e6%ad%a5" class="header-anchor">#&lt;/a>
10.4 无同步
&lt;/h3>
&lt;h4 id="1041-栈封闭">
&lt;a href="#1041-%e6%a0%88%e5%b0%81%e9%97%ad" class="header-anchor">#&lt;/a>
10.4.1 栈封闭
&lt;/h4>
&lt;p>多个线程访问同一个方法的&lt;strong>局部变量&lt;/strong>时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。&lt;/p>
&lt;h4 id="1042-线程本地存储">
&lt;a href="#1042-%e7%ba%bf%e7%a8%8b%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8" class="header-anchor">#&lt;/a>
10.4.2 线程本地存储
&lt;/h4>
&lt;p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围&lt;strong>限制在同一个线程之内&lt;/strong>，这样，无须同步也能保证线程之间不出现数据争用的问题。&lt;/p>
&lt;p>它提供了线程本地变量，也就是如果你创建了一个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作的自己本地内存里面的变量，从而避免了线程安全问题&lt;/p>
&lt;p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。&lt;/p>
&lt;p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&amp;gt;value 键值对插入到该 Map 中。&lt;/p>
&lt;h4 id="1043-可重入代码">
&lt;a href="#1043-%e5%8f%af%e9%87%8d%e5%85%a5%e4%bb%a3%e7%a0%81" class="header-anchor">#&lt;/a>
10.4.3 可重入代码
&lt;/h4>
&lt;p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。&lt;/p>
&lt;p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。&lt;/p>
&lt;h2 id="11-锁优化">
&lt;a href="#11-%e9%94%81%e4%bc%98%e5%8c%96" class="header-anchor">#&lt;/a>
11 锁优化
&lt;/h2>
&lt;h3 id="111-自旋锁">
&lt;a href="#111-%e8%87%aa%e6%97%8b%e9%94%81" class="header-anchor">#&lt;/a>
11.1 自旋锁
&lt;/h3>
&lt;p>自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。&lt;/p>
&lt;p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于&lt;strong>共享数据的锁定状态很短&lt;/strong>的场景。&lt;/p>
&lt;p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。&lt;/p>
&lt;h3 id="112-锁消除">
&lt;a href="#112-%e9%94%81%e6%b6%88%e9%99%a4" class="header-anchor">#&lt;/a>
11.2 锁消除
&lt;/h3>
&lt;p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。&lt;/p>
&lt;p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。&lt;/p>
&lt;h3 id="113-锁粗化">
&lt;a href="#113-%e9%94%81%e7%b2%97%e5%8c%96" class="header-anchor">#&lt;/a>
11.3 锁粗化
&lt;/h3>
&lt;p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。&lt;/p>
&lt;p>如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。&lt;/p>
&lt;h3 id="114-轻量级锁">
&lt;a href="#114-%e8%bd%bb%e9%87%8f%e7%ba%a7%e9%94%81" class="header-anchor">#&lt;/a>
11.4 轻量级锁
&lt;/h3>
&lt;p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。&lt;/p>
&lt;p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。&lt;/p>
&lt;h3 id="115-偏向锁">
&lt;a href="#115-%e5%81%8f%e5%90%91%e9%94%81" class="header-anchor">#&lt;/a>
11.5 偏向锁
&lt;/h3>
&lt;p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。&lt;/p>
&lt;hr>
&lt;p>本文转载自：&lt;a class="link" href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener" >https://github.com/CyC2018/CS-Notes
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
，用于个人复习。&lt;/p></description></item><item><title>Java 容器知识点笔记</title><link>https://cuterwrite.top/p/java-collection/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/java-collection/</guid><description>&lt;img src="https://cloud.cuterwrite.fun/blog/antarctica-1987579_1920.4sf6q29twew0.webp" alt="Featured image of post Java 容器知识点笔记" />&lt;h1 id="java-容器知识点笔记">
&lt;a href="#java-%e5%ae%b9%e5%99%a8%e7%9f%a5%e8%af%86%e7%82%b9%e7%ac%94%e8%ae%b0" class="header-anchor">#&lt;/a>
Java 容器知识点笔记
&lt;/h1>
&lt;h2 id="1-概述">
&lt;a href="#1-%e6%a6%82%e8%bf%b0" class="header-anchor">#&lt;/a>
1 概述
&lt;/h2>
&lt;p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。&lt;/p>
&lt;h3 id="11-collection">
&lt;a href="#11-collection" class="header-anchor">#&lt;/a>
1.1 Collection
&lt;/h3>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208220948084.png" width="90%" loading="lazy">
&lt;/figure>
&lt;h4 id="111-set">
&lt;a href="#111-set" class="header-anchor">#&lt;/a>
1.1.1 Set
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="112-list">
&lt;a href="#112-list" class="header-anchor">#&lt;/a>
1.1.2 List
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>ArrayList：基于动态数组实现，支持随机访问。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Vector：和 ArrayList 类似，但它是线程安全的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="113-queue">
&lt;a href="#113-queue" class="header-anchor">#&lt;/a>
1.1.3 Queue
&lt;/h4>
&lt;ul>
&lt;li>LinkedList：可以用它来实现双向队列。&lt;/li>
&lt;li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。&lt;/li>
&lt;/ul>
&lt;h2 id="2-源码分析">
&lt;a href="#2-%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90" class="header-anchor">#&lt;/a>
2 源码分析
&lt;/h2>
&lt;h3 id="21-arraylist">
&lt;a href="#21-arraylist" class="header-anchor">#&lt;/a>
2.1 ArrayList
&lt;/h3>
&lt;h4 id="211-概述">
&lt;a href="#211-%e6%a6%82%e8%bf%b0" class="header-anchor">#&lt;/a>
2.1.1 概述
&lt;/h4>
&lt;p>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问，默认容量为 10&lt;/p>
&lt;pre>&lt;code class="language-java">transient Object[] elementData;
private static final int DEFAULT_CAPACITY = 10;
&lt;/code>&lt;/pre>
&lt;h4 id="212-扩容">
&lt;a href="#212-%e6%89%a9%e5%ae%b9" class="header-anchor">#&lt;/a>
2.1.2 扩容
&lt;/h4>
&lt;p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 &lt;code>oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1)&lt;/code>，即 oldCapacity+oldCapacity/2。其中 oldCapacity &amp;raquo; 1 需要取整，所以新容量大约是旧容量的 1.5 倍左右。（oldCapacity 为偶数就是 1.5 倍，为奇数就是 1.5 倍-0.5）&lt;/p>
&lt;p>扩容操作需要调用 &lt;code>Arrays.copyOf()&lt;/code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。&lt;/p>
&lt;h4 id="213-删除元素">
&lt;a href="#213-%e5%88%a0%e9%99%a4%e5%85%83%e7%b4%a0" class="header-anchor">#&lt;/a>
2.1.3 删除元素
&lt;/h4>
&lt;p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。&lt;/p>
&lt;h4 id="214-序列化">
&lt;a href="#214-%e5%ba%8f%e5%88%97%e5%8c%96" class="header-anchor">#&lt;/a>
2.1.4 序列化
&lt;/h4>
&lt;p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。&lt;/p>
&lt;p>保存元素的数组 elementData 使用 &lt;strong>transient&lt;/strong> 修饰，该关键字声明数组默认不会被序列化。&lt;/p>
&lt;p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。&lt;/p>
&lt;p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。&lt;/p>
&lt;h4 id="215-fail-fast">
&lt;a href="#215-fail-fast" class="header-anchor">#&lt;/a>
2.1.5 Fail-fast
&lt;/h4>
&lt;p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。&lt;/p>
&lt;p>在进行序列化或者迭代等操作时，&lt;strong>需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException&lt;/strong>。代码参考上节序列化中的 writeObject() 方法。&lt;/p>
&lt;h3 id="22-vector">
&lt;a href="#22-vector" class="header-anchor">#&lt;/a>
2.2 Vector
&lt;/h3>
&lt;h4 id="221-同步">
&lt;a href="#221-%e5%90%8c%e6%ad%a5" class="header-anchor">#&lt;/a>
2.2.1 同步
&lt;/h4>
&lt;p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。&lt;/p>
&lt;h4 id="222-扩容">
&lt;a href="#222-%e6%89%a9%e5%ae%b9" class="header-anchor">#&lt;/a>
2.2.2 扩容
&lt;/h4>
&lt;p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。&lt;/p>
&lt;p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。&lt;/p>
&lt;h4 id="223-与-arraylist-的比较">
&lt;a href="#223-%e4%b8%8e-arraylist-%e7%9a%84%e6%af%94%e8%be%83" class="header-anchor">#&lt;/a>
2.2.3 与 ArrayList 的比较
&lt;/h4>
&lt;ul>
&lt;li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；&lt;/li>
&lt;li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。&lt;/li>
&lt;/ul>
&lt;h4 id="224-替代方案">
&lt;a href="#224-%e6%9b%bf%e4%bb%a3%e6%96%b9%e6%a1%88" class="header-anchor">#&lt;/a>
2.2.4 替代方案
&lt;/h4>
&lt;p>可以使用 &lt;code>Collections.synchronizedList();&lt;/code> 得到一个线程安全的 ArrayList。&lt;/p>
&lt;p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。&lt;/p>
&lt;h3 id="23-copyonwritearraylist">
&lt;a href="#23-copyonwritearraylist" class="header-anchor">#&lt;/a>
2.3 CopyOnWriteArrayList
&lt;/h3>
&lt;h4 id="231-读写分离">
&lt;a href="#231-%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb" class="header-anchor">#&lt;/a>
2.3.1 读写分离
&lt;/h4>
&lt;p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。&lt;/p>
&lt;p>写操作需要加锁，防止并发写入时导致写入数据丢失。&lt;/p>
&lt;p>写操作结束之后需要把原始数组指向新的复制数组。&lt;/p>
&lt;h4 id="232-适用场景">
&lt;a href="#232-%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af" class="header-anchor">#&lt;/a>
2.3.2 适用场景
&lt;/h4>
&lt;p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。&lt;/p>
&lt;p>但是 CopyOnWriteArrayList 有其缺陷：&lt;/p>
&lt;ul>
&lt;li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；&lt;/li>
&lt;li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。&lt;/li>
&lt;/ul>
&lt;p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。&lt;/p>
&lt;h3 id="24-linkedlist">
&lt;a href="#24-linkedlist" class="header-anchor">#&lt;/a>
2.4 LinkedList
&lt;/h3>
&lt;h4 id="241-概述">
&lt;a href="#241-%e6%a6%82%e8%bf%b0" class="header-anchor">#&lt;/a>
2.4.1 概述
&lt;/h4>
&lt;p>基于双向链表实现，使用 Node 存储链表节点信息。&lt;/p>
&lt;pre>&lt;code class="language-java">private static class Node&amp;lt;E&amp;gt; {
E item;
Node&amp;lt;E&amp;gt; next;
Node&amp;lt;E&amp;gt; prev;
}
&lt;/code>&lt;/pre>
&lt;p>每个链表存储了 first 和 last 指针：&lt;/p>
&lt;pre>&lt;code class="language-java">transient Node&amp;lt;E&amp;gt; first;
transient Node&amp;lt;E&amp;gt; last;
&lt;/code>&lt;/pre>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208233940066.png" width="90%" loading="lazy">
&lt;/figure>
&lt;h4 id="242-与-arraylist-的比较">
&lt;a href="#242-%e4%b8%8e-arraylist-%e7%9a%84%e6%af%94%e8%be%83" class="header-anchor">#&lt;/a>
2.4.2 与 ArrayList 的比较
&lt;/h4>
&lt;p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：&lt;/p>
&lt;ul>
&lt;li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素；&lt;/li>
&lt;li>链表不支持随机访问，但插入删除只需要改变指针。&lt;/li>
&lt;/ul>
&lt;h3 id="25-hashmap">
&lt;a href="#25-hashmap" class="header-anchor">#&lt;/a>
2.5 HashMap
&lt;/h3>
&lt;h4 id="251-概述">
&lt;a href="#251-%e6%a6%82%e8%bf%b0" class="header-anchor">#&lt;/a>
2.5.1 概述
&lt;/h4>
&lt;ul>
&lt;li>基于数组+链表+红黑树实现&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java">transient Node&amp;lt;K,V&amp;gt;[] table;
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>默认容量 16，每次扩容为 2 倍&lt;/li>
&lt;li>默认负载因子为 0.75&lt;/li>
&lt;li>当链表长度大于等于 8 时，检查 table 长度是否大于 64，如果是则转成红黑树。&lt;/li>
&lt;li>基本原理：通过 key 的 hashcode 经过扰动处理得到 hash 值，然后通过(n - 1) &amp;amp; hash 判断当前元素存放的位置，如果当前位置存在元素的话，就判断该元素与要存放的元素的 hash 值以及 key 是否相同，如果相同则直接覆盖，不相同就用拉链法解决冲突。&lt;/li>
&lt;/ul>
&lt;h4 id="252-拉链法">
&lt;a href="#252-%e6%8b%89%e9%93%be%e6%b3%95" class="header-anchor">#&lt;/a>
2.5.2 拉链法
&lt;/h4>
&lt;p>将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。&lt;/p>
&lt;h4 id="253-确认桶下标方法">
&lt;a href="#253-%e7%a1%ae%e8%ae%a4%e6%a1%b6%e4%b8%8b%e6%a0%87%e6%96%b9%e6%b3%95" class="header-anchor">#&lt;/a>
2.5.3 确认桶下标方法
&lt;/h4>
&lt;ol>
&lt;li>计算 key 的 hash（h = key.hashcode(); h ^ (h &amp;raquo;&amp;gt; 16)）&lt;/li>
&lt;li>hash &amp;amp; (n - 1)&lt;/li>
&lt;/ol>
&lt;h4 id="254-扩容基本原理">
&lt;a href="#254-%e6%89%a9%e5%ae%b9%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86" class="header-anchor">#&lt;/a>
2.5.4 扩容基本原理
&lt;/h4>
&lt;p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。&lt;/p>
&lt;p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。&lt;/p>
&lt;p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。&lt;/p>
&lt;h4 id="255-扩容重新计算桶下标">
&lt;a href="#255-%e6%89%a9%e5%ae%b9%e9%87%8d%e6%96%b0%e8%ae%a1%e7%ae%97%e6%a1%b6%e4%b8%8b%e6%a0%87" class="header-anchor">#&lt;/a>
2.5.5 扩容重新计算桶下标
&lt;/h4>
&lt;p>在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，HashMap 使用 hash%capacity 来确定桶下标。HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。&lt;/p>
&lt;h4 id="256-与-hashtable-对比">
&lt;a href="#256-%e4%b8%8e-hashtable-%e5%af%b9%e6%af%94" class="header-anchor">#&lt;/a>
2.5.6 与 HashTable 对比
&lt;/h4>
&lt;ul>
&lt;li>Hashtable 使用 synchronized 来进行同步。&lt;/li>
&lt;li>HashMap 可以插入键为 null 的 Entry。&lt;/li>
&lt;li>HashMap 的迭代器是 fail-fast 迭代器。&lt;/li>
&lt;li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。&lt;/li>
&lt;/ul>
&lt;h3 id="26-concurrenthashmap">
&lt;a href="#26-concurrenthashmap" class="header-anchor">#&lt;/a>
2.6 ConcurrentHashMap
&lt;/h3>
&lt;h4 id="261-存储结构">
&lt;a href="#261-%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84" class="header-anchor">#&lt;/a>
2.6.1 存储结构
&lt;/h4>
&lt;p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。&lt;/p>
&lt;p>Segment 继承自 ReentrantLock。&lt;/p>
&lt;p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。&lt;/p>
&lt;h4 id="262-size-操作">
&lt;a href="#262-size-%e6%93%8d%e4%bd%9c" class="header-anchor">#&lt;/a>
2.6.2 size 操作
&lt;/h4>
&lt;p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。&lt;/p>
&lt;p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。&lt;/p>
&lt;p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。&lt;/p>
&lt;p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。&lt;/p>
&lt;p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。&lt;/p>
&lt;h4 id="263-jdk8-的改动">
&lt;a href="#263-jdk8-%e7%9a%84%e6%94%b9%e5%8a%a8" class="header-anchor">#&lt;/a>
2.6.3 jdk8 的改动
&lt;/h4>
&lt;p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。&lt;/p>
&lt;p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。&lt;/p>
&lt;p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。&lt;/p>
&lt;h3 id="27-linkedhashmap">
&lt;a href="#27-linkedhashmap" class="header-anchor">#&lt;/a>
2.7 LinkedHashMap
&lt;/h3>
&lt;h4 id="271-存储结构">
&lt;a href="#271-%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84" class="header-anchor">#&lt;/a>
2.7.1 存储结构
&lt;/h4>
&lt;p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。&lt;/p>
&lt;p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。&lt;/p>
&lt;pre>&lt;code class="language-java">transient LinkedHashMap.Entry&amp;lt;K,V&amp;gt; head;
transient LinkedHashMap.Entry&amp;lt;K,V&amp;gt; tail;
&lt;/code>&lt;/pre>
&lt;p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。&lt;/p>
&lt;pre>&lt;code class="language-java">final boolean accessOrder;
&lt;/code>&lt;/pre>
&lt;p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。&lt;/p>
&lt;pre>&lt;code class="language-java">void afterNodeAccess(Node&amp;lt;K,V&amp;gt; p) { }
void afterNodeInsertion(boolean evict) { }
&lt;/code>&lt;/pre>
&lt;h4 id="272-afternodeaccess">
&lt;a href="#272-afternodeaccess" class="header-anchor">#&lt;/a>
2.7.2 afterNodeAccess()
&lt;/h4>
&lt;p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。&lt;/p>
&lt;h4 id="273-afternodeinsertion">
&lt;a href="#273-afternodeinsertion" class="header-anchor">#&lt;/a>
2.7.3 afterNodeInsertion()
&lt;/h4>
&lt;p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。&lt;/p>
&lt;p>evict 只有在构建 Map 的时候才为 false，在这里为 true。&lt;/p>
&lt;hr>
&lt;p>本文转载自：&lt;a class="link" href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener" >https://github.com/CyC2018/CS-Notes
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
，用于个人复习。&lt;/p></description></item><item><title>JavaSE 知识点笔记</title><link>https://cuterwrite.top/p/java-se/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/java-se/</guid><description>&lt;img src="https://cloud.cuterwrite.fun/blog/river-6021951_1920.4hwe8w8ugb20.webp" alt="Featured image of post JavaSE 知识点笔记" />&lt;h1 id="javase-知识点笔记">
&lt;a href="#javase-%e7%9f%a5%e8%af%86%e7%82%b9%e7%ac%94%e8%ae%b0" class="header-anchor">#&lt;/a>
JavaSE 知识点笔记
&lt;/h1>
&lt;h2 id="1-数据类型">
&lt;a href="#1-%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" class="header-anchor">#&lt;/a>
1 数据类型
&lt;/h2>
&lt;h3 id="11-基本类型">
&lt;a href="#11-%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b" class="header-anchor">#&lt;/a>
1.1 基本类型
&lt;/h3>
&lt;ul>
&lt;li>byte/8&lt;/li>
&lt;li>char/16&lt;/li>
&lt;li>short/16&lt;/li>
&lt;li>int/32&lt;/li>
&lt;li>float/32&lt;/li>
&lt;li>long/64&lt;/li>
&lt;li>double/64&lt;/li>
&lt;li>boolean/~&lt;/li>
&lt;/ul>
&lt;h3 id="12-包装类型">
&lt;a href="#12-%e5%8c%85%e8%a3%85%e7%b1%bb%e5%9e%8b" class="header-anchor">#&lt;/a>
1.2 包装类型
&lt;/h3>
&lt;p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。&lt;/p>
&lt;pre>&lt;code class="language-java">Integer x = 2; // 装箱 调用了 Integer.valueOf(2)
int y = x; // 拆箱 调用了 X.intValue()
&lt;/code>&lt;/pre>
&lt;h3 id="13-缓存池">
&lt;a href="#13-%e7%bc%93%e5%ad%98%e6%b1%a0" class="header-anchor">#&lt;/a>
1.3 缓存池
&lt;/h3>
&lt;p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：&lt;/p>
&lt;ul>
&lt;li>new Integer(123) 每次都会新建一个对象；&lt;/li>
&lt;li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。&lt;/li>
&lt;/ul>
&lt;p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。&lt;/p>
&lt;p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。&lt;/p>
&lt;p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。&lt;/p>
&lt;p>基本类型对应的缓冲池如下：&lt;/p>
&lt;ul>
&lt;li>boolean values true and false&lt;/li>
&lt;li>all byte values&lt;/li>
&lt;li>short values between -128 and 127&lt;/li>
&lt;li>int values between -128 and 127&lt;/li>
&lt;li>char in the range \u0000 to \u007F&lt;/li>
&lt;/ul>
&lt;h2 id="2-string">
&lt;a href="#2-string" class="header-anchor">#&lt;/a>
2 String
&lt;/h2>
&lt;h3 id="21-概述">
&lt;a href="#21-%e6%a6%82%e8%bf%b0" class="header-anchor">#&lt;/a>
2.1 概述
&lt;/h3>
&lt;p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）&lt;/p>
&lt;p>在 Java 8 中，String 内部使用 char 数组存储数据。&lt;/p>
&lt;pre>&lt;code class="language-java">private final char[] value;
&lt;/code>&lt;/pre>
&lt;p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 &lt;code>coder&lt;/code> 来标识使用了哪种编码。&lt;/p>
&lt;pre>&lt;code class="language-java">private final byte[] value;
private final byte coder;
&lt;/code>&lt;/pre>
&lt;p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。&lt;/p>
&lt;h3 id="22-不可变的优点">
&lt;a href="#22-%e4%b8%8d%e5%8f%af%e5%8f%98%e7%9a%84%e4%bc%98%e7%82%b9" class="header-anchor">#&lt;/a>
2.2 不可变的优点
&lt;/h3>
&lt;h4 id="221-可以缓存-hash-值">
&lt;a href="#221-%e5%8f%af%e4%bb%a5%e7%bc%93%e5%ad%98-hash-%e5%80%bc" class="header-anchor">#&lt;/a>
2.2.1 可以缓存 hash 值
&lt;/h4>
&lt;p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。&lt;/p>
&lt;h4 id="222-string-pool">
&lt;a href="#222-string-pool" class="header-anchor">#&lt;/a>
2.2.2 String Pool
&lt;/h4>
&lt;p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。&lt;/p>
&lt;h4 id="223-安全性">
&lt;a href="#223-%e5%ae%89%e5%85%a8%e6%80%a7" class="header-anchor">#&lt;/a>
2.2.3 安全性
&lt;/h4>
&lt;p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。&lt;/p>
&lt;h4 id="224-线程安全">
&lt;a href="#224-%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8" class="header-anchor">#&lt;/a>
2.2.4 线程安全
&lt;/h4>
&lt;p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。&lt;/p>
&lt;h3 id="23-stringstringbuilder-和-stringbuffer">
&lt;a href="#23-stringstringbuilder-%e5%92%8c-stringbuffer" class="header-anchor">#&lt;/a>
2.3 String、StringBuilder 和 StringBuffer
&lt;/h3>
&lt;h4 id="231-可变性">
&lt;a href="#231-%e5%8f%af%e5%8f%98%e6%80%a7" class="header-anchor">#&lt;/a>
2.3.1 可变性
&lt;/h4>
&lt;ul>
&lt;li>String 不可变&lt;/li>
&lt;li>StringBuilder 和 StringBuffer 可变&lt;/li>
&lt;/ul>
&lt;h4 id="232-线程安全">
&lt;a href="#232-%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8" class="header-anchor">#&lt;/a>
2.3.2 线程安全
&lt;/h4>
&lt;ul>
&lt;li>String 线程安全&lt;/li>
&lt;li>StringBuilder 线程不安全&lt;/li>
&lt;li>StringBuffer 线程安全：synchronized 机制&lt;/li>
&lt;/ul>
&lt;h3 id="24-string-pool">
&lt;a href="#24-string-pool" class="header-anchor">#&lt;/a>
2.4 String Pool
&lt;/h3>
&lt;p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。&lt;/p>
&lt;p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。&lt;/p>
&lt;p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。&lt;/p>
&lt;h3 id="25-new-stringabc">
&lt;a href="#25-new-stringabc" class="header-anchor">#&lt;/a>
2.5 new String（“abc”）
&lt;/h3>
&lt;p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 &amp;ldquo;abc&amp;rdquo; 字符串对象）。&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;abc&amp;rdquo; 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 &amp;ldquo;abc&amp;rdquo; 字符串字面量；&lt;/li>
&lt;li>而使用 new 的方式会在堆中创建一个字符串对象。&lt;/li>
&lt;/ul>
&lt;h2 id="3-运算">
&lt;a href="#3-%e8%bf%90%e7%ae%97" class="header-anchor">#&lt;/a>
3 运算
&lt;/h2>
&lt;h3 id="31-参数传递">
&lt;a href="#31-%e5%8f%82%e6%95%b0%e4%bc%a0%e9%80%92" class="header-anchor">#&lt;/a>
3.1 参数传递
&lt;/h3>
&lt;p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。&lt;/p>
&lt;h3 id="32-float-与-double">
&lt;a href="#32-float-%e4%b8%8e-double" class="header-anchor">#&lt;/a>
3.2 float 与 double
&lt;/h3>
&lt;p>Java 不能隐式执行向下转型，因为这会使得精度降低。&lt;/p>
&lt;h3 id="33-隐式类型转换">
&lt;a href="#33-%e9%9a%90%e5%bc%8f%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2" class="header-anchor">#&lt;/a>
3.3 隐式类型转换
&lt;/h3>
&lt;p>使用+=和++运算符会执行隐式类型转换，相当于强制类型转换。&lt;/p>
&lt;p>（比如：int 转 short）&lt;/p>
&lt;h2 id="4-关键字">
&lt;a href="#4-%e5%85%b3%e9%94%ae%e5%ad%97" class="header-anchor">#&lt;/a>
4 关键字
&lt;/h2>
&lt;h3 id="41-final">
&lt;a href="#41-final" class="header-anchor">#&lt;/a>
4.1 final
&lt;/h3>
&lt;p>（1）数据&lt;/p>
&lt;p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。&lt;/p>
&lt;ul>
&lt;li>对于基本类型，final 使数值不变；&lt;/li>
&lt;li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。&lt;/li>
&lt;/ul>
&lt;p>（2）方法&lt;/p>
&lt;p>声明方法不能被子类重写。&lt;/p>
&lt;p>&lt;strong>private 方法隐式地被指定为 final&lt;/strong>，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法&lt;strong>不是重写基类方法，而是在子类中定义了一个新的方法&lt;/strong>。&lt;/p>
&lt;p>（3）类&lt;/p>
&lt;p>声明类不允许被继承。&lt;/p>
&lt;h3 id="42--static">
&lt;a href="#42--static" class="header-anchor">#&lt;/a>
4.2 static
&lt;/h3>
&lt;p>&lt;strong>1. 静态变量&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。&lt;/li>
&lt;li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2. 静态方法&lt;/strong>&lt;/p>
&lt;p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。&lt;/p>
&lt;p>&lt;strong>3. 静态语句块&lt;/strong>&lt;/p>
&lt;p>静态语句块在类初始化时运行一次。&lt;/p>
&lt;p>&lt;strong>4. 静态内部类&lt;/strong>&lt;/p>
&lt;p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。&lt;/p>
&lt;p>&lt;strong>5. 静态导包&lt;/strong>&lt;/p>
&lt;p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。&lt;/p>
&lt;p>&lt;strong>6. 初始化顺序&lt;/strong>&lt;/p>
&lt;p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。&lt;/p>
&lt;h2 id="5-object-通用方法">
&lt;a href="#5-object-%e9%80%9a%e7%94%a8%e6%96%b9%e6%b3%95" class="header-anchor">#&lt;/a>
5 Object 通用方法
&lt;/h2>
&lt;ul>
&lt;li>hashcode&lt;/li>
&lt;li>equals&lt;/li>
&lt;li>clone&lt;/li>
&lt;li>toString&lt;/li>
&lt;li>getClass&lt;/li>
&lt;li>finalize&lt;/li>
&lt;li>notify&lt;/li>
&lt;li>notifyAll&lt;/li>
&lt;li>wait&lt;/li>
&lt;/ul>
&lt;h2 id="6-继承">
&lt;a href="#6-%e7%bb%a7%e6%89%bf" class="header-anchor">#&lt;/a>
6 继承
&lt;/h2>
&lt;h3 id="61-访问权限">
&lt;a href="#61-%e8%ae%bf%e9%97%ae%e6%9d%83%e9%99%90" class="header-anchor">#&lt;/a>
6.1 访问权限
&lt;/h3>
&lt;p>private、protected、public，以及 default（如果不加访问修饰符，表示包级可见。）&lt;/p>
&lt;p>可以对类或类中的成员（字段和方法）加上访问修饰符。&lt;/p>
&lt;ul>
&lt;li>类可见表示其它类可以用这个类创建实例对象。&lt;/li>
&lt;li>成员可见表示其它类可以用这个类的实例对象访问到该成员；&lt;/li>
&lt;/ul>
&lt;p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。&lt;/p>
&lt;h3 id="62-抽象类与接口">
&lt;a href="#62-%e6%8a%bd%e8%b1%a1%e7%b1%bb%e4%b8%8e%e6%8e%a5%e5%8f%a3" class="header-anchor">#&lt;/a>
6.2 抽象类与接口
&lt;/h3>
&lt;p>&lt;strong>1. 抽象类&lt;/strong>&lt;/p>
&lt;p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。&lt;/p>
&lt;p>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。&lt;/p>
&lt;p>&lt;strong>2. 接口&lt;/strong>&lt;/p>
&lt;p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。&lt;/p>
&lt;p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。&lt;/p>
&lt;p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。从 Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。&lt;/p>
&lt;p>接口的字段默认都是 static 和 final 的。&lt;/p>
&lt;h3 id="63-super">
&lt;a href="#63-super" class="header-anchor">#&lt;/a>
6.3 super
&lt;/h3>
&lt;ul>
&lt;li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。&lt;/li>
&lt;li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。&lt;/li>
&lt;/ul>
&lt;h3 id="64-重写与重载">
&lt;a href="#64-%e9%87%8d%e5%86%99%e4%b8%8e%e9%87%8d%e8%bd%bd" class="header-anchor">#&lt;/a>
6.4 重写与重载
&lt;/h3>
&lt;p>&lt;strong>1. 重写（Override）&lt;/strong>&lt;/p>
&lt;p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。&lt;/p>
&lt;p>为了满足里式替换原则，重写有以下三个限制：&lt;/p>
&lt;ul>
&lt;li>子类方法的访问权限必须大于等于父类方法；&lt;/li>
&lt;li>子类方法的返回类型必须是父类方法返回类型或为其子类型。&lt;/li>
&lt;li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。&lt;/li>
&lt;/ul>
&lt;p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。&lt;/p>
&lt;p>&lt;strong>2. 重载（Overload）&lt;/strong>&lt;/p>
&lt;p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。&lt;/p>
&lt;p>应该注意的是，返回值不同，其它都相同不算是重载。&lt;/p>
&lt;h2 id="7-反射">
&lt;a href="#7-%e5%8f%8d%e5%b0%84" class="header-anchor">#&lt;/a>
7 反射
&lt;/h2>
&lt;p>每个类都有一个 &lt;strong>Class&lt;/strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。&lt;/p>
&lt;p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 &lt;code>Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;)&lt;/code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。&lt;/p>
&lt;p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。&lt;/p>
&lt;p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Field&lt;/strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；&lt;/li>
&lt;li>&lt;strong>Method&lt;/strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；&lt;/li>
&lt;li>&lt;strong>Constructor&lt;/strong> ：可以用 Constructor 的 newInstance() 创建新的对象。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>反射的优点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>可扩展性&lt;/strong> ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。&lt;/li>
&lt;li>&lt;strong>类浏览器和可视化开发环境&lt;/strong> ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。&lt;/li>
&lt;li>&lt;strong>调试器和测试工具&lt;/strong> ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>反射的缺点：&lt;/strong>&lt;/p>
&lt;p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>性能开销&lt;/strong> ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。&lt;/li>
&lt;li>&lt;strong>安全限制&lt;/strong> ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。&lt;/li>
&lt;li>&lt;strong>内部暴露&lt;/strong> ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。&lt;/li>
&lt;/ul>
&lt;h2 id="8-异常">
&lt;a href="#8-%e5%bc%82%e5%b8%b8" class="header-anchor">#&lt;/a>
8 异常
&lt;/h2>
&lt;p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： &lt;strong>Error&lt;/strong> 和 &lt;strong>Exception&lt;/strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>受检异常&lt;/strong> ：需要用 try&amp;hellip;catch&amp;hellip; 语句捕获并进行处理，并且可以从异常中恢复；&lt;/li>
&lt;li>&lt;strong>非受检异常&lt;/strong> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。&lt;/li>
&lt;/ul>
&lt;h2 id="9-泛型注解新特性">
&lt;a href="#9-%e6%b3%9b%e5%9e%8b%e6%b3%a8%e8%a7%a3%e6%96%b0%e7%89%b9%e6%80%a7" class="header-anchor">#&lt;/a>
9 泛型、注解、新特性
&lt;/h2>
&lt;p>略。&lt;/p>
&lt;hr>
&lt;p>本文转载自：&lt;a class="link" href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener" >https://github.com/CyC2018/CS-Notes
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
，用于个人复习。&lt;/p></description></item><item><title>JVM 知识点笔记</title><link>https://cuterwrite.top/p/jvm/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/jvm/</guid><description>&lt;img src="https://cloud.cuterwrite.fun/blog/naples-122698_1920.2vb750rs8te0.webp" alt="Featured image of post JVM 知识点笔记" />&lt;h1 id="jvm-知识点笔记">
&lt;a href="#jvm-%e7%9f%a5%e8%af%86%e7%82%b9%e7%ac%94%e8%ae%b0" class="header-anchor">#&lt;/a>
JVM 知识点笔记
&lt;/h1>
&lt;h2 id="1-运行时数据区域">
&lt;a href="#1-%e8%bf%90%e8%a1%8c%e6%97%b6%e6%95%b0%e6%8d%ae%e5%8c%ba%e5%9f%9f" class="header-anchor">#&lt;/a>
1 运行时数据区域
&lt;/h2>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5778d113-8e13-4c53-b5bf-801e58080b97.png" width="90%" loading="lazy">
&lt;/figure>
&lt;h3 id="11-程序计数器">
&lt;a href="#11-%e7%a8%8b%e5%ba%8f%e8%ae%a1%e6%95%b0%e5%99%a8" class="header-anchor">#&lt;/a>
1.1 程序计数器
&lt;/h3>
&lt;p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。&lt;/p>
&lt;h3 id="12-java-虚拟机栈">
&lt;a href="#12-java-%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88" class="header-anchor">#&lt;/a>
1.2 Java 虚拟机栈
&lt;/h3>
&lt;p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。&lt;/p>
&lt;p>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：&lt;/p>
&lt;p>该区域可能抛出以下异常：&lt;/p>
&lt;ul>
&lt;li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；&lt;/li>
&lt;li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。&lt;/li>
&lt;/ul>
&lt;h3 id="13-本地方法栈">
&lt;a href="#13-%e6%9c%ac%e5%9c%b0%e6%96%b9%e6%b3%95%e6%a0%88" class="header-anchor">#&lt;/a>
1.3 本地方法栈
&lt;/h3>
&lt;p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。&lt;/p>
&lt;p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。&lt;/p>
&lt;h3 id="14-堆">
&lt;a href="#14-%e5%a0%86" class="header-anchor">#&lt;/a>
1.4 堆
&lt;/h3>
&lt;p>所有对象都在这里分配内存，是垃圾收集的主要区域（&amp;ldquo;GC 堆&amp;rdquo;）。&lt;/p>
&lt;p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：&lt;/p>
&lt;ul>
&lt;li>新生代（Young Generation）&lt;/li>
&lt;li>老年代（Old Generation）&lt;/li>
&lt;/ul>
&lt;p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。&lt;/p>
&lt;p>可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。&lt;/p>
&lt;pre>&lt;code class="language-java">java -Xms1M -Xmx2M HackTheJava
&lt;/code>&lt;/pre>
&lt;h3 id="15-方法区">
&lt;a href="#15-%e6%96%b9%e6%b3%95%e5%8c%ba" class="header-anchor">#&lt;/a>
1.5 方法区
&lt;/h3>
&lt;p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。&lt;/p>
&lt;p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。&lt;/p>
&lt;p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。&lt;/p>
&lt;p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。&lt;/p>
&lt;p>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。&lt;/p>
&lt;h3 id="16-运行时常量池">
&lt;a href="#16-%e8%bf%90%e8%a1%8c%e6%97%b6%e5%b8%b8%e9%87%8f%e6%b1%a0" class="header-anchor">#&lt;/a>
1.6 运行时常量池
&lt;/h3>
&lt;p>运行时常量池是方法区的一部分。&lt;/p>
&lt;p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。&lt;/p>
&lt;p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。&lt;/p>
&lt;h3 id="17-直接内存">
&lt;a href="#17-%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ad%98" class="header-anchor">#&lt;/a>
1.7 直接内存
&lt;/h3>
&lt;p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。&lt;/p>
&lt;h2 id="2-垃圾收集">
&lt;a href="#2-%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86" class="header-anchor">#&lt;/a>
2 垃圾收集
&lt;/h2>
&lt;p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。&lt;/p>
&lt;h3 id="21-判断一个对象是否可回收">
&lt;a href="#21-%e5%88%a4%e6%96%ad%e4%b8%80%e4%b8%aa%e5%af%b9%e8%b1%a1%e6%98%af%e5%90%a6%e5%8f%af%e5%9b%9e%e6%94%b6" class="header-anchor">#&lt;/a>
2.1 判断一个对象是否可回收
&lt;/h3>
&lt;h4 id="211-引用计数算法">
&lt;a href="#211-%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0%e7%ae%97%e6%b3%95" class="header-anchor">#&lt;/a>
2.1.1 引用计数算法
&lt;/h4>
&lt;p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。&lt;/p>
&lt;p>在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。&lt;/p>
&lt;h4 id="212-可达性分析算法">
&lt;a href="#212-%e5%8f%af%e8%be%be%e6%80%a7%e5%88%86%e6%9e%90%e7%ae%97%e6%b3%95" class="header-anchor">#&lt;/a>
2.1.2 可达性分析算法
&lt;/h4>
&lt;p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。&lt;/p>
&lt;p>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：&lt;/p>
&lt;ul>
&lt;li>虚拟机栈中局部变量表中引用的对象&lt;/li>
&lt;li>本地方法栈中 JNI 中引用的对象&lt;/li>
&lt;li>方法区中类静态属性引用的对象&lt;/li>
&lt;li>方法区中的常量引用的对象&lt;/li>
&lt;/ul>
&lt;h4 id="213-方法区的回收">
&lt;a href="#213-%e6%96%b9%e6%b3%95%e5%8c%ba%e7%9a%84%e5%9b%9e%e6%94%b6" class="header-anchor">#&lt;/a>
2.1.3 方法区的回收
&lt;/h4>
&lt;p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。&lt;/p>
&lt;p>主要是对常量池的回收和对类的卸载。&lt;/p>
&lt;p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。&lt;/p>
&lt;p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：&lt;/p>
&lt;ul>
&lt;li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。&lt;/li>
&lt;li>加载该类的 ClassLoader 已经被回收。&lt;/li>
&lt;li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。&lt;/li>
&lt;/ul>
&lt;h4 id="214-finalize">
&lt;a href="#214-finalize" class="header-anchor">#&lt;/a>
2.1.4 finalize()
&lt;/h4>
&lt;p>类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。&lt;/p>
&lt;p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。&lt;/p>
&lt;h3 id="22-引用类型">
&lt;a href="#22-%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b" class="header-anchor">#&lt;/a>
2.2 引用类型
&lt;/h3>
&lt;p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。&lt;/p>
&lt;p>Java 提供了四种强度不同的引用类型。&lt;/p>
&lt;h4 id="221-强引用">
&lt;a href="#221-%e5%bc%ba%e5%bc%95%e7%94%a8" class="header-anchor">#&lt;/a>
2.2.1 强引用
&lt;/h4>
&lt;p>被强引用关联的对象不会被回收。&lt;/p>
&lt;p>使用 new 一个新对象的方式来创建强引用。&lt;/p>
&lt;h4 id="222-软引用">
&lt;a href="#222-%e8%bd%af%e5%bc%95%e7%94%a8" class="header-anchor">#&lt;/a>
2.2.2 软引用
&lt;/h4>
&lt;p>被软引用关联的对象只有在内存不够的情况下才会被回收。&lt;/p>
&lt;p>使用 SoftReference 类来创建软引用。&lt;/p>
&lt;h4 id="223-弱引用">
&lt;a href="#223-%e5%bc%b1%e5%bc%95%e7%94%a8" class="header-anchor">#&lt;/a>
2.2.3 弱引用
&lt;/h4>
&lt;p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。&lt;/p>
&lt;p>使用 WeakReference 类来创建弱引用。&lt;/p>
&lt;h4 id="224-虚引用">
&lt;a href="#224-%e8%99%9a%e5%bc%95%e7%94%a8" class="header-anchor">#&lt;/a>
2.2.4 虚引用
&lt;/h4>
&lt;p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。&lt;/p>
&lt;p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。&lt;/p>
&lt;p>使用 PhantomReference 来创建虚引用。&lt;/p>
&lt;h3 id="23-垃圾收集算法">
&lt;a href="#23-%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95" class="header-anchor">#&lt;/a>
2.3 垃圾收集算法
&lt;/h3>
&lt;h4 id="231-标记---清除">
&lt;a href="#231-%e6%a0%87%e8%ae%b0---%e6%b8%85%e9%99%a4" class="header-anchor">#&lt;/a>
2.3.1 标记 - 清除
&lt;/h4>
&lt;p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。&lt;/p>
&lt;p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。&lt;/p>
&lt;p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。&lt;/p>
&lt;p>不足：&lt;/p>
&lt;ul>
&lt;li>标记和清除过程效率都不高；&lt;/li>
&lt;li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/005b481b-502b-4e3f-985d-d043c2b330aa.png" width="90%" loading="lazy">
&lt;/figure>
&lt;h4 id="232-标记-整理">
&lt;a href="#232-%e6%a0%87%e8%ae%b0-%e6%95%b4%e7%90%86" class="header-anchor">#&lt;/a>
2.3.2 标记-整理
&lt;/h4>
&lt;p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。&lt;/p>
&lt;p>优点:&lt;/p>
&lt;ul>
&lt;li>不会产生内存碎片&lt;/li>
&lt;/ul>
&lt;p>不足:&lt;/p>
&lt;ul>
&lt;li>需要移动大量对象，处理效率比较低。&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ccd773a5-ad38-4022-895c-7ac318f31437.png" width="90%" loading="lazy">
&lt;/figure>
&lt;h4 id="233-复制">
&lt;a href="#233-%e5%a4%8d%e5%88%b6" class="header-anchor">#&lt;/a>
2.3.3 复制
&lt;/h4>
&lt;p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。&lt;/p>
&lt;p>主要不足是只使用了内存的一半。&lt;/p>
&lt;p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。&lt;/p>
&lt;p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png" width="90%" loading="lazy">
&lt;/figure>
&lt;h4 id="234-分代收集">
&lt;a href="#234-%e5%88%86%e4%bb%a3%e6%94%b6%e9%9b%86" class="header-anchor">#&lt;/a>
2.3.4 分代收集
&lt;/h4>
&lt;p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。&lt;/p>
&lt;p>一般将堆分为新生代和老年代。&lt;/p>
&lt;ul>
&lt;li>新生代使用：复制算法&lt;/li>
&lt;li>老年代使用：标记 - 清除 或者 标记 - 整理 算法&lt;/li>
&lt;/ul>
&lt;h3 id="24-垃圾收集器">
&lt;a href="#24-%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8" class="header-anchor">#&lt;/a>
2.4 垃圾收集器
&lt;/h3>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" width="90%" loading="lazy">
&lt;/figure>
&lt;p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。&lt;/p>
&lt;ul>
&lt;li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；&lt;/li>
&lt;li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。&lt;/li>
&lt;/ul>
&lt;h2 id="3-内存分配与回收策略">
&lt;a href="#3-%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e4%b8%8e%e5%9b%9e%e6%94%b6%e7%ad%96%e7%95%a5" class="header-anchor">#&lt;/a>
3 内存分配与回收策略
&lt;/h2>
&lt;h3 id="31-minor-gc-和-full-gc">
&lt;a href="#31-minor-gc-%e5%92%8c-full-gc" class="header-anchor">#&lt;/a>
3.1 Minor GC 和 Full GC
&lt;/h3>
&lt;ul>
&lt;li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。&lt;/li>
&lt;li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。&lt;/li>
&lt;/ul>
&lt;h3 id="32-内存分配策略">
&lt;a href="#32-%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e7%ad%96%e7%95%a5" class="header-anchor">#&lt;/a>
3.2 内存分配策略
&lt;/h3>
&lt;h4 id="321-对象优先在-eden-分配">
&lt;a href="#321-%e5%af%b9%e8%b1%a1%e4%bc%98%e5%85%88%e5%9c%a8-eden-%e5%88%86%e9%85%8d" class="header-anchor">#&lt;/a>
3.2.1. 对象优先在 Eden 分配
&lt;/h4>
&lt;p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。&lt;/p>
&lt;h4 id="322-大对象直接进入老年代">
&lt;a href="#322-%e5%a4%a7%e5%af%b9%e8%b1%a1%e7%9b%b4%e6%8e%a5%e8%bf%9b%e5%85%a5%e8%80%81%e5%b9%b4%e4%bb%a3" class="header-anchor">#&lt;/a>
3.2.2. 大对象直接进入老年代
&lt;/h4>
&lt;p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。&lt;/p>
&lt;p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。&lt;/p>
&lt;p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。&lt;/p>
&lt;h4 id="323-长期存活的对象进入老年代">
&lt;a href="#323-%e9%95%bf%e6%9c%9f%e5%ad%98%e6%b4%bb%e7%9a%84%e5%af%b9%e8%b1%a1%e8%bf%9b%e5%85%a5%e8%80%81%e5%b9%b4%e4%bb%a3" class="header-anchor">#&lt;/a>
3.2.3. 长期存活的对象进入老年代
&lt;/h4>
&lt;p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。&lt;/p>
&lt;p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。&lt;/p>
&lt;h4 id="324-动态对象年龄判定">
&lt;a href="#324-%e5%8a%a8%e6%80%81%e5%af%b9%e8%b1%a1%e5%b9%b4%e9%be%84%e5%88%a4%e5%ae%9a" class="header-anchor">#&lt;/a>
3.2.4. 动态对象年龄判定
&lt;/h4>
&lt;p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。&lt;/p>
&lt;h4 id="325-空间分配担保">
&lt;a href="#325-%e7%a9%ba%e9%97%b4%e5%88%86%e9%85%8d%e6%8b%85%e4%bf%9d" class="header-anchor">#&lt;/a>
3.2.5. 空间分配担保
&lt;/h4>
&lt;p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。&lt;/p>
&lt;p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。&lt;/p>
&lt;h3 id="33-full-gc-触发条件">
&lt;a href="#33-full-gc-%e8%a7%a6%e5%8f%91%e6%9d%a1%e4%bb%b6" class="header-anchor">#&lt;/a>
3.3 Full GC 触发条件
&lt;/h3>
&lt;p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：&lt;/p>
&lt;h4 id="331-调用-systemgc">
&lt;a href="#331-%e8%b0%83%e7%94%a8-systemgc" class="header-anchor">#&lt;/a>
3.3.1. 调用 System.gc()
&lt;/h4>
&lt;p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。&lt;/p>
&lt;h4 id="332-老年代空间不足">
&lt;a href="#332-%e8%80%81%e5%b9%b4%e4%bb%a3%e7%a9%ba%e9%97%b4%e4%b8%8d%e8%b6%b3" class="header-anchor">#&lt;/a>
3.3.2. 老年代空间不足
&lt;/h4>
&lt;p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。&lt;/p>
&lt;p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。&lt;/p>
&lt;h4 id="333-空间分配担保失败">
&lt;a href="#333-%e7%a9%ba%e9%97%b4%e5%88%86%e9%85%8d%e6%8b%85%e4%bf%9d%e5%a4%b1%e8%b4%a5" class="header-anchor">#&lt;/a>
3.3.3. 空间分配担保失败
&lt;/h4>
&lt;p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。&lt;/p>
&lt;h4 id="334-jdk-17-及以前的永久代空间不足">
&lt;a href="#334-jdk-17-%e5%8f%8a%e4%bb%a5%e5%89%8d%e7%9a%84%e6%b0%b8%e4%b9%85%e4%bb%a3%e7%a9%ba%e9%97%b4%e4%b8%8d%e8%b6%b3" class="header-anchor">#&lt;/a>
3.3.4. JDK 1.7 及以前的永久代空间不足
&lt;/h4>
&lt;p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。&lt;/p>
&lt;p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。&lt;/p>
&lt;p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。&lt;/p>
&lt;h4 id="335-concurrent-mode-failure">
&lt;a href="#335-concurrent-mode-failure" class="header-anchor">#&lt;/a>
3.3.5. Concurrent Mode Failure
&lt;/h4>
&lt;p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。&lt;/p>
&lt;h2 id="4-类加载机制">
&lt;a href="#4-%e7%b1%bb%e5%8a%a0%e8%bd%bd%e6%9c%ba%e5%88%b6" class="header-anchor">#&lt;/a>
4 类加载机制
&lt;/h2>
&lt;hr>
&lt;p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。&lt;/p>
&lt;h3 id="41-类的生命周期">
&lt;a href="#41-%e7%b1%bb%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f" class="header-anchor">#&lt;/a>
4.1 类的生命周期
&lt;/h3>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/335fe19c-4a76-45ab-9320-88c90d6a0d7e.png" width="90%" loading="lazy">
&lt;/figure>
&lt;p>包括以下 7 个阶段：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>加载（Loading）&lt;/strong>&lt;/li>
&lt;li>&lt;strong>验证（Verification）&lt;/strong>&lt;/li>
&lt;li>&lt;strong>准备（Preparation）&lt;/strong>&lt;/li>
&lt;li>&lt;strong>解析（Resolution）&lt;/strong>&lt;/li>
&lt;li>&lt;strong>初始化（Initialization）&lt;/strong>&lt;/li>
&lt;li>使用（Using）&lt;/li>
&lt;li>卸载（Unloading）&lt;/li>
&lt;/ul>
&lt;h3 id="42-类加载过程">
&lt;a href="#42-%e7%b1%bb%e5%8a%a0%e8%bd%bd%e8%bf%87%e7%a8%8b" class="header-anchor">#&lt;/a>
4.2 类加载过程
&lt;/h3>
&lt;p>包含了加载、验证、准备、解析和初始化这 5 个阶段。&lt;/p>
&lt;h4 id="421-加载">
&lt;a href="#421-%e5%8a%a0%e8%bd%bd" class="header-anchor">#&lt;/a>
4.2.1. 加载
&lt;/h4>
&lt;p>加载是类加载的一个阶段，注意不要混淆。&lt;/p>
&lt;p>加载过程完成以下三件事：&lt;/p>
&lt;ul>
&lt;li>通过类的完全限定名称获取定义该类的二进制字节流。&lt;/li>
&lt;li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。&lt;/li>
&lt;li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。&lt;/li>
&lt;/ul>
&lt;p>其中二进制字节流可以从以下方式中获取：&lt;/p>
&lt;ul>
&lt;li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。&lt;/li>
&lt;li>从网络中获取，最典型的应用是 Applet。&lt;/li>
&lt;li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。&lt;/li>
&lt;li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。&lt;/li>
&lt;/ul>
&lt;h4 id="422-验证">
&lt;a href="#422-%e9%aa%8c%e8%af%81" class="header-anchor">#&lt;/a>
4.2.2. 验证
&lt;/h4>
&lt;p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。&lt;/p>
&lt;h4 id="423-准备">
&lt;a href="#423-%e5%87%86%e5%a4%87" class="header-anchor">#&lt;/a>
4.2.3. 准备
&lt;/h4>
&lt;p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。&lt;/p>
&lt;p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。&lt;/p>
&lt;p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。&lt;/p>
&lt;pre>&lt;code class="language-java">public static int value = 123;
&lt;/code>&lt;/pre>
&lt;p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。&lt;/p>
&lt;pre>&lt;code class="language-java">public static final int value = 123;
&lt;/code>&lt;/pre>
&lt;h4 id="424-解析">
&lt;a href="#424-%e8%a7%a3%e6%9e%90" class="header-anchor">#&lt;/a>
4.2.4. 解析
&lt;/h4>
&lt;p>将常量池的符号引用替换为直接引用的过程。&lt;/p>
&lt;p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。&lt;/p>
&lt;h4 id="425-初始化">
&lt;a href="#425-%e5%88%9d%e5%a7%8b%e5%8c%96" class="header-anchor">#&lt;/a>
4.2.5. 初始化
&lt;/h4>
&lt;!-- raw HTML omitted -->
&lt;p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &amp;lt;clinit&amp;gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。&lt;/p>
&lt;p>&amp;lt;clinit&amp;gt;() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：&lt;/p>
&lt;pre>&lt;code class="language-java">public class Test {
static {
i = 0; // 给变量赋值可以正常编译通过
System.out.print(i); // 这句编译器会提示“非法向前引用”
}
static int i = 1;
}
&lt;/code>&lt;/pre>
&lt;p>由于父类的 &amp;lt;clinit&amp;gt;() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：&lt;/p>
&lt;pre>&lt;code class="language-java">static class Parent {
public static int A = 1;
static {
A = 2;
}
}
static class Sub extends Parent {
public static int B = A;
}
public static void main(String[] args) {
System.out.println(Sub.B); // 2
}
&lt;/code>&lt;/pre>
&lt;p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &amp;lt;clinit&amp;gt;() 方法。但接口与类不同的是，执行接口的 &amp;lt;clinit&amp;gt;() 方法不需要先执行父接口的 &amp;lt;clinit&amp;gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &amp;lt;clinit&amp;gt;() 方法。&lt;/p>
&lt;p>虚拟机会保证一个类的 &amp;lt;clinit&amp;gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &amp;lt;clinit&amp;gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &amp;lt;clinit&amp;gt;() 方法完毕。如果在一个类的 &amp;lt;clinit&amp;gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。&lt;/p>
&lt;h3 id="43-类初始化时机">
&lt;a href="#43-%e7%b1%bb%e5%88%9d%e5%a7%8b%e5%8c%96%e6%97%b6%e6%9c%ba" class="header-anchor">#&lt;/a>
4.3 类初始化时机
&lt;/h3>
&lt;h4 id="431-主动引用">
&lt;a href="#431-%e4%b8%bb%e5%8a%a8%e5%bc%95%e7%94%a8" class="header-anchor">#&lt;/a>
4.3.1. 主动引用
&lt;/h4>
&lt;p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="432-被动引用">
&lt;a href="#432-%e8%a2%ab%e5%8a%a8%e5%bc%95%e7%94%a8" class="header-anchor">#&lt;/a>
4.3.2. 被动引用
&lt;/h4>
&lt;p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：&lt;/p>
&lt;ul>
&lt;li>通过子类引用父类的静态字段，不会导致子类初始化。&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java">System.out.println(SubClass.value); // value 字段在 SuperClass 中定义
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java">SuperClass[] sca = new SuperClass[10];
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java">System.out.println(ConstClass.HELLOWORLD);
&lt;/code>&lt;/pre>
&lt;h3 id="44-类与类加载器">
&lt;a href="#44-%e7%b1%bb%e4%b8%8e%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8" class="header-anchor">#&lt;/a>
4.4 类与类加载器
&lt;/h3>
&lt;p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。&lt;/p>
&lt;p>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。&lt;/p>
&lt;h3 id="45-类加载器分类">
&lt;a href="#45-%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8%e5%88%86%e7%b1%bb" class="header-anchor">#&lt;/a>
4.5 类加载器分类
&lt;/h3>
&lt;p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &amp;lt;JRE_HOME&amp;gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &amp;lt;JAVA_HOME&amp;gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="46-双亲委派模型">
&lt;a href="#46-%e5%8f%8c%e4%ba%b2%e5%a7%94%e6%b4%be%e6%a8%a1%e5%9e%8b" class="header-anchor">#&lt;/a>
4.6 双亲委派模型
&lt;/h3>
&lt;p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。&lt;/p>
&lt;p>下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0dd2d40a-5b2b-4d45-b176-e75a4cd4bdbf.png" width="90%" loading="lazy">
&lt;/figure>
&lt;h4 id="461-工作过程">
&lt;a href="#461-%e5%b7%a5%e4%bd%9c%e8%bf%87%e7%a8%8b" class="header-anchor">#&lt;/a>
4.6.1. 工作过程
&lt;/h4>
&lt;p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。&lt;/p>
&lt;h4 id="462-好处">
&lt;a href="#462-%e5%a5%bd%e5%a4%84" class="header-anchor">#&lt;/a>
4.6.2. 好处
&lt;/h4>
&lt;p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。&lt;/p>
&lt;p>例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。&lt;/p>
&lt;h4 id="463-实现">
&lt;a href="#463-%e5%ae%9e%e7%8e%b0" class="header-anchor">#&lt;/a>
4.6.3. 实现
&lt;/h4>
&lt;p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。&lt;/p>
&lt;pre>&lt;code class="language-java">public abstract class ClassLoader {
// The parent class loader for delegation
private final ClassLoader parent;
public Class&amp;lt;?&amp;gt; loadClass(String name) throws ClassNotFoundException {
return loadClass(name, false);
}
protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
synchronized (getClassLoadingLock(name)) {
// First, check if the class has already been loaded
Class&amp;lt;?&amp;gt; c = findLoadedClass(name);
if (c == null) {
try {
if (parent != null) {
c = parent.loadClass(name, false);
} else {
c = findBootstrapClassOrNull(name);
}
} catch (ClassNotFoundException e) {
// ClassNotFoundException thrown if class not found
// from the non-null parent class loader
}
if (c == null) {
// If still not found, then invoke findClass in order
// to find the class.
c = findClass(name);
}
}
if (resolve) {
resolveClass(c);
}
return c;
}
}
protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {
throw new ClassNotFoundException(name);
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="47-自定义类加载器实现">
&lt;a href="#47-%e8%87%aa%e5%ae%9a%e4%b9%89%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8%e5%ae%9e%e7%8e%b0" class="header-anchor">#&lt;/a>
4.7 自定义类加载器实现
&lt;/h3>
&lt;p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。&lt;/p>
&lt;p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。&lt;/p>
&lt;hr>
&lt;p>本文转载自：&lt;a class="link" href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener" >https://github.com/CyC2018/CS-Notes
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
，用于个人复习。&lt;/p></description></item><item><title>ArrayList 源码分析</title><link>https://cuterwrite.top/p/arraylist-source-code/</link><pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/arraylist-source-code/</guid><description>&lt;img src="https://cloud.cuterwrite.fun/blog/man-5640540_1920.5mr5hqwq7xc0.webp" alt="Featured image of post ArrayList 源码分析" />&lt;h1 id="arraylist-源码分析">
&lt;a href="#arraylist-%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90" class="header-anchor">#&lt;/a>
ArrayList 源码分析
&lt;/h1>
&lt;h2 id="1-简介">
&lt;a href="#1-%e7%ae%80%e4%bb%8b" class="header-anchor">#&lt;/a>
1 简介
&lt;/h2>
&lt;p>底层：Object[]，容量能动态增长。在添加大量元素前，会先调用 ensureCapacity 来增加 ArrayList 的容量，可以减少递增再分配的次数。&lt;/p>
&lt;p>ArrayList 继承了 AbstractList，实现了 List，RandomAccess，Cloneable，Serializable 等接口。&lt;/p>
&lt;ul>
&lt;li>RandomAccess：标志接口，接口体是空的，只是用来表明 ArrayList 是支持快速随机访问的。&lt;/li>
&lt;li>Cloneable：能被克隆&lt;/li>
&lt;li>Serializable：可序列化&lt;/li>
&lt;/ul>
&lt;h3 id="11-arraylist-和-vector-的区别">
&lt;a href="#11-arraylist-%e5%92%8c-vector-%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-anchor">#&lt;/a>
1.1 ArrayList 和 Vector 的区别
&lt;/h3>
&lt;p>底层都是 Object[]，但是 ArrayList 线程不安全，Vector 线程安全。&lt;/p>
&lt;h3 id="12-arraylist-和-linkedlist-的区别">
&lt;a href="#12-arraylist-%e5%92%8c-linkedlist-%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-anchor">#&lt;/a>
1.2 ArrayList 和 LinkedList 的区别
&lt;/h3>
&lt;ol>
&lt;li>线程安全：ArrayList 和 LinkedList 都是线程不安全的。&lt;/li>
&lt;li>底层数据结构：ArrayList 是 Object[]，LinkedList 底层是双向链表。&lt;/li>
&lt;li>插入和删除：ArrayList 插入和删除元素的时间复杂度受元素位置的影响，为 O(n - i)；LinkedList 的插入和删除元素的时间复杂度不受插入元素位置的影响，都近似于 O(1)，但如果在指定位置插入和删除，需要先移动到指定位置再执行操作，时间复杂度近似于 O(n)。&lt;/li>
&lt;li>是否支持快速随机访问：ArrayList 支持，LinkedList 不支持。&lt;/li>
&lt;li>内存空间占用：ArrayList 需要在列表末尾预留一定的容量空间，LinkedList 的每一个元素都需要多消耗 pre 和 next 指针的空间。&lt;/li>
&lt;/ol>
&lt;h2 id="2-核心源码分析">
&lt;a href="#2-%e6%a0%b8%e5%bf%83%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90" class="header-anchor">#&lt;/a>
2 核心源码分析
&lt;/h2>
&lt;h3 id="21-属性">
&lt;a href="#21-%e5%b1%9e%e6%80%a7" class="header-anchor">#&lt;/a>
2.1 属性
&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>默认初始容量大小&lt;/p>
&lt;pre>&lt;code class="language-java">private static final int DEFAULT_CAPACITY = 10;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>元素个数&lt;/p>
&lt;pre>&lt;code class="language-java">private int size;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>存放数据的数组&lt;/p>
&lt;pre>&lt;code class="language-java">transient Object[] elementData
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>空数组&lt;/p>
&lt;pre>&lt;code class="language-java">private static final Object[] EMPTY_ELEMENTDATA = {};
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>用于默认大小实例的共享空数组实例&lt;/p>
&lt;pre>&lt;code class="language-java">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h3 id="22-构造函数">
&lt;a href="#22-%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0" class="header-anchor">#&lt;/a>
2.2 构造函数
&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>无参&lt;/p>
&lt;pre>&lt;code class="language-java">public ArrayList(){
this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
&lt;/code>&lt;/pre>
&lt;p>注意：以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。（用了懒汉式的单例设计模式）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指定容量&lt;/p>
&lt;pre>&lt;code class="language-java">public ArrayList(int initialCapacity){
if (initialCapacity &amp;gt; 0){
this.elementData = new Object[initialCapacity];
} else if (initialCapacity == 0){
this.elementData = EMPTY_ELEMENTDATA;
} else {
//抛出异常
}
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>指定 collection&lt;/p>
&lt;pre>&lt;code class="language-java">public ArrayList(Collection&amp;lt;? extends E&amp;gt; c){
elementData = c.toArray();
if ((size = elementData.length) != 0){
if (elementData.getClass() != Object[].class){
elementData = Arrays.copyOf(elementData, size, Object[].class);
}
} else {
this.elementData = EMPTY_ELEMENTDATA;
}
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h3 id="23-扩容机制">
&lt;a href="#23-%e6%89%a9%e5%ae%b9%e6%9c%ba%e5%88%b6" class="header-anchor">#&lt;/a>
2.3 扩容机制
&lt;/h3>
&lt;h4 id="231-add-方法">
&lt;a href="#231-add-%e6%96%b9%e6%b3%95" class="header-anchor">#&lt;/a>
2.3.1 add 方法
&lt;/h4>
&lt;h4 id="232-ensurecapacityinternal-方法">
&lt;a href="#232-ensurecapacityinternal-%e6%96%b9%e6%b3%95" class="header-anchor">#&lt;/a>
2.3.2 ensureCapacityInternal 方法
&lt;/h4>
&lt;h4 id="233-ensureexplicitcapacity">
&lt;a href="#233-ensureexplicitcapacity" class="header-anchor">#&lt;/a>
2.3.3 ensureExplicitCapacity
&lt;/h4>
&lt;h4 id="234-grow-方法">
&lt;a href="#234-grow-%e6%96%b9%e6%b3%95" class="header-anchor">#&lt;/a>
2.3.4 grow 方法
&lt;/h4>
&lt;h4 id="235-hugecapacity-方法">
&lt;a href="#235-hugecapacity-%e6%96%b9%e6%b3%95" class="header-anchor">#&lt;/a>
2.3.5 hugeCapacity 方法
&lt;/h4>
&lt;h3 id="24-拷贝机制">
&lt;a href="#24-%e6%8b%b7%e8%b4%9d%e6%9c%ba%e5%88%b6" class="header-anchor">#&lt;/a>
2.4 拷贝机制
&lt;/h3>
&lt;h3 id="25-ensurecapacity-方法">
&lt;a href="#25-ensurecapacity-%e6%96%b9%e6%b3%95" class="header-anchor">#&lt;/a>
2.5 ensureCapacity 方法
&lt;/h3></description></item><item><title>HashMap 源码分析</title><link>https://cuterwrite.top/p/hashmap/</link><pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/hashmap/</guid><description>&lt;img src="https://cloud.cuterwrite.fun/blog/mountains-6207115_1920.6ff92y51zus0.webp" alt="Featured image of post HashMap 源码分析" />&lt;h1 id="hashmap-源码分析">
&lt;a href="#hashmap-%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90" class="header-anchor">#&lt;/a>
HashMap 源码分析
&lt;/h1>
&lt;h2 id="1-属性">
&lt;a href="#1-%e5%b1%9e%e6%80%a7" class="header-anchor">#&lt;/a>
1 属性
&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>初始化容量&lt;/p>
&lt;pre>&lt;code class="language-java">static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>最大容量&lt;/p>
&lt;pre>&lt;code class="language-java">static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>负载因子&lt;/p>
&lt;pre>&lt;code class="language-java">static final float DEFAULT_LOAD_FACTOR = 0.75f;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>红黑树阈值&lt;/p>
&lt;pre>&lt;code class="language-java">static final int TREEIFY_THRESHOLD = 8;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>链表阈值&lt;/p>
&lt;pre>&lt;code class="language-java">static final int UNTREEIFY_THRESHOLD = 6;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>红黑树桶阈值&lt;/p>
&lt;pre>&lt;code class="language-java">static final int MIN_TREEIFY_CAPACITY = 64;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>table 数组，用来初始化&lt;/p>
&lt;pre>&lt;code class="language-java">transient Node&amp;lt;K,V&amp;gt;[] table;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>entrySet 存放缓存&lt;/p>
&lt;pre>&lt;code class="language-java">transient Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>桶的数量&lt;/p>
&lt;pre>&lt;code class="language-java">transient int size
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>修改次数&lt;/p>
&lt;pre>&lt;code class="language-java">transient int modCount;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>阈值&lt;/p>
&lt;pre>&lt;code class="language-java">int threshold
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>负载因子&lt;/p>
&lt;pre>&lt;code class="language-java">float loadFactor
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h2 id="2-构造方法">
&lt;a href="#2-%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95" class="header-anchor">#&lt;/a>
2 构造方法
&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>HashMap()&lt;/p>
&lt;pre>&lt;code class="language-java">public HashMap(){
this.loadFactor = DEFAULT_LOAD_FACTOR;
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>HashMap(int initialCapacity)&lt;/p>
&lt;pre>&lt;code class="language-java">public HashMap(int initialCapacity){
this(int initialCapacity, DEFAULT_LOAD_FACTOR);
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>HashMap(int initialCapacity, float loadFactor )&lt;/p>
&lt;pre>&lt;code class="language-java">public HashMap(int initialCapacity, float loadFactor){
if (initialCapacity &amp;lt; 0){
//抛出数值异常
}
if (initialCapacity &amp;gt; MAXIMUM_CAPACITY){
initialCapacity = MAXIMUM_CAPACITY;
}
if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor)){
//抛出数值异常
}
this.loadFactor = loadFactor;
//tableSizeFor，大于等于当前值的下一个 2 的幂，比如输入 17，返回 32
this.threshold = tableSizeFor(initialCapacity);
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h2 id="3-增加元素">
&lt;a href="#3-%e5%a2%9e%e5%8a%a0%e5%85%83%e7%b4%a0" class="header-anchor">#&lt;/a>
3 增加元素
&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>put 方法分析&lt;/p>
&lt;pre>&lt;code class="language-java">public V put(K key, V value){
return putVal(hash(key), key, value, false, true);
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>hash 方法分析&lt;/p>
&lt;pre>&lt;code class="language-java">static int hash(Object key){
int h;
//key 为空返回 0，先计算 key 的 hashcode，然后与 h 无符号右移 16 位后的二进制进行异或
return key == null ? 0 : (h = key.hashCode() ^ (h &amp;gt;&amp;gt;&amp;gt; 16));
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>putVal 方法分析&lt;/p>
&lt;pre>&lt;code class="language-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict){
Node&amp;lt;K,V&amp;gt;[] tab;
Node&amp;lt;K,V&amp;gt; p;
int n, i;
/*
* 如果 table 是否等于空或者等于 0，如果是则进行初始化
*/
if ((tab = table) == null || (n = tab.length) == 0){
n = (tab = resize()).length();
}
/*
* 哈希取模，i = (n - 1) &amp;amp; hash，对值的位置进行确定
* 也是 capacity 为 2 的幂的原因，与运算效率高于%
* capacity 为 2 的幂次时，(n - 1) &amp;amp; hash = hash % n
* 如果 tab[i] = null，新增一个元素
*/
if ((p = tab[i = (n - 1) &amp;amp; hash]) == null){
tab[i] = newNode(hash, key, value, null);
} else {
//说明该位置有值了
Node&amp;lt;K,V&amp;gt; e;
K k;
if (p.hash == hash &amp;amp;&amp;amp; ((k = p.key) == key ||
(key != null &amp;amp;&amp;amp; key.eqauls(k)))){
//key 值存在，无论链表还是红黑树都需要替换
e = p;
} else if (p instanceof TreeNode){
//如果是红黑树
e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
} else {
/*
* 链表，遍历到最后节点然后插入；
*/
for (int binCount = 0; ;binCount++){
if ((e = p.next) == null){
p.next = newNode(hash, key, value, null);
//大于红黑树阈值，转换红黑树
if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1){
treeifyBin(tab, hash);
}
break;
}
if (e.hash &amp;amp;&amp;amp; hahs &amp;amp;&amp;amp; ((k = e.key) == key ||
(key != null &amp;amp;&amp;amp; key.equals(k)))){
break;
}
p = e;
}
}
/*
* 如果链表中重复就直接替换
*/
if (e != null){
V oldValue = e.value;
if (!onlyIfAbsent || oldValue == null){
e.value = value;
}
afterNodeAccess(e);
return oldValue;
}
}
//记录修改次数
modCount++;
//如果超过 threshold，调用 resize
if (++size &amp;gt; threshold){
resize();
}
afterNodeInsertion(evict);
return null;
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>如果定位到的数组位置没有元素，直接插入。&lt;/li>
&lt;li>如果定位到的数组位置有元素，就要和插入的 key 比较，key 相同则直接覆盖，如果不相同，则判断 p 是否是 TreeNode，如果是则调用 e=((TreeNode&amp;lt;K,V)p).putTreeVal(this, tab, hash, key, value)将元素添加进入。如果不是则遍历链表插入到链表尾部。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>resize 方法分析&lt;/p>
&lt;pre>&lt;code class="language-java">final Node&amp;lt;k,V&amp;gt;[] resize(){
Node&amp;lt;K,V&amp;gt;[] oldTab = table;
int oldCap = (oldTab == null) ? 0 : oldTab.length;
int oldThr = threshold;
int newCap, newThr = 0;
if (oldCap &amp;gt; 0){
if (oldCap &amp;gt;= MAXIMUM_CAPACITY){
threshold = Integer.MAX_VALUE;
return oldTab;
} else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY){
//threshold 加倍
newThr = oldThr &amp;lt;&amp;lt; 1;
}
} else if (oldThr &amp;gt; 0){
newCap = oldThr;
} else {
//默认 Capacity 和 threshold，分别为 16 和 12
newCap = DEFAULT_INITIAL_CAPACITY;
newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
}
if (newThr == 0){
float ft = (float)newCap * loadFactor;
newThr = (newCap &amp;lt; MAXIMUN_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
(int) ft : Integer.MAX_VALUE);
}
threshold = newThr;
Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap];
table = newTab;
if (oldTab != null){
/*
* 省略，拷贝旧的 hash 桶到 newTab
*/
}
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h2 id="4-读取元素">
&lt;a href="#4-%e8%af%bb%e5%8f%96%e5%85%83%e7%b4%a0" class="header-anchor">#&lt;/a>
4 读取元素
&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>get 方法分析&lt;/p>
&lt;pre>&lt;code class="language-java">public V get(Object key){
Node&amp;lt;K,V&amp;gt; e;
return (e = getNode(hash(key), key)) == null ? null : e.value;
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>getNode 方法分析&lt;/p>
&lt;pre>&lt;code class="language-java">final Node&amp;lt;K,V&amp;gt; getNode(int hash, Object key){
Node&amp;lt;K,V&amp;gt;[] tab;
Node&amp;lt;K,V&amp;gt; first, e;
int n;
K k;
//table 有元素
if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
(first = tab[(n - 1) &amp;amp; hash]) != null){
//从第一个 node 开始
if (first.hash = hash &amp;amp;&amp;amp; ((k = first.key) == key ||
(key != null &amp;amp;&amp;amp; key.equals(k)))){
return first;
}
//first 的下一个 node
if ((e = first.next) != null){
//若是红黑树，调用红黑树查找方法
if (first instanceof TreeNode){
return ((TreeNode&amp;lt;K,V&amp;gt;)first).getTreeNode(hash, key);
}
//否则遍历链表查找
do {
if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key ||
(key != null &amp;amp;&amp;amp; key.equals(k)))){
return e;
}
} while ((e = e.next) != null);
}
}
//table 没元素了，直接返回 null
return null;
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h2 id="5-删除元素">
&lt;a href="#5-%e5%88%a0%e9%99%a4%e5%85%83%e7%b4%a0" class="header-anchor">#&lt;/a>
5 删除元素
&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>remove 方法分析&lt;/p>
&lt;pre>&lt;code class="language-java">public V remove(Object key){
Node&amp;lt;K,V&amp;gt; e;
return (e = removeNode(hash(key), key, null, false, true)) == null ?
null : e.value;
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>removeNode 方法分析&lt;/p>
&lt;pre>&lt;code class="language-java">final Node&amp;lt;K,V&amp;gt; removeNode(int hash, Object key, Object value,
boolean matchValue, boolean movable){
Node&amp;lt;K,V&amp;gt;[] tab;
Node&amp;lt;K,V&amp;gt; p;
int n, index;
if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
(p = tab[index = (n - 1) &amp;amp; hash]) != null){
Node&amp;lt;K,V&amp;gt; node = null;
Node&amp;lt;K,V&amp;gt; e;
K k;
V v;
if (p.hash == hash &amp;amp;&amp;amp; ((k = p.key) == key ||
(key != null &amp;amp;&amp;amp; key.equals(k)))){
node = p;
} else if ((e = p.next) != null){
//如果是红黑树，调用红黑树查找方法
if (p instanceof TreeNode){
node = ((TreeNode&amp;lt;K,V&amp;gt;)p).getTreeNode(hash,key);
} else {
//否则，迭代链表
do{
if (e.hash == hash &amp;amp;&amp;amp; ((k = p.key) == key ||
(key != null &amp;amp;&amp;amp; key.equals(k)))){
node = e;
break;
}
p = e;
} while ((e = e.next) != null);
}
}
//找到节点了
if (node != null &amp;amp;&amp;amp; (!matchValue || (v = node.value) == value ||
(value != null &amp;amp;&amp;amp; value.equals(v)))){
//调用红黑树删除节点的方法
if (node instanceof TreeNode){
((TreeNode&amp;lt;K,V&amp;gt;)node).removeTreeNode(this, tab, movable);
} else if (node == p){
//是链表头部
tab[index] = node.next;
} else {
p.next = node.next;
}
//修改次数
modCount++;
size--;
afterNodeRemoval(node);
return node;
}
}
return null;
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h2 id="6-底层数据结构分析">
&lt;a href="#6-%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90" class="header-anchor">#&lt;/a>
6 底层数据结构分析
&lt;/h2>
&lt;h3 id="61-jdk18-之前">
&lt;a href="#61-jdk18-%e4%b9%8b%e5%89%8d" class="header-anchor">#&lt;/a>
6.1 JDK1.8 之前
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>底层：数组加链表&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基本原理：通过 key 的 hashcode 经过扰动处理得到 hash 值，然后通过(n - 1) &amp;amp; hash 判断当前元素存放的位置，如果当前位置存在元素的话，就判断该元素与要存放的元素的 hash 值以及 key 是否相同，如果相同则直接覆盖，不相同就用拉链法解决冲突。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>扰动函数：hash 方法，目的是防止一些实现比较差的 hashcode 方法，减少碰撞。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>hash 方法：&lt;/p>
&lt;pre>&lt;code class="language-java">static int hash(int h){
h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12);
return h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4);
}
&lt;/code>&lt;/pre>
&lt;p>性能较于 1.8 差，扰动次数为 4&lt;/p>
&lt;/li>
&lt;li>
&lt;p>拉链法：将链表和数组结合，也就是创建一个链表数组 Node&amp;lt;K,V&amp;gt;[]，如果遇到哈希冲突，则将冲突的值加到链表中即可。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="62-jdk18-之后">
&lt;a href="#62-jdk18-%e4%b9%8b%e5%90%8e" class="header-anchor">#&lt;/a>
6.2 JDK1.8 之后
&lt;/h3>
&lt;ul>
&lt;li>底层：数组加链表加红黑树&lt;/li>
&lt;li>基本原理：当链表长度大于阈值 8 时，会调用 treeifyBin 方法，根据 HashMap 数组决定是否转化成红黑树，只有当&lt;strong>数组长度大于或者等于 64&lt;/strong>时，才会执行转换红黑树的操作，减减少搜索时间。否则只会进行 resize()方法对数组进行扩容。&lt;/li>
&lt;/ul></description></item><item><title>Spring Cloud Alibaba 笔记</title><link>https://cuterwrite.top/p/spring-cloud-alibaba-1/</link><pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/spring-cloud-alibaba-1/</guid><description>&lt;img src="https://cloud.cuterwrite.fun/blog/dolomites-5076492_1920.5srkr3iefto0.webp" alt="Featured image of post Spring Cloud Alibaba 笔记" />&lt;h1 id="spring-cloud-alibaba-笔记">
&lt;a href="#spring-cloud-alibaba-%e7%ac%94%e8%ae%b0" class="header-anchor">#&lt;/a>
Spring Cloud alibaba 笔记
&lt;/h1>
&lt;h2 id="soa-与微服务的区别">
&lt;a href="#soa-%e4%b8%8e%e5%be%ae%e6%9c%8d%e5%8a%a1%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-anchor">#&lt;/a>
SOA 与微服务的区别：
&lt;/h2>
&lt;ol>
&lt;li>SOA 关注的是服务的重用性及解决信息孤岛问题&lt;/li>
&lt;li>微服务关注的是解耦，虽然解耦和可重用性从特定的角度来看是一样的，但本质上是有区别的，解耦是降低业务之间的耦合度，而重用性关注的是服务的复用。&lt;/li>
&lt;li>微服务会更多地关注在 DevOps 的持续交付上，因为服务粒度细化之后使得开发运维变得更加重要，因此微服务与容器化技术的结合更加紧密。&lt;/li>
&lt;/ol>
&lt;h2 id="spring-cloud-alibaba-与-spring-cloud-netflix-的对比">
&lt;a href="#spring-cloud-alibaba-%e4%b8%8e-spring-cloud-netflix-%e7%9a%84%e5%af%b9%e6%af%94" class="header-anchor">#&lt;/a>
Spring Cloud Alibaba 与 Spring Cloud Netflix 的对比
&lt;/h2>
&lt;ol>
&lt;li>Alibaba 开源组件在没有织入 Spring Cloud 生态之前，已经在各大公司广泛应用，所以容易实现技术整合及迁移。&lt;/li>
&lt;li>Alibaba 开源组件在服务治理上和处理高并发的能力上有天然的优势。&lt;/li>
&lt;/ol>
&lt;h2 id="什么是-spring-boot">
&lt;a href="#%e4%bb%80%e4%b9%88%e6%98%af-spring-boot" class="header-anchor">#&lt;/a>
什么是 Spring Boot？
&lt;/h2>
&lt;p>帮助开发者快速构建一个基于 Spring Framework 及 Spring 生态体系的应用解决方案，也是对于“约定优于配置”理念的最佳实践。&lt;/p>
&lt;h2 id="iocdi控制反转与依赖注入">
&lt;a href="#iocdi%e6%8e%a7%e5%88%b6%e5%8f%8d%e8%bd%ac%e4%b8%8e%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5" class="header-anchor">#&lt;/a>
IOC/DI（控制反转与依赖注入）
&lt;/h2>
&lt;ol>
&lt;li>IOC：把对象的生命周期托管到 Spring 容器中，而反转是指对象的获取方式被反转了。&lt;/li>
&lt;li>当使用 IOC 容器之后，客户端类不需要通过 new 来创建这些对象，而是直接从 IOC 容器中获得。早期的 Spring 中，主要通过 XML 的方式来定义 Bean，Spring 会解析 XML 文件，把定义的 Bean 转载到 IOC 容器中。&lt;/li>
&lt;li>DI：IOC 容器在运行期间，动态地把某种依赖关系注入组件中。&lt;/li>
&lt;li>DI 的三种方法：接口注入、构造方法注入、setter 方法注入；目前是基于注解的形式：有@Autowired、@Inject 和@Resource&lt;/li>
&lt;/ol>
&lt;h2 id="spring-发展过程">
&lt;a href="#spring-%e5%8f%91%e5%b1%95%e8%bf%87%e7%a8%8b" class="header-anchor">#&lt;/a>
Spring 发展过程
&lt;/h2>
&lt;ol>
&lt;li>J2EE 的 EJB 时代&lt;/li>
&lt;li>Spring XML 配置文件时代&lt;/li>
&lt;li>JavaConfig 的无配置化注入时代&lt;/li>
&lt;li>Spring Boot 时代：约定优于配置，核心为：
&lt;ol>
&lt;li>Starter 组件：开箱即用&lt;/li>
&lt;li>自动装配：自动根据上下文完成 Bean 的装配&lt;/li>
&lt;li>Actuator：应用监控&lt;/li>
&lt;li>Spring Boot CLI：脚手架&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="自动装配的实现">
&lt;a href="#%e8%87%aa%e5%8a%a8%e8%a3%85%e9%85%8d%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-anchor">#&lt;/a>
自动装配的实现
&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>实现原理：@EnableAutoConfiguration，这个注解的声明在启动类注解@SpringBootApplication 内。进一步又涉及到@Enable 注解（本质上是对@Configuration 和@Bean 的封装）；使用 Enable 注解后，Spring 会解析到@Import 导入的配置类，从而根据这个配置类中的描述来实现 Bean 的装配。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>例子：可以直接使用@Autowired 来注入 RedisTemplate 实例。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>EnableAutoConfiguration 的原理&lt;/p>
&lt;p>@Import：导入一个 AutoConfigurationImportSelector 类。&lt;/p>
&lt;p>@AutoConfigurationPackage：把使用了该注解的类所在的类所在的包及子包下所有组件扫描到 Spring IoC 容器中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>AutoConfigurationImportSelector：是 ImportSelector 的实现类，只有一个 selectImports 抽象方法，并且返回一个 String 数组，在这个数组中可以指定需要装配到 IOC 容器的类，当@Import 中导入一个 ImportSelectord 的实现类后，会把该实现类中返回的 Class 名称都装载到 IOC 容器中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ImportSelector 与@Configuration 的区别：前者可以实现批量装配，并且还可以通过逻辑处理来实现 Bean 的选择性装配，也就是根据上下文来决定哪些类能够被 IOC 容器初始化。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自动装配原理总结：&lt;/p>
&lt;ol>
&lt;li>通过@Import(AutoConfigurationImportSelector)实现配置类的导入&lt;/li>
&lt;li>AutoConfigurationImportSelector 类实现了 ImportSelector 接口，重写了方法 selectImports，用于实现选择性批量配置类的装配。&lt;/li>
&lt;li>通过 Spring 提供的 SpringFactoriesLoader 机制，扫描 classpath 路径下的 META-INF/spring.factories，读取需要实现自动装配的配置类。&lt;/li>
&lt;li>通过条件筛选的方式，把不符合条件的配置类移除，最终完成自动装配。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>@Conditional 条件装配&lt;/p>
&lt;p>是 Spring Framework 提供的一个核心注解，这个注解的作用是提供自动装配的条件约束，一般与@Configuration 和**@Bean**配合使用。&lt;/p>
&lt;p>简单来说，Spring 在解析@Configuration 配置类时，如果该配置类增加了@Conditional 注解，那么就会根据该注解配置的条件来决定是否要实现 Bean 的装配。&lt;/p>
&lt;pre>&lt;code class="language-java">@Configuration
public class ConditionConfig {
@Bean
@Conditional(GpCondition.class)
public ThirdClass thirdClass() {
return new ThirdClass();
}
}
&lt;/code>&lt;/pre>
&lt;p>表示：如果 GpCondition 类中的 matches 返回 true，则装载 ThirdClass 这个类。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>@Conditional 在 Spring Boot 中的扩展&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210224200015800.webp"
alt="image-20210224200015800" width="auto" loading="lazy">
&lt;/figure>
&lt;p>常用装配注解：&lt;/p>
&lt;p>@ConditionalOnBean&lt;/p>
&lt;p>@ConditionalOnMissingBean&lt;/p>
&lt;p>@ConditionalOnResource&lt;/p>
&lt;p>@ConditionalOnProperties&lt;/p>
&lt;/li>
&lt;li>
&lt;p>spring-autoconfigure-metadata&lt;/p>
&lt;p>用于实现批量自动装配条件配置，作用和@Conditional 一致，只是把这些条件配置放在了配置文件中。&lt;/p>
&lt;p>两个条件：&lt;/p>
&lt;p>（1）配置文件的路径和名称必须是/META-INF/spring-autoconfigure-metadata.properties&lt;/p>
&lt;p>（2）配置文件中 key 的配置格式：自动配置类的类全路径名.条件=值&lt;/p>
&lt;p>好处：有效降低 Spring Boot 的启动时间，通过这种过滤方式可以减少配置类的加载数量，因为这个过滤发生在配置类的装载之前，所以它可以降低 Spring Boot 启动时装载 Bean 的耗时。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="手写实现一个-starter">
&lt;a href="#%e6%89%8b%e5%86%99%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa-starter" class="header-anchor">#&lt;/a>
手写实现一个 Starter
&lt;/h2>
&lt;h3 id="1-starter-的功能">
&lt;a href="#1-starter-%e7%9a%84%e5%8a%9f%e8%83%bd" class="header-anchor">#&lt;/a>
1 Starter 的功能
&lt;/h3>
&lt;ul>
&lt;li>涉及相关组件的 Jar 包依赖&lt;/li>
&lt;li>自动实现 Bean 的装配&lt;/li>
&lt;li>自动声明并且加载 application.properties 文件中的属性配置。&lt;/li>
&lt;/ul>
&lt;h3 id="2-starter-的命名规范">
&lt;a href="#2-starter-%e7%9a%84%e5%91%bd%e5%90%8d%e8%a7%84%e8%8c%83" class="header-anchor">#&lt;/a>
2 Starter 的命名规范
&lt;/h3>
&lt;p>Starter 的命名主要分为官方命名和自定义组件命名两类，这种命名格式不是强制性的，也是一种约定俗成的方式。&lt;/p>
&lt;ul>
&lt;li>官方命名格式：spring-boot-starter-模块名称&lt;/li>
&lt;li>自定义命名格式：模块名称-spring-boot-starter&lt;/li>
&lt;/ul>
&lt;h3 id="3-实现基于-redis-的-starter">
&lt;a href="#3-%e5%ae%9e%e7%8e%b0%e5%9f%ba%e4%ba%8e-redis-%e7%9a%84-starter" class="header-anchor">#&lt;/a>
3 实现基于 Redis 的 Starter
&lt;/h3>
&lt;ul>
&lt;li>创建一个工程，命名为 redis-spring-boot-starter&lt;/li>
&lt;li>添加 Jar 包依赖&lt;/li>
&lt;li>定义属性类，实现在 application.properties 中配置 Redis 的连接参数，使用@ConfigurationProperties，把当前类中的属性和配置文件中的配置进行绑定，并且规定前缀。&lt;/li>
&lt;li>定义需要自动装配的配置类，主要就是把 RedissonClient 装配到 IOC 容器中。&lt;/li>
&lt;/ul>
&lt;h2 id="apache-dubbo">
&lt;a href="#apache-dubbo" class="header-anchor">#&lt;/a>
Apache Dubbo
&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>什么是 Dubbo：一个分布式服务框架，主要实现多个系统之间的高性能、透明化调用，简单来说就是一个 RPC 框架，但是和普通的 RPC 框架不同，它提供了服务治理功能，比如服务注册、监控、路由、容错等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务提供者开发流程：&lt;/p>
&lt;ol>
&lt;li>创建一个普通的 Maven 工程 provider，并创建两个模块：api 和 provider，其中 provider 是一个 Spring Boot 工程&lt;/li>
&lt;li>在 api 模块中定义接口，并且通过 mvn install 安装到本地仓库&lt;/li>
&lt;li>在 provider 模块的 pom 文件中引入 api 和 dubbo 组件。&lt;/li>
&lt;li>在 provider 中实现接口，并且使用@DubboService 注解发布服务&lt;/li>
&lt;li>在 application.properties 文件（或 yml）中添加 Dubbo 服务的配置信息，包括 application.name、protocal.name、protocol.port 和 registry.address&lt;/li>
&lt;li>启动 Spring Boot&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>服务调用者的开发流程：&lt;/p>
&lt;ol>
&lt;li>创建一个 Spring Boot 项目 consumer，添加 Jar 包依赖（Dubbo 和 api）&lt;/li>
&lt;li>在 application.properties 中配置 dubbo.application.name&lt;/li>
&lt;li>使用@DubboReference 注解获取一个远程代理对象。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="zookeeper">
&lt;a href="#zookeeper" class="header-anchor">#&lt;/a>
Zookeeper
&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>Zookeeper 是一个高性能的分布式协调中间件，基于 Java 编写。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Zookeeper 的数据结构：数据模型和分布式文件系统类似，是一种层次化的属性结构，区别是：Zookeeper 的数据是结构化存储的，并没有在物理上体现出文件和目录。Zookeeper 树中的每个节点被称为 Znode，Znode 维护了一个 stat 状态信息，其中包含数据变化的时间和版本等。并且每个 Znode 可以设置一个 value 值，Zookeeper 并不用于通用的数据库或者大容量的对象存储，它只是管理和协调有关的数据，所以 value 的数据大小不建议设置得非常大，否则会带来更大的网络开销。Zookeeper 上的每一个节点的数据都是允许读和写的，读表示指定获得 Znode 上的 value 数据，写表示修改 Znode 上的 value 数据。另外，节点的创建规则和文件系统中文件的创建规则类似，必须按照层次创建。例如：创建/node/node1/node1-1，先要创建/node/node1 这两个层次节点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Zookeeper 的特性：Znode 在被创建后，需要指定节点的类型，节点类型分为：&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/img/image-20210225003640228.png" width="auto" loading="lazy">
&lt;/figure>
&lt;/li>
&lt;li>
&lt;p>Watcher 机制：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Znode 的订阅/通知机制：当 Znode 节点状态发生变化时或者 Zookeeper 客户端连接状态发生变化时，会触发事件通知。这个机制在服务注册与发现中，针对服务调用者及时感知到服务提供者的变化提供了非常好的解决方案。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Zookeeper 提供的 Java API 中，提供了三种机制来针对 Znode 进行注册监听，分别是：&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210225003945831.webp"
alt="image-20210225003945831" width="auto" loading="lazy">
&lt;/figure>
&lt;/li>
&lt;li>
&lt;p>常用应用场景分析&lt;/p>
&lt;ol>
&lt;li>分布式锁：（1）多线程中 Synchronized 和 Lock 用于解决共享资源访问的数据安全性问题，但范围是线程级别的。（2）在分布式架构中，多个进程对同一个共享资源的访问，也存在数据安全性问题，因此也需要使用锁的形式来解决这类问题，而解决分布式环境下多进程对于共享资源访问带来的安全性问题的方案就是使用分布式锁。锁的本质是排他性，也就是避免同一时刻多个进程同时访问某一个共享资源。（3）如果使用 Zookeeper 实现分布式锁来达到排他性的目的，只需要用到节点的特性：临时节点，以及同级节点的唯一性。（4）具体实现：a.获得锁的过程：所有客户端可以去 Zookeeper 服务器上/Exclusive_Locks 节点下创建一个临时节点/lock。Zookeeper 基于同级节点的唯一性，会保证所有客户端中只有一个客户端能创建成功，创建成功的客户端获得了排它锁，没有获得锁的客户端就需要通过 Watcher 机制监听/Exclusive_Locks 节点下子节点的变更事件，用于实时监听/lock 节点的变化情况以作出反应。 b.释放锁的过程：①获得锁的客户端因为异常断开了和服务端的连接，临时节点会自动删除。②获得锁的客户端执行完业务逻辑后，主动删除创建的 lock 节点。&lt;/li>
&lt;li>Master 选举：分布式系统中的集群模式，某一机器宕机后，其他节点会接替故障节点继续工作。（1）Zookeeper 有两种方式来实现 Master 选举的场景。假设集群中有 3 个节点，需要选举出 Master，那么三个节点同时去 Zookeeper 服务器上创建一个临时节点/master-election，由于节点的唯一性，只会有一个客户端创建成功，创建成功就称为 Master。同时，其他没有创建成功的客户端，针对该节点注册 Watcher 事件，监控 master，一旦/master-election 节点被删除，其他客户端重新发起 master 选举。（2）方法二：利用临时有序节点的特性来实现。所有参与选举的节点在/master 节点下创建一个临时有序节点，编号最小的节点表示 master，后续的节点监听上一个节点的删除事件，用于触发重新选举。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="dubbo-集成-zookeeper">
&lt;a href="#dubbo-%e9%9b%86%e6%88%90-zookeeper" class="header-anchor">#&lt;/a>
Dubbo 集成 Zookeeper
&lt;/h2>
&lt;h3 id="1-需要解决的问题">
&lt;a href="#1-%e9%9c%80%e8%a6%81%e8%a7%a3%e5%86%b3%e7%9a%84%e9%97%ae%e9%a2%98" class="header-anchor">#&lt;/a>
1 需要解决的问题
&lt;/h3>
&lt;ul>
&lt;li>服务动态上下线感知：服务调用者要感知到服务提供者上下线的变化。&lt;/li>
&lt;li>负载均衡&lt;/li>
&lt;/ul>
&lt;h3 id="2-实现步骤">
&lt;a href="#2-%e5%ae%9e%e7%8e%b0%e6%ad%a5%e9%aa%a4" class="header-anchor">#&lt;/a>
2 实现步骤
&lt;/h3>
&lt;ol>
&lt;li>在 provider 模块中添加 Zookeeper 相关依赖&lt;/li>
&lt;li>修改 application.properties 配置文件，修改 dubbo 的 registry-addr 为 zookeeper 服务器的地址，表示当前 Dubbo 服务需要注册到 Zookeeper 上。&lt;/li>
&lt;li>consumer 只需要修改 application.properties，设置 dubbo 的 registry-addr 即可&lt;/li>
&lt;/ol>
&lt;h3 id="3-原理">
&lt;a href="#3-%e5%8e%9f%e7%90%86" class="header-anchor">#&lt;/a>
3 原理
&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>Dubbo 服务注册到 Zookeeper 上之后，可以在 Zookeeper 服务器上看到图下所示的树形结构。&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210225005911001.webp"
alt="image-20210225005911001" width="auto" loading="lazy">
&lt;/figure>
&lt;/li>
&lt;li>
&lt;p>其中 URL 是临时节点，其他皆为持久化节点，如果注册该节点的服务器下线了，那么这个服务器的 URL 地址就会被移除。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当 Dubbo 服务消费者启动时，会对/providers 下的子节点注册 Watcher 监听，这样就可以感知到服务提供方的上下线变化，从而防止请求发送到已经下线的服务器造成访问失败。同时，服务消费者会在/consumers 下写入自己的 URL，这样可以在监控平台上看到某个 Dubbo 服务正在被哪些服务调用。最重要的是，如果服务消费者需要调用一个服务，那么它会先去/providers 路径下获得所有该服务的提供方 URL 列表，然后通过负载均衡算法计算出一个地址进行远程访问。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>此外，Dubbo 还可以针对不同的情况实现以下功能：&lt;/p>
&lt;ol>
&lt;li>基于临时节点的特性，当服务器宕机或者下线时，注册中心会自动删除该服务提供者的信息。&lt;/li>
&lt;li>注册中心重启时，Dubbo 能自动恢复注册数据及订阅请求。&lt;/li>
&lt;li>为了保证节点操作的安全性，Zookeeper 提供了 ACL 权限控制，在 Dubbo 中可以通过 register.username 和 password 来设置节点的验证信息。&lt;/li>
&lt;li>注册中心默认的根节点为/dubbo，如果需要针对不同环境设置不同的根节点，可以使用 registry.group 修改根节点名称。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h3 id="4-实战-dubbo-spring-cloud">
&lt;a href="#4-%e5%ae%9e%e6%88%98-dubbo-spring-cloud" class="header-anchor">#&lt;/a>
4 实战 Dubbo Spring Cloud
&lt;/h3>
&lt;ol>
&lt;li>创建 service-provider 工程，创建两个子模块 api 和 provider，前者为 maven 工程，后者为 Spring Boot 工程&lt;/li>
&lt;li>在 api 中声明接口，并执行 mvn install&lt;/li>
&lt;li>在 provider 中添加 api、Spring Boot、Spring Cloud 和 Spring Cloud Alibaba 相关组件的依赖。（包括 spring-cloud-starter、spring-cloud-starter-dubbo、api、discovery）&lt;/li>
&lt;li>在父 pom 中显示声明 dependencyManagement 配置版本。&lt;/li>
&lt;li>在 provider 中创建接口的实现类，并且声明@DubboService&lt;/li>
&lt;li>在 application.properties 中配置 Dubbo 相关信息。&lt;/li>
&lt;li>启动 provider 服务。&lt;/li>
&lt;li>创建 consumer，依赖与 provider 类似，同样在 application.properties 中配置 Dubbo 相关信息。注意：dubbo-cloud-subscribed-services 表示服务调用者订阅的服务提供方的应用名称列表，如果有多个应用名称，可以通过&amp;quot;,&amp;ldquo;分开，默认值为“*”&lt;/li>
&lt;li>使用@DubboReference 消费服务，启动即可。&lt;/li>
&lt;/ol>
&lt;h2 id="dubbo-的高级应用">
&lt;a href="#dubbo-%e7%9a%84%e9%ab%98%e7%ba%a7%e5%ba%94%e7%94%a8" class="header-anchor">#&lt;/a>
Dubbo 的高级应用
&lt;/h2>
&lt;h3 id="1-集群容错">
&lt;a href="#1-%e9%9b%86%e7%be%a4%e5%ae%b9%e9%94%99" class="header-anchor">#&lt;/a>
1 集群容错
&lt;/h3>
&lt;p>Dubbo 默认提供 6 种容错模式，默认为 Failover Cluster，此外可以根据实际需求自行扩展。&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210225012015079.webp"
alt="image-20210225012015079" width="auto" loading="lazy">
&lt;/figure>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210225012046078.webp"
alt="image-20210225012046078" width="auto" loading="lazy">
&lt;/figure>
&lt;ul>
&lt;li>配置方式：在@DubboService 中增加参数 cluster=&amp;ldquo;failfast&amp;rdquo; 即可。&lt;/li>
&lt;li>推荐：查询语句容错策略建议使用默认的 Failover Cluster，而增删改操作建议使用 Failfast Cluster 或者使用 Failover Cluster(retries=0)，防止出现数据重复添加等其他问题！建议在设计接口的时候把查询接口方法单独做成一个接口提供查询。&lt;/li>
&lt;/ul>
&lt;h3 id="2-负载均衡">
&lt;a href="#2-%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" class="header-anchor">#&lt;/a>
2 负载均衡
&lt;/h3>
&lt;p>Dubbo 提供了 4 种负载均衡策略，默认为 random，也可以自行扩展（基于 SPI 机制）。&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210225012419926.webp"
alt="image-20210225012419926" width="auto" loading="lazy">
&lt;/figure>
&lt;h3 id="3-服务降级">
&lt;a href="#3-%e6%9c%8d%e5%8a%a1%e9%99%8d%e7%ba%a7" class="header-anchor">#&lt;/a>
3 服务降级
&lt;/h3>
&lt;p>服务降级是一种系统保护策略，当服务器访问压力较大时，可以根据当前业务情况对不重要的服务进行降级，以保证核心业务的正常运行。所谓的降级，就是把一些非必要的功能在流量较大的时间段暂时关闭，比如在双十一大促时，淘宝会把查看历史订单、商品评论等功能关闭。&lt;/p>
&lt;p>降级的分类：&lt;/p>
&lt;ul>
&lt;li>是否自动化：人工降级、自动降级&lt;/li>
&lt;li>功能划分：读服务降级和写服务降级&lt;/li>
&lt;/ul>
&lt;p>自动降级更多来自于系统出现某些异常时自动触发“兜底的流畅”，比如：&lt;/p>
&lt;ul>
&lt;li>故障降级：调用的远程服务挂了，网络故障或者 RPC 服务返回异常。这类情况在业务情况下可以通过设置兜底数据响应给客户端。&lt;/li>
&lt;li>限流降级：为了保护系统不被压垮，在系统中会针对核心业务进行限流，当请求流量达到阈值时，后续的请求会被拦截。&lt;/li>
&lt;/ul>
&lt;p>Dubbo 提供了一种 Mock 配置来实现服务降级，也就是当服务提供方出现网络异常无法访问时，客户端不抛出异常，步骤如下：&lt;/p>
&lt;ol>
&lt;li>在 consumer 中创建 MockService，这个类只需要实现降级的接口即可，重写接口中的抽象方法实现本地数据的返回。&lt;/li>
&lt;li>在@DubboReference 中增加 mock 参数，制定 MockService 的位置。&lt;/li>
&lt;li>在不启动 Dubbo 服务或者服务端的返回值超过默认的超时时间时，得到的数据就是 MockService 中的数据。&lt;/li>
&lt;/ol>
&lt;h2 id="主机绑定规则">
&lt;a href="#%e4%b8%bb%e6%9c%ba%e7%bb%91%e5%ae%9a%e8%a7%84%e5%88%99" class="header-anchor">#&lt;/a>
主机绑定规则
&lt;/h2>
&lt;p>主机绑定表示的是 Dubbo 服务对外发布的 IP 地址，默认情况下 Dubbo 会按照以下顺序来查找并绑定主机 IP 地址。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>查找环境变量 DUBBO_IP_TO_BIND 属性配置的 IP 地址。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>查找 dubbo.protocol.host 属性的 IP 地址，默认是空，如果没有配置或者 IP 地址不合法则继续查找。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过 LocalHost.getHostAddress 获取本机 IP 地址，获取失败则继续。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果配置了注册中心的地址，则使用 Socket 通信连接到注册中心的地址后，使用 for 循环通过 socket.getLocalAddress().getHostAddress()扫描各个网卡来获取网卡 IP 的地址。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>建议：通过 dubbo.protocal.host 设置主机地址，防止注册错误的 IP 地址，使服务消费者无法调用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>docker 部署解决方案：使用&amp;ndash;net=host 绑定网络，然后配置 application.yml&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210301020007424.webp"
alt="image-20210301020007424" width="auto" loading="lazy">
&lt;/figure>
&lt;p>配置 inetutils 下的两个参数&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="dubbo-源码分析">
&lt;a href="#dubbo-%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90" class="header-anchor">#&lt;/a>
Dubbo 源码分析
&lt;/h2>
&lt;h3 id="1-核心点">
&lt;a href="#1-%e6%a0%b8%e5%bf%83%e7%82%b9" class="header-anchor">#&lt;/a>
1 核心点
&lt;/h3>
&lt;ul>
&lt;li>SPI 机制&lt;/li>
&lt;li>自适应扩展点&lt;/li>
&lt;li>IOC 和 AOP&lt;/li>
&lt;li>Dubbo 如何与 Spring 集成。&lt;/li>
&lt;/ul>
&lt;h3 id="2-生成-ide-工程的命令">
&lt;a href="#2-%e7%94%9f%e6%88%90-ide-%e5%b7%a5%e7%a8%8b%e7%9a%84%e5%91%bd%e4%bb%a4" class="header-anchor">#&lt;/a>
2 生成 IDE 工程的命令
&lt;/h3>
&lt;ul>
&lt;li>mvn idea:idea&lt;/li>
&lt;li>mvn eclipse:eclipse&lt;/li>
&lt;/ul>
&lt;h3 id="3-spiservice-provider-interface">
&lt;a href="#3-spiservice-provider-interface" class="header-anchor">#&lt;/a>
3 SPI(Service Provider Interface)
&lt;/h3>
&lt;ul>
&lt;li>自适应扩展点：AdaptiveExtension&lt;/li>
&lt;li>指定名称扩展点：Extension(name)&lt;/li>
&lt;li>激活扩展点：ActivateExtension(url,key)&lt;/li>
&lt;/ul>
&lt;p>SPI 是 JDK 内置的一种服务提供发现机制，主要用于服务的扩展实现。SPI 机制在很多场景中都有运用，比如数据库连接，JDK 提供了 Driver 接口，这个驱动类由不同的数据库厂商来实现，然后 JDK 利用 SPI 机制从 classpath 下找到相应的驱动来获得指定数据库的连接。这种插拔式的扩展加载方式，也同样遵循一定的协议约定，比如所有的扩展点必须要放在 resources/META-INF/services 目录下，SPI 机制会默认扫描这个路径下的属性文件以完成加载。&lt;/p>
&lt;h3 id="4-dubbo-中的-spi-思想">
&lt;a href="#4-dubbo-%e4%b8%ad%e7%9a%84-spi-%e6%80%9d%e6%83%b3" class="header-anchor">#&lt;/a>
4 Dubbo 中的 SPI 思想
&lt;/h3>
&lt;p>Dubbo 或者 SpringFactoriesLoader 并没有使用 JDK 内置的 SPI 机制，只是利用了 SPI 的思想。Dubbo SPI 的相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader 我们可以加载指定的实现类。&lt;/p>
&lt;p>Dubbo 的 SPI 扩展有两个规则：&lt;/p>
&lt;ul>
&lt;li>和 JDK 内置的 SPI 一样，需要在 resources 目录下创建任一目录结构：META-INF/dubbo、META-INF/dubbp/internal、META-INF/services，在对应的目录下创建以接口全路径名命名的文件，Dubbo 会去三个目录下加载相应扩展点。&lt;/li>
&lt;li>文件内容和 JDK 内置的 SPI 不一样，内容是 key-value 形式的数据，key 是一个字符串，value 是一个对应扩展点的实现，这样的方式可以按照需要加载指定的实现类。&lt;/li>
&lt;/ul>
&lt;p>实现步骤如下：&lt;/p>
&lt;ul>
&lt;li>在一个依赖了 Dubbo 框架的工程中，创建一个扩展点及一个实现。其中，扩展点需要声明@SPI 注解。&lt;/li>
&lt;li>在 resources/META-INF/dubbo 目录下创建以 SPI 接口命名的文件&lt;/li>
&lt;li>使用 ExtensionLoader.getExtensionLoader.getExtension(key)获得指定名称的扩展点实现。&lt;/li>
&lt;/ul>
&lt;h3 id="5-dubbo-中的-spi-原理">
&lt;a href="#5-dubbo-%e4%b8%ad%e7%9a%84-spi-%e5%8e%9f%e7%90%86" class="header-anchor">#&lt;/a>
5 Dubbo 中的 SPI 原理
&lt;/h3>
&lt;p>（1）ExtensionLoader.getExtensionLoader：这个方法用于返回一个 ExtensionLoader 实例，逻辑如下：&lt;/p>
&lt;ul>
&lt;li>先从缓存中获取与扩展类对应的 ExtensionLoader&lt;/li>
&lt;li>缓存未命中，则创建一个新的实例，保存到 eEXTENXION_LOADERS 集合中缓存起来。&lt;/li>
&lt;li>在 ExtensionLoader 构造方法中，初始化一个 objectFactory&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210225020109248.webp"
alt="image-20210225020109248" width="auto" loading="lazy">
&lt;/figure>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210225020130724.webp"
alt="image-20210225020130724" width="auto" loading="lazy">
&lt;/figure>
&lt;p>（2）getExtension：这个方法用于根据指定名称获取对应的扩展点并返回。&lt;/p>
&lt;ul>
&lt;li>name 用于参数的判断，如果 name=&amp;ldquo;true&amp;rdquo;，则返回一个默认的扩展实现。&lt;/li>
&lt;li>创建一个 Holder 对象，用户缓存该扩展点的实例。&lt;/li>
&lt;li>如果缓存中不存在，则通过 createExtension(name)创建一个扩展点。&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210225020354825.webp"
alt="image-20210225020354825" width="auto" loading="lazy">
&lt;/figure>
&lt;p>（3）createExtension()：去指定的路径下查找 name 对应的扩展点的实现。&lt;/p>
&lt;ul>
&lt;li>通过 getExtensionClasses().get(name)获取一个扩展类&lt;/li>
&lt;li>通过反射实例化之后缓存到 EXTENSION_INSTANCES 集合中。&lt;/li>
&lt;li>injectExtension 实例依赖注入&lt;/li>
&lt;li>把扩展类对象通过 Wrapper 进行包装。&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210225020624033.webp"
alt="image-20210225020624033" width="auto" loading="lazy">
&lt;/figure>
&lt;p>（4）getExtensionClasses()&lt;/p>
&lt;ul>
&lt;li>从缓存中换取已经被加载的扩展类&lt;/li>
&lt;li>如果缓存未命中，则调用 loadExtensionClasses 加载扩展类。&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210225020823393.webp"
alt="image-20210225020823393" width="auto" loading="lazy">
&lt;/figure>
&lt;p>（5）loadExtensionClasses()&lt;/p>
&lt;ul>
&lt;li>通过 cacheDefaultExtensionName 方法获取当且扩展接口的默认扩展对象，并且缓存。&lt;/li>
&lt;li>调用 loadDirectory 方法加载指定文件目录下的配置文件。&lt;/li>
&lt;/ul>
&lt;p>（6）cacheDefaultExtensionName()&lt;/p>
&lt;ul>
&lt;li>获得指定扩展接口的@SPI 注解&lt;/li>
&lt;li>得到@SPI 注解中的名字，保存到 cacheDefaultName 属性中。&lt;/li>
&lt;/ul>
&lt;h3 id="6-自适应扩展点">
&lt;a href="#6-%e8%87%aa%e9%80%82%e5%ba%94%e6%89%a9%e5%b1%95%e7%82%b9" class="header-anchor">#&lt;/a>
6 自适应扩展点
&lt;/h3>
&lt;p>Adaptive Extension：能够根据上下文动态匹配一个扩展类，使用方式如下：&lt;/p>
&lt;pre>&lt;code class="language-java">ExtensionLoader.getExtensionLoader(class).getAdaptiveExtension();
&lt;/code>&lt;/pre>
&lt;p>自适应扩展点通过@Adaptive 注解声明，有两种使用方式&lt;/p>
&lt;p>（1）@Adaptive 注解定义在类上面，表示当前类为自适应扩展点。&lt;/p>
&lt;p>（2）@Adaptive 注解定义上方法层面，会通过动态代理的方式生成一个动态字节码，进行自适应匹配。&lt;/p>
&lt;h3 id="7-protocol-自适应扩展点源码">
&lt;a href="#7-protocol-%e8%87%aa%e9%80%82%e5%ba%94%e6%89%a9%e5%b1%95%e7%82%b9%e6%ba%90%e7%a0%81" class="header-anchor">#&lt;/a>
7 Protocol 自适应扩展点源码
&lt;/h3>
&lt;pre>&lt;code class="language-java">ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();
&lt;/code>&lt;/pre>
&lt;p>首先是 getExtensionLoader：&lt;/p>
&lt;p>（1）从缓存中获取自适应扩展点实例。&lt;/p>
&lt;p>（2）如果缓存未命中，则通过 createAdaptiveExtension 创建自适应扩展点。&lt;/p>
&lt;p>然后是 createAdaptiveExtension：&lt;/p>
&lt;p>（1）getAdaptiveExtensionClass：获取一个自适应扩展类的实例。&lt;/p>
&lt;p>（2）injectExtension 完成依赖注入。&lt;/p>
&lt;p>接着是 getAdaptiveExtensionClass：&lt;/p>
&lt;p>（1）通过&lt;strong>getExtensionClasses&lt;/strong>方法加载当前传入类型的所有扩展点，缓存在一个集合中。&lt;/p>
&lt;p>（2）如果 cachedAdaptiveClass 为空，则调用 createAdaptiveExtensionClass 进行创建。&lt;/p>
&lt;h3 id="8-ioc">
&lt;a href="#8-ioc" class="header-anchor">#&lt;/a>
8 IOC
&lt;/h3>
&lt;p>上文中的 injectExtension 就是依赖注入的实现，整体逻辑为：&lt;/p>
&lt;p>（1）遍历被加载的扩展类中的所有 set 方法。&lt;/p>
&lt;p>（2）得到 set 方法中的参数类型，如果参数类型是对象类型，则获得这个 set 方法中的属性名称。&lt;/p>
&lt;p>（3）使用自适应扩展点加载该属性名称对应的扩展类。&lt;/p>
&lt;p>（4）调用 set 完成赋值。&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210225192001158.webp"
alt="image-20210225192001158" width="auto" loading="lazy">
&lt;/figure>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210225192017631.webp"
alt="image-20210225192017631" width="auto" loading="lazy">
&lt;/figure>
&lt;p>简单来说，injectExtension 方法的主要功能是，如果当前加载的扩展类中存在一个成员对象，并且为它提供了 set 方法，那么就会通过自适应扩展点进行加载并赋值。&lt;/p>
&lt;h3 id="9-aop">
&lt;a href="#9-aop" class="header-anchor">#&lt;/a>
9 AOP
&lt;/h3>
&lt;p>面向切面编程，意图是把业务逻辑和功能逻辑分离，然后在运行期间或者类加载期间进行织入，可以降低代码的复杂性，以及提高重用性。&lt;/p>
&lt;pre>&lt;code class="language-java">instance = injectExtension((T)WrapperClass.getConstructor(type).newInstance(instance));
&lt;/code>&lt;/pre>
&lt;p>这段代码分别用到了依赖注入和 AOP，AOP 体现在基于 Wrapper 装饰器类实现对原有的扩展类 instance 进行包装。&lt;/p>
&lt;h3 id="10-dubbo-集成-spring-机制略">
&lt;a href="#10-dubbo-%e9%9b%86%e6%88%90-spring-%e6%9c%ba%e5%88%b6%e7%95%a5" class="header-anchor">#&lt;/a>
10 Dubbo 集成 Spring 机制（略）
&lt;/h3>
&lt;p>p89&lt;/p>
&lt;h2 id="什么是-nacos">
&lt;a href="#%e4%bb%80%e4%b9%88%e6%98%af-nacos" class="header-anchor">#&lt;/a>
什么是 Nacos？
&lt;/h2>
&lt;p>Nacos 致力于解决微服务中的统一配置、服务注册与发现等问题。它提供了一组简单易用的特性集，帮助开发者快速实现动态服务发现、服务配置、服务元数据以及流量管理。&lt;/p>
&lt;h3 id="1-关键特性">
&lt;a href="#1-%e5%85%b3%e9%94%ae%e7%89%b9%e6%80%a7" class="header-anchor">#&lt;/a>
1 关键特性
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>服务发现和服务健康监测&lt;/p>
&lt;p>Nacos 基于 DNS 和基于 RPC 的服务发现。服务提供者通过原生 SDK、OpenAPI 或一个独立的 Agent TODO 注册 Service 后，服务消费者可以使用 DNS 或 HTTP&amp;amp;API 查找和发现服务。&lt;/p>
&lt;p>Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层（PING 或 TCP）和应用层（如 HTTP、MYSQL、用户自定义）的健康检查。对于复杂的云环境和网络拓扑环境（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了&lt;strong>agent 上报&lt;/strong>和&lt;strong>服务端主动监测&lt;/strong>两种健康检查模式。Nacos 还提供了统一的健康检查仪表盘。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>动态配置服务&lt;/p>
&lt;p>业务服务一般都会维护一个本地配置文件，然后把一些常量配置到这个文件中。这种方式在某些场景会存在某些问题，比如配置变更时需要重新部署应用。而动态配置服务可以以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>动态 DNS 服务&lt;/p>
&lt;p>支持权重路由，让开发者更容易实现中间层负载均衡、更灵活的路由策略、流量控制，以及数据中心内网的简单 DNS 服务。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务及其元数据管理&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="2-nacos-集群">
&lt;a href="#2-nacos-%e9%9b%86%e7%be%a4" class="header-anchor">#&lt;/a>
2 Nacos 集群
&lt;/h3>
&lt;p>包含一个 Leader 节点和多个 Follower 节点。&lt;/p>
&lt;p>数据一致性算法采用的 Raft（Etcd、Redis 哨兵选举也是这个算法）&lt;/p>
&lt;p>3 个或 3 个以上 Nacos 节点才能构成集群。&lt;/p>
&lt;h2 id="搭建-nacos-注册中心的注意点">
&lt;a href="#%e6%90%ad%e5%bb%ba-nacos-%e6%b3%a8%e5%86%8c%e4%b8%ad%e5%bf%83%e7%9a%84%e6%b3%a8%e6%84%8f%e7%82%b9" class="header-anchor">#&lt;/a>
搭建 Nacos 注册中心的注意点
&lt;/h2>
&lt;ul>
&lt;li>dubbo.scan.base-packages 功能等同于@DubboComponentScan&lt;/li>
&lt;li>dubbo.registry.address：Dubbo 服务注册中心的配置地址，它的值 spring-cloud://url 表示挂载到 Spring Cloud 注册中心，不配置的话会提示没有配置注册中心的错误。&lt;/li>
&lt;li>spring.cloud.nacos.discovery.server-addr：Nacos 服务注册中心的地址。&lt;/li>
&lt;/ul>
&lt;h2 id="nacos-实现原理">
&lt;a href="#nacos-%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86" class="header-anchor">#&lt;/a>
Nacos 实现原理
&lt;/h2>
&lt;h3 id="1-模块组成">
&lt;a href="#1-%e6%a8%a1%e5%9d%97%e7%bb%84%e6%88%90" class="header-anchor">#&lt;/a>
1 模块组成
&lt;/h3>
&lt;ul>
&lt;li>Provider App&lt;/li>
&lt;li>Consumer App&lt;/li>
&lt;li>Name Server&lt;/li>
&lt;li>Nacos Server&lt;/li>
&lt;li>Nacos Console&lt;/li>
&lt;/ul>
&lt;p>整体来说，服务提供者通过 Virtual IP 访问 Nacos Server 高可用集群，基于 Open API 完成服务的注册和服务的查询。Nacos Server 本身可以支持主备模式，所以底层会采用数据一致性算法来完成主从节点的整体同步。服务消费者也是如此。&lt;/p>
&lt;h3 id="2-注册中心的原理">
&lt;a href="#2-%e6%b3%a8%e5%86%8c%e4%b8%ad%e5%bf%83%e7%9a%84%e5%8e%9f%e7%90%86" class="header-anchor">#&lt;/a>
2 注册中心的原理
&lt;/h3>
&lt;p>服务注册的功能主要体现在：&lt;/p>
&lt;ul>
&lt;li>服务实例在启动时注册到服务注册表，并在关闭时注销。（Open API）&lt;/li>
&lt;li>服务消费者查询服务注册表，获得可用实例。&lt;/li>
&lt;li>服务注册中心需要调用服务实例的健康检查 API 来验证它是否能够处理请求。（心跳机制）&lt;/li>
&lt;/ul>
&lt;h3 id="3-nacos-源码略">
&lt;a href="#3-nacos-%e6%ba%90%e7%a0%81%e7%95%a5" class="header-anchor">#&lt;/a>
3 Nacos 源码（略）
&lt;/h3>
&lt;ul>
&lt;li>服务注册&lt;/li>
&lt;li>服务地址的获取&lt;/li>
&lt;li>服务地址变化的感知&lt;/li>
&lt;/ul>
&lt;h2 id="nacos-实现统一配置管理">
&lt;a href="#nacos-%e5%ae%9e%e7%8e%b0%e7%bb%9f%e4%b8%80%e9%85%8d%e7%bd%ae%e7%ae%a1%e7%90%86" class="header-anchor">#&lt;/a>
Nacos 实现统一配置管理
&lt;/h2>
&lt;p>各个应用自己独立维护本地配置方式的不足：&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210225222922897.webp"
alt="image-20210225222922897" width="auto" loading="lazy">
&lt;/figure>
&lt;h3 id="1-nacos-集成-spring-boot">
&lt;a href="#1-nacos-%e9%9b%86%e6%88%90-spring-boot" class="header-anchor">#&lt;/a>
1 Nacos 集成 Spring Boot
&lt;/h3>
&lt;ul>
&lt;li>在 application.properties 中配置 nacos.config.server-addr&lt;/li>
&lt;li>创建 NacosConfigController，用于从 Nacos Server 动态读取配置。&lt;/li>
&lt;li>@NacosPropertiesSource：用于加载 dataId 为 example 的配置源，autoRefreshed 表示开启自动更新。&lt;/li>
&lt;li>@NacosValue：设置属性的值，其中 info 表示 key，而 Local Hello World 表示默认值。也就是说如果 key 不存在，则使用默认值。这是一种高可用的策略。&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210225223903497.webp"
alt="image-20210225223903497" width="auto" loading="lazy">
&lt;/figure>
&lt;h3 id="2-nacos-集成-spring-cloud">
&lt;a href="#2-nacos-%e9%9b%86%e6%88%90-spring-cloud" class="header-anchor">#&lt;/a>
2 Nacos 集成 Spring Cloud
&lt;/h3>
&lt;ul>
&lt;li>spring.cloud.nacos.config.prefix 表示 Nacos 配置中心上的 DataID 的前缀。&lt;/li>
&lt;li>spring.cloud.nacos.config.server-addr 表示 Nacos 配置中心的地址。&lt;/li>
&lt;li>在 Nacos Console 创建配置&lt;/li>
&lt;li>在启动类中，读取配置中心的数据。&lt;/li>
&lt;li>注意坑：配置文件必须用 bootstrap.yml 这个名称，因为 bootstrap 加载顺序优于 application，因为需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息。&lt;/li>
&lt;/ul>
&lt;h3 id="3-动态更新配置">
&lt;a href="#3-%e5%8a%a8%e6%80%81%e6%9b%b4%e6%96%b0%e9%85%8d%e7%bd%ae" class="header-anchor">#&lt;/a>
3 动态更新配置
&lt;/h3>
&lt;p>通过一个 while 循环不断读取 info 属性，当 info 属性发生变化时，控制台可以监听到。&lt;/p>
&lt;h3 id="4-基于-dataid-配置-yaml-的文件扩展名">
&lt;a href="#4-%e5%9f%ba%e4%ba%8e-dataid-%e9%85%8d%e7%bd%ae-yaml-%e7%9a%84%e6%96%87%e4%bb%b6%e6%89%a9%e5%b1%95%e5%90%8d" class="header-anchor">#&lt;/a>
4 基于 DataID 配置 yaml 的文件扩展名
&lt;/h3>
&lt;p>DataID 默认规则是${prefix}-${spring.profile.active}.${file-extension}&lt;/p>
&lt;ul>
&lt;li>在默认情况下，会去 Nacos 服务器上加载 DataID 以${spring.application.name}.${file-extension:properties}为前缀的基础配置。例如：在不通过 spring.cloud.nacos.config.prefix 指定 DataID 时，会默认读取 DataID 为 nacos-config-demo.properties 的配置信息。&lt;/li>
&lt;li>如果明确指定了 spring.cloud.nacos.config.prefix，则会加载 DataID 为指定值的配置。&lt;/li>
&lt;li>spring.profile.active 表示多环境支持。&lt;/li>
&lt;/ul>
&lt;p>在实际应用中，&lt;strong>如果使用 YAML 格式配置&lt;/strong>，则需要声明 spring.cloud.nacos.config.file-extension=yaml&lt;/p>
&lt;h3 id="5-不同环境的配置切换">
&lt;a href="#5-%e4%b8%8d%e5%90%8c%e7%8e%af%e5%a2%83%e7%9a%84%e9%85%8d%e7%bd%ae%e5%88%87%e6%8d%a2" class="header-anchor">#&lt;/a>
5 不同环境的配置切换
&lt;/h3>
&lt;p>Spring Boot 多环境支持配置步骤如下：&lt;/p>
&lt;ul>
&lt;li>在 resource 目录下根据不同环境创建不同的配置：
&lt;ul>
&lt;li>application-dev.properties&lt;/li>
&lt;li>application-test.properties&lt;/li>
&lt;li>application-prod.properties&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>定义一个 application.properties 默认配置，在该配置中通过 spring.profile.active=${env}来指定使用哪个环境的配置，如果${env}的值为 prod，表示使用 prod 环境。&lt;/li>
&lt;li>也可以通过设置 VM Options=-Dspring.profiles.active=prod 来指定。&lt;/li>
&lt;/ul>
&lt;p>Nacos Config 配置步骤如下：&lt;/p>
&lt;ul>
&lt;li>在 bootstrap.properties 中声明 spring.profiles.active=prod&lt;/li>
&lt;li>在 Nacos 控制台新增 DataID 为 nacos-config-demo-prod.properties 的配置项。&lt;/li>
&lt;/ul>
&lt;h3 id="6-自定义-namespace-和-group">
&lt;a href="#6-%e8%87%aa%e5%ae%9a%e4%b9%89-namespace-%e5%92%8c-group" class="header-anchor">#&lt;/a>
6 自定义 Namespace 和 Group
&lt;/h3>
&lt;ul>
&lt;li>Namespace：解决多环境及多租户数据的隔离问题。
&lt;ul>
&lt;li>使用：在 bootstrap.properties 里指定 spring.cloud.nacos.config.namespace&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Group：用于分组管理 Data ID
&lt;ul>
&lt;li>使用：在 bootstrap.properties 里指定 spring.cloud.nacos.config.group&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="nacos-config-实现原理略">
&lt;a href="#nacos-config-%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e7%95%a5" class="header-anchor">#&lt;/a>
Nacos Config 实现原理（略）
&lt;/h2>
&lt;ul>
&lt;li>获取配置&lt;/li>
&lt;li>监听配置&lt;/li>
&lt;li>发布配置&lt;/li>
&lt;li>删除配置&lt;/li>
&lt;/ul>
&lt;p>分为两类：配置的 CRUD 和配置的动态监听&lt;/p>
&lt;h2 id="spring-cloud-加载配置的原理略">
&lt;a href="#spring-cloud-%e5%8a%a0%e8%bd%bd%e9%85%8d%e7%bd%ae%e7%9a%84%e5%8e%9f%e7%90%86%e7%95%a5" class="header-anchor">#&lt;/a>
Spring Cloud 加载配置的原理（略）
&lt;/h2>
&lt;h2 id="nacos-源码略">
&lt;a href="#nacos-%e6%ba%90%e7%a0%81%e7%95%a5" class="header-anchor">#&lt;/a>
Nacos 源码（略）
&lt;/h2>
&lt;h2 id="sentinel-限流及熔断">
&lt;a href="#sentinel-%e9%99%90%e6%b5%81%e5%8f%8a%e7%86%94%e6%96%ad" class="header-anchor">#&lt;/a>
Sentinel 限流及熔断
&lt;/h2>
&lt;h3 id="1-服务限流的作用及实现">
&lt;a href="#1-%e6%9c%8d%e5%8a%a1%e9%99%90%e6%b5%81%e7%9a%84%e4%bd%9c%e7%94%a8%e5%8f%8a%e5%ae%9e%e7%8e%b0" class="header-anchor">#&lt;/a>
1 服务限流的作用及实现
&lt;/h3>
&lt;p>主要作用：损失一部分用户的可用性，为大部分用户提供稳定可靠的服务。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>计算器算法：在制定周期内累加访问次数，当访问次数达到阈值时，触发限流策略。&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210225232943900.webp"
alt="image-20210225232943900" width="auto" loading="lazy">
&lt;/figure>
&lt;/li>
&lt;li>
&lt;p>滑动窗口算法：源于 TCP 拥塞控制，原理是在固定窗口中分割出&lt;strong>多个小时间窗口&lt;/strong>，分别在每个小时间窗口中记录访问次数，然后根据时间将窗口往前滑动并删除过期的小时间窗口。最终只需要统计滑动窗口范围内所有小时间窗口总的计数即可。（Sentinel 的原理）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>令牌桶算法：每一个请求，都需要从令牌桶中获取一个令牌，如果没有获得令牌，则触发限流策略。&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210225233303914.webp"
alt="image-20210225233303914" width="auto" loading="lazy">
&lt;/figure>
&lt;p>特性：短时间内新增的流量系统能够正常处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>漏桶限流算法：用于控制数据注入网络的速度，平滑网络上的突发流量。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210225233550970.webp"
alt="image-20210225233550970" width="auto" loading="lazy">
&lt;/figure>
&lt;h3 id="2-服务熔断和降级">
&lt;a href="#2-%e6%9c%8d%e5%8a%a1%e7%86%94%e6%96%ad%e5%92%8c%e9%99%8d%e7%ba%a7" class="header-anchor">#&lt;/a>
2 服务熔断和降级
&lt;/h3>
&lt;p>在微服务架构中，由于服务拆分粒度较细，会出现请求链路较长的情况，用户发起一个请求操作，需要调用多个微服务才能完成。&lt;/p>
&lt;p>&lt;strong>雪崩效应&lt;/strong>：某个服务因为网络延迟或者请求超时等原因不可用时，就会导致当前请求阻塞，一旦某个链路上被依赖的服务不可用，很可能出现请求堆积而产生雪崩。&lt;/p>
&lt;p>所以，服务熔断就是用来解决这个问题的方案，它指的是当某个服务提供者无法正常为服务调用者提供服务时，为了防止整个系统出现雪崩效应，暂时将出现故障的接口隔离出来，断绝与外部接口的联系，当触发熔断后，后续一段时间内该服务调用者的请求都会&lt;strong>直接失败&lt;/strong>，直至目标服务恢复正常。&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210225234104602.webp"
alt="image-20210225234104602" width="auto" loading="lazy">
&lt;/figure>
&lt;h3 id="3-sentinel-的特性">
&lt;a href="#3-sentinel-%e7%9a%84%e7%89%b9%e6%80%a7" class="header-anchor">#&lt;/a>
3 Sentinel 的特性
&lt;/h3>
&lt;ul>
&lt;li>丰富的应用场景：秒杀、消息削峰填谷、集群流量控制等。&lt;/li>
&lt;li>实时监控&lt;/li>
&lt;li>开源生态支持&lt;/li>
&lt;li>SPI 扩展点支持&lt;/li>
&lt;/ul>
&lt;h3 id="4-sentinel-的组成">
&lt;a href="#4-sentinel-%e7%9a%84%e7%bb%84%e6%88%90" class="header-anchor">#&lt;/a>
4 Sentinel 的组成：
&lt;/h3>
&lt;ul>
&lt;li>核心库（Java 客户端）：不依赖任何框架与库，能够运行于所有 Java 运行时环境。&lt;/li>
&lt;li>控制台（Dashboard）&lt;/li>
&lt;/ul>
&lt;h3 id="5-sentinel-基本应用">
&lt;a href="#5-sentinel-%e5%9f%ba%e6%9c%ac%e5%ba%94%e7%94%a8" class="header-anchor">#&lt;/a>
5 Sentinel 基本应用：
&lt;/h3>
&lt;p>步骤如下：&lt;/p>
&lt;p>（1）定义资源：限流保护的最基本元素，比如一个方法。&lt;/p>
&lt;p>（2）定义限流规则&lt;/p>
&lt;p>（3）检验规则是否生效&lt;/p>
&lt;p>&lt;strong>限流规则&lt;/strong>：通过 initFlowRules 方法设置&lt;/p>
&lt;ul>
&lt;li>grade：限流阈值类型，有 QPS 模式和并发线程数模式。&lt;/li>
&lt;li>count：限流阈值&lt;/li>
&lt;li>resource：设置需要保护的资源&lt;/li>
&lt;/ul>
&lt;h3 id="6-sentinel-资源保护规则">
&lt;a href="#6-sentinel-%e8%b5%84%e6%ba%90%e4%bf%9d%e6%8a%a4%e8%a7%84%e5%88%99" class="header-anchor">#&lt;/a>
6 Sentinel 资源保护规则
&lt;/h3>
&lt;p>Sentinel 支持多种保护规则：流量控制规则、熔断降级规则、系统保护规则、来源访问控制规则、热点参数规则。&lt;/p>
&lt;ul>
&lt;li>限流规则：先通过 FlowRules 来定义限流规则，然后通过 FlowRuleManager.loadRules 来加载规则列表。&lt;/li>
&lt;/ul>
&lt;h4 id="1-qps-流量控制行为">
&lt;a href="#1-qps-%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6%e8%a1%8c%e4%b8%ba" class="header-anchor">#&lt;/a>
1 QPS 流量控制行为
&lt;/h4>
&lt;p>通过 controlBehavior 设置，包含：&lt;/p>
&lt;ul>
&lt;li>直接拒接&lt;/li>
&lt;li>Warm UP，冷启动&lt;/li>
&lt;li>匀速排队&lt;/li>
&lt;li>冷启动 + 匀速排队&lt;/li>
&lt;/ul>
&lt;h3 id="7-sentinel-实现服务熔断">
&lt;a href="#7-sentinel-%e5%ae%9e%e7%8e%b0%e6%9c%8d%e5%8a%a1%e7%86%94%e6%96%ad" class="header-anchor">#&lt;/a>
7 Sentinel 实现服务熔断
&lt;/h3>
&lt;p>通过 DegradeRule 实现：&lt;/p>
&lt;ul>
&lt;li>grade：熔断策略，支持秒级 RT、秒级异常比例、分钟异常数。默认是秒级 RT。&lt;/li>
&lt;li>timeWindow：熔断降级的时间窗口，单位为 s。也就是出发熔断降级之后多长时间内自动熔断。&lt;/li>
&lt;li>rtSlowRequestAmount：在 RT 模式下，1s 内持续多少个请求的平均 RT 超出阈值后出发熔断，默认值是 5&lt;/li>
&lt;li>minRequestAmout：触发的异常熔断最小请求数，请求数小于该值时即使异常比例超出阈值也不会触发熔断，默认值是 5.&lt;/li>
&lt;/ul>
&lt;p>三种熔断策略：&lt;/p>
&lt;ul>
&lt;li>平均响应时间 RT：如果 1s 内持续进来 5 个请求，对应的平均响应时间都超过了阈值(count，单位为 ms)，那么在接下来的时间窗口内，对这个方法的调用都会自动熔断，抛出 DegradeException&lt;/li>
&lt;li>异常比例&lt;/li>
&lt;li>最近一分钟异常数：如果 timeWindow 小于 60s，则结束熔断状态后仍然可能再进入熔断状态。&lt;/li>
&lt;/ul>
&lt;h2 id="sentinel-集成-spring-cloud">
&lt;a href="#sentinel-%e9%9b%86%e6%88%90-spring-cloud" class="header-anchor">#&lt;/a>
Sentinel 集成 Spring Cloud
&lt;/h2>
&lt;p>步骤如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>创建项目，集成 Spring Cloud 依赖。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>添加 Sentinel 依赖。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>创建一个 REST 接口，并且通过@SentinelResource 配置限流保护资源。&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210226000233876.webp"
alt="image-20210226000233876" width="auto" loading="lazy">
&lt;/figure>
&lt;/li>
&lt;li>
&lt;p>在上述代码中，配置限流资源有几种情况&lt;/p>
&lt;ul>
&lt;li>Sentinel starter 在默认情况下会为所有的 HTTP 服务提供限流埋点，所以如果只想对 HTTP 服务进行限流，只需添加依赖即可。&lt;/li>
&lt;li>如果想要对特定的方法进行限流或降级，则需要通过@SentinelResource 注解来定义资源。&lt;/li>
&lt;li>可以通过 SphU.entry()方法来配置资源。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>手动配置流控规则，可以借助 Sentinel 的 InitFunc SPI 扩展接口来实现，只需要实现自己的 InitFunc 接口，并在 init 方法中编写规则加载的逻辑即可。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="基于-sentinel-dashboard-来实现流控配置">
&lt;a href="#%e5%9f%ba%e4%ba%8e-sentinel-dashboard-%e6%9d%a5%e5%ae%9e%e7%8e%b0%e6%b5%81%e6%8e%a7%e9%85%8d%e7%bd%ae" class="header-anchor">#&lt;/a>
基于 Sentinel Dashboard 来实现流控配置
&lt;/h2>
&lt;p>步骤如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>启动 Sentinel Dashboard&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 application.yml 中增加以下配置&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210226000900895.webp"
alt="image-20210226000900895" width="auto" loading="lazy">
&lt;/figure>
&lt;/li>
&lt;li>
&lt;p>提供一个 REST 接口&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进入 Sentinel Dashboard 中配置流控规则。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>访问簇点链路，找到资源名称。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>单机流控按钮设置流控规则&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>注意 sentinel 的坑：&lt;/strong>&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210226015008780.webp"
alt="image-20210226015008780" width="auto" loading="lazy">
&lt;/figure>
&lt;h2 id="sentinel-自定义-url-限流异常">
&lt;a href="#sentinel-%e8%87%aa%e5%ae%9a%e4%b9%89-url-%e9%99%90%e6%b5%81%e5%bc%82%e5%b8%b8" class="header-anchor">#&lt;/a>
Sentinel 自定义 URL 限流异常
&lt;/h2>
&lt;p>默认情况下，URL 触发限流后会返回 Blocked by Sentinel 字符串&lt;/p>
&lt;p>在实际应用中，大都采用 JSON 格式，所以如果希望修改触发限流之后的返回结果形式，则可以通过自定义限流异常来处理，实现&lt;strong>UrlBlockHandler&lt;/strong>并且重写 blocked 方法。&lt;/p>
&lt;p>还有一种场景，当触发限流后，希望跳转到一个降级页面，可以通过下面这个配置来实现。&lt;/p>
&lt;p>spring.cloud.sentinel.servlet.block-page={url}&lt;/p>
&lt;h2 id="sentinel-对-url-资源清洗">
&lt;a href="#sentinel-%e5%af%b9-url-%e8%b5%84%e6%ba%90%e6%b8%85%e6%b4%97" class="header-anchor">#&lt;/a>
Sentinel 对 URL 资源清洗
&lt;/h2>
&lt;p>Sentinel 中 HTTP 服务的限流默认由 Sentinel-Web-Servlet 包中的 CommonFilter 来实现，这个 Filter 会把每个不同的 URL 都作为不同的资源来处理。&lt;/p>
&lt;p>举例：&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210226194317550.webp"
alt="image-20210226194317550" width="auto" loading="lazy">
&lt;/figure>
&lt;ul>
&lt;li>限流统计不准确，实际需求是控制 clean 方法总的 QPS，结果统计的是每个 URL 的 QPS&lt;/li>
&lt;li>导致 Sentinel 中资源数量过多，默认资源数量阈值为 6000，对于多出的资源规则将不会生效。&lt;/li>
&lt;/ul>
&lt;p>针对这个问题可以通过&lt;strong>URLCleaner&lt;/strong>接口来实现资源清洗，也就是对于/clean/{id}这个 URL，我们可以统一归集到/clean/*资源下，具体代码如下：&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210226194545852.webp"
alt="image-20210226194545852" width="auto" loading="lazy">
&lt;/figure>
&lt;h2 id="sentinel-集成-nacos-实现动态流控规则">
&lt;a href="#sentinel-%e9%9b%86%e6%88%90-nacos-%e5%ae%9e%e7%8e%b0%e5%8a%a8%e6%80%81%e6%b5%81%e6%8e%a7%e8%a7%84%e5%88%99" class="header-anchor">#&lt;/a>
Sentinel 集成 Nacos 实现动态流控规则
&lt;/h2>
&lt;p>Sentinel 的理念是只需要开发者关注资源的定义，默认会对资源进行流控。当然我们还需要自定义流控规则，前面有两种方式：&lt;/p>
&lt;ul>
&lt;li>通过 FlowRuleManager.loadRules(List rules)手动加载流控规则&lt;/li>
&lt;li>在 Sentinel Dashboard 上针对资源动态创建流控规则。&lt;/li>
&lt;/ul>
&lt;p>针对第一种方式，如果接入 Sentinel Dashboard，那么同样支持动态修改流控规则。但是，这里会存在一个问题，基于 Sentinel Dashboard 所配置的流控规则，都是保存在&lt;strong>内存&lt;/strong>中的，一旦应用重启，这些规则都会被清除。为了解决这个问题，Sentinel 提供了动态数据源支持。&lt;/p>
&lt;p>目前，Sentinel 支持 Consul、Zookeeper、Redis、Nacos、Apollo、etcd 等数据源的扩展，我们使用 Nacos 的方式来扩展。&lt;/p>
&lt;p>步骤如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>添加 Nacos 数据源依赖包&lt;/p>
&lt;/li>
&lt;li>
&lt;p>创建一个 REST 接口用于测试。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 application.yml 中添加数据源配置。&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210226195049493.webp"
alt="image-20210226195049493" width="auto" loading="lazy">
&lt;/figure>
&lt;p>配置说明：&lt;/p>
&lt;p>rule-type：flow、degrade、param-flow、gw-flow 等&lt;/p>
&lt;p>data-type：Spring Cloud Alibaba 提供了 JSON 和 XML 两种格式。如果需要自定义，则可以将值配置为 custom，并配置 converter-class 指向 converter 类。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>登录 Nacos 控制台，创建流控配置规则，配置信息如下：&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210226195526683.webp"
alt="image-20210226195526683" width="auto" loading="lazy">
&lt;/figure>
&lt;/li>
&lt;li>
&lt;p>最后，登录 Sentinel Dashboard，找到执行项目名称菜单下的“流控规则”，就可以看到在 Nacos 上所配置的流控规则已经被加载了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当在 Nacos 控制台修改流控规则后，可以同步在 Sentinel Dashboard 上看到流控规则的变化。&lt;/p>
&lt;ul>
&lt;li>注意：在 Sentinel Dashboard 上修改无法同步到 Nacos 上。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>强烈建议&lt;/strong>：不要在 Nacos 上修改流控规则，因为这种修改的危险系数很高。这就意味着流控规则的管理应该集中在 Sentinel Dashboard 上，所以我们需要实现 Sentinel Dashboard 来动态维护规则并同步到 Nacos 上，目前官方还没有提供支持，但可以自己实现。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这里有一个坑：出现了&lt;strong>空指针异常&lt;/strong>org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;lsquo;ds1-sentinel-nacos-datasource&amp;rsquo;: FactoryBean threw exception on object creation; nested exception is java.lang.NullPointerException，出现原因是 Spring-Cloud-Alibaba 与 Sentinel 的&lt;strong>版本对应不上&lt;/strong>，解决办法是把 Spring Cloud Alibaba 的版本升到 2.2.5.RELEASE 即可。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="sentinel-集成-nacos-实现规则同步">
&lt;a href="#sentinel-%e9%9b%86%e6%88%90-nacos-%e5%ae%9e%e7%8e%b0%e8%a7%84%e5%88%99%e5%90%8c%e6%ad%a5" class="header-anchor">#&lt;/a>
Sentinel 集成 Nacos 实现规则同步
&lt;/h2>
&lt;p>Sentinel Dashboard 的“流控规则”下的所有操作，都会调用 Sentinel 源码中的 FlowControllerV1 类，这个类包含流控规则本地化的 CRUD&lt;/p>
&lt;p>另外，在 com.alibaba.csp.sentinel.dashboard.controller.v2 包下存在一个 FlowControllerV2 类，这个类同样提供流控规则的 CRUD，和 V1 版本不同的是，它可以实现指定数据源的规则拉取和同步。&lt;/p>
&lt;p>FlowControllerV2 依赖以下两个非常重要的类&lt;/p>
&lt;ul>
&lt;li>DynamicRuleProvider：动态规则的拉取，从指定数据源中获取流控规则后在 Sentinel Dashboard 中展示。&lt;/li>
&lt;li>DynamicRulePublisher：动态规则的发布，将在 Sentinel Dashboard 中修改的规则同步到指定数据源中。&lt;/li>
&lt;/ul>
&lt;p>这里我们扩展这两个类，然后集成 Nacos 来实现 Sentinel Dashboard 规则的同步。&lt;/p>
&lt;h3 id="1-sentinel-dashboard-源码修改">
&lt;a href="#1-sentinel-dashboard-%e6%ba%90%e7%a0%81%e4%bf%ae%e6%94%b9" class="header-anchor">#&lt;/a>
1 Sentinel Dashboard 源码修改：
&lt;/h3>
&lt;p>具体步骤如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>打开 sentinel-dashboard 工程，在 pom.xml 中把 sentinel-datasource-nacos 依赖的 scope 注释掉。&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210226220250575.webp"
alt="image-20210226220250575" width="auto" loading="lazy">
&lt;/figure>
&lt;/li>
&lt;li>
&lt;p>修改 resouces/app/scripts/directives/sidebar/sidebar.html 文件下的代码，将 dashboard.flowV1 改成 dashboard.flow&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210226220240096.webp"
alt="image-20210226220240096" width="auto" loading="lazy">
&lt;/figure>
&lt;p>修改之后，会调用 FlowControllerV2 中的接口。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 com.alibaba.csp.sentinel.dashboard.rule 包中创建一个 nacos 包，并创建一个类用来加载外部化配置。&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210226220601939.webp"
alt="image-20210226220601939" width="auto" loading="lazy">
&lt;/figure>
&lt;/li>
&lt;li>
&lt;p>创建一个 Nacos 配置类 NacosConfiguration&lt;/p>
&lt;ul>
&lt;li>注入 Converter 转换器，将 FlowRuleEntity 转化为 FlowRule，以及反向转化。&lt;/li>
&lt;li>注入 Nacos 配置服务 ConfigService&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>创建一个常量类 NacosConstants，分别表示默认的 GROUP_ID 和 DATA_ID 的后缀。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实现动态从 Nacos 配置中心获取流控规则。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>创建一个流控规则发布类，在 Sentinel Dashboard 上修改完配置后，需要调用该发布方法将数据持久化到 Nacos 中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改 FlowControllerV2 类，将上面配置的两个类注入进来，表示规则的拉取和规则的发布统一用我们前面自定义的两个实例。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 application.properties 文件中添加 nacos 服务端的配置信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将代码打包成一个 fat jar&lt;/p>
&lt;/li>
&lt;li>
&lt;p>详见 &lt;a class="link" href="https://blog.csdn.net/weixin_42073629/article/details/107117433" target="_blank" rel="noopener" >https://blog.csdn.net/weixin_42073629/article/details/107117433
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
或者 test 包中的 nacos 代码&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="2-sentinel-dashboard-规则同步">
&lt;a href="#2-sentinel-dashboard-%e8%a7%84%e5%88%99%e5%90%8c%e6%ad%a5" class="header-anchor">#&lt;/a>
2 Sentinel Dashboard 规则同步
&lt;/h3>
&lt;p>应用程序需要修改的地方比较少，只需注意配置文件中 data-id 的命名要以-sentinel-flow 结尾即可。&lt;/p>
&lt;h2 id="sentinel-集成-dubbo-实现限流">
&lt;a href="#sentinel-%e9%9b%86%e6%88%90-dubbo-%e5%ae%9e%e7%8e%b0%e9%99%90%e6%b5%81" class="header-anchor">#&lt;/a>
Sentinel 集成 Dubbo 实现限流
&lt;/h2>
&lt;p>Sentinel 提供了与 Dubbo 整合的模块 Sentinel Apache Dubbo Adapter，可以针对服务提供者和服务消费者进行流控，在使用的时候，只需要添加以下依赖。&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210227193606798.webp"
alt="image-20210227193606798" width="auto" loading="lazy">
&lt;/figure>
&lt;p>添加后该依赖后，Dubbo 服务中的接口和方法（包括服务端和消费端）就会成为 Sentinel 中的资源，只需针对指定资源配置流控规则就可以实现 Sentinel 流控功能。&lt;/p>
&lt;p>Sentinel Apache Dubbo Adapter 实现限流的核心原理是基于 Dubbo 的 SPI 机制实现 Filter 扩展，Dubbo 的 Filter 机制是专门为服务提供者和服务消费者调用过程进行拦截设计的，每次执行远程方法，该拦截都会被执行。&lt;/p>
&lt;p>同时，Sentinel Apache Dubbo Adapter 还可以自定义开启或者关闭某个 Filter 的功能，下面表示关闭消费端的过滤器。&lt;/p>
&lt;h3 id="hahahugoshortcode127s32hbhb">
&lt;a href="#hahahugoshortcode127s32hbhb" class="header-anchor">#&lt;/a>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210227193903284.webp"
alt="image-20210227193903284" width="auto" loading="lazy">
&lt;/figure>
&lt;/h3>
&lt;h3 id="1-dubbo-服务接入-sentinel-dashboard">
&lt;a href="#1-dubbo-%e6%9c%8d%e5%8a%a1%e6%8e%a5%e5%85%a5-sentinel-dashboard" class="header-anchor">#&lt;/a>
1 Dubbo 服务接入 Sentinel Dashboard
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>引入 sentinel-transport-simple-http 依赖&lt;/p>
&lt;/li>
&lt;li>
&lt;p>添加启动参数&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210227194238456.webp"
alt="image-20210227194238456" width="auto" loading="lazy">
&lt;/figure>
&lt;/li>
&lt;li>
&lt;p>登录 Sentinel Dashboard 之后，进入“簇点链路”，就可以看到资源信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>需要注意的是，限流可以通过服务接口或服务方法设置&lt;/p>
&lt;ul>
&lt;li>服务接口：resourceName 为接口的全限定名（包+接口名）&lt;/li>
&lt;li>服务方法：resourceName 为接口全限定名：方法名（包+接口名:方法名）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="2-dubbo-服务限流规则">
&lt;a href="#2-dubbo-%e6%9c%8d%e5%8a%a1%e9%99%90%e6%b5%81%e8%a7%84%e5%88%99" class="header-anchor">#&lt;/a>
2 Dubbo 服务限流规则
&lt;/h3>
&lt;p>两种方式&lt;/p>
&lt;ul>
&lt;li>Sentinel Dashboard&lt;/li>
&lt;li>FlowRuleManager.loadRules(List rules)&lt;/li>
&lt;/ul>
&lt;p>Sentinel Apache Dubbo Adapter 组件中没有实现规则持久化，因此有以下步骤来支持：&lt;/p>
&lt;ul>
&lt;li>在 dubbo 服务中添加 sentinel-datasource-nacos 依赖&lt;/li>
&lt;li>通过 Sentinel 提供的 InitFunc 扩展点，实现 Nacos 数据源的配置&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210227204336472.webp"
alt="image-20210227204336472" width="auto" loading="lazy">
&lt;/figure>
&lt;ul>
&lt;li>访问 Sentinel Dashboard，在针对某个资源创建流控规则时，这个规则会同步保存到 Nacos 的配置中心，而当 Nacos 配置中心发生变化时，会触发事件机制通知 Dubbo 应用重新加载流控规则。&lt;/li>
&lt;/ul>
&lt;h2 id="sentinel-热点限流">
&lt;a href="#sentinel-%e7%83%ad%e7%82%b9%e9%99%90%e6%b5%81" class="header-anchor">#&lt;/a>
Sentinel 热点限流
&lt;/h2>
&lt;p>热点数据表示经常访问的数据，在有限场景中我们希望针对这些访问频次非常高的数据进行限流，比如针对一段时间内频繁访问的用户 ID 地址进行限流，或者针对频繁访问的某个用户 ID 进行限流。&lt;/p>
&lt;p>Sentinel 提供了热点参数限流的规则，它是一种特殊的限流，在普通限流的基础上对同一个受保护的资源区根据请求中的参数分别处理，该策略只对包含热点参数的资源调用生效。热点限流在&lt;strong>以下场景&lt;/strong>使用较多：&lt;/p>
&lt;ul>
&lt;li>服务网关层：例如防止网络爬虫和恶意攻击，一种常用方法就是限制爬虫的 IP 地址。&lt;/li>
&lt;li>写数据的服务：例如业务系统提供写数据的服务，数据会写入数据库之类的存储系统。存储系统的底层会加锁写磁盘上的文件，部分存储系统会将某一类数据写入同一个文件中。如果底层写同一文件，会出现抢占锁的情况，导致出现大量超时和失败。出现这种情况时一般有两种解决方法：修改存储设计、对热点参数限流。&lt;/li>
&lt;/ul>
&lt;p>Sentinel 通过&lt;strong>LRU 策略结合滑动窗口机制&lt;/strong>来实现热点参数的统计，其中 LRU 策略可以统计单位时间内最常访问的热点数据，滑动窗口机制可以协助统计每个参数的 QPS。&lt;/p>
&lt;h3 id="1-热点参数限流的使用">
&lt;a href="#1-%e7%83%ad%e7%82%b9%e5%8f%82%e6%95%b0%e9%99%90%e6%b5%81%e7%9a%84%e4%bd%bf%e7%94%a8" class="header-anchor">#&lt;/a>
1 热点参数限流的使用
&lt;/h3>
&lt;ul>
&lt;li>引用热点参数限流依赖包 sentinel-parameter-flow-control&lt;/li>
&lt;li>接下来创建一个 REST 接口，并定义限流埋点，此处针对参数 ID 配置热点限流规则。&lt;/li>
&lt;li>针对不同的热点参数，需要通过 SphU.entry(resourceName,EntryType.IN,1,id)方法设置，其最后一个参数是一个数组，有多个热点参数就按照次序依次传入，该配置表示后续会针对该参数进行热点限流。&lt;/li>
&lt;li>通过 ParamFlowRuleManager.loadRules 加载热点参数规则。&lt;/li>
&lt;/ul>
&lt;h3 id="2-sentinelresource">
&lt;a href="#2-sentinelresource" class="header-anchor">#&lt;/a>
2 @SentinelResource
&lt;/h3>
&lt;p>如果是通过@SentinelResource 注解来定义资源，当注解所配置得方法上有参数时，Sentinel 会把这些参数传入 SphU.entry 中&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210227231844217.webp"
alt="image-20210227231844217" width="auto" loading="lazy">
&lt;/figure>
&lt;h3 id="3-热点参数规则说明">
&lt;a href="#3-%e7%83%ad%e7%82%b9%e5%8f%82%e6%95%b0%e8%a7%84%e5%88%99%e8%af%b4%e6%98%8e" class="header-anchor">#&lt;/a>
3 热点参数规则说明
&lt;/h3>
&lt;ul>
&lt;li>durationInSec：统计窗口时间长度，单位为 s&lt;/li>
&lt;li>maxQueueingTimeMS：最长排队等待时长，只有当流控为 controlBehavior 设置为匀速排队模式时生效。&lt;/li>
&lt;li>paramIdx：热点参数的索引，属于必填项，对应的是 SphU.entry 中的参数索引位置。&lt;/li>
&lt;li>paramFlowItemList：针对指定参数值单独设置限流阈值，不受 count 阈值的限制。&lt;/li>
&lt;/ul>
&lt;h2 id="sentinel-的工作原理略">
&lt;a href="#sentinel-%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%e7%95%a5" class="header-anchor">#&lt;/a>
Sentinel 的工作原理（略）
&lt;/h2>
&lt;ul>
&lt;li>工作流程：由各个 Slot 插槽组成（责任链模式）&lt;/li>
&lt;li>p229&lt;/li>
&lt;/ul>
&lt;h2 id="spring-cloud-sentinel-工作原理略">
&lt;a href="#spring-cloud-sentinel-%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%e7%95%a5" class="header-anchor">#&lt;/a>
Spring Cloud Sentinel 工作原理（略）
&lt;/h2>
&lt;ul>
&lt;li>starter 自动装配&lt;/li>
&lt;li>p232&lt;/li>
&lt;/ul>
&lt;h2 id="sentinel-核心源码分析略">
&lt;a href="#sentinel-%e6%a0%b8%e5%bf%83%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%e7%95%a5" class="header-anchor">#&lt;/a>
Sentinel 核心源码分析（略）
&lt;/h2>
&lt;ul>
&lt;li>sentinel-adapter&lt;/li>
&lt;li>sentinel-core&lt;/li>
&lt;li>sentinel-dashboard&lt;/li>
&lt;li>sentinel-demo&lt;/li>
&lt;li>sentinel-extension&lt;/li>
&lt;li>sentinel-transport&lt;/li>
&lt;/ul>
&lt;h3 id="1-限流的源码实现">
&lt;a href="#1-%e9%99%90%e6%b5%81%e7%9a%84%e6%ba%90%e7%a0%81%e5%ae%9e%e7%8e%b0" class="header-anchor">#&lt;/a>
1 限流的源码实现
&lt;/h3>
&lt;h3 id="2-实时指标数据统计">
&lt;a href="#2-%e5%ae%9e%e6%97%b6%e6%8c%87%e6%a0%87%e6%95%b0%e6%8d%ae%e7%bb%9f%e8%ae%a1" class="header-anchor">#&lt;/a>
2 实时指标数据统计
&lt;/h3>
&lt;h3 id="3-服务降级的实现原理">
&lt;a href="#3-%e6%9c%8d%e5%8a%a1%e9%99%8d%e7%ba%a7%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86" class="header-anchor">#&lt;/a>
3 服务降级的实现原理
&lt;/h3>
&lt;h2 id="什么是分布式事务">
&lt;a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1" class="header-anchor">#&lt;/a>
什么是分布式事务？
&lt;/h2>
&lt;p>事务：作为单个逻辑工作单元执行的多个数据库操作，要么同时成功，要么同时失败，必须满足 ACID 特性。（单库多表）&lt;/p>
&lt;p>在微服务架构下，随着业务服务的拆分及数据库的拆分，举例说，订单和库存分别拆分成两个独立的数据库，当客户端发起一个下单操作，需要在订单服务对应的数据库创建订单，同时基于 RPC 通信调用库存服务完成商品库存的扣减。&lt;/p>
&lt;p>这样，原来的单库事务操作就变成了多个数据库的事务操作 =&amp;gt; 数据不一致问题。&lt;/p>
&lt;h3 id="1-分布式事务问题的理论模型">
&lt;a href="#1-%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1%e9%97%ae%e9%a2%98%e7%9a%84%e7%90%86%e8%ae%ba%e6%a8%a1%e5%9e%8b" class="header-anchor">#&lt;/a>
1 分布式事务问题的理论模型
&lt;/h3>
&lt;p>核心原因：存储资源的分布性&lt;/p>
&lt;p>在实际应用中，应该尽可能从设计层面去避免分布式事务的问题。&lt;/p>
&lt;h4 id="1-xopen-分布式模型">
&lt;a href="#1-xopen-%e5%88%86%e5%b8%83%e5%bc%8f%e6%a8%a1%e5%9e%8b" class="header-anchor">#&lt;/a>
1 X/Open 分布式模型
&lt;/h4>
&lt;p>X/Open DTP 是 X/Open 这个组织定义的一套分布式事务的标准。这个标准提出了&lt;strong>两阶段提交&lt;/strong>（2PC，2-phase-commit）来保证分布式事务的完整性。X/Open DTP 包含以下三种角色。&lt;/p>
&lt;ul>
&lt;li>AP：Application&lt;/li>
&lt;li>RM：Resource Manager&lt;/li>
&lt;li>TM：Transaction Manager&lt;/li>
&lt;/ul>
&lt;p>如果 TM 需要能够管理多个数据库的事务，则实现步骤如下：&lt;/p>
&lt;ul>
&lt;li>配置 TM，把多个 RM 注册到 TM，相当于 TM 注册 RM 作为数据源。&lt;/li>
&lt;li>AP 从 TM 管理的 RM 中获取连接，如果 RM 是数据库则获取 JDBC 连接。&lt;/li>
&lt;li>AP 向 TM 发起一个全局事务，生成全局事务 ID（XID），XID 会通知各个 RM。&lt;/li>
&lt;li>AP 通过第二步获得的连接直接操作 RM 完成数据库操作。这时，AP 在每次操作会把 XID 传递给 RM。&lt;/li>
&lt;li>AP 结束全局事务，TM 会通知各个 RM 全局事务结束。&lt;/li>
&lt;li>根据各个 RM 的事务执行结果，执行提交或者回滚操作。&lt;/li>
&lt;/ul>
&lt;p>其中，TM 和多个 RM 之间的事务控制，是基于 XA 协议来完成的。目前 Oracle、MySQL、DB2 都实现了 XA 接口，因此都能作为 RM。&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210227233821400.webp"
alt="image-20210227233821400" width="auto" loading="lazy">
&lt;/figure>
&lt;h4 id="2-两阶段提交协议">
&lt;a href="#2-%e4%b8%a4%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a4%e5%8d%8f%e8%ae%ae" class="header-anchor">#&lt;/a>
2 两阶段提交协议
&lt;/h4>
&lt;p>第一阶段：事务的准备阶段&lt;/p>
&lt;p>第二阶段：事务的提交或回滚阶段&lt;/p>
&lt;p>这两个阶段都是由事务管理器发起的，流程如下：&lt;/p>
&lt;ul>
&lt;li>准备阶段：TM 通知 RM 准备分支事务，记录事务日志，并告知 TM 的准备结果。&lt;/li>
&lt;li>提交/回滚阶段：如果所有的 RM 在准备阶段都明确返回成功，TM 向所有 RM 发起提交指令完成数据的变更；反之，则 TM 向所有 RM 发送回滚指令。&lt;/li>
&lt;/ul>
&lt;p>然而，它并不是完美的，也有缺点：&lt;/p>
&lt;ul>
&lt;li>同步阻塞：所有 RM 都是事务阻塞型的，对于任何一次指令都必须要有明确的响应才能进行下一步，否则会处于阻塞状态。&lt;/li>
&lt;li>过于保守：任何一个节点失败都会导致数据回滚。&lt;/li>
&lt;li>TM 的单点故障：如果 TM 在第二阶段故障，则所有 RM 会一直处于锁定状态。&lt;/li>
&lt;li>“脑裂”导致数据不一致问题：在第二阶段中，TM 向所有 RM 发送 commit 请求后，发生局部网络异常导致只有一部分 RM 接受到 commit，剩余未收到请求的则没提交，导致数据出现不一致问题。&lt;/li>
&lt;/ul>
&lt;h4 id="3-三阶段提交协议">
&lt;a href="#3-%e4%b8%89%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a4%e5%8d%8f%e8%ae%ae" class="header-anchor">#&lt;/a>
3 三阶段提交协议
&lt;/h4>
&lt;p>利用超时机制解决了同步阻塞的问题&lt;/p>
&lt;ul>
&lt;li>CanCommit（询问阶段）：TM 向 RM 发送事务执行请求，询问是否可以完成指令，参与者只需回答是或者不是即可，不需要做真正的事务操作，这个阶段会有超时中止机制。&lt;/li>
&lt;li>PreCommit（准备阶段）：TM 根据 RM 的反馈结果决定是否继续，如果在询问阶段所有 RM 都能执行操作，则 TM 向所有 RM 发送 PreCommit 请求，RM 收到请求后写 redo 和 undo 日志，执行事务操作但是不提交事务，然后返回 ACK 响应等待 TM 的下一步通知。如果询问阶段任意参与者返回不能执行操作的结果，则 TM 发送事务中断请求。&lt;/li>
&lt;li>DoCommit（提交或回滚阶段）：根据上一步骤的执行结果，如果每个 RM 都返回成功，则 TM 发送事务提交指令，反之则中止。&lt;/li>
&lt;/ul>
&lt;p>三阶段提交协议与二阶段提交协议的区别&lt;/p>
&lt;ul>
&lt;li>增加了一个 CanCommit 阶段，可以尽早发现无法执行操作而中止后续的行为。&lt;/li>
&lt;li>在准备阶段之后，TM 和 RM 都引入超时机制，一旦超时，TM 和 RM 会继续提交事务，并且认为处于成功状态，因为这种情况下事务默认为成功的可能性比较大。&lt;/li>
&lt;/ul>
&lt;p>实际上，一旦超时，在三阶段提交协议下仍然可能出现数据不一致的问题，当然概率是比较小的。另外，最大的好处是基于超时机制来避免资源的永久锁定。&lt;/p>
&lt;h4 id="4-cap-定理和-base-理论">
&lt;a href="#4-cap-%e5%ae%9a%e7%90%86%e5%92%8c-base-%e7%90%86%e8%ae%ba" class="header-anchor">#&lt;/a>
4 CAP 定理和 BASE 理论
&lt;/h4>
&lt;p>XA 协议：二阶段提交和三阶段提交，数据一致性强，但可用性低。&lt;/p>
&lt;p>CAP 定理：布鲁尔定理，指在分布式系统中不可能同时满足一致性 C、可用性 A、分区容错性 P，最多同时满足两个。&lt;/p>
&lt;ul>
&lt;li>C：数据在多个副本中要保持强一致&lt;/li>
&lt;li>A：系统对外提供的服务必须一直处于可用状态。&lt;/li>
&lt;li>P：在分布式系统中遇到任何网络分区故障，系统仍然能够正常对外提供服务。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>在分布式系统中，要么满足 CP，要么满足 AP，不可能实现 CAP 或者 CA，因为网络通信不是绝对可靠的。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>AP：放弃强一致性，实现最终的一致。（很多互联网公司的主要选择）&lt;/li>
&lt;li>CP：放弃高可用性，实现强一致性。（2PC 和 3PC，存在问题：用户完成一个操作可能会等待较长的时间，用户体验差）&lt;/li>
&lt;/ul>
&lt;p>BASE 理论：由于 CAP 中 CA 不可兼得衍生出来的一种新的思想。核心思想是：牺牲数据的强一致性来获得高可用性，有三个特性：&lt;/p>
&lt;ul>
&lt;li>Basically Avaliable（基本可用）：分布式系统出现故障时，允许损失一部分功能的可用性，保证核心功能的可用。&lt;/li>
&lt;li>Soft State（软状态）：允许系统中的数据存在中间状态，这个状态不影响系统的可用性，也就是允许系统中不同节点的数据副本之间的同步存在延时。&lt;/li>
&lt;li>Eventually Consistent（最终一致性）：中间状态的数据在经过一段时间之后，会达到一个最终的数据一致性。&lt;/li>
&lt;/ul>
&lt;h3 id="2-分布式事务问题的常见解决方案">
&lt;a href="#2-%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1%e9%97%ae%e9%a2%98%e7%9a%84%e5%b8%b8%e8%a7%81%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" class="header-anchor">#&lt;/a>
2 分布式事务问题的常见解决方案
&lt;/h3>
&lt;h4 id="1-tcc-补偿性方案">
&lt;a href="#1-tcc-%e8%a1%a5%e5%81%bf%e6%80%a7%e6%96%b9%e6%a1%88" class="header-anchor">#&lt;/a>
1 TCC 补偿性方案
&lt;/h4>
&lt;p>TCC（Try-Confirm-Cancel）是一种比较成熟的分布式数据一致性解决方案，它实际上是把一个完整的业务拆分为如下三个步骤&lt;/p>
&lt;ul>
&lt;li>Try：这个阶段主要是对数据的校验或者资源的预留。&lt;/li>
&lt;li>Confirm：确定真正执行的任务，只操作 Try 阶段预留的资源。&lt;/li>
&lt;li>Cancel：取消执行，释放 Try 阶段预留的资源。&lt;/li>
&lt;/ul>
&lt;p>本质：二阶段提交的思想，第一阶段通过 Try 准备，第二阶段通过 Confirm/Cancel&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210228000708843.webp"
alt="image-20210228000708843" width="auto" loading="lazy">
&lt;/figure>
&lt;h4 id="2-基于可靠性消息的最终一致性方案">
&lt;a href="#2-%e5%9f%ba%e4%ba%8e%e5%8f%af%e9%9d%a0%e6%80%a7%e6%b6%88%e6%81%af%e7%9a%84%e6%9c%80%e7%bb%88%e4%b8%80%e8%87%b4%e6%80%a7%e6%96%b9%e6%a1%88" class="header-anchor">#&lt;/a>
2 &lt;strong>基于可靠性消息的最终一致性方案&lt;/strong>
&lt;/h4>
&lt;p>基于可靠性消息的最终一致性方案是互联网公司比较常用的分布式数据一致性解决方案，它主要利用消息中间件（Kafka、RocketMQ 或 RabbitMQ）的可靠性机制来实现数据一致性的投递。&lt;/p>
&lt;figure>&lt;img src="https://cloud.cuterwrite.fun/blog/image-20210228001428049.webp"
alt="image-20210228001428049" width="auto" loading="lazy">
&lt;/figure>
&lt;p>总结：消费者没有向消息中间件服务器发送确认之前，这个消息会被重复投递，确保消息的可靠性消费。&lt;/p>
&lt;h4 id="3-最大努力通知型">
&lt;a href="#3-%e6%9c%80%e5%a4%a7%e5%8a%aa%e5%8a%9b%e9%80%9a%e7%9f%a5%e5%9e%8b" class="header-anchor">#&lt;/a>
3 最大努力通知型
&lt;/h4>
&lt;p>与基于可靠性消息的最终一致性方案实现类似，是一种比较简单的柔性事务解决方案。&lt;/p>
&lt;p>&lt;strong>如果没有返回一个消息确认时，则不断进行重试，直到收到一个消息确认或者达到最大重试次数。&lt;/strong>&lt;/p>
&lt;h3 id="3-分布式事务框架-seata">
&lt;a href="#3-%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1%e6%a1%86%e6%9e%b6-seata" class="header-anchor">#&lt;/a>
3 分布式事务框架 Seata
&lt;/h3>
&lt;p>提供了 AT、TCC、Saga 和 XA 四种事务模式。&lt;/p>
&lt;h4 id="1-at-模式">
&lt;a href="#1-at-%e6%a8%a1%e5%bc%8f" class="header-anchor">#&lt;/a>
1 AT 模式
&lt;/h4>
&lt;p>Seata 最主推的分布式事务解决方案，基于 XA 演进而来，分为 TM、RM 和 TC，TC 作为 Seata 的服务器独立部署。&lt;/p>
&lt;h4 id="2-saga-模式">
&lt;a href="#2-saga-%e6%a8%a1%e5%bc%8f" class="header-anchor">#&lt;/a>
2 Saga 模式
&lt;/h4>
&lt;p>又称长事务解决方案，主要描述的是在没有 2PC 的情况下如何解决分布式事务问题。其核心思想是：把一个业务流程中的长事务拆分为多个本地短事务，业务流程中的每个参与者都提交真实提交给本地段事务，当其中一个参与者失败，则通过补偿机制补偿前面已经成功的参与者。&lt;/p>
&lt;p>两种补偿恢复方式：&lt;/p>
&lt;ul>
&lt;li>向后恢复：如果任一子事务失败，则撤销执行结果。&lt;/li>
&lt;li>向前恢复：不进行补偿，而是对失败的事务进行 redo，这种方式比较适合于事务必须要执行成功的场景。&lt;/li>
&lt;/ul>
&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>一阶段直接提交本地事务&lt;/li>
&lt;li>没有锁等待，性能较高&lt;/li>
&lt;li>在事件驱动的模式下，短事务可以异步执行。&lt;/li>
&lt;li>补偿机制的实现比较简单。&lt;/li>
&lt;/ul>
&lt;p>缺点：不提供原子性和隔离性支持&lt;/p>
&lt;p>协调模式：&lt;/p>
&lt;ul>
&lt;li>事件/编排式&lt;/li>
&lt;li>命令/协同式&lt;/li>
&lt;/ul></description></item></channel></rss>