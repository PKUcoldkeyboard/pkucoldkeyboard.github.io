<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Cuterwrite's Blog</title><link>https://cuterwrite.top/tags/java/</link><description>Recent content in Java on Cuterwrite's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>cuterwrite</copyright><lastBuildDate>Thu, 15 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cuterwrite.top/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring Cloud OAuth2 从零开始实现用户认证和单点登录</title><link>https://cuterwrite.top/p/oauth2-guide/</link><pubDate>Thu, 15 Jul 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/oauth2-guide/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/image.rglemef8w74.webp" alt="Featured image of post Spring Cloud OAuth2 从零开始实现用户认证和单点登录" />&lt;h1 id="spring-cloud-oauth2-从零开始实现用户认证和单点登录">Spring Cloud OAuth2 从零开始实现用户认证和单点登录&lt;/h1>
&lt;h2 id="oauth2-是什么">OAuth2 是什么&lt;/h2>
&lt;p>OAuth2 其实是一个关于授权的网络标准，它制定了设计思路和运行流程，利用这个标准我们其实是可以自己实现 OAuth2 的认证过程的。 spring-cloud-starter-oauth2 是 Spring Cloud 按照 OAuth2 的标准并结合 spring-security 封装好的一个具体实现。&lt;/p>
&lt;p>OAuth 2 有四种授权模式，分别是授权码模式（authorization code）、简化模式（implicit）、密码模式（resource owner password credentials）、客户端模式（client credentials），具体 OAuth2 是什么，可以参考这篇文章（&lt;a class="link" href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener" >http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
）。&lt;/p>
&lt;h2 id="oauth2-的使用场景">OAuth2 的使用场景&lt;/h2>
&lt;ul>
&lt;li>典型的 OAuth2 使用场景：微信登录、QQ 登录、微博登录、Google 帐号登录、Github 帐号登录等。第一次使用就无需注册，直接通过第三方平台授权登录即可，大大提高了使用效率。此外，服务不需要存储用户的密码，只需要存储认证平台返回的唯一 ID 和用户信息即可。&lt;/li>
&lt;li>不使用 OAuth2 的场景：用户需要先完成注册，然后用注册号的帐号密码或者用手机验证码登录。&lt;/li>
&lt;/ul>
&lt;h2 id="oauth2-实现统一认证功能">OAuth2 实现统一认证功能&lt;/h2>
&lt;h3 id="创建并配置认证服务端-auth-server">创建并配置认证服务端 auth-server&lt;/h3>
&lt;p>认证服务端负责验证帐号、密码、存储 Token、检查 Token、刷新 Token 等。&lt;/p>
&lt;h4 id="1引入需要的-maven-包">1、引入需要的 Maven 包&lt;/h4>
&lt;pre>&lt;code class="language-xml">&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;spring-boot-starter-oauth2&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code>&lt;/pre>
&lt;h4 id="2配置-bootstrapyml-和-nacos-配置">2、配置 bootstrap.yml 和 Nacos 配置&lt;/h4>
&lt;p>认证服务器采用 Nacos Config 方案，将配置放在 Nacos 注册中心上&lt;/p>
&lt;ul>
&lt;li>bootstrap.yml 配置&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-yaml">spring:
application:
name: auth-server
cloud:
nacos:
config:
prefix: auth-server-config
server-addr: xxxx
file-extension: yaml
group: refactored-spring-cloud
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>auth-server-config 配置&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-yaml">server:
port: 18003
spring:
datasource:
url: jdbc:mysql://xxxx:3306/spring?useUnicode=true&amp;amp;&amp;amp;characterEncoding=UTF-8&amp;amp;&amp;amp;serverTimezone=Asia/Shanghai
username: xxxx
password: xxxx
jpa:
show-sql: true
generate-ddl: true
database-platform: org.hibernate.dialect.MYSQL5InnoDBDialect
database: mysql
application:
name: auth-server
cloud:
nacos:
discovery:
server-addr: xxxx:8848
group: refactored-spring-cloud
inetutils:
ignored-interfaces: eth.*
preferred-networks: xxxx
redis:
host: xxxx
port: 6379
management:
endpoint:
health:
enabled: true
dubbo:
protocol:
name: dubbo
port: -1
registry:
address: spring-cloud://xxxx
consumer:
timeout: 3000
&lt;/code>&lt;/pre>
&lt;h4 id="3配置-spring-security">3、配置 Spring Security&lt;/h4>
&lt;pre>&lt;code class="language-java">public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
@Bean
public PasswordEncoder passwordEncoder() {
return new BCryptPasswordEncoder();
}
@Bean
@Override
public AuthenticationManager authenticationManager() throws Exception {
return super.authenticationManager();
}
/**
* 开放所有接口
*/
@Override
protected void configure(HttpSecurity http) throws Exception {
http.authorizeRequests()
.antMatchers(&amp;quot;/**&amp;quot;)
.permitAll();
}
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>PasswordEncoder：采用 BCrypt 加密算法&lt;/li>
&lt;li>AuthenticationManager：OAuth2 密码模式必须制定的授权管理，用默认的即可&lt;/li>
&lt;li>configure：配置拦截器，使用通配符开放所有接口访问权限&lt;/li>
&lt;/ul>
&lt;h4 id="4实现-userdetailsservice">4、实现 UserDetailsService&lt;/h4>
&lt;pre>&lt;code class="language-java">@Slf4j
@Commponent(value = &amp;quot;kiteUserDetailService&amp;quot;)
public class KiteUserDetailService implements UserDetailService {
@DubboReference
IUserService service;
@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
log.info(&amp;quot;username is: &amp;quot; + username);
// 查询用户
if (user == null) {
throw new UsernameNotFoundException(&amp;quot;The user is not found&amp;quot;);
} else {
// 查询角色
List&amp;lt;SysRole&amp;gt; roles = user.getRoles();
List&amp;lt;SimpleGrantedAuthority&amp;gt; authorities = new ArrayList&amp;lt;&amp;gt;();
for (SysRole role : roles) {
authorities.add(new SimpleGrantedAuthority(role.getRoleName()));
}
// 查询密码
String password = user.getPassword();
return new User(username, password, authorities);
}
}
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>loadUserByUsername：首先利用用户微服务接口通过 username 查询用户、角色以及密码，然后返回&lt;code>org.springframework.security.core.userdetails.User&lt;/code> 即可。&lt;/li>
&lt;/ul>
&lt;h4 id="5配置-oauth2">5、配置 OAuth2&lt;/h4>
&lt;pre>&lt;code class="language-java">@Configuration
@EnableAuthorizationServer
public class OAuth2Config extends AuthorizationServerConfigurerAdapter {
@Autowired
public PasswordEncoder passwordEncoder;
@Autowired
public UserDetailsService kiteUserDetailsService;
@Autowired
private TokenStore jwtTokenStore;
@Autowired
private JwtAccessTokenConverter jwtAccessTokenConverter;
@Autowired
private DataSource dataSource;
@Override
public void configure(final AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
// Redis token 方式
endpoints.authenticaionManager(authenticationManager)
.userDetailsService(kiteUserDetailsService)
.accessTokenConverter(jwtAccessTokenConverter)
.tokenStore(jwtTokenStore);
}
@Override
public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
JdbcClientDetailsServiceBuilder builder = clients.jdbc(dataSource);
builder.passwordEncoder(passwordEncoder);
}
@Override
public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
security.allowFromAuthenticationForClients();
security.checkTokenAccess(&amp;quot;isAuthenticated&amp;quot;);
security.tokenKeyAccess(&amp;quot;isAuthenticated&amp;quot;);
}
}
&lt;/code>&lt;/pre>
&lt;p>有三个 configure 方法的重写&lt;/p>
&lt;ul>
&lt;li>
&lt;p>AuthorizationServerEndpointConfigurer 参数的重写&lt;/p>
&lt;ul>
&lt;li>authenticationManager：用于支持 password 模式&lt;/li>
&lt;li>userDetailsService：设置用户验证服务&lt;/li>
&lt;li>tokenStore：制定 token 的存储方式&lt;/li>
&lt;li>accessTokenConverter：开启 json web token 模式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ClientDetailsServiceConfigure 参数的重写：采用数据库配置的方式，预先定义好 oauth2_client_details 表，如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>参数说明：&lt;/p>
&lt;ul>
&lt;li>clientId、client_secret：这两个参数对应请求端定义的 cleint-id 和 client-secret&lt;/li>
&lt;li>authorized_grant_types：包括 authorization_code（授权码模式）、password（密码模式）、implicit（隐式授权类型）、client_credentials、refresh_token 这五种中的一种或多种。&lt;/li>
&lt;li>access_token_validity：token 的有效期&lt;/li>
&lt;li>scopes：用来限定客户端访问的权限，只有在 scopes 定义内的，才可以正常换取 token。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-sql">create table oauth_client_details (
client_id VARCHAR(256) PRIMARY KEY,
resource_ids VARCHAR(256),
client_secret VARCHAR(256),
scope VARCHAR(256),
authorized_grant_types VARCHAR(256),
web_server_redirect_uri VARCHAR(256),
authorities VARCHAR(256),
access_token_validity INTEGER,
refresh_token_validity INTEGER,
additional_information VARCHAR(4096),
autoapprove VARCHAR(256)
);
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>AuthorizationServerSecurityConfigurer 参数的重写：限制客户端访问认证接口的权限&lt;/p>
&lt;ul>
&lt;li>allowFormAuthenticationForClients()：允许客户端访问 OAuth2 授权接口，否则返回 401&lt;/li>
&lt;li>checkTokenAccess ：允许已授权用户访问 checkToken 接口。&lt;/li>
&lt;li>tokenKeyAccess：允许已授权用户访问获取 token 接口。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="6配置-jwttokenstore">6、配置 JWTTokenStore&lt;/h4>
&lt;pre>&lt;code class="language-java">@Configuration
public class JWTTokenStore {
@Bean
public TokenStore jwtTokenStore() {
return new JwtTokenStore(jwtAccessTokenConverter());
}
@Bean
public JwtAccessTokenConverter jwtAccessTokenConverter() {
JwtAccessTokenConverter accessTokenConverter = new JwtAccessTokenConverter();
accessTokenConverter.setSigningKey(&amp;quot;dev&amp;quot;);
return accessTokenConverter;
}
}
&lt;/code>&lt;/pre>
&lt;h4 id="7启动-auth-server">7、启动 auth-server&lt;/h4>
&lt;p>现在已经可以访问 OAuth2 相关的 Restful 接口：&lt;/p>
&lt;ul>
&lt;li>POST /oauth/authorize 授权码模式认证授权接口&lt;/li>
&lt;li>GET/POST /oauth/token 获取 token 的接口&lt;/li>
&lt;li>POST /oauth/check_token 检查 token 合法性接口&lt;/li>
&lt;/ul></description></item><item><title>Java-Stream 常见用法</title><link>https://cuterwrite.top/p/java-stream/</link><pubDate>Tue, 11 May 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/java-stream/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/bridge-5621201_1920.6p53ez4buso0.webp" alt="Featured image of post Java-Stream 常见用法" />&lt;hr>
&lt;h1 id="stream-常见用法">Stream 常见用法&lt;/h1>
&lt;h2 id="1-stream-概述">1 Stream 概述&lt;/h2>
&lt;p>&lt;code>Stream&lt;/code> 将要处理的元素集合看作一种流，在流的过程中，借助&lt;code>Stream API&lt;/code> 对流中的元素进行操作，比如：筛选、排序、聚合等。&lt;/p>
&lt;p>&lt;code>Stream&lt;/code> 可以由数组或集合创建，对流的操作分为两种：&lt;/p>
&lt;ol>
&lt;li>中间操作，每次返回一个新的流，可以有多个。&lt;/li>
&lt;li>终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值。&lt;/li>
&lt;/ol>
&lt;p>另外，&lt;code>Stream&lt;/code> 有几个特性：&lt;/p>
&lt;ol>
&lt;li>stream 不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。&lt;/li>
&lt;li>stream 不会改变数据源，通常情况下会产生一个新的集合或一个值。&lt;/li>
&lt;li>stream 具有延迟执行特性，只有调用终端操作时，中间操作才会执行。&lt;/li>
&lt;/ol>
&lt;h2 id="2-stream-创建">2 Stream 创建&lt;/h2>
&lt;h3 id="21-collectionstream">2.1 Collection.stream()&lt;/h3>
&lt;pre>&lt;code class="language-java">List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
Stream&amp;lt;Integer&amp;gt; stream = list.stream();
//并行流
Stream&amp;lt;Integer&amp;gt; parallelStream = list.parallelStream();
&lt;/code>&lt;/pre>
&lt;h3 id="22-arraysstreamt-array">2.2 Arrays.stream(T[] array)&lt;/h3>
&lt;pre>&lt;code class="language-java">int[] array = new int[]{1, 2, 3, 4, 5};
IntStream stream = Arrays.stream(array)
&lt;/code>&lt;/pre>
&lt;h3 id="23-streamof--iterate--generate">2.3 Stream.of / iterate / generate&lt;/h3>
&lt;pre>&lt;code>Stream&amp;lt;Integer&amp;gt; stream = Stream.of(1, 2, 3, 4, 5, 6);
//创建从 0 开始，间距为 3 的 stream（个数为 4）
Stream&amp;lt;Integer&amp;gt; stream2 = Stream.iterate(0, x -&amp;gt; x + 3).limit(4);
&lt;/code>&lt;/pre>
&lt;h2 id="3-stream-使用">3 Stream 使用&lt;/h2>
&lt;h3 id="31-optional">3.1 Optional&lt;/h3>
&lt;p>&lt;code>Optional&lt;/code> 类是一个可以为&lt;code>null&lt;/code> 的容器对象。如果值存在则&lt;code>isPresent()&lt;/code>方法会返回&lt;code>true&lt;/code>，调用&lt;code>get()&lt;/code>方法会返回该对象。&lt;/p>
&lt;h3 id="32-遍历-foreachfindmatch">3.2 遍历 forEach/find/match&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>遍历输出符合条件的元素&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().filter(x -&amp;gt; x &amp;gt; 6).forEach(System.out::println);
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>遍历对元素执行某个方法&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().forEach(methodName);
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>匹配一个&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().filter(x -&amp;gt; x &amp;gt; 6).findFirst();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>是否包含特定条件的元素&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().anyMatch(x -&amp;gt; x &amp;lt; 6);
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>所有元素满足条件&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().allMatch(x -&amp;gt; x == 1);
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h3 id="33-筛选-filter">3.3 筛选 filter&lt;/h3>
&lt;p>同上，直接在 stream 对象上使用就行&lt;/p>
&lt;h3 id="34-聚合-maxmincount">3.4 聚合 max/min/count&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>获取 int 数组中中的最大值&lt;/p>
&lt;pre>&lt;code class="language-java">Arrays.stream(array).max().getAsInt();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>获取 Integer 列表中的最大值，需要传入一个 Comparator 对象&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().max(Integer::compareTo).get();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>获取 String 列里中长度最长的元素&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().max(Comparator.comparing(String::length)).get();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>获取员工列表工资最高的员工&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().max(Comparator.comparing(Person::getSalary)).get();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>计算 Integer 集合中大于 6 的元素的个数&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().filter(x -&amp;gt; x &amp;gt; 6).count();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h3 id="35-映射-mapflatmap">3.5 映射 map/flatMap&lt;/h3>
&lt;p>映射，可以将一个流的元素按照一定的映射规则映射到另一个流中。分为&lt;code>map&lt;/code> 和&lt;code>flatMap&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>&lt;code>map&lt;/code>：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。&lt;/li>
&lt;li>&lt;code>flatMap&lt;/code>：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ul>
&lt;li>
&lt;p>将字符串数组的元素全部改成大写&lt;/p>
&lt;pre>&lt;code class="language-java">Arrays.stream(array).map(String::toUpperCase).collect(Collectors.toList());
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>将员工薪资全部增加 1000&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().map(person -&amp;gt; {
person.setSalary(person.getSalary() + 1000);
return person;
}).collect(Collectors.toList());
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h3 id="36-规约-reduce">3.6 规约 reduce&lt;/h3>
&lt;p>将一个流缩减为一个值，能实现集合求和，求乘积和求最值操作等。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>求 Integer 列表的元素之和，乘积和最大值&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().reduce(Integer::sum).get();
list.stream().reduce((x,y) -&amp;gt; x + y).get();
list.stream().reduce((x,y) -&amp;gt; x * y).get();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h3 id="37-收集-collect">3.7 收集 collect&lt;/h3>
&lt;p>就是把一个流收集起来，最终可以是收集成一个值也可以收集成一个新的集合。&lt;/p>
&lt;p>&lt;code>collect&lt;/code> 主要依赖&lt;code>java.util.stream.Collectors&lt;/code> 类内置的静态方法。&lt;/p>
&lt;ul>
&lt;li>归集：toList()，toSet()，toMap()&lt;/li>
&lt;li>统计：counting、averagingInt、averagingLong、averagingDouble、maxBy、minBy、summingInt、summingLong、summingDouble、sumarizingInt、sumarizingLong、sumarizingDouble&lt;/li>
&lt;/ul>
&lt;h3 id="38-分组-groupingbypartitioningby">3.8 分组 groupingBy/partitioningBy&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>将员工按薪资是否高于 8000 分组&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().collect(Collectors.groupingBy(x -&amp;gt; x.getSalary() &amp;gt; 8000))
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>将员工按性别分组&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().collect(Collectors.groupingBy(Person::getSex));
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h3 id="39-连接-joining">3.9 连接 joining&lt;/h3>
&lt;p>将 stream 中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().collect(Collectors.joining(&amp;quot;,&amp;quot;));
&lt;/code>&lt;/pre>
&lt;h3 id="310-排序-sorted">3.10 排序 sorted&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>按工资升序排序&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().sorted(Compartor.comparing(Person::getSalary));
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>按工资倒序排序&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().sorted(Compartor.comparing(Person::getSalary)).reversed();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>多列排序&lt;/p>
&lt;pre>&lt;code class="language-java">list.stream().sorted(Compartor.comparing(Person::getSalary).thenComparing(Person::getAge));
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul></description></item><item><title>Java 并发知识点笔记</title><link>https://cuterwrite.top/p/java-concurrent/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/java-concurrent/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/santorini-1578440_1920.3ldusy6rm1k0.webp" alt="Featured image of post Java 并发知识点笔记" />&lt;h1 id="java-并发知识点笔记">Java 并发知识点笔记&lt;/h1>
&lt;h2 id="1-使用线程的方法">1 使用线程的方法&lt;/h2>
&lt;ul>
&lt;li>实现 Runnable 接口；&lt;/li>
&lt;li>实现 Callable 接口；&lt;/li>
&lt;li>继承 Thread 类。&lt;/li>
&lt;/ul>
&lt;h2 id="2-基础线程机制">2 基础线程机制&lt;/h2>
&lt;h3 id="21-executor">2.1 Executor&lt;/h3>
&lt;p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。&lt;/p>
&lt;p>主要有三种 Executor：&lt;/p>
&lt;ul>
&lt;li>CachedThreadPool：一个任务创建一个线程；&lt;/li>
&lt;li>FixedThreadPool：所有任务只能使用固定大小的线程；&lt;/li>
&lt;li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。&lt;/li>
&lt;/ul>
&lt;h3 id="22-daemon">2.2 Daemon&lt;/h3>
&lt;p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。&lt;/p>
&lt;p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。&lt;/p>
&lt;p>main() 属于非守护线程。&lt;/p>
&lt;p>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。&lt;/p>
&lt;h3 id="23-sleep">2.3 sleep()&lt;/h3>
&lt;p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。&lt;/p>
&lt;p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。&lt;/p>
&lt;h3 id="24-yield">2.4 yield()&lt;/h3>
&lt;p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。&lt;/p>
&lt;h2 id="3-线程中断">3 线程中断&lt;/h2>
&lt;p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。&lt;/p>
&lt;h3 id="31-interruptedexception">3.1 InterruptedException&lt;/h3>
&lt;p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。&lt;/p>
&lt;h3 id="32-interrupted">3.2 interrupted()&lt;/h3>
&lt;p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。&lt;/p>
&lt;p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。&lt;/p>
&lt;h3 id="33-executor-的中断操作">3.3 Executor 的中断操作&lt;/h3>
&lt;p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。&lt;/p>
&lt;h2 id="4-互斥锁">4 互斥锁&lt;/h2>
&lt;p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。&lt;/p>
&lt;h3 id="41-synchronized">4.1 synchronized&lt;/h3>
&lt;ul>
&lt;li>同步代码块：锁对象&lt;/li>
&lt;li>同步一个方法：锁对象&lt;/li>
&lt;li>同步一个类：锁整个类&lt;/li>
&lt;li>同步一个静态方法：锁整个类&lt;/li>
&lt;/ul>
&lt;h3 id="42-reentrantlock">4.2 ReentrantLock&lt;/h3>
&lt;p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。&lt;/p>
&lt;p>通过 lock 和 unlock 操作&lt;/p>
&lt;h3 id="43-比较">4.3 比较&lt;/h3>
&lt;p>&lt;strong>1. 锁的实现&lt;/strong>&lt;/p>
&lt;p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。&lt;/p>
&lt;p>&lt;strong>2. 性能&lt;/strong>&lt;/p>
&lt;p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。&lt;/p>
&lt;p>&lt;strong>3. 等待可中断&lt;/strong>&lt;/p>
&lt;p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。&lt;/p>
&lt;p>ReentrantLock 可中断，而 synchronized 不行。&lt;/p>
&lt;p>&lt;strong>4. 公平锁&lt;/strong>&lt;/p>
&lt;p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。&lt;/p>
&lt;p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。&lt;/p>
&lt;p>&lt;strong>5. 锁绑定多个条件&lt;/strong>&lt;/p>
&lt;p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。&lt;/p>
&lt;h3 id="44-选择">4.4 选择&lt;/h3>
&lt;p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。&lt;/p>
&lt;h2 id="5-线程协作">5 线程协作&lt;/h2>
&lt;h3 id="51-join">5.1 join&lt;/h3>
&lt;p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。&lt;/p>
&lt;h3 id="52-waitnotify">5.2 wait/notify&lt;/h3>
&lt;p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。&lt;/p>
&lt;p>它们都属于 Object 的一部分，而不属于 Thread。&lt;/p>
&lt;p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。&lt;/p>
&lt;p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁&lt;/p>
&lt;p>&lt;strong>wait() 和 sleep() 的区别&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；&lt;/li>
&lt;li>wait() 会释放锁，sleep() 不会。&lt;/li>
&lt;/ul>
&lt;h3 id="53-awaitsignal">5.3 await/signal&lt;/h3>
&lt;p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。&lt;/p>
&lt;p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。&lt;/p>
&lt;p>使用 Lock 来获取一个 Condition 对象。&lt;/p>
&lt;h2 id="6-线程状态">6 线程状态&lt;/h2>
&lt;ul>
&lt;li>new&lt;/li>
&lt;li>runable&lt;/li>
&lt;li>blocked&lt;/li>
&lt;li>waiting&lt;/li>
&lt;li>timed_waiting&lt;/li>
&lt;li>terminated&lt;/li>
&lt;/ul>
&lt;h2 id="7-juc-包aqs">7 JUC 包/AQS&lt;/h2>
&lt;h3 id="71-countdownlatch">7.1 CountDownLatch&lt;/h3>
&lt;p>用来控制一个或者多个线程等待多个线程。&lt;/p>
&lt;p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="72-cyclicbarrier">7.2 CyclicBarrier&lt;/h3>
&lt;p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。&lt;/p>
&lt;p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。&lt;/p>
&lt;p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。&lt;/p>
&lt;p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png" width="90%" loading="lazy"/>
&lt;/figure>
&lt;h3 id="73-semaphore">7.3 Semaphore&lt;/h3>
&lt;p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。&lt;/p>
&lt;h2 id="8-juc-包其它组件">8 JUC 包其它组件&lt;/h2>
&lt;h3 id="81-futuretask">8.1 FutureTask&lt;/h3>
&lt;p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future&amp;lt;V&amp;gt; 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future&amp;lt;V&amp;gt; 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。&lt;/p>
&lt;p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。&lt;/p>
&lt;h3 id="82-blockingqueue">8.2 BlockingQueue&lt;/h3>
&lt;p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>FIFO 队列&lt;/strong> ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）&lt;/li>
&lt;li>&lt;strong>优先级队列&lt;/strong> ：PriorityBlockingQueue&lt;/li>
&lt;/ul>
&lt;p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。&lt;/p>
&lt;h3 id="83-forkjoin">8.3 ForkJoin&lt;/h3>
&lt;p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。&lt;/p>
&lt;p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。&lt;/p>
&lt;h2 id="9-内存模型">9 内存模型&lt;/h2>
&lt;p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。&lt;/p>
&lt;h3 id="91-主内存与工作内存">9.1 主内存与工作内存&lt;/h3>
&lt;p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。&lt;/p>
&lt;p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942ca0d2-9d5c-45a4-89cb-5fd89b61913f.png" width="90%" loading="lazy"/>
&lt;/figure>
&lt;p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。&lt;/p>
&lt;p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15851555-5abc-497d-ad34-efed10f43a6b.png" width="90%" loading="lazy"/>
&lt;/figure>
&lt;h3 id="92-内存间交互操作">9.2 内存间交互操作&lt;/h3>
&lt;p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8b7ebbad-9604-4375-84e3-f412099d170c.png" width="90%" loading="lazy"/>
&lt;/figure>
&lt;ul>
&lt;li>read：把一个变量的值从主内存传输到工作内存中&lt;/li>
&lt;li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中&lt;/li>
&lt;li>use：把工作内存中一个变量的值传递给执行引擎&lt;/li>
&lt;li>assign：把一个从执行引擎接收到的值赋给工作内存的变量&lt;/li>
&lt;li>store：把工作内存的一个变量的值传送到主内存中&lt;/li>
&lt;li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中&lt;/li>
&lt;li>lock：作用于主内存的变量&lt;/li>
&lt;li>unlock&lt;/li>
&lt;/ul>
&lt;h3 id="93-内存模型三大特性">9.3 内存模型三大特性&lt;/h3>
&lt;h4 id="931-原子性">9.3.1. 原子性&lt;/h4>
&lt;p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。&lt;/p>
&lt;p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。&lt;/p>
&lt;p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。&lt;/p>
&lt;p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2797a609-68db-4d7b-8701-41ac9a34b14f.jpg" width="90%" loading="lazy"/>
&lt;/figure>
&lt;p>AtomicInteger 能保证多个线程修改的原子性。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dd563037-fcaa-4bd8-83b6-b39d93a12c77.jpg" width="90%" loading="lazy"/>
&lt;/figure>
&lt;p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。&lt;/p>
&lt;h4 id="932-可见性">9.3.2. 可见性&lt;/h4>
&lt;p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。&lt;/p>
&lt;p>主要有三种实现可见性的方式：&lt;/p>
&lt;ul>
&lt;li>volatile&lt;/li>
&lt;li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。&lt;/li>
&lt;li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。&lt;/li>
&lt;/ul>
&lt;p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。&lt;/p>
&lt;h4 id="933-有序性">9.3.3. 有序性&lt;/h4>
&lt;p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。&lt;/p>
&lt;p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。&lt;/p>
&lt;p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。&lt;/p>
&lt;h3 id="94-先行发生原则">9.4 先行发生原则&lt;/h3>
&lt;p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。&lt;/p>
&lt;ol>
&lt;li>单一线程原则：在一个线程内，在程序前面的操作先行发生于后面的操作。&lt;/li>
&lt;li>管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。&lt;/li>
&lt;li>volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。&lt;/li>
&lt;li>线程启动规则：Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。&lt;/li>
&lt;li>线程加入规则：Thread 对象的结束先行发生于 join() 方法返回。&lt;/li>
&lt;li>线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。&lt;/li>
&lt;li>对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。&lt;/li>
&lt;li>传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。&lt;/li>
&lt;/ol>
&lt;h2 id="10-线程安全策略">10 线程安全策略&lt;/h2>
&lt;h3 id="101-不可变">10.1 不可变&lt;/h3>
&lt;p>不可变的类型：&lt;/p>
&lt;ul>
&lt;li>final 关键字修饰的基本数据类型&lt;/li>
&lt;li>String&lt;/li>
&lt;li>枚举类型&lt;/li>
&lt;li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。&lt;/li>
&lt;/ul>
&lt;p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。&lt;/p>
&lt;h3 id="102-互斥同步">10.2 互斥同步&lt;/h3>
&lt;p>synchronized 和 ReentrantLock。&lt;/p>
&lt;h3 id="103-非阻塞同步">10.3 非阻塞同步&lt;/h3>
&lt;ul>
&lt;li>CAS&lt;/li>
&lt;li>AtomicInteger&lt;/li>
&lt;/ul>
&lt;p>ABA 问题：如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。&lt;/p>
&lt;p>解决方法：J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。&lt;/p>
&lt;h3 id="104-无同步">10.4 无同步&lt;/h3>
&lt;h4 id="1041-栈封闭">10.4.1 栈封闭&lt;/h4>
&lt;p>多个线程访问同一个方法的&lt;strong>局部变量&lt;/strong>时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。&lt;/p>
&lt;h4 id="1042-线程本地存储">10.4.2 线程本地存储&lt;/h4>
&lt;p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围&lt;strong>限制在同一个线程之内&lt;/strong>，这样，无须同步也能保证线程之间不出现数据争用的问题。&lt;/p>
&lt;p>它提供了线程本地变量，也就是如果你创建了一个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作的自己本地内存里面的变量，从而避免了线程安全问题&lt;/p>
&lt;p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。&lt;/p>
&lt;p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&amp;gt;value 键值对插入到该 Map 中。&lt;/p>
&lt;h4 id="1043-可重入代码">10.4.3 可重入代码&lt;/h4>
&lt;p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。&lt;/p>
&lt;p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。&lt;/p>
&lt;h2 id="11-锁优化">11 锁优化&lt;/h2>
&lt;h3 id="111-自旋锁">11.1 自旋锁&lt;/h3>
&lt;p>自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。&lt;/p>
&lt;p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于&lt;strong>共享数据的锁定状态很短&lt;/strong>的场景。&lt;/p>
&lt;p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。&lt;/p>
&lt;h3 id="112-锁消除">11.2 锁消除&lt;/h3>
&lt;p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。&lt;/p>
&lt;p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。&lt;/p>
&lt;h3 id="113-锁粗化">11.3 锁粗化&lt;/h3>
&lt;p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。&lt;/p>
&lt;p>如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。&lt;/p>
&lt;h3 id="114-轻量级锁">11.4 轻量级锁&lt;/h3>
&lt;p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。&lt;/p>
&lt;p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。&lt;/p>
&lt;h3 id="115-偏向锁">11.5 偏向锁&lt;/h3>
&lt;p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。&lt;/p>
&lt;hr>
&lt;p>本文转载自：&lt;a class="link" href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener" >https://github.com/CyC2018/CS-Notes
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
，用于个人复习。&lt;/p></description></item><item><title>Java 容器知识点笔记</title><link>https://cuterwrite.top/p/java-collection/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/java-collection/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/antarctica-1987579_1920.4sf6q29twew0.webp" alt="Featured image of post Java 容器知识点笔记" />&lt;h1 id="java-容器知识点笔记">Java 容器知识点笔记&lt;/h1>
&lt;h2 id="1-概述">1 概述&lt;/h2>
&lt;p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。&lt;/p>
&lt;h3 id="11-collection">1.1 Collection&lt;/h3>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208220948084.png" width="90%" loading="lazy"/>
&lt;/figure>
&lt;h4 id="111-set">1.1.1 Set&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="112-list">1.1.2 List&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>ArrayList：基于动态数组实现，支持随机访问。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Vector：和 ArrayList 类似，但它是线程安全的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="113-queue">1.1.3 Queue&lt;/h4>
&lt;ul>
&lt;li>LinkedList：可以用它来实现双向队列。&lt;/li>
&lt;li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。&lt;/li>
&lt;/ul>
&lt;h2 id="2-源码分析">2 源码分析&lt;/h2>
&lt;h3 id="21-arraylist">2.1 ArrayList&lt;/h3>
&lt;h4 id="211-概述">2.1.1 概述&lt;/h4>
&lt;p>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问，默认容量为 10&lt;/p>
&lt;pre>&lt;code class="language-java">transient Object[] elementData;
private static final int DEFAULT_CAPACITY = 10;
&lt;/code>&lt;/pre>
&lt;h4 id="212-扩容">2.1.2 扩容&lt;/h4>
&lt;p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 &lt;code>oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1)&lt;/code>，即 oldCapacity+oldCapacity/2。其中 oldCapacity &amp;raquo; 1 需要取整，所以新容量大约是旧容量的 1.5 倍左右。（oldCapacity 为偶数就是 1.5 倍，为奇数就是 1.5 倍-0.5）&lt;/p>
&lt;p>扩容操作需要调用 &lt;code>Arrays.copyOf()&lt;/code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。&lt;/p>
&lt;h4 id="213-删除元素">2.1.3 删除元素&lt;/h4>
&lt;p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。&lt;/p>
&lt;h4 id="214-序列化">2.1.4 序列化&lt;/h4>
&lt;p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。&lt;/p>
&lt;p>保存元素的数组 elementData 使用 &lt;strong>transient&lt;/strong> 修饰，该关键字声明数组默认不会被序列化。&lt;/p>
&lt;p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。&lt;/p>
&lt;p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。&lt;/p>
&lt;h4 id="215-fail-fast">2.1.5 Fail-fast&lt;/h4>
&lt;p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。&lt;/p>
&lt;p>在进行序列化或者迭代等操作时，&lt;strong>需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException&lt;/strong>。代码参考上节序列化中的 writeObject() 方法。&lt;/p>
&lt;h3 id="22-vector">2.2 Vector&lt;/h3>
&lt;h4 id="221-同步">2.2.1 同步&lt;/h4>
&lt;p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。&lt;/p>
&lt;h4 id="222-扩容">2.2.2 扩容&lt;/h4>
&lt;p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。&lt;/p>
&lt;p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。&lt;/p>
&lt;h4 id="223-与-arraylist-的比较">2.2.3 与 ArrayList 的比较&lt;/h4>
&lt;ul>
&lt;li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；&lt;/li>
&lt;li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。&lt;/li>
&lt;/ul>
&lt;h4 id="224-替代方案">2.2.4 替代方案&lt;/h4>
&lt;p>可以使用 &lt;code>Collections.synchronizedList();&lt;/code> 得到一个线程安全的 ArrayList。&lt;/p>
&lt;p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。&lt;/p>
&lt;h3 id="23-copyonwritearraylist">2.3 CopyOnWriteArrayList&lt;/h3>
&lt;h4 id="231-读写分离">2.3.1 读写分离&lt;/h4>
&lt;p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。&lt;/p>
&lt;p>写操作需要加锁，防止并发写入时导致写入数据丢失。&lt;/p>
&lt;p>写操作结束之后需要把原始数组指向新的复制数组。&lt;/p>
&lt;h4 id="232-适用场景">2.3.2 适用场景&lt;/h4>
&lt;p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。&lt;/p>
&lt;p>但是 CopyOnWriteArrayList 有其缺陷：&lt;/p>
&lt;ul>
&lt;li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；&lt;/li>
&lt;li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。&lt;/li>
&lt;/ul>
&lt;p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。&lt;/p>
&lt;h3 id="24-linkedlist">2.4 LinkedList&lt;/h3>
&lt;h4 id="241-概述">2.4.1 概述&lt;/h4>
&lt;p>基于双向链表实现，使用 Node 存储链表节点信息。&lt;/p>
&lt;pre>&lt;code class="language-java">private static class Node&amp;lt;E&amp;gt; {
E item;
Node&amp;lt;E&amp;gt; next;
Node&amp;lt;E&amp;gt; prev;
}
&lt;/code>&lt;/pre>
&lt;p>每个链表存储了 first 和 last 指针：&lt;/p>
&lt;pre>&lt;code class="language-java">transient Node&amp;lt;E&amp;gt; first;
transient Node&amp;lt;E&amp;gt; last;
&lt;/code>&lt;/pre>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208233940066.png" width="90%" loading="lazy"/>
&lt;/figure>
&lt;h4 id="242-与-arraylist-的比较">2.4.2 与 ArrayList 的比较&lt;/h4>
&lt;p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：&lt;/p>
&lt;ul>
&lt;li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素；&lt;/li>
&lt;li>链表不支持随机访问，但插入删除只需要改变指针。&lt;/li>
&lt;/ul>
&lt;h3 id="25-hashmap">2.5 HashMap&lt;/h3>
&lt;h4 id="251-概述">2.5.1 概述&lt;/h4>
&lt;ul>
&lt;li>基于数组+链表+红黑树实现&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java">transient Node&amp;lt;K,V&amp;gt;[] table;
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>默认容量 16，每次扩容为 2 倍&lt;/li>
&lt;li>默认负载因子为 0.75&lt;/li>
&lt;li>当链表长度大于等于 8 时，检查 table 长度是否大于 64，如果是则转成红黑树。&lt;/li>
&lt;li>基本原理：通过 key 的 hashcode 经过扰动处理得到 hash 值，然后通过(n - 1) &amp;amp; hash 判断当前元素存放的位置，如果当前位置存在元素的话，就判断该元素与要存放的元素的 hash 值以及 key 是否相同，如果相同则直接覆盖，不相同就用拉链法解决冲突。&lt;/li>
&lt;/ul>
&lt;h4 id="252-拉链法">2.5.2 拉链法&lt;/h4>
&lt;p>将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。&lt;/p>
&lt;h4 id="253-确认桶下标方法">2.5.3 确认桶下标方法&lt;/h4>
&lt;ol>
&lt;li>计算 key 的 hash（h = key.hashcode(); h ^ (h &amp;raquo;&amp;gt; 16)）&lt;/li>
&lt;li>hash &amp;amp; (n - 1)&lt;/li>
&lt;/ol>
&lt;h4 id="254-扩容基本原理">2.5.4 扩容基本原理&lt;/h4>
&lt;p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。&lt;/p>
&lt;p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。&lt;/p>
&lt;p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。&lt;/p>
&lt;h4 id="255-扩容重新计算桶下标">2.5.5 扩容重新计算桶下标&lt;/h4>
&lt;p>在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，HashMap 使用 hash%capacity 来确定桶下标。HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。&lt;/p>
&lt;h4 id="256-与-hashtable-对比">2.5.6 与 HashTable 对比&lt;/h4>
&lt;ul>
&lt;li>Hashtable 使用 synchronized 来进行同步。&lt;/li>
&lt;li>HashMap 可以插入键为 null 的 Entry。&lt;/li>
&lt;li>HashMap 的迭代器是 fail-fast 迭代器。&lt;/li>
&lt;li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。&lt;/li>
&lt;/ul>
&lt;h3 id="26-concurrenthashmap">2.6 ConcurrentHashMap&lt;/h3>
&lt;h4 id="261-存储结构">2.6.1 存储结构&lt;/h4>
&lt;p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。&lt;/p>
&lt;p>Segment 继承自 ReentrantLock。&lt;/p>
&lt;p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。&lt;/p>
&lt;h4 id="262-size-操作">2.6.2 size 操作&lt;/h4>
&lt;p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。&lt;/p>
&lt;p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。&lt;/p>
&lt;p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。&lt;/p>
&lt;p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。&lt;/p>
&lt;p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。&lt;/p>
&lt;h4 id="263-jdk8-的改动">2.6.3 jdk8 的改动&lt;/h4>
&lt;p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。&lt;/p>
&lt;p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。&lt;/p>
&lt;p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。&lt;/p>
&lt;h3 id="27-linkedhashmap">2.7 LinkedHashMap&lt;/h3>
&lt;h4 id="271-存储结构">2.7.1 存储结构&lt;/h4>
&lt;p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。&lt;/p>
&lt;p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。&lt;/p>
&lt;pre>&lt;code class="language-java">transient LinkedHashMap.Entry&amp;lt;K,V&amp;gt; head;
transient LinkedHashMap.Entry&amp;lt;K,V&amp;gt; tail;
&lt;/code>&lt;/pre>
&lt;p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。&lt;/p>
&lt;pre>&lt;code class="language-java">final boolean accessOrder;
&lt;/code>&lt;/pre>
&lt;p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。&lt;/p>
&lt;pre>&lt;code class="language-java">void afterNodeAccess(Node&amp;lt;K,V&amp;gt; p) { }
void afterNodeInsertion(boolean evict) { }
&lt;/code>&lt;/pre>
&lt;h4 id="272-afternodeaccess">2.7.2 afterNodeAccess()&lt;/h4>
&lt;p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。&lt;/p>
&lt;h4 id="273-afternodeinsertion">2.7.3 afterNodeInsertion()&lt;/h4>
&lt;p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。&lt;/p>
&lt;p>evict 只有在构建 Map 的时候才为 false，在这里为 true。&lt;/p>
&lt;hr>
&lt;p>本文转载自：&lt;a class="link" href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener" >https://github.com/CyC2018/CS-Notes
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
，用于个人复习。&lt;/p></description></item><item><title>JavaSE 知识点笔记</title><link>https://cuterwrite.top/p/java-se/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/java-se/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/river-6021951_1920.4hwe8w8ugb20.webp" alt="Featured image of post JavaSE 知识点笔记" />&lt;h1 id="javase-知识点笔记">JavaSE 知识点笔记&lt;/h1>
&lt;h2 id="1-数据类型">1 数据类型&lt;/h2>
&lt;h3 id="11-基本类型">1.1 基本类型&lt;/h3>
&lt;ul>
&lt;li>byte/8&lt;/li>
&lt;li>char/16&lt;/li>
&lt;li>short/16&lt;/li>
&lt;li>int/32&lt;/li>
&lt;li>float/32&lt;/li>
&lt;li>long/64&lt;/li>
&lt;li>double/64&lt;/li>
&lt;li>boolean/~&lt;/li>
&lt;/ul>
&lt;h3 id="12-包装类型">1.2 包装类型&lt;/h3>
&lt;p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。&lt;/p>
&lt;pre>&lt;code class="language-java">Integer x = 2; // 装箱 调用了 Integer.valueOf(2)
int y = x; // 拆箱 调用了 X.intValue()
&lt;/code>&lt;/pre>
&lt;h3 id="13-缓存池">1.3 缓存池&lt;/h3>
&lt;p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：&lt;/p>
&lt;ul>
&lt;li>new Integer(123) 每次都会新建一个对象；&lt;/li>
&lt;li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。&lt;/li>
&lt;/ul>
&lt;p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。&lt;/p>
&lt;p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。&lt;/p>
&lt;p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。&lt;/p>
&lt;p>基本类型对应的缓冲池如下：&lt;/p>
&lt;ul>
&lt;li>boolean values true and false&lt;/li>
&lt;li>all byte values&lt;/li>
&lt;li>short values between -128 and 127&lt;/li>
&lt;li>int values between -128 and 127&lt;/li>
&lt;li>char in the range \u0000 to \u007F&lt;/li>
&lt;/ul>
&lt;h2 id="2-string">2 String&lt;/h2>
&lt;h3 id="21-概述">2.1 概述&lt;/h3>
&lt;p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）&lt;/p>
&lt;p>在 Java 8 中，String 内部使用 char 数组存储数据。&lt;/p>
&lt;pre>&lt;code class="language-java">private final char[] value;
&lt;/code>&lt;/pre>
&lt;p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 &lt;code>coder&lt;/code> 来标识使用了哪种编码。&lt;/p>
&lt;pre>&lt;code class="language-java">private final byte[] value;
private final byte coder;
&lt;/code>&lt;/pre>
&lt;p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。&lt;/p>
&lt;h3 id="22-不可变的优点">2.2 不可变的优点&lt;/h3>
&lt;h4 id="221-可以缓存-hash-值">2.2.1 可以缓存 hash 值&lt;/h4>
&lt;p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。&lt;/p>
&lt;h4 id="222-string-pool">2.2.2 String Pool&lt;/h4>
&lt;p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。&lt;/p>
&lt;h4 id="223-安全性">2.2.3 安全性&lt;/h4>
&lt;p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。&lt;/p>
&lt;h4 id="224-线程安全">2.2.4 线程安全&lt;/h4>
&lt;p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。&lt;/p>
&lt;h3 id="23-stringstringbuilder-和-stringbuffer">2.3 String、StringBuilder 和 StringBuffer&lt;/h3>
&lt;h4 id="231-可变性">2.3.1 可变性&lt;/h4>
&lt;ul>
&lt;li>String 不可变&lt;/li>
&lt;li>StringBuilder 和 StringBuffer 可变&lt;/li>
&lt;/ul>
&lt;h4 id="232-线程安全">2.3.2 线程安全&lt;/h4>
&lt;ul>
&lt;li>String 线程安全&lt;/li>
&lt;li>StringBuilder 线程不安全&lt;/li>
&lt;li>StringBuffer 线程安全：synchronized 机制&lt;/li>
&lt;/ul>
&lt;h3 id="24-string-pool">2.4 String Pool&lt;/h3>
&lt;p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。&lt;/p>
&lt;p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。&lt;/p>
&lt;p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。&lt;/p>
&lt;h3 id="25-new-stringabc">2.5 new String（“abc”）&lt;/h3>
&lt;p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 &amp;ldquo;abc&amp;rdquo; 字符串对象）。&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;abc&amp;rdquo; 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 &amp;ldquo;abc&amp;rdquo; 字符串字面量；&lt;/li>
&lt;li>而使用 new 的方式会在堆中创建一个字符串对象。&lt;/li>
&lt;/ul>
&lt;h2 id="3-运算">3 运算&lt;/h2>
&lt;h3 id="31-参数传递">3.1 参数传递&lt;/h3>
&lt;p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。&lt;/p>
&lt;h3 id="32-float-与-double">3.2 float 与 double&lt;/h3>
&lt;p>Java 不能隐式执行向下转型，因为这会使得精度降低。&lt;/p>
&lt;h3 id="33-隐式类型转换">3.3 隐式类型转换&lt;/h3>
&lt;p>使用+=和++运算符会执行隐式类型转换，相当于强制类型转换。&lt;/p>
&lt;p>（比如：int 转 short）&lt;/p>
&lt;h2 id="4-关键字">4 关键字&lt;/h2>
&lt;h3 id="41-final">4.1 final&lt;/h3>
&lt;p>（1）数据&lt;/p>
&lt;p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。&lt;/p>
&lt;ul>
&lt;li>对于基本类型，final 使数值不变；&lt;/li>
&lt;li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。&lt;/li>
&lt;/ul>
&lt;p>（2）方法&lt;/p>
&lt;p>声明方法不能被子类重写。&lt;/p>
&lt;p>&lt;strong>private 方法隐式地被指定为 final&lt;/strong>，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法&lt;strong>不是重写基类方法，而是在子类中定义了一个新的方法&lt;/strong>。&lt;/p>
&lt;p>（3）类&lt;/p>
&lt;p>声明类不允许被继承。&lt;/p>
&lt;h3 id="42--static">4.2 static&lt;/h3>
&lt;p>&lt;strong>1. 静态变量&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。&lt;/li>
&lt;li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2. 静态方法&lt;/strong>&lt;/p>
&lt;p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。&lt;/p>
&lt;p>&lt;strong>3. 静态语句块&lt;/strong>&lt;/p>
&lt;p>静态语句块在类初始化时运行一次。&lt;/p>
&lt;p>&lt;strong>4. 静态内部类&lt;/strong>&lt;/p>
&lt;p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。&lt;/p>
&lt;p>&lt;strong>5. 静态导包&lt;/strong>&lt;/p>
&lt;p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。&lt;/p>
&lt;p>&lt;strong>6. 初始化顺序&lt;/strong>&lt;/p>
&lt;p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。&lt;/p>
&lt;h2 id="5-object-通用方法">5 Object 通用方法&lt;/h2>
&lt;ul>
&lt;li>hashcode&lt;/li>
&lt;li>equals&lt;/li>
&lt;li>clone&lt;/li>
&lt;li>toString&lt;/li>
&lt;li>getClass&lt;/li>
&lt;li>finalize&lt;/li>
&lt;li>notify&lt;/li>
&lt;li>notifyAll&lt;/li>
&lt;li>wait&lt;/li>
&lt;/ul>
&lt;h2 id="6-继承">6 继承&lt;/h2>
&lt;h3 id="61-访问权限">6.1 访问权限&lt;/h3>
&lt;p>private、protected、public，以及 default（如果不加访问修饰符，表示包级可见。）&lt;/p>
&lt;p>可以对类或类中的成员（字段和方法）加上访问修饰符。&lt;/p>
&lt;ul>
&lt;li>类可见表示其它类可以用这个类创建实例对象。&lt;/li>
&lt;li>成员可见表示其它类可以用这个类的实例对象访问到该成员；&lt;/li>
&lt;/ul>
&lt;p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。&lt;/p>
&lt;h3 id="62-抽象类与接口">6.2 抽象类与接口&lt;/h3>
&lt;p>&lt;strong>1. 抽象类&lt;/strong>&lt;/p>
&lt;p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。&lt;/p>
&lt;p>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。&lt;/p>
&lt;p>&lt;strong>2. 接口&lt;/strong>&lt;/p>
&lt;p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。&lt;/p>
&lt;p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。&lt;/p>
&lt;p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。从 Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。&lt;/p>
&lt;p>接口的字段默认都是 static 和 final 的。&lt;/p>
&lt;h3 id="63-super">6.3 super&lt;/h3>
&lt;ul>
&lt;li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。&lt;/li>
&lt;li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。&lt;/li>
&lt;/ul>
&lt;h3 id="64-重写与重载">6.4 重写与重载&lt;/h3>
&lt;p>&lt;strong>1. 重写（Override）&lt;/strong>&lt;/p>
&lt;p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。&lt;/p>
&lt;p>为了满足里式替换原则，重写有以下三个限制：&lt;/p>
&lt;ul>
&lt;li>子类方法的访问权限必须大于等于父类方法；&lt;/li>
&lt;li>子类方法的返回类型必须是父类方法返回类型或为其子类型。&lt;/li>
&lt;li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。&lt;/li>
&lt;/ul>
&lt;p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。&lt;/p>
&lt;p>&lt;strong>2. 重载（Overload）&lt;/strong>&lt;/p>
&lt;p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。&lt;/p>
&lt;p>应该注意的是，返回值不同，其它都相同不算是重载。&lt;/p>
&lt;h2 id="7-反射">7 反射&lt;/h2>
&lt;p>每个类都有一个 &lt;strong>Class&lt;/strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。&lt;/p>
&lt;p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 &lt;code>Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;)&lt;/code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。&lt;/p>
&lt;p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。&lt;/p>
&lt;p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Field&lt;/strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；&lt;/li>
&lt;li>&lt;strong>Method&lt;/strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；&lt;/li>
&lt;li>&lt;strong>Constructor&lt;/strong> ：可以用 Constructor 的 newInstance() 创建新的对象。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>反射的优点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>可扩展性&lt;/strong> ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。&lt;/li>
&lt;li>&lt;strong>类浏览器和可视化开发环境&lt;/strong> ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。&lt;/li>
&lt;li>&lt;strong>调试器和测试工具&lt;/strong> ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>反射的缺点：&lt;/strong>&lt;/p>
&lt;p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>性能开销&lt;/strong> ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。&lt;/li>
&lt;li>&lt;strong>安全限制&lt;/strong> ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。&lt;/li>
&lt;li>&lt;strong>内部暴露&lt;/strong> ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。&lt;/li>
&lt;/ul>
&lt;h2 id="8-异常">8 异常&lt;/h2>
&lt;p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： &lt;strong>Error&lt;/strong> 和 &lt;strong>Exception&lt;/strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>受检异常&lt;/strong> ：需要用 try&amp;hellip;catch&amp;hellip; 语句捕获并进行处理，并且可以从异常中恢复；&lt;/li>
&lt;li>&lt;strong>非受检异常&lt;/strong> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。&lt;/li>
&lt;/ul>
&lt;h2 id="9-泛型注解新特性">9 泛型、注解、新特性&lt;/h2>
&lt;p>略。&lt;/p>
&lt;hr>
&lt;p>本文转载自：&lt;a class="link" href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener" >https://github.com/CyC2018/CS-Notes
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
，用于个人复习。&lt;/p></description></item><item><title>JVM 知识点笔记</title><link>https://cuterwrite.top/p/jvm/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/jvm/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/naples-122698_1920.2vb750rs8te0.webp" alt="Featured image of post JVM 知识点笔记" />&lt;h1 id="jvm-知识点笔记">JVM 知识点笔记&lt;/h1>
&lt;h2 id="1-运行时数据区域">1 运行时数据区域&lt;/h2>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5778d113-8e13-4c53-b5bf-801e58080b97.png" width="90%" loading="lazy"/>
&lt;/figure>
&lt;h3 id="11-程序计数器">1.1 程序计数器&lt;/h3>
&lt;p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。&lt;/p>
&lt;h3 id="12-java-虚拟机栈">1.2 Java 虚拟机栈&lt;/h3>
&lt;p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。&lt;/p>
&lt;p>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：&lt;/p>
&lt;p>该区域可能抛出以下异常：&lt;/p>
&lt;ul>
&lt;li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；&lt;/li>
&lt;li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。&lt;/li>
&lt;/ul>
&lt;h3 id="13-本地方法栈">1.3 本地方法栈&lt;/h3>
&lt;p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。&lt;/p>
&lt;p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。&lt;/p>
&lt;h3 id="14-堆">1.4 堆&lt;/h3>
&lt;p>所有对象都在这里分配内存，是垃圾收集的主要区域（&amp;ldquo;GC 堆&amp;rdquo;）。&lt;/p>
&lt;p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：&lt;/p>
&lt;ul>
&lt;li>新生代（Young Generation）&lt;/li>
&lt;li>老年代（Old Generation）&lt;/li>
&lt;/ul>
&lt;p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。&lt;/p>
&lt;p>可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。&lt;/p>
&lt;pre>&lt;code class="language-java">java -Xms1M -Xmx2M HackTheJava
&lt;/code>&lt;/pre>
&lt;h3 id="15-方法区">1.5 方法区&lt;/h3>
&lt;p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。&lt;/p>
&lt;p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。&lt;/p>
&lt;p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。&lt;/p>
&lt;p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。&lt;/p>
&lt;p>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。&lt;/p>
&lt;h3 id="16-运行时常量池">1.6 运行时常量池&lt;/h3>
&lt;p>运行时常量池是方法区的一部分。&lt;/p>
&lt;p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。&lt;/p>
&lt;p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。&lt;/p>
&lt;h3 id="17-直接内存">1.7 直接内存&lt;/h3>
&lt;p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。&lt;/p>
&lt;h2 id="2-垃圾收集">2 垃圾收集&lt;/h2>
&lt;p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。&lt;/p>
&lt;h3 id="21-判断一个对象是否可回收">2.1 判断一个对象是否可回收&lt;/h3>
&lt;h4 id="211-引用计数算法">2.1.1 引用计数算法&lt;/h4>
&lt;p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。&lt;/p>
&lt;p>在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。&lt;/p>
&lt;h4 id="212-可达性分析算法">2.1.2 可达性分析算法&lt;/h4>
&lt;p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。&lt;/p>
&lt;p>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：&lt;/p>
&lt;ul>
&lt;li>虚拟机栈中局部变量表中引用的对象&lt;/li>
&lt;li>本地方法栈中 JNI 中引用的对象&lt;/li>
&lt;li>方法区中类静态属性引用的对象&lt;/li>
&lt;li>方法区中的常量引用的对象&lt;/li>
&lt;/ul>
&lt;h4 id="213-方法区的回收">2.1.3 方法区的回收&lt;/h4>
&lt;p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。&lt;/p>
&lt;p>主要是对常量池的回收和对类的卸载。&lt;/p>
&lt;p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。&lt;/p>
&lt;p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：&lt;/p>
&lt;ul>
&lt;li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。&lt;/li>
&lt;li>加载该类的 ClassLoader 已经被回收。&lt;/li>
&lt;li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。&lt;/li>
&lt;/ul>
&lt;h4 id="214-finalize">2.1.4 finalize()&lt;/h4>
&lt;p>类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。&lt;/p>
&lt;p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。&lt;/p>
&lt;h3 id="22-引用类型">2.2 引用类型&lt;/h3>
&lt;p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。&lt;/p>
&lt;p>Java 提供了四种强度不同的引用类型。&lt;/p>
&lt;h4 id="221-强引用">2.2.1 强引用&lt;/h4>
&lt;p>被强引用关联的对象不会被回收。&lt;/p>
&lt;p>使用 new 一个新对象的方式来创建强引用。&lt;/p>
&lt;h4 id="222-软引用">2.2.2 软引用&lt;/h4>
&lt;p>被软引用关联的对象只有在内存不够的情况下才会被回收。&lt;/p>
&lt;p>使用 SoftReference 类来创建软引用。&lt;/p>
&lt;h4 id="223-弱引用">2.2.3 弱引用&lt;/h4>
&lt;p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。&lt;/p>
&lt;p>使用 WeakReference 类来创建弱引用。&lt;/p>
&lt;h4 id="224-虚引用">2.2.4 虚引用&lt;/h4>
&lt;p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。&lt;/p>
&lt;p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。&lt;/p>
&lt;p>使用 PhantomReference 来创建虚引用。&lt;/p>
&lt;h3 id="23-垃圾收集算法">2.3 垃圾收集算法&lt;/h3>
&lt;h4 id="231-标记---清除">2.3.1 标记 - 清除&lt;/h4>
&lt;p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。&lt;/p>
&lt;p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。&lt;/p>
&lt;p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。&lt;/p>
&lt;p>不足：&lt;/p>
&lt;ul>
&lt;li>标记和清除过程效率都不高；&lt;/li>
&lt;li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/005b481b-502b-4e3f-985d-d043c2b330aa.png" width="90%" loading="lazy"/>
&lt;/figure>
&lt;h4 id="232-标记-整理">2.3.2 标记-整理&lt;/h4>
&lt;p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。&lt;/p>
&lt;p>优点:&lt;/p>
&lt;ul>
&lt;li>不会产生内存碎片&lt;/li>
&lt;/ul>
&lt;p>不足:&lt;/p>
&lt;ul>
&lt;li>需要移动大量对象，处理效率比较低。&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ccd773a5-ad38-4022-895c-7ac318f31437.png" width="90%" loading="lazy"/>
&lt;/figure>
&lt;h4 id="233-复制">2.3.3 复制&lt;/h4>
&lt;p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。&lt;/p>
&lt;p>主要不足是只使用了内存的一半。&lt;/p>
&lt;p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。&lt;/p>
&lt;p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png" width="90%" loading="lazy"/>
&lt;/figure>
&lt;h4 id="234-分代收集">2.3.4 分代收集&lt;/h4>
&lt;p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。&lt;/p>
&lt;p>一般将堆分为新生代和老年代。&lt;/p>
&lt;ul>
&lt;li>新生代使用：复制算法&lt;/li>
&lt;li>老年代使用：标记 - 清除 或者 标记 - 整理 算法&lt;/li>
&lt;/ul>
&lt;h3 id="24-垃圾收集器">2.4 垃圾收集器&lt;/h3>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" width="90%" loading="lazy"/>
&lt;/figure>
&lt;p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。&lt;/p>
&lt;ul>
&lt;li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；&lt;/li>
&lt;li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。&lt;/li>
&lt;/ul>
&lt;h2 id="3-内存分配与回收策略">3 内存分配与回收策略&lt;/h2>
&lt;h3 id="31-minor-gc-和-full-gc">3.1 Minor GC 和 Full GC&lt;/h3>
&lt;ul>
&lt;li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。&lt;/li>
&lt;li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。&lt;/li>
&lt;/ul>
&lt;h3 id="32-内存分配策略">3.2 内存分配策略&lt;/h3>
&lt;h4 id="321-对象优先在-eden-分配">3.2.1. 对象优先在 Eden 分配&lt;/h4>
&lt;p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。&lt;/p>
&lt;h4 id="322-大对象直接进入老年代">3.2.2. 大对象直接进入老年代&lt;/h4>
&lt;p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。&lt;/p>
&lt;p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。&lt;/p>
&lt;p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。&lt;/p>
&lt;h4 id="323-长期存活的对象进入老年代">3.2.3. 长期存活的对象进入老年代&lt;/h4>
&lt;p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。&lt;/p>
&lt;p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。&lt;/p>
&lt;h4 id="324-动态对象年龄判定">3.2.4. 动态对象年龄判定&lt;/h4>
&lt;p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。&lt;/p>
&lt;h4 id="325-空间分配担保">3.2.5. 空间分配担保&lt;/h4>
&lt;p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。&lt;/p>
&lt;p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。&lt;/p>
&lt;h3 id="33-full-gc-触发条件">3.3 Full GC 触发条件&lt;/h3>
&lt;p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：&lt;/p>
&lt;h4 id="331-调用-systemgc">3.3.1. 调用 System.gc()&lt;/h4>
&lt;p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。&lt;/p>
&lt;h4 id="332-老年代空间不足">3.3.2. 老年代空间不足&lt;/h4>
&lt;p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。&lt;/p>
&lt;p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。&lt;/p>
&lt;h4 id="333-空间分配担保失败">3.3.3. 空间分配担保失败&lt;/h4>
&lt;p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。&lt;/p>
&lt;h4 id="334-jdk-17-及以前的永久代空间不足">3.3.4. JDK 1.7 及以前的永久代空间不足&lt;/h4>
&lt;p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。&lt;/p>
&lt;p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。&lt;/p>
&lt;p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。&lt;/p>
&lt;h4 id="335-concurrent-mode-failure">3.3.5. Concurrent Mode Failure&lt;/h4>
&lt;p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。&lt;/p>
&lt;h2 id="4-类加载机制">4 类加载机制&lt;/h2>
&lt;hr>
&lt;p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。&lt;/p>
&lt;h3 id="41-类的生命周期">4.1 类的生命周期&lt;/h3>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/335fe19c-4a76-45ab-9320-88c90d6a0d7e.png" width="90%" loading="lazy"/>
&lt;/figure>
&lt;p>包括以下 7 个阶段：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>加载（Loading）&lt;/strong>&lt;/li>
&lt;li>&lt;strong>验证（Verification）&lt;/strong>&lt;/li>
&lt;li>&lt;strong>准备（Preparation）&lt;/strong>&lt;/li>
&lt;li>&lt;strong>解析（Resolution）&lt;/strong>&lt;/li>
&lt;li>&lt;strong>初始化（Initialization）&lt;/strong>&lt;/li>
&lt;li>使用（Using）&lt;/li>
&lt;li>卸载（Unloading）&lt;/li>
&lt;/ul>
&lt;h3 id="42-类加载过程">4.2 类加载过程&lt;/h3>
&lt;p>包含了加载、验证、准备、解析和初始化这 5 个阶段。&lt;/p>
&lt;h4 id="421-加载">4.2.1. 加载&lt;/h4>
&lt;p>加载是类加载的一个阶段，注意不要混淆。&lt;/p>
&lt;p>加载过程完成以下三件事：&lt;/p>
&lt;ul>
&lt;li>通过类的完全限定名称获取定义该类的二进制字节流。&lt;/li>
&lt;li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。&lt;/li>
&lt;li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。&lt;/li>
&lt;/ul>
&lt;p>其中二进制字节流可以从以下方式中获取：&lt;/p>
&lt;ul>
&lt;li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。&lt;/li>
&lt;li>从网络中获取，最典型的应用是 Applet。&lt;/li>
&lt;li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。&lt;/li>
&lt;li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。&lt;/li>
&lt;/ul>
&lt;h4 id="422-验证">4.2.2. 验证&lt;/h4>
&lt;p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。&lt;/p>
&lt;h4 id="423-准备">4.2.3. 准备&lt;/h4>
&lt;p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。&lt;/p>
&lt;p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。&lt;/p>
&lt;p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。&lt;/p>
&lt;pre>&lt;code class="language-java">public static int value = 123;
&lt;/code>&lt;/pre>
&lt;p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。&lt;/p>
&lt;pre>&lt;code class="language-java">public static final int value = 123;
&lt;/code>&lt;/pre>
&lt;h4 id="424-解析">4.2.4. 解析&lt;/h4>
&lt;p>将常量池的符号引用替换为直接引用的过程。&lt;/p>
&lt;p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。&lt;/p>
&lt;h4 id="425-初始化">4.2.5. 初始化&lt;/h4>
&lt;!-- raw HTML omitted -->
&lt;p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &amp;lt;clinit&amp;gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。&lt;/p>
&lt;p>&amp;lt;clinit&amp;gt;() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：&lt;/p>
&lt;pre>&lt;code class="language-java">public class Test {
static {
i = 0; // 给变量赋值可以正常编译通过
System.out.print(i); // 这句编译器会提示“非法向前引用”
}
static int i = 1;
}
&lt;/code>&lt;/pre>
&lt;p>由于父类的 &amp;lt;clinit&amp;gt;() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：&lt;/p>
&lt;pre>&lt;code class="language-java">static class Parent {
public static int A = 1;
static {
A = 2;
}
}
static class Sub extends Parent {
public static int B = A;
}
public static void main(String[] args) {
System.out.println(Sub.B); // 2
}
&lt;/code>&lt;/pre>
&lt;p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &amp;lt;clinit&amp;gt;() 方法。但接口与类不同的是，执行接口的 &amp;lt;clinit&amp;gt;() 方法不需要先执行父接口的 &amp;lt;clinit&amp;gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &amp;lt;clinit&amp;gt;() 方法。&lt;/p>
&lt;p>虚拟机会保证一个类的 &amp;lt;clinit&amp;gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &amp;lt;clinit&amp;gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &amp;lt;clinit&amp;gt;() 方法完毕。如果在一个类的 &amp;lt;clinit&amp;gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。&lt;/p>
&lt;h3 id="43-类初始化时机">4.3 类初始化时机&lt;/h3>
&lt;h4 id="431-主动引用">4.3.1. 主动引用&lt;/h4>
&lt;p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="432-被动引用">4.3.2. 被动引用&lt;/h4>
&lt;p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：&lt;/p>
&lt;ul>
&lt;li>通过子类引用父类的静态字段，不会导致子类初始化。&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java">System.out.println(SubClass.value); // value 字段在 SuperClass 中定义
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java">SuperClass[] sca = new SuperClass[10];
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java">System.out.println(ConstClass.HELLOWORLD);
&lt;/code>&lt;/pre>
&lt;h3 id="44-类与类加载器">4.4 类与类加载器&lt;/h3>
&lt;p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。&lt;/p>
&lt;p>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。&lt;/p>
&lt;h3 id="45-类加载器分类">4.5 类加载器分类&lt;/h3>
&lt;p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &amp;lt;JRE_HOME&amp;gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &amp;lt;JAVA_HOME&amp;gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="46-双亲委派模型">4.6 双亲委派模型&lt;/h3>
&lt;p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。&lt;/p>
&lt;p>下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。&lt;/p>
&lt;figure>&lt;img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0dd2d40a-5b2b-4d45-b176-e75a4cd4bdbf.png" width="90%" loading="lazy"/>
&lt;/figure>
&lt;h4 id="461-工作过程">4.6.1. 工作过程&lt;/h4>
&lt;p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。&lt;/p>
&lt;h4 id="462-好处">4.6.2. 好处&lt;/h4>
&lt;p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。&lt;/p>
&lt;p>例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。&lt;/p>
&lt;h4 id="463-实现">4.6.3. 实现&lt;/h4>
&lt;p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。&lt;/p>
&lt;pre>&lt;code class="language-java">public abstract class ClassLoader {
// The parent class loader for delegation
private final ClassLoader parent;
public Class&amp;lt;?&amp;gt; loadClass(String name) throws ClassNotFoundException {
return loadClass(name, false);
}
protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
synchronized (getClassLoadingLock(name)) {
// First, check if the class has already been loaded
Class&amp;lt;?&amp;gt; c = findLoadedClass(name);
if (c == null) {
try {
if (parent != null) {
c = parent.loadClass(name, false);
} else {
c = findBootstrapClassOrNull(name);
}
} catch (ClassNotFoundException e) {
// ClassNotFoundException thrown if class not found
// from the non-null parent class loader
}
if (c == null) {
// If still not found, then invoke findClass in order
// to find the class.
c = findClass(name);
}
}
if (resolve) {
resolveClass(c);
}
return c;
}
}
protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {
throw new ClassNotFoundException(name);
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="47-自定义类加载器实现">4.7 自定义类加载器实现&lt;/h3>
&lt;p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。&lt;/p>
&lt;p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。&lt;/p>
&lt;hr>
&lt;p>本文转载自：&lt;a class="link" href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener" >https://github.com/CyC2018/CS-Notes
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
，用于个人复习。&lt;/p></description></item><item><title>ArrayList 源码分析</title><link>https://cuterwrite.top/p/arraylist-source-code/</link><pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/arraylist-source-code/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/man-5640540_1920.5mr5hqwq7xc0.webp" alt="Featured image of post ArrayList 源码分析" />&lt;h1 id="arraylist-源码分析">ArrayList 源码分析&lt;/h1>
&lt;h2 id="1-简介">1 简介&lt;/h2>
&lt;p>底层：Object[]，容量能动态增长。在添加大量元素前，会先调用 ensureCapacity 来增加 ArrayList 的容量，可以减少递增再分配的次数。&lt;/p>
&lt;p>ArrayList 继承了 AbstractList，实现了 List，RandomAccess，Cloneable，Serializable 等接口。&lt;/p>
&lt;ul>
&lt;li>RandomAccess：标志接口，接口体是空的，只是用来表明 ArrayList 是支持快速随机访问的。&lt;/li>
&lt;li>Cloneable：能被克隆&lt;/li>
&lt;li>Serializable：可序列化&lt;/li>
&lt;/ul>
&lt;h3 id="11-arraylist-和-vector-的区别">1.1 ArrayList 和 Vector 的区别&lt;/h3>
&lt;p>底层都是 Object[]，但是 ArrayList 线程不安全，Vector 线程安全。&lt;/p>
&lt;h3 id="12-arraylist-和-linkedlist-的区别">1.2 ArrayList 和 LinkedList 的区别&lt;/h3>
&lt;ol>
&lt;li>线程安全：ArrayList 和 LinkedList 都是线程不安全的。&lt;/li>
&lt;li>底层数据结构：ArrayList 是 Object[]，LinkedList 底层是双向链表。&lt;/li>
&lt;li>插入和删除：ArrayList 插入和删除元素的时间复杂度受元素位置的影响，为 O(n - i)；LinkedList 的插入和删除元素的时间复杂度不受插入元素位置的影响，都近似于 O(1)，但如果在指定位置插入和删除，需要先移动到指定位置再执行操作，时间复杂度近似于 O(n)。&lt;/li>
&lt;li>是否支持快速随机访问：ArrayList 支持，LinkedList 不支持。&lt;/li>
&lt;li>内存空间占用：ArrayList 需要在列表末尾预留一定的容量空间，LinkedList 的每一个元素都需要多消耗 pre 和 next 指针的空间。&lt;/li>
&lt;/ol>
&lt;h2 id="2-核心源码分析">2 核心源码分析&lt;/h2>
&lt;h3 id="21-属性">2.1 属性&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>默认初始容量大小&lt;/p>
&lt;pre>&lt;code class="language-java">private static final int DEFAULT_CAPACITY = 10;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>元素个数&lt;/p>
&lt;pre>&lt;code class="language-java">private int size;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>存放数据的数组&lt;/p>
&lt;pre>&lt;code class="language-java">transient Object[] elementData
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>空数组&lt;/p>
&lt;pre>&lt;code class="language-java">private static final Object[] EMPTY_ELEMENTDATA = {};
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>用于默认大小实例的共享空数组实例&lt;/p>
&lt;pre>&lt;code class="language-java">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h3 id="22-构造函数">2.2 构造函数&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>无参&lt;/p>
&lt;pre>&lt;code class="language-java">public ArrayList(){
this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
&lt;/code>&lt;/pre>
&lt;p>注意：以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。（用了懒汉式的单例设计模式）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指定容量&lt;/p>
&lt;pre>&lt;code class="language-java">public ArrayList(int initialCapacity){
if (initialCapacity &amp;gt; 0){
this.elementData = new Object[initialCapacity];
} else if (initialCapacity == 0){
this.elementData = EMPTY_ELEMENTDATA;
} else {
//抛出异常
}
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>指定 collection&lt;/p>
&lt;pre>&lt;code class="language-java">public ArrayList(Collection&amp;lt;? extends E&amp;gt; c){
elementData = c.toArray();
if ((size = elementData.length) != 0){
if (elementData.getClass() != Object[].class){
elementData = Arrays.copyOf(elementData, size, Object[].class);
}
} else {
this.elementData = EMPTY_ELEMENTDATA;
}
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h3 id="23-扩容机制">2.3 扩容机制&lt;/h3>
&lt;h4 id="231-add-方法">2.3.1 add 方法&lt;/h4>
&lt;h4 id="232-ensurecapacityinternal-方法">2.3.2 ensureCapacityInternal 方法&lt;/h4>
&lt;h4 id="233-ensureexplicitcapacity">2.3.3 ensureExplicitCapacity&lt;/h4>
&lt;h4 id="234-grow-方法">2.3.4 grow 方法&lt;/h4>
&lt;h4 id="235-hugecapacity-方法">2.3.5 hugeCapacity 方法&lt;/h4>
&lt;h3 id="24-拷贝机制">2.4 拷贝机制&lt;/h3>
&lt;h3 id="25-ensurecapacity-方法">2.5 ensureCapacity 方法&lt;/h3></description></item></channel></rss>