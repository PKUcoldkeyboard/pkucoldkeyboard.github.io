<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on cuterwrite (Pang S.Z)</title>
    <link>https://cuterwrite.top/tags/java/</link>
    <description>Recent content in Java on cuterwrite (Pang S.Z)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 04 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cuterwrite.top/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JavaSE知识点笔记</title>
      <link>https://cuterwrite.top/p/java-se/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/java-se/</guid>
      <description>JavaSE知识点笔记  1 数据类型  1.1 基本类型 1.2 包装类型 1.3 缓存池   2 String  2.1 概述 2.2 不可变的优点  2.2.1 可以缓存hash值 2.2.2 String Pool 2.2.3 安全性 2.2.4 线程安全   2.3 String、StringBuilder和StringBuffer  2.3.1 可变性 2.3.2 线程安全   2.4 String Pool 2.5 new String（“abc”）   3 运算  3.1 参数传递 3.2 float与double 3.3 隐式类型转换   4 关键字  4.1 final 4.2 static   5 Object通用方法 6 继承  6.</description>
    </item>
    
    <item>
      <title>Java容器知识点笔记</title>
      <link>https://cuterwrite.top/p/java-collection/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/java-collection/</guid>
      <description>Java容器知识点笔记  1 概述  1.1 Collection  1.1.1 Set 1.1.2 List 1.1.3 Queue     2 源码分析  2.1 ArrayList  2.1.1 概述 2.1.2 扩容 2.1.3 删除元素 2.1.4 序列化 2.1.5 Fail-fast   2.2 Vector  2.2.1 同步 2.2.2 扩容 2.2.3 与ArrayList的比较 2.2.4 替代方案   2.3 CopyOnWriteArrayList  2.3.1 读写分离 2.3.2 适用场景   2.4 LinkedList  2.4.1 概述 2.4.2 与ArrayList的比较   2.5 HashMap  2.</description>
    </item>
    
    <item>
      <title>Java并发知识点笔记</title>
      <link>https://cuterwrite.top/p/java-concurrent/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/java-concurrent/</guid>
      <description>Java并发知识点笔记  1 使用线程的方法 2 基础线程机制  2.1 Executor 2.2 Daemon 2.3 sleep() 2.4 yield()   3 线程中断  3.1 InterruptedException 3.2 interrupted() 3.3 Executor 的中断操作   4 互斥锁  4.1 synchronized 4.2 ReentrantLock 4.3 比较 4.4 选择   5 线程协作  5.1 join 5.2 wait/notify 5.3 await/signal   6 线程状态 7 JUC包/AQS  7.1 CountDownLatch 7.2 CyclicBarrier 7.3 Semaphore   8 JUC包其它组件  8.</description>
    </item>
    
    <item>
      <title>JVM知识点笔记</title>
      <link>https://cuterwrite.top/p/jvm/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/jvm/</guid>
      <description>JVM知识点笔记  1 运行时数据区域  1.1 程序计数器 1.2 Java虚拟机栈 1.3 本地方法栈 1.4 堆 1.5 方法区 1.6 运行时常量池 1.7 直接内存   2 垃圾收集  2.1 判断一个对象是否可回收  2.1.1 引用计数算法 2.1.2 可达性分析算法 2.1.3 方法区的回收 2.1.4 finalize()   2.2 引用类型  2.2.1 强引用 2.2.2 软引用 2.2.3 弱引用 2.2.4 虚引用   2.3 垃圾收集算法  2.3.1 标记 - 清除 2.3.2 标记-整理 2.3.3 复制 2.3.4 分代收集   2.4 垃圾收集器   3 内存分配与回收策略  3.</description>
    </item>
    
    <item>
      <title>ArrayList源码分析</title>
      <link>https://cuterwrite.top/p/arraylist-source-code/</link>
      <pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/arraylist-source-code/</guid>
      <description>ArrayList源码分析 1 简介 底层：Object[]，容量能动态增长。在添加大量元素前，会先调用ensureCapacity来增加ArrayList的容量，可以减少递增再分配的次数。
ArrayList继承了AbstractList，实现了List，RandomAccess，Cloneable，Serializable等接口。
 RandomAccess：标志接口，接口体是空的，只是用来表明ArrayList是支持快速随机访问的。 Cloneable：能被克隆 Serializable：可序列化  1.1 ArrayList和Vector的区别 底层都是Object[]，但是ArrayList线程不安全，Vector线程安全。
1.2 ArrayList和LinkedList的区别  线程安全：ArrayList和LinkedList都是线程不安全的。 底层数据结构：ArrayList是Object[]，LinkedList底层是双向链表。 插入和删除：ArrayList插入和删除元素的时间复杂度受元素位置的影响，为O(n - i)；LinkedList的插入和删除元素的时间复杂度不受插入元素位置的影响，都近似于O(1)，但如果在指定位置插入和删除，需要先移动到指定位置再执行操作，时间复杂度近似于O(n)。 是否支持快速随机访问：ArrayList支持，LinkedList不支持。 内存空间占用：ArrayList需要在列表末尾预留一定的容量空间，LinkedList的每一个元素都需要多消耗pre和next指针的空间。  2 核心源码分析 2.1 属性   默认初始容量大小
private static final int DEFAULT_CAPACITY = 10;   元素个数
private int size;   存放数据的数组
transient Object[] elementData   空数组
private static final Object[] EMPTY_ELEMENTDATA = {};   用于默认大小实例的共享空数组实例
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}   2.</description>
    </item>
    
    <item>
      <title>HashMap源码分析</title>
      <link>https://cuterwrite.top/p/hashmap/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/hashmap/</guid>
      <description>HashMap源码分析  1 属性 2 构造方法 3 增加元素 4 读取元素 5 删除元素 6 底层数据结构分析  6.1 JDK1.8之前 6.2 JDK1.8之后      HashMap源码分析 1 属性   初始化容量
static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4;   最大容量
static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;   负载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;   红黑树阈值
static final int TREEIFY_THRESHOLD = 8;   链表阈值</description>
    </item>
    
    <item>
      <title>Spring Cloud Alibaba笔记</title>
      <link>https://cuterwrite.top/p/spring-cloud-alibaba-1/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/spring-cloud-alibaba-1/</guid>
      <description>Spring Cloud alibaba笔记  SOA与微服务的区别： Spring Cloud Alibaba与Spring Cloud Netflix的对比 什么是Spring Boot？ IOC/DI（控制反转与依赖注入） Spring发展过程 自动装配的实现 手写实现一个Starter  1 Starter的功能 2 Starter的命名规范 3 实现基于Redis的Starter   Apache Dubbo Zookeeper Dubbo集成Zookeeper  1 需要解决的问题 2 实现步骤 3 原理 4 实战Dubbo Spring Cloud   Dubbo的高级应用  1 集群容错 2 负载均衡 3 服务降级   主机绑定规则 Dubbo源码分析  1 核心点 2 生成IDE工程的命令 3 SPI(Service Provider Interface) 4 Dubbo中的SPI思想 5 Dubbo中的SPI原理 6 自适应扩展点 7 Protocol自适应扩展点源码 8 IOC 9 AOP 10 Dubbo集成Spring机制（略）   什么是Nacos？  1 关键特性 2 Nacos集群   搭建Nacos注册中心的注意点 Nacos实现原理  1 模块组成 2 注册中心的原理 3 Nacos源码（略）   Nacos实现统一配置管理  1 Nacos集成Spring Boot 2 Nacos集成Spring Cloud 3 动态更新配置 4 基于DataID配置yaml的文件扩展名 5 不同环境的配置切换 6 自定义Namespace和Group   Nacos Config实现原理（略） Spring Cloud加载配置的原理（略） Nacos源码（略） Sentinel限流及熔断  1 服务限流的作用及实现 2 服务熔断和降级 3 Sentinel的特性 4 Sentinel的组成： 5 Sentinel基本应用： 6 Sentinel资源保护规则  1 QPS流量控制行为   7 Sentinel实现服务熔断   Sentinel集成Spring Cloud 基于Sentinel Dashboard来实现流控配置 Sentinel自定义URL限流异常 Sentinel对URL资源清洗 Sentinel集成Nacos实现动态流控规则 Sentinel集成Nacos实现规则同步  1 Sentinel Dashboard源码修改： 2 Sentinel Dashboard规则同步   Sentinel集成Dubbo实现限流  1 Dubbo服务接入Sentinel Dashboard 2 Dubbo服务限流规则   Sentinel热点限流  1 热点参数限流的使用 2 @SentinelResource 3 热点参数规则说明   Sentinel的工作原理（略） Spring Cloud Sentinel工作原理（略） Sentinel核心源码分析（略）  1 限流的源码实现 2 实时指标数据统计 3 服务降级的实现原理   什么是分布式事务？  1 分布式事务问题的理论模型  1 X/Open分布式模型 2 两阶段提交协议 3 三阶段提交协议 4 CAP定理和BASE理论   2 分布式事务问题的常见解决方案  1 TCC补偿性方案 2 基于可靠性消息的最终一致性方案 3 最大努力通知型   3 分布式事务框架Seata  1 AT模式 2 Saga模式        Spring Cloud alibaba笔记 SOA与微服务的区别：  SOA关注的是服务的重用性及解决信息孤岛问题 微服务关注的是解耦，虽然解耦和可重用性从特定的角度来看是一样的，但本质上是有区别的，解耦是降低业务之间的耦合度，而重用性关注的是服务的复用。 微服务会更多地关注在DevOps的持续交付上，因为服务粒度细化之后使得开发运维变得更加重要，因此微服务与容器化技术的结合更加紧密。  Spring Cloud Alibaba与Spring Cloud Netflix的对比  Alibaba开源组件在没有织入Spring Cloud生态之前，已经在各大公司广泛应用，所以容易实现技术整合及迁移。 Alibaba开源组件在服务治理上和处理高并发的能力上有天然的优势。  什么是Spring Boot？ 帮助开发者快速构建一个基于Spring Framework及Spring生态体系的应用解决方案，也是对于“约定优于配置”理念的最佳实践。</description>
    </item>
    
  </channel>
</rss>
