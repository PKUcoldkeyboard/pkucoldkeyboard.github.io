<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Netty on cuterwrite (Pang S.Z)</title>
    <link>https://cuterwrite.top/tags/netty/</link>
    <description>Recent content in Netty on cuterwrite (Pang S.Z)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 13 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://cuterwrite.top/tags/netty/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Netty学习笔记</title>
      <link>https://cuterwrite.top/p/netty/</link>
      <pubDate>Wed, 13 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/netty/</guid>
      <description>Netty学习笔记 一、Netty基础 1、简介 Netty是一个开源的、基于NIO的客户端和服务器端Java编程框架，包含的知识点如下：
graph LR;A(Netty框架)---&amp;gt;B1(Netty基础)A---&amp;gt;B2(Netty线程模型)A--&amp;gt;B3(Netty内存管理)A---&amp;gt;B4(Netty Transport)A--&amp;gt;B5(Netty Channel)A--&amp;gt;B6(Netty Codec)A---&amp;gt;B7(Netty Bootstrap)B2--&amp;gt;C1(Rector模型/多路复用)B2--&amp;gt;C2(boss线程池)B2--&amp;gt;C3(worker线程池)B3--&amp;gt;C4(堆外内存分配) 2、Java中的IO通信 （1）IO通信基础 同步与异步的区别：
同步就是请求方发送一个请求后，接收方在未处理该请求之前，不会向请求方返回结果。
异步就是请求方发送一个请求后，接收方在得到该请求之后，立即向请求方返回响应（表示已接收到该请求）。此时请求方已知晓接收方收到了自己发出的请求，但很可能没有收到返回结果。这样，请求方可以继续自己的任务，通过事件回调等机制来获取返回结果。
阻塞和非阻塞的区别：
阻塞就是“请求方”发起一个请求，然后一直等待“被请求方”返回结果，这期间一直处于“挂起等待”状态，直到返回结果满足条件后才会执行后续任务。
非阻塞就是“请求方”发起一个请求，但不用一直等待“被请求方”返回结果，可以先行执行后续任务。
“同步／异步”这组概念主要用于描述“请求-响应”的方式，而“阻塞／非阻塞”这组概念主要用于描述返回结果的方式。
（2）BIO方式（同步阻塞IO） 主要特点：一个请求对应一个响应，弹性伸缩性能较差。
服务器端：一个接收器（Acceptor），负责监听每一个客户端的连接请求，并创建对应的线程来处理该客户端请求。服务器端一旦接收到客户端请求、并通过创建线程来处理该请求，该线程就不会再接收其他的客户端请求了，直到请求处理完成并返回结果（随后销毁该线程）。
实现：基于流（Stream）
问题：客户端数量较大时，需要创建的线程数量也十分巨大，导致系统性能急剧下降。
（3）伪异步IO方式 简单来说，就是在服务器端引入线程池来控制线程的数量
核心：线程池
不足：底层仍然使用BIO，治标不治本
（4）NIO方式（同步非阻塞IO） 核心组件：通道（Channel）、轮询器（Selector）和缓冲区（Buffer）
实现：基于通道和缓冲区
简单来说，NIO操作都是面向通道和缓冲来实现的，数据总是从通道读取到缓冲区或者从缓冲区写入到通道中。
轮询器（Selector）：负责监视全部通道IO的状态，当其中任意一个或者多个通道具有可用的IO操作时，该轮询器会通过一个方法返回大于0的整数，表示具体有多少个通道上具有可用的IO的操作，从而完成单事件轮询机制，并实现多路复用功能。</description>
    </item>
    
  </channel>
</rss>
