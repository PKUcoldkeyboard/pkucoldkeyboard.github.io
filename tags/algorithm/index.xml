<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithm on cuterwrite (Pang S.Z)</title>
    <link>https://cuterwrite.top/tags/algorithm/</link>
    <description>Recent content in algorithm on cuterwrite (Pang S.Z)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 16 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cuterwrite.top/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>聊聊前缀树Trie</title>
      <link>https://cuterwrite.top/p/trie/</link>
      <pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/p/trie/</guid>
      <description>聊聊前缀树Trie Trie树简介 Trie 树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。
此外 Trie 树也称前缀树（因为某节点的后代存在共同的前缀，比如pan是panda的前缀）。
它的key都为字符串，能做到高效查询和插入，时间复杂度为O(k)，k为字符串长度，缺点是如果大量字符串没有共同前缀时很耗内存。
它的核心思想就是通过最大限度地减少无谓的字符串比较，使得查询高效率，即「用空间换时间」，再利用共同前缀来提高查询效率。
Trie树特点 假设有 5 个字符串，它们分别是：code，cook，five，file，fat。现在需要在里面多次查找某个字符串是否存在。常见的方案有：①如果每次查找，都是拿要查找的字符串跟这 5 个字符串依次进行字符串匹配，时间复杂度为O(n)。②将字符串存入HashSet中，查找的时候时间复杂度为O(1)，但是缺点是空间复杂度高，假如有大量的字符串（比如10亿条）则会浪费大量的空间。
Trie树则通过空间换时间的方式，将字符串组织成下图的结构：
通过上图，可以发现 Trie树 的三个特点：
 根节点不包含字符，除根节点外每一个节点都只包含一个字符 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串 每个节点的所有子节点包含的字符都不相同  Trie树的插入操作 Trie树的插入操作很简单，其实就是将单词的每个字母逐一插入 Trie树。插入前先看字母对应的节点是否存在，存在则共享该节点，不存在则创建对应的节点。比如要插入新单词cook，就有下面几步：
 插入第一个字母 c，发现 root 节点下方存在子节点 c，则共享节点 c 插入第二个字母 o，发现 c 节点下方存在子节点 o，则共享节点 o 插入第三个字母 o，发现 o 节点下方不存在子节点 o，则创建子节点 o 插入第三个字母 k，发现 o 节点下方不存在子节点 k，则创建子节点 k 至此，单词 cook 中所有字母已被插入 Trie树 中，然后设置节点 k 中的标志位，标记路径 root-&amp;gt;c-&amp;gt;o-&amp;gt;o-&amp;gt;k这条路径上所有节点的字符可以组成一个单词cook  Trie树的查询操作 在 Trie 树中查找一个字符串的时候，比如查找字符串 code，可以将要查找的字符串分割成单个的字符 c，o，d，e，然后从 Trie 树的根节点开始匹配。如图所示，绿色的路径就是在 Trie 树中匹配的路径</description>
    </item>
    
  </channel>
</rss>
