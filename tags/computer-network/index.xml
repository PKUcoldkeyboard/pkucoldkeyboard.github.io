<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>计算机网络 on cuterwrite</title><link>https://cuterwrite.top/tags/computer-network/</link><description>Recent content in 计算机网络 on cuterwrite</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>cuterwrite</copyright><lastBuildDate>Fri, 02 Feb 2024 01:01:01 +0000</lastBuildDate><atom:link href="https://cuterwrite.top/tags/computer-network/index.xml" rel="self" type="application/rss+xml"/><item><title>RDMA 基本元素</title><link>https://cuterwrite.top/p/rdma-element/</link><pubDate>Fri, 02 Feb 2024 01:01:01 +0000</pubDate><guid>https://cuterwrite.top/p/rdma-element/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/73c30b990886bf6988c97858a3e16011195413_crop-2024-02-04.webp" alt="Featured image of post RDMA 基本元素" />&lt;h1 id="rdma-基本元素">RDMA 基本元素&lt;/h1>
&lt;p>&lt;strong>本文欢迎非商业转载，转载请注明出处。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>声明：仅用于收藏，便于阅读&lt;/p>&lt;span class="cite">&lt;span>― &lt;/span>&lt;span>Savir, &lt;/span>&lt;a href="https://zhuanlan.zhihu.com/p/141267386">&lt;cite>知乎专栏：3. RDMA 基本元素&lt;/cite>&lt;/a>&lt;/span>&lt;/blockquote>
&lt;p>RDMA 技术中经常使用缩略语，很容易让刚接触的人一头雾水，本篇的目的是讲解 RDMA 中最基本的元素及其含义。&lt;/p>
&lt;p>我将常见的缩略语对照表写在前面，阅读的时候如果忘记了可以翻到前面查阅。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/v2-b6723caa5b291ee161d94fd8fd8ce09c_720w-2024-02-03.webp"
alt="v2-b6723caa5b291ee161d94fd8fd8ce09c_720w-2024-02-03" width="auto" loading="lazy"/>
&lt;/figure>
&lt;h2 id="wq">WQ&lt;/h2>
&lt;p>Work Queue 简称 WQ，是 RDMA 技术中最重要的概念之一。WQ 是一个储存工作请求的队列，为了讲清楚 WQ 是什么，我们先介绍这个队列中的元素 WQE（Work Queue Element，工作队列元素）。&lt;/p>
&lt;h3 id="wqe">WQE&lt;/h3>
&lt;p>WQE 可以认为是一种“任务说明”，这个工作请求是软件下发给硬件的，这份说明中包含了软件所希望硬件去做的任务以及有关这个任务的详细信息。比如，某一份任务是这样的：“我想把位于地址 0x12345678 的长度为 10 字节的数据发送给对面的节点”，硬件接到任务之后，就会通过 DMA 去内存中取数据，组装数据包，然后发送。&lt;/p>
&lt;p>WQE 的含义应该比较明确了，那么我们最开始提到的 WQ 是什么呢？它就是用来存放“任务书”的“文件夹”，WQ 里面可以容纳很多 WQE。有数据结构基础的读者应该都了解，队列是一种先进先出的数据结构，在计算机系统中非常常见，我们可以用下图表示上文中描述的 WQ 和 WQE 的关系：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/v2-40c7e57f2760323c6b6665306e8f8896_720w-2024-02-03.webp"
alt="v2-40c7e57f2760323c6b6665306e8f8896_720w-2024-02-03" width="auto" loading="lazy"/>
&lt;/figure>
&lt;p>WQ 这个队列总是由软件向其中增加 WQE（入队），硬件从中取出 WQE，这就是软件给硬件“下发任务”的过程。为什么用队列而不是栈？因为进行“存”和“取“操作的分别是软件和硬件，并且需要保证用户的请求按照顺序被处理在 RDMA 技术中，所有的通信请求都要按照上图这种方式告知硬件，这种方式常被称为“Post”。&lt;/p>
&lt;h3 id="qp">QP&lt;/h3>
&lt;p>Queue Pair 简称 QP，就是“一对”WQ 的意思。&lt;/p>
&lt;h3 id="sq-和-rq">SQ 和 RQ&lt;/h3>
&lt;p>任何通信过程都要有收发两端，QP 就是一个发送工作队列和一个接受工作队列的组合，这两个队列分别称为 SQ（Send Queue）和 RQ（Receive Queue）。我们再把上面的图丰富一下，左边是发送端，右边是接收端：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/v2-b89b321b8d1ae5ab6dcbaf8d6085f107_720w-2024-02-03.webp"
alt="v2-b89b321b8d1ae5ab6dcbaf8d6085f107_720w-2024-02-03" width="auto" loading="lazy"/>
&lt;/figure>
&lt;p>WQ 怎么不见了？SQ 和 RQ 都是 WQ，WQ 只是表示一种可以存储 WQE 的单元，SQ 和 RQ 才是实例。&lt;/p>
&lt;p>SQ 专门用来存放发送任务，RQ 专门用来存放接收任务。在一次 SEND-RECV 流程中，发送端需要把表示一次发送任务的 WQE 放到 SQ 里面。同样的，接收端软件需要给硬件下发一个表示接收任务的 WQE，这样硬件才知道收到数据之后放到内存中的哪个位置。上文我们提到的 Post 操作，对于 SQ 来说称为 Post Send，对于 RQ 来说称为 Post Receive。&lt;/p>
&lt;p>需要注意的是，在 RDMA 技术中&lt;strong>通信的基本单元是 QP&lt;/strong>，而不是节点。如下图所示，对于每个节点来说，每个进程都可以使用若干个 QP，而每个本地 QP 可以“关联”一个远端的 QP。我们用“节点 A 给节点 B 发送数据”并不足以完整的描述一次 RDMA 通信，而应该是类似于“节点 A 上的 QP3 给节点 C 上的 QP4 发送数据”。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/v2-71b3b17ef8aec45d74ef9e4a42a69201_720w-2024-02-03.webp"
alt="v2-71b3b17ef8aec45d74ef9e4a42a69201_720w-2024-02-03" width="auto" loading="lazy"/>
&lt;/figure>
&lt;p>每个节点的每个 QP 都有一个唯一的编号，称为 QPN（Queue Pair Number），通过 QPN 可以唯一确定一个节点上的 QP。&lt;/p>
&lt;h3 id="srq">SRQ&lt;/h3>
&lt;p>Shared Receive Queue 简称 SRQ，意为共享接收队列。概念很好理解，就是一种几个 QP 共享同一个 RQ 时，我们称其为 SRQ。以后我们会了解到，使用 RQ 的情况要远远小于使用 SQ，而每个队列都是要消耗内存资源的。当我们需要使用大量的 QP 时，可以通过 SRQ 来节省内存。如下图所示，QP2~QP4 一起使用同一个 RQ：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/v2-4a21f2b1333877b4b0d97a1ca91d4096_720w-2024-02-03.webp"
alt="v2-4a21f2b1333877b4b0d97a1ca91d4096_720w-2024-02-03" width="auto" loading="lazy"/>
&lt;/figure>
&lt;h2 id="cq">CQ&lt;/h2>
&lt;p>Completion Queue 简称 CQ，意为完成队列。跟 WQ 一样，我们先介绍 CQ 这个队列当中的元素——CQE（Completion Queue Element）。可以认为 CQE 跟 WQE 是相反的概念，如果 WQE 是软件下发给硬件的“任务书”的话，那么 CQE 就是硬件完成任务之后返回给软件的“任务报告”。CQE 中描述了某个任务是被正确无误的执行，还是遇到了错误，如果遇到了错误，那么错误的原因是什么。&lt;/p>
&lt;p>而 CQ 就是承载 CQE 的容器——一个先进先出的队列。我们把表示 WQ 和 WQE 关系的图倒过来画，就得到了 CQ 和 CQE 的关系：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/v2-31f9a407ab66381fbc557d8acc5573cb_720w-2024-02-03.webp"
alt="v2-31f9a407ab66381fbc557d8acc5573cb_720w-2024-02-03" width="auto" loading="lazy"/>
&lt;/figure>
&lt;p>每个 CQE 都包含某个 WQE 的完成信息，他们的关系如下图所示：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/v2-701fa8eacb10c90c45b0241c75254a01_720w-2024-02-03.webp"
alt="v2-701fa8eacb10c90c45b0241c75254a01_720w-2024-02-03" width="auto" loading="lazy"/>
&lt;/figure>
&lt;p>下面我们把 CQ 和 WQ（QP）放在一起，看一下一次 SEND-RECV 操作中，软硬件的互动（图中序号顺序不表示实际时序）：&lt;/p>
&lt;blockquote>
&lt;p>2022/5/23：下图及后面的列表顺序有修改，将原来第 2 条的“接收端硬件从 RQ 中拿到任务书，准备接收数据”移动到“接收端收到数据，进行校验后回复 ACK 报文给发送端”之后，并且修改了描述，现在为第 6 条。&lt;/p>
&lt;p>这里我犯了错误的点是 RQ 和 SQ 不同，是一个“被动接收”的过程，只有收到 Send 报文（或者带立即数的 Write 报文）时硬件才会消耗 RQ WQE。感谢 @连接改变世界 的指正。&lt;/p>
&lt;/blockquote>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/v2-a8d38721903672037b27cc7e49ecee03_720w-2024-02-03.webp"
alt="v2-a8d38721903672037b27cc7e49ecee03_720w-2024-02-03" width="auto" loading="lazy"/>
&lt;/figure>
&lt;ol>
&lt;li>接收端 APP 以 WQE 的形式下发一次 RECV 任务到 RQ。&lt;/li>
&lt;li>发送端 APP 以 WQE 的形式下发一次 SEND 任务到 SQ。&lt;/li>
&lt;li>发送端硬件从 SQ 中拿到任务书，从内存中拿到待发送数据，组装数据包。&lt;/li>
&lt;li>发送端网卡将数据包通过物理链路发送给接收端网卡。&lt;/li>
&lt;li>接收端收到数据，进行校验后回复 ACK 报文给发送端。&lt;/li>
&lt;li>接收端硬件从 RQ 中取出一个任务书（WQE）。&lt;/li>
&lt;li>接收端硬件将数据放到 WQE 中指定的位置，然后生成“任务报告”CQE，放置到 CQ 中。&lt;/li>
&lt;li>接收端 APP 取得任务完成信息。&lt;/li>
&lt;li>发送端网卡收到 ACK 后，生成 CQE，放置到 CQ 中。&lt;/li>
&lt;li>发送端 APP 取得任务完成信息。&lt;/li>
&lt;/ol>
&lt;div class="notice notice-note" >
&lt;div class="notice-title">&lt;svg t="1705946198814" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23141" width="200" height="200">&lt;path d="M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864a149.333333 149.333333 0 0 1-149.333334 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z m426.666667 0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864a149.333333 149.333333 0 0 1-149.333333 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z" p-id="23142" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;p>NOTE: 需要注意的一点是，上图中的例子是可靠服务类型的交互流程，如果是不可靠服务，那么不会有步骤 5 的 ACK 回复，而且步骤 9 以及之后的步骤会在步骤 5 之后立即触发。关于服务类型以及可靠与不可靠，我们将在《RDMA 基本服务类型》一文中讲解。&lt;/p>&lt;/div>
&lt;p>至此，通过 WQ 和 CQ 这两种媒介，两端软硬件共同完成了一次收发过程。&lt;/p>
&lt;h2 id="wr-和-wc">WR 和 WC&lt;/h2>
&lt;p>说完了几个 Queue 之后，其实还有两个文章开头提到的概念没有解释，那就是 WR 和 WC（不是 Water Closet 的缩写）。&lt;/p>
&lt;p>WR 全称为 Work Request，意为工作请求；WC 全称 Work Completion，意为工作完成。这两者其实是 WQE 和 CQE 在用户层的“映射”。因为 APP 是通过调用协议栈接口来完成 RDMA 通信的，WQE 和 CQE 本身并不对用户可见，是驱动中的概念。用户真正通过 API 下发的是 WR，收到的是 WC。&lt;/p>
&lt;p>WR/WC 和 WQE/CQE 是相同的概念在不同层次的实体，他们都是“任务书”和“任务报告”。于是我们把前文的两个图又加了点内容：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/v2-00b87c111a8e1701f96fbfb78e078b29_720w-2024-02-03.webp"
alt="v2-00b87c111a8e1701f96fbfb78e078b29_720w-2024-02-03" width="auto" loading="lazy"/>
&lt;/figure>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>好了，我们用 IB 协议[1]3.2.1 中的 Figure 11 这张图总结一下本篇文章的内容：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/v2-2107a9bf8230c45ad73aa5ff0b8626ff_720w-2024-02-03.webp"
alt="v2-2107a9bf8230c45ad73aa5ff0b8626ff_720w-2024-02-03" width="auto" loading="lazy"/>
&lt;/figure>
&lt;p>用户态的 WR，由驱动转化成了 WQE 填写到了 WQ 中，WQ 可以是负责发送的 SQ，也可以是负责接收的 RQ。硬件会从各个 WQ 中取出 WQE，并根据 WQE 中的要求完成发送或者接收任务。任务完成后，会给这个任务生成一个 CQE 填写到 CQ 中。驱动会从 CQ 中取出 CQE，并转换成 WC 返回给用户。&lt;/p>
&lt;p>基础概念就介绍到这里，下一篇将介绍 RDMA 的几种常见操作类型。&lt;/p>
&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;p>[1]《IB Specification Vol 1-Release-1.3-2015-03-03》&lt;/p></description></item><item><title>比较基于传统以太网与 RDMA 技术的通信</title><link>https://cuterwrite.top/p/ethernet-vs-rdma/</link><pubDate>Thu, 01 Feb 2024 02:01:01 +0000</pubDate><guid>https://cuterwrite.top/p/ethernet-vs-rdma/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/cropped_2024010202-2024-02-03.webp" alt="Featured image of post 比较基于传统以太网与 RDMA 技术的通信" />&lt;h1 id="比较基于传统以太网与-rdma-技术的通信">比较基于传统以太网与 RDMA 技术的通信&lt;/h1>
&lt;p>&lt;strong>本文欢迎非商业转载，转载请注明出处。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>声明：仅用于收藏，便于阅读&lt;/p>&lt;span class="cite">&lt;span>― &lt;/span>&lt;span>Savir, &lt;/span>&lt;a href="https://zhuanlan.zhihu.com/p/139548242">&lt;cite>知乎专栏：2. 比较基于传统以太网与 RDMA 技术的通信&lt;/cite>&lt;/a>&lt;/span>&lt;/blockquote>
&lt;p>本篇的目的是通过对比一次典型的基于 TCP/IP 协议栈的以太网和 RDMA 通信的过程，直观的展示 RDMA 技术相比传统以太网的优势，尽量不涉及协议和软件实现细节。&lt;/p>
&lt;p>假设本端的某个应用想把自己内存中的数据复制到对端某个应用可以访问的内存中（或者通俗的讲，本端要给对端发送数据），我们来看一下以太网和 RDMA 的 SEND-RECV 语义都做了哪些操作。&lt;/p>
&lt;h2 id="传统以太网">传统以太网&lt;/h2>
&lt;p>在描述通信过程时的软硬件关系时，我们通常将模型划分为用户层 Userspace，内核 Kernel 以及硬件 Hardware。Userspace 和 Kernel 实际上使用的是同一块物理内存，但是处于安全考虑，Linux 将内存划分为用户空间和内核空间。用户层没有权限访问和修改内核空间的内存内容，只能通过系统调用陷入内核态，Linux 的内存管理机制比较复杂，本文不展开讨论。&lt;/p>
&lt;p>一次典型的基于传统以太网的通信过程的可以如下图所示进行分层：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/v2-0931cab010cbf296edeaa368c45a503b_720w-2024-02-03.webp"
alt="v2-0931cab010cbf296edeaa368c45a503b_720w-2024-02-03" width="auto" loading="lazy"/>
&lt;/figure>
&lt;p>一次收-发过程的步骤如下：&lt;/p>
&lt;ol>
&lt;li>发送端和接收端通过 Socket 库提供的接口建立链接（就是在两个节点间建立了一条逻辑上的道路，数据可以沿这条道路从一端发送到另一端）并分别在内存中申请好发送和接收 Buffer。&lt;/li>
&lt;li>发送端 APP 通过 Socket 接口陷入内核态，待发送数据经过 TCP/IP 协议栈的一层层封装，最后被 CPU 复制到 Socket Buffer 中。&lt;/li>
&lt;li>发送端通过网卡驱动，告知网卡可以发送数据了，网卡将通过 DMA 从 Buffer 中复制封装好的数据包到内部缓存中，然后将其发送到物理链路。&lt;/li>
&lt;li>接收端网卡收到数据包后，将数据包放到接收 Buffer 中，然后 CPU 将通过内核中的 TCP/IP 协议栈对报文进行层层解析，取出有效的数据。&lt;/li>
&lt;li>接收端 APP 通过 Socket 接口陷入内核态，CPU 将数据从内核空间复制到用户空间。&lt;/li>
&lt;/ol>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/v2-b89b321b8d1ae5ab6dcbaf8d6085f107_720w-2024-02-03.webp"
alt="v2-b89b321b8d1ae5ab6dcbaf8d6085f107_720w-2024-02-03" width="auto" loading="lazy"/>
&lt;/figure>
&lt;p>这个模型的数据流向大致是像上图这个样子，数据首先需要从用户空间复制一份到内核空间，这一次复制由 CPU 完成，将数据块从用户空间复制到内核空间的 Socket Buffer 中。内核中软件 TCP/IP 协议栈给数据添加各层头部和校验信息。最后网卡会通过 DMA 从内存中复制数据，并通过物理链路发送给对端的网卡。&lt;/p>
&lt;p>而对端是完全相反的过程：硬件将数据包 DMA 拷贝到内存中，然后 CPU 会对数据包进行逐层解析和校验，最后将数据复制到用户空间。&lt;/p>
&lt;p>上述过程中的关键点是需要 CPU 参与的把数据从用户空间拷贝到内核空间，以及同样需要 CPU 全程参与的数据包组装和解析，数据量大的情况下，这将对 CPU 将造成很大的负担。&lt;/p>
&lt;p>下面我们看一下 RDMA 是如何将 CPU“解放”出来的。&lt;/p>
&lt;h2 id="rdma">RDMA&lt;/h2>
&lt;p>同样是一端发送，一端接收的场景，我们将 RDMA 的分层模型分成两部分“控制通路”和“数据通路”，控制通路需要进入内核态准备通信所需的内存资源，而数据通路指的是实际数据交互过程中的流程。这一过程的分层关系如下图所示：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/v2-8ef2b015ba9d111fc2d42983cd5fe152_720w-2024-02-03.webp"
alt="v2-8ef2b015ba9d111fc2d42983cd5fe152_720w-2024-02-03" width="auto" loading="lazy"/>
&lt;/figure>
&lt;p>同 Socket 一样，我们简单描述下通信的过程：&lt;/p>
&lt;ol>
&lt;li>发送端和接收端分别通过控制通路陷入内核态创建好通信所需要的内存资源。&lt;/li>
&lt;li>在数据通路上，接收端 APP 通知硬件准备接收数据，告诉硬件将接收到的数据放在哪片内存中。&lt;/li>
&lt;li>在数据通路上，发送端 APP 通知硬件发送数据，告诉硬件待发送数据位于哪片内存中。&lt;/li>
&lt;li>发送端 RDMA 网卡从内存中搬移数据，组装报文发送给对端。&lt;/li>
&lt;li>对端收到报文，对其进行解析并通过 DMA 将有效载荷写入内存。然后以某种方式通知上层 APP，告知其数据已接收并妥善存放到指定位置。&lt;/li>
&lt;/ol>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/v2-cb1492c24773e725dd5f112bb67f9deb_720w-2024-02-03.webp"
alt="v2-cb1492c24773e725dd5f112bb67f9deb_720w-2024-02-03" width="auto" loading="lazy"/>
&lt;/figure>
&lt;p>这一过程中的数据流向大致如上图所示。通过和 Socket 的对比，我们可以明显看到，&lt;strong>数据收发绕过了内核并且数据交换过程并不需要 CPU 参与，报文的组装和解析是由硬件完成的&lt;/strong>。&lt;/p>
&lt;p>通过上面的对比，我们可以明显的体会到 RDMA 的优势，既将 CPU 从数据包封装和解析中解放出来，又减少了 CPU 拷贝数据的功率和时间损耗。需要注意的是，本文只描述了 SEND-RECV 流程，而 RDMA 技术所独有的，效率更高的 WRITE/READ 语义将在后续文章中介绍。&lt;/p>
&lt;p>下一篇我们将介绍一些 RDMA 技术中的重要且基本的概念。&lt;/p></description></item><item><title>编译安装 UCX 1.15.0 与 OpenMPI 5.0.0：详尽指南</title><link>https://cuterwrite.top/p/openmpi-with-ucx/</link><pubDate>Thu, 01 Feb 2024 01:01:01 +0000</pubDate><guid>https://cuterwrite.top/p/openmpi-with-ucx/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/cropped_2024010204-2024-02-03.webp" alt="Featured image of post 编译安装 UCX 1.15.0 与 OpenMPI 5.0.0：详尽指南" />&lt;h1 id="编译安装-ucx-1150-与-openmpi-500详尽指南">编译安装 UCX 1.15.0 与 OpenMPI 5.0.0：详尽指南&lt;/h1>
&lt;h2 id="一环境准备">一、环境准备&lt;/h2>
&lt;p>首先，请确保您的系统满足以下基本要求：&lt;/p>
&lt;ol>
&lt;li>操作系统：支持 Linux（如 Ubuntu 20.04 LTS）或其他类 Unix 操作系统。&lt;/li>
&lt;li>开发工具包：安装必要的构建工具和库，例如 &lt;code>build-essential&lt;/code> ，&lt;code>libnuma-dev&lt;/code> ，&lt;code>pkg-config&lt;/code> 等。&lt;/li>
&lt;li>内核版本：对于最佳性能，建议使用最新稳定版内核。&lt;/li>
&lt;li>需要支持 RDMA 的硬件环境或虚拟环境。&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">sudo apt-get update
sudo apt-get install -y build-essential libnuma-dev pkg-config
&lt;/code>&lt;/pre>
&lt;h2 id="二编译安装-ucx-1150">二、编译安装 UCX 1.15.0&lt;/h2>
&lt;ol>
&lt;li>下载 UCX 源码包：&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">wget https://github.com/openucx/ucx/releases/download/v1.15.0/ucx-1.15.0.tar.gz
tar -xzvf ucx-1.15.0.tar.gz
cd ucx-1.15.0
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>配置 UCX 编译选项：&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">mkdir build &amp;amp;&amp;amp; cd build
../configure --prefix=/root/software/ucx/1.5.0
&lt;/code>&lt;/pre>
&lt;p>您可以根据实际需求添加更多配置选项，比如指定特定的网卡类型或者启用特定的功能。&lt;/p>
&lt;ol start="3">
&lt;li>编译并安装：&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">make -j 8
make install
&lt;/code>&lt;/pre>
&lt;ol start="4">
&lt;li>UCX 架构说明&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>UCX 1.15.0 的架构如下图所示：&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/Architecture-2024-02-03.webp"
alt="Architecture-2024-02-03" width="auto" loading="lazy"/>
&lt;/figure>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>组件&lt;/th>
&lt;th>角色&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>UCP&lt;/td>
&lt;td>Protocol&lt;/td>
&lt;td>实现高级抽象，如标记匹配、流、连接协商和建立、多轨以及处理不同的内存类型。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UCT&lt;/td>
&lt;td>Transport&lt;/td>
&lt;td>实现低级通信原语，如活动消息、远程内存访问和原子操作。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UCM&lt;/td>
&lt;td>Memory&lt;/td>
&lt;td>通用的数据结构、算法和系统实用程序的集合。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UCP&lt;/td>
&lt;td>Protocol&lt;/td>
&lt;td>截获内存注册缓存使用的内存分配和释放事件。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="三编译安装-openmpi-500">三、编译安装 OpenMPI 5.0.0&lt;/h2>
&lt;ol>
&lt;li>下载 OpenMPI 源码包：&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">wget https://download.open-mpi.org/release/open-mpi/v5.0/openmpi-5.0.0.tar.gz
tar -xzvf openmpi-5.0.0.tar.gz
cd openmpi-5.0.0
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>配置 OpenMPI 编译选项，指定使用 UCX 作为传输层：&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">mkdir build &amp;amp;&amp;amp; cd build
../configure --without-hcoll \
--enable-python-bindings \
--enable-mpirun-prefix-by-default \
--prefix=/root/software/openmpi/5.0.0-ucx-1.15.0 \
--with-ucx=/root/software/ucx/1.15.0 \
--enable-mca-no-build=btl-uct
&lt;/code>&lt;/pre>
&lt;div class="notice notice-info" >
&lt;div class="notice-title">&lt;svg t="1705940100069" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6252" width="200" height="200">&lt;path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64z m32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272z m-32-344c-26.5 0-48-21.5-48-48s21.5-48 48-48 48 21.5 48 48-21.5 48-48 48z" p-id="6253" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;ul>
&lt;li>对于 OpenMPI 4.0 及更高版本，&lt;code>btl_uct&lt;/code> 组件可能存在编译错误。该组件对于使用 UCX 来说并不重要；因此可以通过 &lt;code>--enable-mca-no-build=btl-uct&lt;/code> 禁用：&lt;/li>
&lt;li>&lt;code>--enable-python-bindings&lt;/code> 选项用于启用 Python 绑定。&lt;/li>
&lt;li>&lt;code>--enable-mpirun-prefix-by-default&lt;/code> 选项用于在使用 &lt;code>mpirun&lt;/code> 启动 MPI 程序时自动添加 &lt;code>--prefix&lt;/code> 选项。&lt;/li>
&lt;li>&lt;code>--without-hcoll&lt;/code> 选项用于禁用 HCOLL 组件。不设置编译时会报错 &lt;code>cannot find -lnuma&lt;/code> 与 &lt;code>cannot find -ludev&lt;/code> 的错误。&lt;/li>
&lt;/ul>&lt;/div>
&lt;p>最后配置选项如下：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/ompi-config-2024-02-03.webp"
alt="ompi-config-2024-02-03" width="auto" loading="lazy"/>
&lt;/figure>
&lt;ol start="3">
&lt;li>编译并安装：&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">make -j 8
make install
&lt;/code>&lt;/pre>
&lt;h2 id="四验证安装与设置环境变量">四、验证安装与设置环境变量&lt;/h2>
&lt;p>安装完成后，可以通过运行简单的 MPI 程序来验证 UCX 和 OpenMPI 是否成功集成：&lt;/p>
&lt;pre>&lt;code class="language-bash">mpirun -np 2 --mca pml ucx --mca btl ^vader,tcp,openib,uct [-x UCX_NET_DEVICES=mlx5_0:1] hostname
&lt;/code>&lt;/pre>
&lt;p>（如果在 root 上运行则需要加上 &lt;code>--allow-run-as-root&lt;/code> 选项，如果有 RDMA 设备可以设置 &lt;code>-x UCX_NET_DEVICES&lt;/code> ）&lt;/p>
&lt;p>如果一切正常，您会看到两台主机名的输出。为了方便使用，可以将 OpenMPI 的 bin 目录等添加到系统 PATH 环境变量中：&lt;/p>
&lt;pre>&lt;code class="language-bash">vim ~/.bashrc
export PATH=/root/software/openmpi/5.0.0-ucx-1.15.0/bin:$PATH
export LD_LIBRARY_PATH=/root/software/openmpi/5.0.0-ucx-1.15.0/lib:$LD_LIBRARY_PATH
export CPATH=/root/software/openmpi/5.0.0-ucx-1.15.0/include:$CPATH
export MANPATH=/root/software/openmpi/5.0.0-ucx-1.15.0/share/man:$MANPATH
source ~/.bashrc
&lt;/code>&lt;/pre>
&lt;h2 id="五ucx-性能测试">五、UCX 性能测试&lt;/h2>
&lt;p>发送方：&lt;/p>
&lt;pre>&lt;code class="language-bash">ucx_perftest -c 0 -d mlx5_0:1
&lt;/code>&lt;/pre>
&lt;p>接收方：&lt;/p>
&lt;pre>&lt;code class="language-bash">ucx_perftest -c 1 -d mlx5_0:1 &amp;lt;server_hostname&amp;gt; -t tag_lat
&lt;/code>&lt;/pre>
&lt;p>总之，通过以上步骤，我们已经成功地从源代码编译并安装了 UCX 1.15.0 和 OpenMPI 5.0.0，并将其整合为一个高效稳定的高性能计算环境。在实际应用中，可以根据具体需求进一步优化配置以获得更优性能。&lt;/p></description></item><item><title>RDMA 概述</title><link>https://cuterwrite.top/p/rdma-overview/</link><pubDate>Mon, 01 Jan 2024 01:01:01 +0000</pubDate><guid>https://cuterwrite.top/p/rdma-overview/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/crop_65b36f302c1d3715061e824224dcc9ca195413.jpg@1256w_1806h_!web-article-pic-2024-01-14.webp" alt="Featured image of post RDMA 概述" />&lt;h1 id="rdma-概述">RDMA 概述&lt;/h1>
&lt;p>&lt;strong>本文欢迎非商业转载，转载请注明出处。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>声明：仅用于收藏，便于阅读&lt;/p>&lt;span class="cite">&lt;span>― &lt;/span>&lt;span>Savir, &lt;/span>&lt;a href="https://zhuanlan.zhihu.com/p/138874738">&lt;cite>知乎专栏：1. RDMA 概述&lt;/cite>&lt;/a>&lt;/span>&lt;/blockquote>
&lt;p>本想完全靠自己的语言完成这篇概述，然而开篇并没有想象当中的好写，看样子从宏观上概括一个技术比从微观上探究细枝末节要困难不少。本文是以前人们对 RDMA 技术的介绍为主，加入了一些自己的理解。随着本专栏内容的增加，本篇概述也会更新和逐渐完善。&lt;/p>
&lt;h2 id="什么是-dma">什么是 DMA&lt;/h2>
&lt;p>DMA 全称为 Direct Memory Access，即直接内存访问。意思是外设对内存的读写过程可以不用 CPU 参与而直接进行。我们先来看一下没有 DMA 的时候：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20240114203040-2024-01-14.png"
alt="无 DMA 控制器时 I/O 设备和内存间的数据路径" width="auto" loading="lazy"/>&lt;figcaption>
&lt;h4>无 DMA 控制器时 I/O 设备和内存间的数据路径&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>假设 I/O 设备为一个普通网卡，为了从内存拿到需要发送的数据，然后组装数据包发送到物理链路上，网卡需要通过总线告知 CPU 自己的数据请求。然后 CPU 将会把内存缓冲区中的数据复制到自己内部的寄存器中，再复制到 I/O 设备的存储空间中。如果数据量比较大，那么很长一段时间内 CPU 都会忙于搬移数据，而无法投入到其他工作中去。&lt;/p>
&lt;p>CPU 的最主要工作是计算，而不是进行数据复制，这种工作属于白白浪费了它的计算能力。为了给 CPU“减负”，让它投入到更有意义的工作中去，后来人们设计了 DMA 机制：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20240114203114-2024-01-14.png"
alt="有 DMA 控制器时 I/O 设备和内存间的数据路径" width="auto" loading="lazy"/>&lt;figcaption>
&lt;h4>有 DMA 控制器时 I/O 设备和内存间的数据路径&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>可以看到总线上又挂了一个 DMA 控制器，它是专门用来读写内存的设备。有了它以后，当我们的网卡想要从内存中拷贝数据时，除了一些必要的控制命令外，整个数据复制过程都是由 DMA 控制器完成的。过程跟 CPU 复制是一样的，只不过这次是把内存中的数据通过总线复制到 DMA 控制器内部的寄存器中，再复制到 I/O 设备的存储空间中。CPU 除了关注一下这个过程的开始和结束以外，其他时间可以去做其他事情。&lt;/p>
&lt;p>DMA 控制器一般是和 I/O 设备在一起的，也就是说一块网卡中既有负责数据收发的模块，也有 DMA 模块。&lt;/p>
&lt;h2 id="什么是-rdma">什么是 RDMA&lt;/h2>
&lt;p>RDMA（ Remote Direct Memory Access ）意为远程直接地址访问，通过 RDMA，本端节点可以“直接”访问远端节点的内存。所谓直接，指的是可以像访问本地内存一样，绕过传统以太网复杂的 TCP/IP 网络协议栈读写远端内存，而这个过程对端是不感知的，而且这个读写过程的大部分工作是由硬件而不是软件完成的。&lt;/p>
&lt;p>为了能够直观的理解这一过程，请看下面两个图（图中箭头仅做示意，不表示实际逻辑或物理关系）：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20240115235555-2024-01-15.png"
alt="20240115235555-2024-01-15" width="90%" loading="lazy"/>
&lt;/figure>
&lt;p>传统网络中，“节点 A 给节点 B 发消息”实际上做的是“把节点 A 内存中的一段数据，通过网络链路搬移到节点 B 的内存中”，而这一过程无论是发端还是收段，都需要 CPU 的指挥和控制，包括网卡的控制，中断的处理，报文的封装和解析等等。&lt;/p>
&lt;p>上图中左边的节点在内存用户空间中的数据，需要经过 CPU 拷贝到内核空间的缓冲区中，然后才可以被网卡访问，这期间数据会经过软件实现的 TCP/IP 协议栈，加上各层头部和校验码，比如 TCP 头，IP 头等。网卡通过 DMA 拷贝内核中的数据到网卡内部的缓冲区中，进行处理后通过物理链路发送给对端。&lt;/p>
&lt;p>对端收到数据后，会进行相反的过程：从网卡内部存储空间，将数据通过 DMA 拷贝到内存内核空间的缓冲区中，然后 CPU 会通过 TCP/IP 协议栈对其进行解析，将数据取出来拷贝到用户空间中。&lt;/p>
&lt;p>可以看到，即使有了 DMA 技术，上述过程还是对 CPU 有较强的依赖。&lt;/p>
&lt;p>而使用了 RDMA 技术之后，这一过程可以简单的表示成下面的示意图：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20240115235612-2024-01-15.png"
alt="20240115235612-2024-01-15" width="90%" loading="lazy"/>
&lt;/figure>
&lt;p>同样是把本端内存中的一段数据，复制到对端内存中，在使用了 RDMA 技术时，两端的 CPU 几乎不用参与数据传输过程（只参与控制面）。本端的网卡直接从内存的用户空间 DMA 拷贝数据到内部存储空间，然后硬件进行各层报文的组装后，通过物理链路发送到对端网卡。对端的 RDMA 网卡收到数据后，剥离各层报文头和校验码，通过 DMA 将数据直接拷贝到用户空间内存中。&lt;/p>
&lt;h2 id="rdma-的优势">RDMA 的优势&lt;/h2>
&lt;p>RDMA 主要应用在高性能计算（HPC）领域和大型数据中心当中，并且设备相对普通以太网卡要昂贵不少（比如 Mellanox 公司的 Connext-X 5 100Gb PCIe 网卡市价在 4000 元以上）。由于使用场景和价格的原因，RDMA 与普通开发者和消费者的距离较远，目前主要是一些大型互联网企业在部署和使用。&lt;/p>
&lt;p>RDMA 技术为什么可以应用在上述场景中呢？这就涉及到它的以下几个特点：&lt;/p>
&lt;ul>
&lt;li>0 拷贝：指的是不需要在用户空间和内核空间中来回复制数据。&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20240115235643-2024-01-15.png"
alt="20240115235643-2024-01-15" width="60%" loading="lazy"/>
&lt;/figure>
&lt;p>由于 Linux 等操作系统将内存划分为用户空间和内核空间，在传统的 Socket 通信流程中 CPU 需要多次把数据在内存中来回拷贝。而通过 RDMA 技术，我们可以直接访问远端已经注册的内存区域。&lt;/p>
&lt;p>关于 0 拷贝可以参考这篇文章：&lt;a class="link" href="https://www.jianshu.com/p/e76e3580e356" target="_blank" rel="noopener" >浅谈 Linux 下的零拷贝机制
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;ul>
&lt;li>内核 Bypass：指的是 IO（数据）流程可以绕过内核，即在用户层就可以把数据准备好并通知硬件准备发送和接收。避免了系统调用和上下文切换的开销。&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20240115235721-2024-01-15.png"
alt="20240115235721-2024-01-15" width="90%" loading="lazy"/>
&lt;/figure>
&lt;p>上图（原图&lt;a class="link" href="https://pc.nanog.org/static/published/meetings/NANOG76/1999/20190612_Cardona_Towards_Hyperscale_High_v1.pdf" target="_blank" rel="noopener" >[1]
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
）可以很好的解释“0 拷贝”和“内核 Bypass”的含义。上下两部分分别是基于 Socket 的和基于 RDMA 的一次收-发流程，左右分别为两个节点。可以明显的看到 Socket 流程中在软件中多了一次拷贝动作。而 RDMA 绕过了内核同时也减少了内存拷贝，数据可以直接在用户层和硬件间传递。&lt;/p>
&lt;ul>
&lt;li>CPU 卸载：指的是可以在远端节点 CPU 不参与通信的情况下（当然要持有访问远端某段内存的“钥匙”才行）对内存进行读写，这实际上是 &lt;strong>把报文封装和解析放到硬件中做了&lt;/strong>。而传统的以太网通信，双方 CPU 都必须参与各层报文的解析，如果数据量大且交互频繁，对 CPU 来讲将是一笔不小的开销，而这些被占用的 CPU 计算资源本可以做一些更有价值的工作。&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20240115235929-2024-01-15.png"
alt="20240115235929-2024-01-15" width="60%" loading="lazy"/>
&lt;/figure>
&lt;p>通信领域两大出场率最高的性能指标就是“带宽”和“时延”。简单的说，所谓带宽指的是指单位时间内能够传输的数据量，而时延指的是数据从本端发出到被对端接收所耗费的时间。因为上述几个特点，相比于传统以太网，RDMA 技术同时做到了更高带宽和更低时延，所以其在带宽敏感的场景——比如海量数据的交互，时延敏感——比如多个计算节点间的数据同步的场景下得以发挥其作用。&lt;/p>
&lt;h2 id="协议">协议&lt;/h2>
&lt;p>RDMA 本身指的是一种技术，具体协议层面，包含 Infiniband（IB），RDMA over Converged Ethernet（RoCE）和 internet Wide Area RDMA Protocol（iWARP）。三种协议都符合 RDMA 标准，使用相同的上层接口，在不同层次上有一些差别。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20240116000000-2024-01-16.png"
alt="20240116000000-2024-01-16" width="90%" loading="lazy"/>
&lt;/figure>
&lt;p>上图&lt;a class="link" href="https://www.snia.org/sites/default/files/ESF/RoCE-vs.-iWARP-Final.pdf" target="_blank" rel="noopener" >[2]g
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
对于几种常见的 RDMA 技术的协议层次做了非常清晰的对比&lt;/p>
&lt;h3 id="infiniband">Infiniband&lt;/h3>
&lt;p>2000 年由 IBTA（InfiniBand Trade Association）提出的 IB 协议是当之无愧的核心，其规定了一整套完整的链路层到传输层（非传统 OSI 七层模型的传输层，而是位于其之上）规范，但是其无法兼容现有以太网，除了需要支持 IB 的网卡之外，企业如果想部署的话还要重新购买配套的交换设备。&lt;/p>
&lt;h3 id="roce">RoCE&lt;/h3>
&lt;p>RoCE 从英文全称就可以看出它是基于以太网链路层的协议，v1 版本网络层仍然使用了 IB 规范，而 v2 使用了 UDP+IP 作为网络层，使得数据包也可以被路由。RoCE 可以被认为是 IB 的“低成本解决方案”，将 IB 的报文封装成以太网包进行收发。由于 RoCE v2 可以使用以太网的交换设备，所以现在在企业中应用也比较多，但是相同场景下相比 IB 性能要有一些损失。&lt;/p>
&lt;h3 id="iwarp">iWARP&lt;/h3>
&lt;p>iWARP 协议是 IETF 基于 TCP 提出的，因为 TCP 是面向连接的可靠协议，这使得 iWARP 在面对有损网络场景（可以理解为网络环境中可能经常出现丢包）时相比于 RoCE v2 和 IB 具有更好的可靠性，在大规模组网时也有明显的优势。但是大量的 TCP 连接会耗费很多的内存资源，另外 TCP 复杂的流控等机制会导致性能问题，所以从性能上看 iWARP 要比 UDP 的 RoCE v2 和 IB 差。&lt;/p>
&lt;p>需要注意的是，虽然有软件实现的 RoCE 和 iWARP 协议，但是真正商用时上述几种协议都需要专门的硬件（网卡）支持。&lt;/p>
&lt;p>iWARP 本身不是由 Infiniband 直接发展而来的，但是它继承了一些 Infiniband 技术的设计思想。这三种协议的关系如下图所示：&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20240116000125-2024-01-16.png"
alt="20240116000125-2024-01-16" width="60%" loading="lazy"/>
&lt;/figure>
&lt;h2 id="玩家">玩家&lt;/h2>
&lt;h3 id="标准生态组织">标准/生态组织&lt;/h3>
&lt;p>提到 IB 协议，就不得不提到两大组织——IBTA 和 OFA。&lt;/p>
&lt;h3 id="ibta3httpswwwinfinibandtaorg">IBTA&lt;a class="link" href="https://www.infinibandta.org/" target="_blank" rel="noopener" >[3]
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/h3>
&lt;p>成立于 1999 年，负责制定和维护 Infiniband 协议标准。IBTA 独立于各个厂商，通过赞助技术活动和推动资源共享来将整个行业整合在一起，并且通过线上交流、营销和线下活动等方式积极推广 IB 和 RoCE。&lt;/p>
&lt;p>IBTA 会对商用的 IB 和 RoCE 设备进行协议标准符合性和互操作性测试及认证，由很多大型的 IT 厂商组成的委员会领导，其主要成员包括博通，HPE，IBM，英特尔，Mellanox 和微软等，华为也是 IBTA 的会员。&lt;/p>
&lt;h3 id="ofa4httpswwwopenfabricsorg">OFA&lt;a class="link" href="https://www.openfabrics.org/" target="_blank" rel="noopener" >[4]
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/h3>
&lt;p>成立于 2004 年的非盈利组织，负责开发、测试、认证、支持和分发独立于厂商的开源跨平台 infiniband 协议栈，2010 年开始支持 RoCE。其对用于支撑 RDMA/Kernel bypass 应用的 OFED（OpenFabrics Enterprise Distribution）软件栈负责，保证其与主流软硬件的兼容性和易用性。OFED 软件栈包括驱动、内核、中间件和 API。&lt;/p>
&lt;p>上述两个组织是配合关系，IBTA 主要负责开发、维护和增强 Infiniband 协议标准；OFA 负责开发和维护 Infiniband 协议和上层应用 API。&lt;/p>
&lt;h2 id="开发社区">开发社区&lt;/h2>
&lt;h3 id="linux-社区">Linux 社区&lt;/h3>
&lt;p>Linux 内核的 RDMA 子系统还算比较活跃，经常会讨论一些协议细节，对框架的修改比较频繁，另外包括华为和 Mellanox 在内的一些厂商也会经常对驱动代码进行修改。&lt;/p>
&lt;p>邮件订阅：&lt;a class="link" href="http://vger.kernel.org/vger-lists.html#linux-rdma" target="_blank" rel="noopener" >http://vger.kernel.org/vger-lists.html#linux-rdma
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;p>代码位于内核 drivers/infiniband/目录下，包括框架核心代码和各厂商的驱动代码。&lt;/p>
&lt;p>代码仓：&lt;a class="link" href="https://git.kernel.org/pub/scm/linux/kernel/git/rdma/rdma.git/" target="_blank" rel="noopener" >https://git.kernel.org/pub/scm/linux/kernel/git/rdma/rdma.git/
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;h3 id="rdma-社区">RDMA 社区&lt;/h3>
&lt;p>对于上层用户，IB 提供了一套与 Socket 套接字类似的接口——libibverbs，前文所述三种协议都可以使用。参考着协议、API 文档和示例程序很容易就可以写一个 Demo 出来。本专栏中的 RDMA 社区专指其用户态社区，在 github 上其仓库的名字为 linux-rdma。&lt;/p>
&lt;p>主要包含两个子仓库：&lt;/p>
&lt;ul>
&lt;li>rdma-core&lt;/li>
&lt;/ul>
&lt;p>用户态核心代码，API，文档以及各个厂商的用户态驱动。&lt;/p>
&lt;ul>
&lt;li>perftest
一个功能强大的用于测试 RDMA 性能的工具。&lt;/li>
&lt;/ul>
&lt;p>代码仓：&lt;a class="link" href="https://github.com/linux-rdma/" target="_blank" rel="noopener" >https://github.com/linux-rdma/
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;h2 id="ucx5httpswwwopenucxorg">UCX&lt;a class="link" href="https://www.openucx.org/" target="_blank" rel="noopener" >[5]
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/h2>
&lt;p>UCX 是一个建立在 RDMA 等技术之上的用于数据处理和高性能计算的通信框架，RDMA 是其底层核心之一。我们可以将其理解为是位于应用和 RDMA API 之间的中间件，向上层用户又封装了一层更易开发的接口。&lt;/p>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20240116000429-2024-01-16.png"
alt="20240116000429-2024-01-16" width="90%" loading="lazy"/>
&lt;/figure>
&lt;p>笔者对其并不了解太多，只知道业界有一些企业在基于 UCX 开发应用。&lt;/p>
&lt;p>代码仓：&lt;a class="link" href="https://github.com/openucx/ucx" target="_blank" rel="noopener" >https://github.com/openucx/ucx
&lt;span style="white-space: nowrap;">&lt;svg width=".8em" height=".8em" viewBox="0 0 21 21"
xmlns="http://www.w3.org/2000/svg">
&lt;path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor" />
&lt;path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"
fill="currentColor">
&lt;/svg>&lt;/span>
&lt;/a>
&lt;/p>
&lt;h2 id="硬件厂商">硬件厂商&lt;/h2>
&lt;p>设计和生产 IB 相关硬件的厂商有不少，包括 Mellanox、华为、收购了 Qlogic 的 IB 技术的 Intel，博通、Marvell，富士通等等，这里就不逐个展开了，仅简单提一下 Mellanox 和华为。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Mellanox
IB 领域的领头羊，协议标准制定、软硬件开发和生态建设都能看到 Mellanox 的身影，其在社区和标准制定上上拥有最大的话语权。目前最新一代的网卡是支持 200Gb/s 的 ConnextX-6 系列。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>华为
去年初推出的鲲鹏 920 芯片已经支持 100Gb/s 的 RoCE 协议，技术上在国内处于领先地位。但是软硬件和影响力方面距离 Mellanox 还有比较长的路要走，相信华为能够早日赶上老大哥的步伐。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="用户">用户&lt;/h2>
&lt;p>微软、IBM 和国内的阿里、京东都正在使用 RDMA，另外还有很多大型 IT 公司在做初步的开发和测试。在数据中心和高性能计算场景下，RDMA 代替传统网络是大势所趋。笔者对于市场接触不多，所以并不能提供更详细的应用情况。&lt;/p>
&lt;p>下一篇将用比较直观的方式比较一次典型的基于 Socket 的传统以太网和 RDMA 通信过程。&lt;/p></description></item><item><title>RDMA 技术及其编程方法（二）：编程指导</title><link>https://cuterwrite.top/p/rdma-tutorial/2/</link><pubDate>Thu, 27 Jul 2023 01:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/rdma-tutorial/2/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230725145210.webp" alt="Featured image of post RDMA 技术及其编程方法（二）：编程指导" />&lt;h1 id="rdma-技术及其编程方法二编程指导">RDMA 技术及其编程方法（二）：编程指导&lt;/h1>
&lt;h2 id="一libibverbs-简介">一、libibverbs 简介&lt;/h2>
&lt;ul>
&lt;li>libibverbs 由 Roland Dreier 自 2006 年开始开发和维护，实际上是*nix 中的 Verbs API 标准
&lt;ul>
&lt;li>开源&lt;/li>
&lt;li>Verbs 的核心部分自 2005 年起集成到 Linux 内核中&amp;ndash;内核 2.6.11&lt;/li>
&lt;li>Inbox in several *nix distributions&lt;/li>
&lt;li>目前有多个硬件供应商提供的级别较低的库&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对所有启用 RDMA 的传输协议使用相同的 API
&lt;ul>
&lt;li>&lt;strong>InfiniBand&lt;/strong>： 支持 RDMA 的网络体系结构
&lt;ul>
&lt;li>需要支持它的网卡和 InfiniBand 交换机。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>RoCE&lt;/strong>：基于以太网/IP 帧的 RDMA 数据包封装
&lt;ul>
&lt;li>需要支持它的网卡和标准以太网交换机&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>iWARP&lt;/strong>：提供基于流控制传输协议(SCTP)和传输控制协议(TCP)的 RDMA
&lt;ul>
&lt;li>需要支持它的网卡和标准以太网交换机&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>libibverbs 是完全线程安全的
&lt;ul>
&lt;li>libibverbs 本身是线程安全的&lt;/li>
&lt;li>用户态空间低级驱动程序库也是线程安全的&lt;/li>
&lt;li>应用程序可以在多线程中使用 RDMA 资源&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="notice notice-warning" >
&lt;div class="notice-title">&lt;svg t="1705945674099" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16953" width="200" height="200">&lt;path d="M512 106.666667a405.333333 405.333333 0 1 0 405.333333 405.333333A405.333333 405.333333 0 0 0 512 106.666667z m120.533333 489.6a25.621333 25.621333 0 0 1 0 36.266666 25.749333 25.749333 0 0 1-36.266666 0L512 548.266667l-84.266667 84.266666a25.749333 25.749333 0 0 1-36.266666 0 25.621333 25.621333 0 0 1 0-36.266666L475.733333 512l-84.266666-84.266667a25.642667 25.642667 0 0 1 36.266666-36.266666L512 475.733333l84.266667-84.266666a25.642667 25.642667 0 0 1 36.266666 36.266666L548.266667 512z" fill="#ffffff" p-id="16954">&lt;/path>&lt;/svg>&lt;/div>&lt;p>销毁一个线程中的资源并在另一个线程中使用它将导致 segmentation fault，这个问题在非多线程代码中也会发生&lt;/p>&lt;/div>
&lt;ul>
&lt;li>使用 libibverbs 的基本须知
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">tips&lt;/th>
&lt;th style="text-align:left">说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">头文件引入&lt;/td>
&lt;td style="text-align:left">#include&amp;lt;infiniband/verbs.h&amp;gt;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">编译时链接&lt;/td>
&lt;td style="text-align:left">-libverbs&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">所有的 input structures 需要为 zeroed&lt;/td>
&lt;td style="text-align:left">使用 memset()或结构初始化、如果该 structure 有扩充的需求，则零值将保留遗留行为&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">大多数资源句柄都是指针，因此使用错误的句柄可能会导致分段错误&lt;/td>
&lt;td style="text-align:left">使用 NULL 检查句柄&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">返回指针的 Verbs 成功时返回有效值，失败时返回 NULL&lt;/td>
&lt;td style="text-align:left">检查返回值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">返回整形变量的 Verbs 如果成功则返回零，如果成功则返回-1 或 errno&lt;/td>
&lt;td style="text-align:left">检查返回值&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;h2 id="二verbs-api-详解">二、Verbs API 详解&lt;/h2>
&lt;h3 id="1-简介">1. 简介&lt;/h3>
&lt;ul>
&lt;li>在内核和用户态空间均可使用&lt;/li>
&lt;li>Verbs 中的类
&lt;ul>
&lt;li>资源管理：Qps、CQs、SRQs 等等&lt;/li>
&lt;li>WR 处理：post send, 轮询 CQ 等等&lt;/li>
&lt;li>内存注册&lt;/li>
&lt;li>地址句柄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Verbs 中的操作
&lt;ul>
&lt;li>Device 操作&lt;/li>
&lt;li>上下文操作&lt;/li>
&lt;li>PD 操作&lt;/li>
&lt;li>QP bringup&lt;/li>
&lt;li>活跃 QP 操作&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="2-verbs-对象创建层次">2. Verbs 对象创建层次&lt;/h3>
&lt;ol>
&lt;li>获取 devide 列表&lt;/li>
&lt;li>打开请求的 device&lt;/li>
&lt;li>查询 device 功能&lt;/li>
&lt;li>分配 PD 内存空间&lt;/li>
&lt;li>注册内存域 MR&lt;/li>
&lt;li>关联并创建完成队列 CQ&lt;/li>
&lt;li>创建 QP&lt;/li>
&lt;li>Bring up a QP&lt;/li>
&lt;li>Post WR 并且轮询 CQ&lt;/li>
&lt;li>清理资源
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230724235009.webp"
alt="20230724235009" width="90%" loading="lazy"/>
&lt;/figure>
&lt;/li>
&lt;/ol>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230724235116.webp"
alt="20230724235116" width="90%" loading="lazy"/>
&lt;/figure>
&lt;h3 id="3-两个动态库">3. 两个动态库&lt;/h3>
&lt;ul>
&lt;li>libibverbs.so
&lt;ul>
&lt;li>用于直接通过用户态空间访问 InfiniBand 硬件的库&lt;/li>
&lt;li>Infiniband(根据 Infiniband 规范)和 iWarp(iWARP 动词规范)的 RDMA Verbs 的实现&lt;/li>
&lt;li>它处理创建、修改、查询和销毁资源的控制路径，如保护域(PD)、完成队列(CQ)、队列对(QP)、共享接收队列(SRQ)、地址句柄(AH)、内存区域(MR)&lt;/li>
&lt;li>它还处理发送和接收发布到 QPS 和 SRQ 的数据，使用轮询和完成事件从 CQs 获取完成&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>librdmacm.so
&lt;ul>
&lt;li>用户态空间的 RDMA 连接管理器&lt;/li>
&lt;li>使用 Socket 语义的 RDMA(InfiniBand、ROCE 和 iWARP)通信管理库&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="三connection-manager">三、Connection Manager&lt;/h2>
&lt;h3 id="1-连接的建立">1. 连接的建立&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>基于 Infiniband 通信管理(CM)协议（在通用服务接口(GSI)上定义的协议 QP：QP1）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>提供以下服务&lt;/p>
&lt;ul>
&lt;li>在对等 RC 和 QP 之间交换必要的参数，使它们为通信做好准备
&lt;ul>
&lt;li>初始化器请求连接到远程上的服务 ID（服务 ID 映射）&lt;/li>
&lt;li>类 TCP 握手：请求/响应/即用消息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>查找给定服务 ID 的远程 UD 和 QP 序号
&lt;ul>
&lt;li>服务 ID 请求/响应消息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>加载备用路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>连接管理器（Connection Manager，CM）是一个用户态空间的库，它提供了一个通用的接口，用于在 RDMA 网络中建立连接。它可以用于建立连接，也可以用于查找远程 QP 的地址，以便在不建立连接的情况下发送数据。&lt;/p>
&lt;ul>
&lt;li>需要在对等 QP 之间交换信息&lt;/li>
&lt;li>负责 RC、UC、RD 连接的建立&lt;/li>
&lt;li>应用程序使用 SA 来获取其他信息(例如路径记录)&lt;/li>
&lt;li>SIDR 用于 UD&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="2-cm-的抽象类型rdmacm">2. CM 的抽象类型（RDMACM）&lt;/h3>
&lt;ul>
&lt;li>类似于 Socket 连接模式的语义&lt;/li>
&lt;li>对 IB 和 ROCE 都使用基于 IP 的寻址模式&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">类&lt;/th>
&lt;th style="text-align:left">说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>rdma_create/destroy_id&lt;/strong>&lt;/td>
&lt;td style="text-align:left">creates/destroys a connection identifier (equivalent to a socket)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>rdma_create/destroy_qp&lt;/strong>&lt;/td>
&lt;td style="text-align:left">allocate/destroy a qp for communication&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>rdma_bind_addr&lt;/strong>&lt;/td>
&lt;td style="text-align:left">set local port to listen on&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>rdma_resolve_addr&lt;/strong>&lt;/td>
&lt;td style="text-align:left">obtain local RDMA device to reach remote address&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>rdma_resolve_route&lt;/strong>&lt;/td>
&lt;td style="text-align:left">determine route to remote address&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>rdma_get_src_port&lt;/strong>&lt;/td>
&lt;td style="text-align:left">query local port&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>rdma_get_local_addr&lt;/strong>&lt;/td>
&lt;td style="text-align:left">query local ip&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>rdma_get_peer_addr&lt;/strong>&lt;/td>
&lt;td style="text-align:left">query remote ip&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>rdma_connect/disconnect&lt;/strong>&lt;/td>
&lt;td style="text-align:left">connect/disconnect rc qps, or resolve service id to qp for ud qps&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>rdma_listen&lt;/strong>&lt;/td>
&lt;td style="text-align:left">listen for incoming connections&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>rdma_accept/reject&lt;/strong>&lt;/td>
&lt;td style="text-align:left">accept/reject incoming connection requests&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>rdma_create/destroy_event_channel&lt;/strong>&lt;/td>
&lt;td style="text-align:left">allocate/destroy an event channel&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>rdma_get_cm_event&lt;/strong>&lt;/td>
&lt;td style="text-align:left">get next event&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>rdma_ack_cm_event&lt;/strong>&lt;/td>
&lt;td style="text-align:left">acknowledge event(s) to rdmacm&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>rdma_join/leave_multicast&lt;/strong>&lt;/td>
&lt;td style="text-align:left">join/leave multicast addresses&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>使用 rdmacm 的基本须知
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">tips&lt;/th>
&lt;th style="text-align:left">说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">头文件引入&lt;/td>
&lt;td style="text-align:left">#include&amp;lt;rdma/rdma_cma.h&amp;gt;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">编译时链接&lt;/td>
&lt;td style="text-align:left">-lrdmacm&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;h2 id="四-rdmacm-程序解析被动方">四、 RDMACM 程序解析——被动方&lt;/h2>
&lt;p>流程如下：&lt;/p>
&lt;ol>
&lt;li>创建事件 channel，以便我们可以接收 rdmacm 事件，如连接请求和连接建立通知。&lt;/li>
&lt;li>创建连接 ID 并绑定到地址。&lt;/li>
&lt;li>创建 Listener 并返回端口/地址。&lt;/li>
&lt;li>等待连接请求&lt;/li>
&lt;li>创建 PD、CQ 和 Send-Receive QP&lt;/li>
&lt;li>接受连接请求&lt;/li>
&lt;li>等待建立连接&lt;/li>
&lt;li>视情况发布操作&lt;/li>
&lt;/ol>
&lt;h3 id="1-创建事件-channel">1. 创建事件 channel&lt;/h3>
&lt;ul>
&lt;li>打开用于报告通信事件的 channel。异步事件将通过事件 channel 报告给用户，对应方法为&lt;code>struct rdma_event_channel * rdma_create_event_channel(void)&lt;/code>。&lt;/li>
&lt;li>事件 channel 用于定向 rdma_cm_id 上的所有事件。对于许多客户端来说，单个事件 channel 可能就足够了，然而，当管理大量的连接或 cm_id 时，用户可能会发现将不同 cm_id 的事件定向到不同的 channel 进行处理是有用的。&lt;/li>
&lt;li>必须通过调用&lt;code>rdma_destroy_event_channel&lt;/code> 销毁所有创建的事件 channel。用户应该调用&lt;code>rdma_get_cm_event&lt;/code> 来检索事件 channel 上的事件。&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-c">struct rdma_event_channel *channel = rdma_create_event_channel();
if (!channel) {
perror(&amp;quot;rdma_create_event_channel&amp;quot;);
return -1;
}
struct rdma_cm_event* event;
// 此处会阻塞，直到有事件发生
int err = rdma_get_cm_event(channel, &amp;amp;event);
if (err) {
perror(&amp;quot;rdma_get_cm_event&amp;quot;);
return err;
}
// 中间处理代码...
rdma_destroy_event_channel(channel);
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>每个事件 channel 都映射到一个文件描述符。可以像使用和操作任何其他 FD 一样使用和操作关联的文件描述符，以更改其行为。&lt;/li>
&lt;/ul>
&lt;h3 id="2-创建连接-id">2. 创建连接 ID&lt;/h3>
&lt;ul>
&lt;li>创建用于跟踪通信信息的标识符，对应方法为&lt;code>int rdma_create_id(struct rdma_event_channel *channel, struct rdma_cm_id **id, void *context, enum rdma_port_space ps)&lt;/code>。&lt;/li>
&lt;li>输入参数：
&lt;ul>
&lt;li>channel：事件 channel&lt;/li>
&lt;li>id：指向 rdma_cm_id 指针的指针，用于返回新创建的 rdma_cm_id&lt;/li>
&lt;li>context：用户上下文，将在事件中返回给用户&lt;/li>
&lt;li>ps：RDMA 端口空间，指定要使用的端口空间&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>rdma_cm_id 在概念上等同于用于 RDMA 通信的套接字。不同之处在于，RDMA 通信需要显式绑定到指定的 RDMA 设备，然后才能进行通信，并且大多数操作本质上是异步的。&lt;/li>
&lt;li>端口空间
&lt;ul>
&lt;li>RDMA_PS_TCP：提供可靠、面向连接的 QP 通信。与 TCP 不同，RDMA 端口空间提供基于消息的通信，而不是基于流的通信。&lt;/li>
&lt;li>RDMA_PS_UDP：提供不可靠、无连接的 QP 通信。支持数据报和组播通信。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>销毁：在调用此函数并确认相关事件之前，用户必须释放任何与 rdma_cm_id 相关的 QP。&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-c">struct rdma_cm_id *listen_id;
int err = rdma_create_id(channel, &amp;amp;listen_id, NULL, RDMA_PS_TCP);
if (err) {
perror(&amp;quot;rdma_create_id&amp;quot;);
return err;
}
// 中间处理代码...
rdma_destroy_id(listen_id);
&lt;/code>&lt;/pre>
&lt;h3 id="3-绑定地址">3. 绑定地址&lt;/h3>
&lt;ul>
&lt;li>将源地址与 rdma_cm_id 相关联。对应方法为&lt;code>int rdma_bind_addr(struct rdma_cm_id *id, struct sockaddr *addr)&lt;/code>。
&lt;ul>
&lt;li>地址中可以包含通配符。&lt;/li>
&lt;li>如果绑定到特定本地地址，则 rdma_cm_id 也将绑定到本地 RDMA 设备。&lt;/li>
&lt;li>通常，在调用&lt;code>rdma_listen&lt;/code> 以绑定到特定端口号之前调用此函数，但也可以在调用&lt;code>rdma_resolve_addr&lt;/code> 以绑定到特定地址之前在主动方调用该函数。&lt;/li>
&lt;li>如果用于绑定到端口 0，rdma_cm 将选择一个可用端口，可以使用&lt;code>rdma_get_src_port&lt;/code> 检索该端口。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-c">/* sockaddr_in 是 IPV4 的地址结构体
* AF_INET：IPV4
* htons：将主机字节序转换为网络字节序（小端存储）, 20079 是端口号
* INADDR_ANY：表示任意地址
*/
struct sockaddr_in addr = {
.sin_family = AF_INET,
.sin_port = htons(20079),
.sin_addr = { .s_addr = INADDR_ANY },
};
err = rdma_bind_addr(listen_id, (struct sockaddr *)&amp;amp;addr);
if (err) {
perror(&amp;quot;rdma_bind_addr&amp;quot;);
return err;
}
&lt;/code>&lt;/pre>
&lt;h3 id="4-创建-listener返回端口地址">4. 创建 Listener，返回端口/地址&lt;/h3>
&lt;ul>
&lt;li>初始化传入连接请求或数据报服务查找的 Listener。对应方法为&lt;code>int rdma_listen(struct rdma_cm_id *id, int backlog)&lt;/code>。
&lt;ul>
&lt;li>侦听将被限制为本地绑定源地址&lt;/li>
&lt;li>在调用此函数之前，用户必须已通过调用&lt;code>rdma_bind_addr&lt;/code> 将&lt;code>rdma_cm_id&lt;/code> 绑定到本地地址。&lt;/li>
&lt;li>如果&lt;code>rdma_cm_id&lt;/code> 绑定到特定的 IP 地址，则侦听将仅限于该地址和关联的 RDMA 设备。&lt;/li>
&lt;li>如果&lt;code>rdma_cm_id&lt;/code> 仅绑定到 RDMA 端口号，则将在所有 RDMA 设备上进行侦听。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>返回已绑定到本地地址的&lt;code>rdma_cm_id&lt;/code> 的本地端口号。对应方法为&lt;code>uint16_t rdma_get_src_port(struct rdma_cm_id *id)&lt;/code>。&lt;/li>
&lt;li>返回已绑定到本地设备的&lt;code>rdma_cm_id&lt;/code> 的本地 IP 地址。对应方法为&lt;code>struct sockaddr * rdma_get_local_addr(struct rdma_cm_id *id)&lt;/code>。&lt;/li>
&lt;li>解析目的节点和服务地址，并返回建立通信所需的信息。提供与 getaddrinfo 等效的 RDMA 功能(配合&lt;code>rdma_create_ep&lt;/code> 使用)。对应方法为&lt;code>int rdma_getaddrinfo (char *node, char *service, struct rdma_addrinfo *hints, struct rdma_addrinfo **res)&lt;/code>。
&lt;ul>
&lt;li>node: 可选，目的节点的主机名，或者点分十进制的 IPv4/IPv6 十六进制地址&lt;/li>
&lt;li>service：地址的服务名称或端口号。&lt;/li>
&lt;li>hints：一个包含有关调用方支持的服务类型的提示的 rdma_addrinfo 结构的引用。&lt;/li>
&lt;li>res：指向包含响应信息的 rdma_addrinfo 结构的 LinkedList 的指针。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-c">// 等待连接请求的最大数量
int backlog = 10;
err = rdma_listen(listen_id, backlog);
if (err) {
perror(&amp;quot;rdma_listen&amp;quot;);
return err;
}
uint16_t port = rdma_get_src_port(listen_id);
port = ntohs(port);
printf(&amp;quot;listening on port %u.\n&amp;quot;, port);
struct sockaddr *local_addr = rdma_get_local_addr(listen_id);
if (local_addr-&amp;gt;sa_family == AF_INET) {
struct sockaddr_in *sin = (struct sockaddr_in *)local_addr;
char ip[INET_ADDRSTRLEN];
// 需要加上头文件 #include &amp;lt;arpa/inet.h&amp;gt;
inet_ntop(AF_INET, &amp;amp;(sin-&amp;gt;sin_addr), ip, INET_ADDRSTRLEN);
printf(&amp;quot;Local IP address is: %s\n&amp;quot;, ip);
printf(&amp;quot;Local port is: %d\n&amp;quot;, ntohs(sin-&amp;gt;sin_port));
}
struct rdma_addrinfo hints;
memset(&amp;amp;hints, 0, sizeof(hints));
hints.ai_flags = RAI_PASSIVE;
hints.ai_port_space = RDMA_PS_TCP;
struct rdma_addrinfo *res;
err = rdma_getaddrinfo(NULL, &amp;quot;20079&amp;quot;, &amp;amp;hints, &amp;amp;res);
if (err) {
perror(&amp;quot;rdma_getaddrinfo&amp;quot;);
return err;
}
// do something with struct rdma_addrinfo *cur = res...
&lt;/code>&lt;/pre>
&lt;h3 id="5-等待连接请求">5. 等待连接请求&lt;/h3>
&lt;ul>
&lt;li>检索通信事件。如果没有挂起的事件，默认情况下，调用将阻塞，直到接收到事件。对应方法为&lt;code>int rdma_get_cm_event(struct rdma_event_channel *channel, struct rdma_cm_event **event)&lt;/code>。&lt;/li>
&lt;li>通过修改与给定通道相关联的文件描述符，可以更改此函数的默认同步行为。&lt;/li>
&lt;li>所有报告的事件都必须通过调用&lt;code>rdma_ack_cm_event&lt;/code> 进行确认。&lt;/li>
&lt;li>&lt;code>rdma_cm_id&lt;/code> 的销毁将被阻塞，直到相关事件被确认。&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-c">struct rdma_cm_event* event;
// 此处会阻塞，直到有事件发生
err = rdma_get_cm_event(channel, &amp;amp;event);
&lt;/code>&lt;/pre>
&lt;h3 id="6-创建-pdcq-和-send-receive-qp">6. 创建 PD、CQ 和 Send-Receive QP&lt;/h3>
&lt;ul>
&lt;li>分配与指定的&lt;code>rdma_cm_id&lt;/code> 相关联的 QP，并将其转换为用于发送和接收。对应方法为&lt;code>int rdma_create_qp(struct rdma_cm_id *id, struct ibv_pd *pd, struct ibv_qp_init_attr *qp_init_attr)&lt;/code>。&lt;/li>
&lt;li>在调用此函数之前，&lt;code>rdma_cm_id&lt;/code> 必须绑定到本地 RDMA 设备，且保护域 PD 必须用于同一设备。&lt;/li>
&lt;li>被分配给&lt;code>rdma_cm_id&lt;/code> 的 QP 会由 librdmacm 自动转换状态.&lt;/li>
&lt;li>分配完毕后，QP 将准备就绪，处理接收信息的发布。如果 QP 未连接，它将准备好发布发送。&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-c">pd = ibv_alloc_pd(cm_client_id-&amp;gt;verbs);
if (!pd) {
perror(&amp;quot;Failed to allocate a protection domain&amp;quot;);
return -1;
}
io_completion_channel = ibv_create_comp_channel(cm_client_id-&amp;gt;verbs);
if (!io_completion_channel) {
perror(&amp;quot;Failed to create an I/O completion event channel&amp;quot;);
return -1;
}
cq = ibv_create_cq(cm_client_id-&amp;gt;verbs, 10, NULL, io_completion_channel, 0);
if (!cq) {
perror(&amp;quot;Failed to create a completion queue&amp;quot;);
return -1;
}
ret = ibv_req_notify_cq(cq, 0);
if (ret) {
perror(&amp;quot;Failed to request notifications&amp;quot;);
return -1;
}
bzero(&amp;amp;qp_init_attr, sizeof(qp_init_attr));
qp_init_attr.qp_type = IBV_QPT_RC;
qp_init_attr.cap.max_send_wr = 10;
qp_init_attr.cap.max_recv_wr = 10;
qp_init_attr.cap.max_send_sge = 1;
qp_init_attr.cap.max_recv_sge = 1;
qp_init_attr.send_cq = cq;
qp_init_attr.recv_cq = cq;
ret = rdma_create_qp(cm_client_id, pd, &amp;amp;qp_init_attr);
if (ret) {
perror(&amp;quot;Failed to create QP&amp;quot;);
return -1;
}
client_qp = cm_client_id-&amp;gt;qp;
&lt;/code>&lt;/pre>
&lt;h3 id="7-最后的操作">7. 最后的操作&lt;/h3>
&lt;ol>
&lt;li>Accept 请求连接&lt;/li>
&lt;li>等待连接建立&lt;/li>
&lt;li>发布操作&lt;/li>
&lt;/ol>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230725224928.webp"
alt="20230725224928" width="90%" loading="lazy"/>
&lt;/figure>
&lt;h2 id="五-rdmacm-程序解析主动方">五、 RDMACM 程序解析——主动方&lt;/h2>
&lt;h3 id="1-创建事件-channel-1">1. 创建事件 channel&lt;/h3>
&lt;ul>
&lt;li>与被动方相同&lt;/li>
&lt;/ul>
&lt;h3 id="2-创建连接-id-1">2. 创建连接 ID&lt;/h3>
&lt;ul>
&lt;li>与被动方相同&lt;/li>
&lt;/ul>
&lt;h3 id="3-绑定地址-1">3. 绑定地址&lt;/h3>
&lt;ul>
&lt;li>将目的地址和可选源地址从 IP 地址解析为 RDMA 地址。如果成功，则指定的 rdma_cm_id 将绑定到本地设备。对应方法为&lt;code>int rdma_resolve_addr (struct rdma_cm_id *id, struct sockaddr *src_addr, struct sockaddr *dst_addr, int timeout_ms)&lt;/code>。&lt;/li>
&lt;li>此方法用于将给定的目标 IP 地址映射到可用的 RDMA 地址。&lt;/li>
&lt;li>IP 到 RDMA 地址的映射使用本地路由表或通过 ARP 完成。&lt;/li>
&lt;li>如果给定源地址，则将&lt;code>rdma_cm_id&lt;/code> 绑定到该地址，就像调用&lt;code>rdma_ind_addr&lt;/code> 一样。&lt;/li>
&lt;li>如果没有给出源地址，并且&lt;code>rdma_cm_id&lt;/code> 尚未绑定到设备，则&lt;code>rdma_cm_id&lt;/code> 将根据本地路由表绑定到源地址。&lt;/li>
&lt;li>在此方法调用之后，&lt;code>rdma_cm_id&lt;/code> 将绑定到 RDMA 设备。&lt;/li>
&lt;li>该方法调用通常在调用 &lt;code>rdma_resolve_route&lt;/code> 和 &lt;code>rdma_connect&lt;/code> 之前在主动方上进行。&lt;/li>
&lt;/ul>
&lt;div class="notice notice-note" >
&lt;div class="notice-title">&lt;svg t="1705946198814" class="icon notice-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23141" width="200" height="200">&lt;path d="M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864a149.333333 149.333333 0 0 1-149.333334 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z m426.666667 0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667l38.101333 58.794667c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864a149.333333 149.333333 0 0 1-149.333333 149.333333 165.162667 165.162667 0 0 1-117.248-50.304z" p-id="23142" fill="#ffffff">&lt;/path>&lt;/svg>&lt;/div>&lt;p>InfiniBand 特定&lt;/p>&lt;/div>
&lt;ul>
&lt;li>此方法还会将目标 IP 地址和源 IP 地址(如果给定)映射到 GID。&lt;/li>
&lt;li>为了执行映射，IPoIB 必须同时在本地和远程节点上运行。&lt;/li>
&lt;/ul>
&lt;h3 id="4-创建-qp">4. 创建 QP&lt;/h3>
&lt;ul>
&lt;li>与被动方相同&lt;/li>
&lt;/ul>
&lt;h3 id="5-解析路由">5. 解析路由&lt;/h3>
&lt;ul>
&lt;li>解析指向目标地址的 RDMA 路由，以建立连接。目标地址必须已通过调用 rdma_resolve_addr 解析。对应方法为&lt;code>int rdma_resolve_route (struct rdma_cm_id *id, int timeout_ms);&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="6-建立连接">6. 建立连接&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>对应方法为&lt;code>int rdma_connect (struct rdma_cm_id *id, struct rdma_conn_param *conn_param);&lt;/code>&lt;/p>
&lt;ul>
&lt;li>id：指向 rdma_cm_id 的指针&lt;/li>
&lt;li>conn_param：指向 rdma_conn_param 结构的指针，包含连接参数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>对于 &lt;code>RDMA_PS_TCP&lt;/code> 类型的 &lt;code>rdma_cm_id&lt;/code>，该调用会向远程目的地发起连接请求&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于 &lt;code>RDMA_PS_UDP&lt;/code> 类型的 &lt;code>rdma_cm_id&lt;/code>，它会启动对提供数据报服务的远程 QP 的查询&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="7-最后的操作-1">7. 最后的操作&lt;/h3>
&lt;ol>
&lt;li>等待连接建立&lt;/li>
&lt;li>发布操作&lt;/li>
&lt;/ol>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230725225927.webp"
alt="20230725225927" width="90%" loading="lazy"/>
&lt;/figure>
&lt;hr>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230725225943.webp"
alt="20230725225943" width="90%" loading="lazy"/>
&lt;/figure>
&lt;h2 id="六实战基于-rdma-的-client-server-程序">六、实战：基于 RDMA 的 client-server 程序&lt;/h2>
&lt;h3 id="1-server-端">1. server 端&lt;/h3>
&lt;ul>
&lt;li>工作流程：
&lt;ol>
&lt;li>初始化 RDMA 资源&lt;/li>
&lt;li>等待 client 连接&lt;/li>
&lt;li>分配并固定服务器缓冲区 buffer&lt;/li>
&lt;li>接受客户端连接&lt;/li>
&lt;li>将有关本地服务器缓冲区的信息发送到客户端&lt;/li>
&lt;li>等待断开连接&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h3 id="2-client-端">2. client 端&lt;/h3>
&lt;ul>
&lt;li>工作流程：
&lt;ol>
&lt;li>初始化 RDMA 资源&lt;/li>
&lt;li>连接 server&lt;/li>
&lt;li>通过发送/接收 exchange 接收服务器端缓冲区信息&lt;/li>
&lt;li>从（第一个）本地缓冲区向服务器缓冲区进行 RDMA 写入。&lt;/li>
&lt;li>进行 RDMA 读取，将服务器缓冲区的内容读入第二个本地缓冲区。&lt;/li>
&lt;li>比较第一缓冲区和第二缓冲区的内容，并进行匹配&lt;/li>
&lt;li>断开连接&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h3 id="3-项目实现">3. 项目实现&lt;/h3>
&lt;div class="github">
&lt;div class="logo">
&lt;svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 16 16">&lt;path fill-rule="evenodd" clip-rule="evenodd" d="M2 2.5C2 1.83696 2.26339 1.20107 2.73223 0.732233C3.20108 0.263392 3.83696 0 4.5 0L13.25 0C13.4489 0 13.6397 0.0790176 13.7803 0.21967C13.921 0.360322 14 0.551088 14 0.75V13.25C14 13.4489 13.921 13.6397 13.7803 13.7803C13.6397 13.921 13.4489 14 13.25 14H10.75C10.5511 14 10.3603 13.921 10.2197 13.7803C10.079 13.6397 10 13.4489 10 13.25C10 13.0511 10.079 12.8603 10.2197 12.7197C10.3603 12.579 10.5511 12.5 10.75 12.5H12.5V10.5H4.5C4.30308 10.5 4.11056 10.5582 3.94657 10.6672C3.78257 10.7762 3.65442 10.9312 3.57816 11.1128C3.50191 11.2943 3.48096 11.4943 3.51793 11.6878C3.5549 11.8812 3.64816 12.0594 3.786 12.2C3.92524 12.3422 4.0023 12.5338 4.00024 12.7328C3.99818 12.9318 3.91716 13.1218 3.775 13.261C3.63285 13.4002 3.4412 13.4773 3.24222 13.4752C3.04325 13.4732 2.85324 13.3922 2.714 13.25C2.25571 12.7829 1.99929 12.1544 2 11.5V2.5ZM12.5 1.5V9H4.5C4.144 9 3.806 9.074 3.5 9.208V2.5C3.5 2.23478 3.60536 1.98043 3.79289 1.79289C3.98043 1.60536 4.23478 1.5 4.5 1.5H12.5ZM5 12.25V15.5C5 15.5464 5.01293 15.5919 5.03734 15.6314C5.06175 15.6709 5.09667 15.7028 5.1382 15.7236C5.17972 15.7444 5.22621 15.7532 5.27245 15.749C5.31869 15.7448 5.36286 15.7279 5.4 15.7L6.85 14.613C6.89328 14.5805 6.94591 14.563 7 14.563C7.05409 14.563 7.10673 14.5805 7.15 14.613L8.6 15.7C8.63714 15.7279 8.68131 15.7448 8.72755 15.749C8.77379 15.7532 8.82028 15.7444 8.8618 15.7236C8.90333 15.7028 8.93826 15.6709 8.96266 15.6314C8.98707 15.5919 9 15.5464 9 15.5V12.25C9 12.1837 8.97366 12.1201 8.92678 12.0732C8.87989 12.0263 8.81631 12 8.75 12H5.25C5.1837 12 5.12011 12.0263 5.07322 12.0732C5.02634 12.1201 5 12.1837 5 12.25Z"/>&lt;/svg>
&lt;a class="name" href=https://github.com/PKUcoldkeyboard/RDMA-examples target="_blank">RDMA-examples&lt;/a>
&lt;/div>
&lt;div class="description">RDMA-examples: A repository of practical code examples showcasing the fundamental concepts and usage of RDMA (Remote Direct Memory Access) technology.&lt;/div>
&lt;div class="language">
&lt;span class="language-color" style="background-color: #555555">&lt;/span>
&lt;span class="language-name">C&lt;/span>
&lt;/div>
&lt;/div>
&lt;h3 id="4-补充rdma-应用程序标准流程">4. 补充：RDMA 应用程序标准流程&lt;/h3>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230729185145.webp"
alt="20230729185145" width="90%" loading="lazy"/>
&lt;/figure>
&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;ul>
&lt;li>Mellanox Technologies, Inc. (2017). RDMA Aware Networks Programming User Manual. Mellanox Technologies, Inc.&lt;/li>
&lt;/ul></description></item><item><title>RDMA 技术及其编程方法（一）：RDMA 简介与原理</title><link>https://cuterwrite.top/p/rdma-tutorial/1/</link><pubDate>Fri, 21 Jul 2023 01:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/rdma-tutorial/1/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230722162905.webp" alt="Featured image of post RDMA 技术及其编程方法（一）：RDMA 简介与原理" />&lt;h1 id="rdma-技术及其编程方法一rdma-技术">RDMA 技术及其编程方法（一）：RDMA 技术&lt;/h1>
&lt;h2 id="一-rdma-技术简介">一、 RDMA 技术简介&lt;/h2>
&lt;ul>
&lt;li>RDMA: Remote Direct Memory Access
&lt;ul>
&lt;li>RDMA 就是一种远程直接内存访问技术，它可以让远程主机直接访问本地内存，而不需要经过 CPU 的参与，从而大大减少了 CPU 的开销，提高了数据传输的效率。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">术语&lt;/th>
&lt;th style="text-align:center">含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">Remote&lt;/td>
&lt;td style="text-align:center">数据在同一网络中的节点之间传输&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Direct&lt;/td>
&lt;td style="text-align:center">（1）传输过程没有操作系统内核的参与 （2）所有关于传输的协议都负载在网卡上&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Memory&lt;/td>
&lt;td style="text-align:center">（1）在用户态的应用程序的虚拟内存之间传输（2）没有额外的内存拷贝或缓存&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Access&lt;/td>
&lt;td style="text-align:center">send、receive、read、write、原子操作&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>RDMA 的各种协议
&lt;ul>
&lt;li>InfiniBand - (41.8% of top 500 supercomputers)
&lt;ul>
&lt;li>InfiniBand 是一个工业标准的分组交换网络&lt;/li>
&lt;li>在高性能计算机系统中越来越多地被采用&lt;/li>
&lt;li>用户层网络，可绕过操作系统内核&lt;/li>
&lt;li>SDR 4x - 8 Gbps&lt;/li>
&lt;li>DDR 4x - 16 Gbps&lt;/li>
&lt;li>QDR 4x - 32 Gbps&lt;/li>
&lt;li>FDQ 4x - 54 Gbps&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>RoCE - RDMA over Converged Ethernet
&lt;ul>
&lt;li>允许在以太网络上执行 RDMA 的网络协议&lt;/li>
&lt;li>RoCE v1 - 10 Gbps&lt;/li>
&lt;li>RoCE v2 - 25 Gbps&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>iWarp - internet Wide Area RDMA Protocol
&lt;ul>
&lt;li>运行在 TCP/IP 协议栈上的 RDMA 协议&lt;/li>
&lt;li>10 Gbps&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>RDMA 的支持嵌入在内核之中：Kernel 中的 drivers/infiniband&lt;/li>
&lt;li>RDMA 协议优势
&lt;ol>
&lt;li>&lt;strong>Zero-copy&lt;/strong>：零拷贝，能够读写远程内存，能够直接访问远程缓冲区，无需在不同软件层之间复制数据&lt;/li>
&lt;li>&lt;strong>Kernel bypass&lt;/strong>：跳过内核，可在相同的代码上下文（即用户空间或内核）中收发数据，节省了上下文切换时间&lt;/li>
&lt;li>&lt;strong>No CPU involvement&lt;/strong>：无 CPU 参与，可使用专用硬件收发数据，而不需要 CPU 干预。可降低远程端的 CPU 使用率，因为不需要它执行任何主动操作&lt;/li>
&lt;li>&lt;strong>Message based transactions&lt;/strong>：基于消息的事务，可在不同的连接上同时执行多个事务，而无需等待任何事务完成&lt;/li>
&lt;li>&lt;strong>Scatter/gather entries support&lt;/strong>：支持分散/聚集条目，可在单个操作中传输多个缓冲区，而无需将它们合并到单个缓冲区中&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h2 id="二-rdma-工作原理">二、 RDMA 工作原理&lt;/h2>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230722174248.webp"
alt="20230722174248" width="90%" loading="lazy"/>
&lt;/figure>
&lt;h3 id="1-infiband-与以太网的对比">1. Infiband 与以太网的对比&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Feature/Network Type&lt;/th>
&lt;th style="text-align:center">InfiniBand&lt;/th>
&lt;th style="text-align:center">Ethernet&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">Addressing&lt;/td>
&lt;td style="text-align:center">lids, gid&lt;/td>
&lt;td style="text-align:center">macs, IP addresses&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Path resolution&lt;/td>
&lt;td style="text-align:center">Path queries&lt;/td>
&lt;td style="text-align:center">ARP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Lossless network&lt;/td>
&lt;td style="text-align:center">Credit-based flow control&lt;/td>
&lt;td style="text-align:center">Pause frames/PFC&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">QoS&lt;/td>
&lt;td style="text-align:center">SLs/VLs&lt;/td>
&lt;td style="text-align:center">Priorities/TC&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Virtual networks&lt;/td>
&lt;td style="text-align:center">Pkeys&lt;/td>
&lt;td style="text-align:center">VLANs&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>可以看到，InfiniBand 与以太网的区别首先在于网络地址的表示方式不同，以太网使用 mac 地址和 IP 地址，而 InfiniBand 使用 lid 和 gid&lt;/li>
&lt;li>其次，网络的路径解析方式不同，以太网使用 ARP 地址解析协议，而 InfiniBand 使用 path queries；&lt;/li>
&lt;li>然后，在网络的可靠性方面，以太网使用 Pause frames/PFC（Priority-based Flow Control，基于优先级的流量控制），而 InfiniBand 使用的是 Credit-based flow control(基于信用的流量控制)&lt;/li>
&lt;li>接着在网络的服务质量方面，以太网使用 Priorities/TC（Traffic Class，流量类别），而 InfiniBand 使用 SLs/VLs（Service Level，服务等级）&lt;/li>
&lt;li>最后，在网络的虚拟化方面，以太网使用 VLANs（Virtual Local Area Network，虚拟局域网），而 InfiniBand 使用 Pkeys（Partition Keys，分区键）。&lt;/li>
&lt;/ul>
&lt;h3 id="2-rdma-中的重要概念">2. RDMA 中的重要概念&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">缩写&lt;/th>
&lt;th style="text-align:center">全称&lt;/th>
&lt;th style="text-align:center">说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">PD&lt;/td>
&lt;td style="text-align:center">Protection Domain&lt;/td>
&lt;td style="text-align:center">保护域，是 RDMA 中的一种资源管理机制。PD 定义了一组内存区域和访问权限，用于控制 RDMA 操作的安全性。PD 与 QP、MR 均有关联。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">MR&lt;/td>
&lt;td style="text-align:center">Memory Region&lt;/td>
&lt;td style="text-align:center">内存区域，是 RDMA 中的一种抽象，用于描述应用程序中的内存区域。MR 定义了一块内存区域的起始地址、大小和访问权限，并与 PD 关联。包含 R_Key 和 L_Key。MR 的配套机制用来解决 RDMA 操作中的两个问题：（1）APP 提供的地址都是虚拟地址，经过 MMU 的转换才能得到真实的物理地址，RDMA 网卡是如何得到真实物理地址从而去内存中读取或写入数据的？（2）假设网卡有能力获取目的地址，但如果用户恶意指定了一个非法的虚拟地址，网卡就有可能被指使去读写系统关键内存，如何预防？因此，MR 的作用之一就是实现虚拟地址与物理地址的转换，APP 只能看到虚拟地址，而且会在发起 RDMA Write 时把本地和对端的内存的虚拟地址传递给 RDMA 网卡。网卡需要知道 APP 提供的虚拟地址所对应的物理地址才能访问系统内存。在注册 MR 的过程中，软件会在内存中创建并填写一个虚拟地址到物理地址的映射表供网卡查询。MR 的第二个作用是控制 HCA 访问内存的权限，程序在注册 MR 时会产生两把钥匙 L_KEY（Local）和 R_KEY（Remote）。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">QP&lt;/td>
&lt;td style="text-align:center">Queue Pair&lt;/td>
&lt;td style="text-align:center">队列对，是 RDMA 中的一种通信机制。QR 由发送队列（Send Queue, SQ）和接收队列（Receive Queue, RQ）组成，用于发送和接收 RDMA 操作的请求和数据。SQ 专门用来存放发送任务，RQ 专门用来存放接收任务。在一次 SEND-RECV 流程中，发送端需要把表示一次发送任务的 WR 放到 SQ 里面(这种操作称为 Post Send)，接收端需要把表示一次接收任务的 WR 放到 QP 里面（称为 Post Receive），这样硬件才知道收到数据之后放到内存中的哪个位置。在 RDMA 中，通信的基本对象是 QP，而不是节点。对于每个节点来说，每个进程都可以申请和使用若干个 QP，而每个本地 QP 可以连接到一个远端的 QP。每个节点中的 QP 都有一个唯一的编号，称为 QPN，通过 QPN 可以唯一确定一个节点上的 QP。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">CQ&lt;/td>
&lt;td style="text-align:center">Completion Queue&lt;/td>
&lt;td style="text-align:center">完成队列，用于存储 RDMA 操作的完成事件。当 RDMA 操作完成时，相关的完成事件会被放入 CQ 中，应用程序可以通过轮询或事件通知方式获取这些完成事件。CQ 与 QP 相关联。CQ 中有很多元素，称为 CQE。CQE 是硬件完成任务之后返回给软件的“完成报告”，与 WR 相反。每个 CQE 都包含某个 WR 的完成信息。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">WR&lt;/td>
&lt;td style="text-align:center">Work Request&lt;/td>
&lt;td style="text-align:center">工作请求，用于描述 RDMA 操作的请求。WR 包含了操作类型、源地址、目的地址等信息，应用程序通过将 WR 放入 QP 的发送队列来触发 RDMA 操作。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">SGE&lt;/td>
&lt;td style="text-align:center">Scatter/Gather Element&lt;/td>
&lt;td style="text-align:center">即将读或写的内存地址。必须提供 L_Key 或 R_Key 来认证 MR 的连接&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">WC&lt;/td>
&lt;td style="text-align:center">Work Completion&lt;/td>
&lt;td style="text-align:center">工作完成，用于描述 RDMA 操作的完成事件。WC 包含了操作类型、状态、传输长度等信息，应用程序可以通过读取 CQ 中的 WC 来获取 RDMA 操作的结果。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="3-qpswrs-执行模型">3. QPs/WRs 执行模型&lt;/h3>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230722225719.webp"
alt="20230722225719" width="90%" loading="lazy"/>
&lt;/figure>
&lt;ul>
&lt;li>硬件提供
&lt;ul>
&lt;li>针对每个 QP 上下文&lt;/li>
&lt;li>虚拟到物理内存的转换&lt;/li>
&lt;li>安全的进程控制机制&lt;/li>
&lt;li>可靠性(取决于传输服务)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>操作系统管理资源创建
&lt;ul>
&lt;li>但不发布 WR 和轮询 CQ&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>结果
&lt;ul>
&lt;li>应用程序以安全的方式直接访问硬件&lt;/li>
&lt;li>软件处理缓冲区而不是信息包&lt;/li>
&lt;li>在快速路径中不需要操作系统干预。&lt;/li>
&lt;li>完全异步的过程&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="4-通信语义">4. 通信语义&lt;/h3>
&lt;ul>
&lt;li>Channel（消息传递）
&lt;ul>
&lt;li>请求者提供源缓冲区&lt;/li>
&lt;li>接收者提供目的缓冲区&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Remote Direct Memory Access（RDMA）
&lt;ul>
&lt;li>请求者同时提供源缓冲区和目标缓冲区&lt;/li>
&lt;li>同时支持 RDMA 读取和写入&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="5-传输服务">5. 传输服务&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>分类：Connected（连接）与 Datagram（数据报）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分类：Reliable（可靠）与 Unreliable（不可靠）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>两两组合形成四种类型的传输：&lt;/p>
&lt;ul>
&lt;li>Reliable Connected（RC），例如 TCP&lt;/li>
&lt;li>Unreliable Datagram（UD），例如 UDP&lt;/li>
&lt;li>UC 也可以实现&lt;/li>
&lt;li>RD 不支持，虽然它是由规范定义的，但在 API/DIVER/硬件中不支持&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>QP 的传输类型：&lt;/p>
&lt;ul>
&lt;li>可靠连接 RC
&lt;ul>
&lt;li>QP 仅与一个远程 QP 关联&lt;/li>
&lt;li>由一个 QP 的发送队列发送的消息被可靠地递送到另一个 QP 的接收队列。&lt;/li>
&lt;li>数据包按顺序发送&lt;/li>
&lt;li>发送端，每条消息都被划分为长度为路径 MTU 的数据包，接收方将数据包重组为消息。支持发送、RDMA write/read&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>不可靠连接 RC
&lt;ul>
&lt;li>QP 仅与一个远程 QP 关联&lt;/li>
&lt;li>连接是不可靠的，即发送的数据包可能会丢失&lt;/li>
&lt;li>消息出错时不会重传，错误处理必须由更高级别的协议提供。&lt;/li>
&lt;li>支持发送、RDMA write&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>不可靠数据报 UD
&lt;ul>
&lt;li>队列对可以向/从任何其他多个 QP 发送和接收单数据包消息。&lt;/li>
&lt;li>不能保证有序和数据包到达，并且发送的数据包可能会被接收方丢弃。&lt;/li>
&lt;li>支持广播消息(一对多)&lt;/li>
&lt;li>只支持发送操作&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>RDMA 支持的传输操作&lt;/p>
&lt;ul>
&lt;li>Send（立即）
&lt;ul>
&lt;li>发送方需要加上时间戳&lt;/li>
&lt;li>接收方也需要在某些地方加上该时间戳用来标识该消息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>RDMA Write（立即）&lt;/li>
&lt;li>RDMA Read（异步）&lt;/li>
&lt;li>Atomic operations（原子操作）
&lt;ul>
&lt;li>发送方发送读/写请求，并指定其将访问读写的本地和远程地址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Send 操作流程：&lt;/p>
&lt;ul>
&lt;li>接收方需要发送接收请求（Receive Request, RR）给发送方&lt;/li>
&lt;li>发送方发送 Send 操作请求（Send Request, SR）给接收方&lt;/li>
&lt;li>只在可靠连接中发送 ACK&lt;/li>
&lt;li>接收方轮询 CQ，获取 SR 的完成事件&lt;/li>
&lt;li>发送方轮询 CQ，获取 RR 的完成事件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230722232438.webp"
alt="20230722232438" width="90%" loading="lazy"/>
&lt;/figure>
&lt;ul>
&lt;li>RDMA Write 操作流程：
&lt;ul>
&lt;li>请求方发送 Send 操作请求（Send Request, SR）加上远程地址与 key 给接收方&lt;/li>
&lt;li>只在可靠连接中发送 ACK&lt;/li>
&lt;li>请求方轮询 CQ，获取 SR 的完成事件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>RDMA Write 操作是一端应用主动写入远端内存的行为，除了准备阶段，远端 CPU 不需要参与，也不感知何时有数据写入、数据在何时接收完毕，所以这是一种单端操作。&lt;/li>
&lt;li>需要注意的是，操作发起端的应用程序是通过虚拟地址来读写远端内存的，上层应用可以非常方便的对其进行操作。实际的虚拟地址——物理地址的转换由 RDMA 网卡完成。&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230722232556.webp"
alt="20230722232556" width="90%" loading="lazy"/>
&lt;/figure>
&lt;ul>
&lt;li>RDMA Read 与 Atomic 操作流程：
&lt;ul>
&lt;li>请求方发送 Send 操作请求（Send Request, SR）加上远程地址与 key 给接收方&lt;/li>
&lt;li>只在可靠连接中发送 ACK&lt;/li>
&lt;li>请求方轮询 CQ，获取 SR 的完成事件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230722232758.webp"
alt="20230722232758" width="90%" loading="lazy"/>
&lt;/figure>
&lt;ul>
&lt;li>小结：UD、UC、RC 三种 QP 传输方式对比，w/o-&amp;gt;with/without
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">操作原语&lt;/th>
&lt;th style="text-align:center">UD&lt;/th>
&lt;th style="text-align:center">UC&lt;/th>
&lt;th style="text-align:center">RC&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">Send(w/o immediate)&lt;/td>
&lt;td style="text-align:center">支持&lt;/td>
&lt;td style="text-align:center">支持&lt;/td>
&lt;td style="text-align:center">支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">RDMA Write(w/o immediate)&lt;/td>
&lt;td style="text-align:center">不支持&lt;/td>
&lt;td style="text-align:center">支持&lt;/td>
&lt;td style="text-align:center">支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">RDMA Read&lt;/td>
&lt;td style="text-align:center">不支持&lt;/td>
&lt;td style="text-align:center">不支持&lt;/td>
&lt;td style="text-align:center">支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Atomic operations&lt;/td>
&lt;td style="text-align:center">不支持&lt;/td>
&lt;td style="text-align:center">不支持&lt;/td>
&lt;td style="text-align:center">支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">连接类型&lt;/td>
&lt;td style="text-align:center">数据报（一对多）&lt;/td>
&lt;td style="text-align:center">连接（一对一）&lt;/td>
&lt;td style="text-align:center">连接（一对一）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">最大消息大小&lt;/td>
&lt;td style="text-align:center">最大路径 MTU&lt;/td>
&lt;td style="text-align:center">2GB&lt;/td>
&lt;td style="text-align:center">2GB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">广播&lt;/td>
&lt;td style="text-align:center">支持&lt;/td>
&lt;td style="text-align:center">不支持&lt;/td>
&lt;td style="text-align:center">不支持&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;h3 id="6-rdma-架构层级结构">6. RDMA 架构层级结构&lt;/h3>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230722233900.webp"
alt="20230722233900" width="90%" loading="lazy"/>
&lt;/figure>
&lt;hr>
&lt;figure>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230728235849.webp"
alt="20230728235849" width="90%" loading="lazy"/>
&lt;/figure>
&lt;h2 id="三verbs-与-ofa-verbs-api">三、Verbs 与 OFA Verbs API&lt;/h2>
&lt;h3 id="1-verbs-简介">1. Verbs 简介&lt;/h3>
&lt;ul>
&lt;li>Verbs 是对为使用 RDMA 的应用程序提供的功能的抽象描述
&lt;ul>
&lt;li>Verbs 不是 API&lt;/li>
&lt;li>Verbs 有多种实现&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Verbs 可以被分为两大类
&lt;ul>
&lt;li>控制：管理资源，通常需要切换上下文。
&lt;ul>
&lt;li>创建/销毁/修改/查询/处理事件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>数据：使用资源发送/接收数据，不需要切换上下文。
&lt;ul>
&lt;li>发送 Send/发送 Receive/轮询 CQ/请求完成事件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Verbs 是对 RDMA 编程的底层描述。&lt;/li>
&lt;li>Verbs 旨在提供延迟、带宽、消息速率等方面的最佳性能。它可以被视作许多应用构建的基石。
&lt;ul>
&lt;li>Sockets&lt;/li>
&lt;li>存储&lt;/li>
&lt;li>并行计算&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>InfiniBand 规范以 Verbs 接口形式编写
&lt;ul>
&lt;li>所需行为的语义描述&lt;/li>
&lt;li>没有语法或操作系统特定的详细信息&lt;/li>
&lt;li>可以自由定义实现
&lt;ul>
&lt;li>函数、结构、类型等的语法。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>OpenFabrics Alliance (OFA) Verbs API
&lt;ul>
&lt;li>一种 Verbs 接口，由 OpenFabrics Alliance（OFA）组织定义和推广。OFA Verbs 是基于 RDMA Verbs 的扩展，提供了更加统一和标准化的 RDMA 编程接口。OFA Verbs 是 RDMA 领域的一个重要标准，被广泛应用于高性能计算、数据中心和云计算等领域。&lt;/li>
&lt;li>旨在提供一个开放、跨平台的 RDMA 编程接口，使应用程序能够在不同的 RDMA 硬件和操作系统上进行移植和开发&lt;/li>
&lt;li>OFA 统一 InfiniBand 市场的战略&lt;/li>
&lt;li>OFA 面向 Linux、FreeBSD、Windows 等操作系统实现&lt;/li>
&lt;li>应用程序的软件接口：支持 C/C++程序的数据结构、函数原型&lt;/li>
&lt;li>用户态空间和内核态空间的变体：大多数应用程序和库都在用户态空间中&lt;/li>
&lt;li>客户端-服务器编程模型
&lt;ul>
&lt;li>与 TCP/IP 套接字有一些明显的相似之处&lt;/li>
&lt;li>而许多的其它不同之处，则是由于 RDMA 与 TCP/IP 的不同导致&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="2-ofa-verbs-api-支持应用">2. OFA Verbs API 支持应用&lt;/h3>
&lt;ol>
&lt;li>MPI： Message Passing Interface，支持多种版本
&lt;ul>
&lt;li>OpenMPI&lt;/li>
&lt;li>MVAPICH&lt;/li>
&lt;li>Intel MPI&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>文件系统：
&lt;ul>
&lt;li>Lustre&lt;/li>
&lt;li>NFS_RDMA&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DDN 和 NetApp 公司生产的存储设备
&lt;ul>
&lt;li>SRP：SCSI RDMA (Remote) Protocol – Linux kernel&lt;/li>
&lt;li>iSER – iSCSI Extensions for RDMA – Linux kernel&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>伪 Socket 库
&lt;ul>
&lt;li>SDP – Sockets Direct Protocol – supported by Oracle&lt;/li>
&lt;li>rsockets – RDMA Sockets – supported by Intel&lt;/li>
&lt;li>mva – Mellanox Messaging Accelerator&lt;/li>
&lt;li>SMC-R – proposed by IBM&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="四总结">四、总结&lt;/h2>
&lt;ul>
&lt;li>RDMA 技术是一种远程直接内存访问技术，它可以让远程主机直接访问本地内存，而不需要经过 CPU 的参与，从而大大减少了 CPU 的开销，提高了数据传输的效率。&lt;/li>
&lt;li>RDMA 技术的各种协议：InfiniBand、RoCE、iWarp&lt;/li>
&lt;li>RDMA 技术的优势：Zero-copy、Kernel bypass、No CPU involvement、Message based transactions、Scatter/gather entries support&lt;/li>
&lt;li>RDMA 技术的传输服务：Connected（连接）与 Datagram（数据报）、Reliable（可靠）与 Unreliable（不可靠）&lt;/li>
&lt;li>RDMA 技术的 QP 传输类型：RC、UC、UD&lt;/li>
&lt;li>RDMA 技术的操作原语：Send、RDMA Write、RDMA Read、Atomic operations&lt;/li>
&lt;li>RDMA 技术的 Verbs 与 OFA Verbs API&lt;/li>
&lt;li>RDMA 技术的应用：MPI、文件系统、存储设备、伪 Socket 库&lt;/li>
&lt;/ul>
&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;ul>
&lt;li>Mellanox Technologies, Inc. (2017). RDMA Aware Networks Programming User Manual. Mellanox Technologies, Inc.&lt;/li>
&lt;/ul></description></item><item><title>前端开发知识点复习-基础篇</title><link>https://cuterwrite.top/p/web-development-1/</link><pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate><guid>https://cuterwrite.top/p/web-development-1/</guid><description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/blog/lake-5538757_1920.2fnhpht9u2vw.webp" alt="Featured image of post 前端开发知识点复习-基础篇" />&lt;h1 id="前端开发知识点-基础篇">前端开发知识点-基础篇&lt;/h1>
&lt;h2 id="1-cookiesessionsessionstorage-和-localstorage">1 Cookie、Session、SessionStorage 和 LocalStorage&lt;/h2>
&lt;p>Cookie：服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地的一种纯文本文件，当下一次有同源的请求时，将保存的 Cookie 数据添加到请求头部，发送给服务端。可以用来实现记录用户登录状态等功能。&lt;/p>
&lt;p>Session：服务器为了保存用户状态而创建的一个特殊的对象。在浏览器第一次访问服务器时，服务器会创建一个 session 对象,该对象有一个唯一的 id,即 sessionid，服务器会把 sessionid 以 cookie 的形式发送给浏览器,当浏览器再次访问服务器时,会携带 cookie 在请求头,可以通过 cookie 中的 sessionid 来访问 session 对象，可以实现在 http 无状态基础上实现用户状态管理。&lt;/p>
&lt;p>Cookie 的特点：&lt;/p>
&lt;ol>
&lt;li>Cookie 数据存放在客户端上。&lt;/li>
&lt;li>Cookie 是非安全的，由于存在本地，有被盗取的可能。&lt;/li>
&lt;li>Cookie 保存的数据不能超过 4K。&lt;/li>
&lt;li>Cookie 始终在同源的 HTTP 请求中携带。&lt;/li>
&lt;/ol>
&lt;p>如何设置 Cookie：&lt;/p>
&lt;ol>
&lt;li>服务端：使用 Set-Cookie 的响应头部，包含 5 个属性值 expires、 domain、path、secure 和 httponly，分别代表过期时间、域名、路径、安全传输、是否禁用客户端 js 脚本访问。&lt;/li>
&lt;li>客户端：通过 JS 脚本，例如 document.cookie&lt;/li>
&lt;/ol>
&lt;p>Cookie 和 Session 和区别：&lt;/p>
&lt;ol>
&lt;li>Cookie 存放在客户端，Session 存放在服务端。&lt;/li>
&lt;li>Cookie 是非安全的，考虑安全应该使用 Session&lt;/li>
&lt;li>访问增多时，服务器压力比较大，考虑使用 Cookie&lt;/li>
&lt;li>单个 Cookie 保存的数据不能超过 4K&lt;/li>
&lt;/ol>
&lt;p>Cookie、SessionStorage 和 LocalStorage 的区别：&lt;/p>
&lt;ol>
&lt;li>Cookie 始终在同源的 HTTP 请求中携带。（即使不需要）&lt;/li>
&lt;li>Cookie 可以限制可访问的 path&lt;/li>
&lt;li>存储大小：Cookie 存放数据不能超过 4k，WebStorage 可以达到 5M 或更大。&lt;/li>
&lt;li>有效期不同：SessionStorage 只在当前浏览器窗口关闭前有效，LocalStorage 始终有效，用作持久化，Cookie 在设置的过期时间之前一直有效。&lt;/li>
&lt;/ol>
&lt;p>Cookie 常用场景：&lt;/p>
&lt;ol>
&lt;li>保持用户登录状态&lt;/li>
&lt;li>跟踪用户行为，记录用户选项&lt;/li>
&lt;/ol>
&lt;h2 id="2-http-和-https-的区别">2 Http 和 Https 的区别&lt;/h2>
&lt;p>HTTPS 基本原理：客户端使用 HTTPS URL 访问服务端，要去服务端建立 SSL 连接，服务端接收到客户端请求后，会将网站的证书（携带公钥）返回给客户端，客户端和服务端开始协商 SSL 连接的安全等级，也就是&lt;strong>加密等级&lt;/strong>，然后两者通过协商一致的安全等级，建立&lt;strong>会话密钥&lt;/strong>，然后客户端通过网站的公钥来加密会话密钥，传给网站，服务端通过自己的&lt;strong>私钥&lt;/strong>解密出会话密钥，通过会话密钥加密与客户端的通信。&lt;/p>
&lt;ol>
&lt;li>安全性：HTTPS 是安全超文本协议，在 HTTP 基础上有更强的安全性，简单来说，HTTPS 是使用了 TLS/SSL 加密的 HTTP 协议。&lt;/li>
&lt;li>申请证书：HTTPS 需要使用 CA 证书。&lt;/li>
&lt;li>传输协议：HTTP 以明文形式传输数据，HTTPS 以加密形式传输数据。&lt;/li>
&lt;li>端口号不同：一般来说，HTTP 协议的端口为 80，HTTPS 的端口为 443&lt;/li>
&lt;li>连接方式：HTTP 的连接简单，是无状态的，HTTPS 在 HTTP 的基础上使用了 SSL 协议进行加密传输。&lt;/li>
&lt;/ol>
&lt;h2 id="3-http20-的特性">3 Http2.0 的特性&lt;/h2>
&lt;ol>
&lt;li>提升了访问速度&lt;/li>
&lt;li>允许多路复用：允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。&lt;/li>
&lt;li>二进制分帧：将所有的传输数据分割为更小的数据帧，并对它们进行二进制编码。&lt;/li>
&lt;li>首部压缩&lt;/li>
&lt;li>服务器端推送&lt;/li>
&lt;/ol>
&lt;h2 id="4-osi-七层模型">4 OSI 七层模型&lt;/h2>
&lt;ol>
&lt;li>应用层：文件传输，常用协议 HTTP、STMP、FTP&lt;/li>
&lt;li>表示层：数据格式化、代码转换、数据加密&lt;/li>
&lt;li>会话层：建立和解除会话&lt;/li>
&lt;li>传输层：提供端对端的接口，TCP/UDP&lt;/li>
&lt;li>网络层：为数据包选择路由，IP/ICMP&lt;/li>
&lt;li>数据链路层：传输带有地址的帧。&lt;/li>
&lt;li>物理层：二进制的数据形式在物理媒体上传输数据。&lt;/li>
&lt;/ol>
&lt;h2 id="5-tcp-和-udp-的区别">5 TCP 和 UDP 的区别&lt;/h2>
&lt;ol>
&lt;li>TCP 是面向连接的，UDP 是无连接的，即发送数据前不需要先建立连接。&lt;/li>
&lt;li>TCP 提供可靠的服务，无差错、不丢失、不重复、按序到达，UDP 尽最大努力交付。（大数据量使用 TCP）&lt;/li>
&lt;li>TCP 面向字节流，UDP 面向报文。（UDP 无拥塞控制，可能出现丢包）&lt;/li>
&lt;li>TCP 只能 1 对 1，UDP 支持 1 对 1 和 1 对多。&lt;/li>
&lt;li>TCP 首部较大为 20 字节，UDP 只有 8 字节。&lt;/li>
&lt;/ol>
&lt;h2 id="6-tcp-三次握手和四次挥手">6 TCP 三次握手和四次挥手&lt;/h2>
&lt;p>TCP 三次握手：（A 为客户端，B 为服务端）&lt;/p>
&lt;ol>
&lt;li>B 处于监听，A 向 B 发送连接请求报文 SYN=1，ACK=0，选择一个初始的序号 x&lt;/li>
&lt;li>B 收到连接请求报文，如果同意连接，则向 A 发送连接确认报文 SYN=1，ACK=1，确认号 ack=x+1，选择初始序号 y&lt;/li>
&lt;li>A 收到 B 的连接确认报文，向 B 发送确认报文 ACK=1，确认号 ack=y+1，序号为 x+1&lt;/li>
&lt;li>B 收到 A 的确认，连接建立。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>三次握手的原因&lt;/strong>&lt;/p>
&lt;p>第三次握手防止失效的连接请求到达服务器，让服务器错误打开连接。客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务端返回的确认，导致：客户端超时重传重新建立连接，这时就会出现 2 个 SYN 连接。如果有第三次握手，客户端会忽略服务端之后发送的对滞留连接请求的确认，不进行第三次握手，因此就不会打开连接。&lt;/p>
&lt;p>TCP 四次挥手：&lt;/p>
&lt;ol>
&lt;li>A 发送连接释放报文 FIN=1，序号为 u&lt;/li>
&lt;li>B 收到后发出确认 ACK=1, ack=x+1, 序号为 v，此时 TCP 属于半关闭状态，A 不能发数据，B 能发数据。&lt;/li>
&lt;li>B 不需要连接时，发送连接释放报文 FIN=1，ACK=1，ack=u+1，序号为 w&lt;/li>
&lt;li>A 收到后发出确认 ACK=1，ack=w+1，序号为 u+1，进入 TIME-WAIT 状态，等待 2MSL（最大报文存存活时间）后释放连接。&lt;/li>
&lt;li>B 收到 A 的确认后释放连接。&lt;/li>
&lt;/ol>
&lt;h2 id="7-http-状态码">7 HTTP 状态码&lt;/h2>
&lt;p>状态码按第一个数字分类，1 表示信息，2 表示成功，3 表示重定向，4 表示客户端错误，5 表示服务端错误。&lt;/p>
&lt;p>常见状态码：101 切换协议、200 成功、301 永久重定向、302 临时重定向、304 未修改、400 请求无效、401 未认证、403 拒绝执行、404 未找到资源&lt;/p>
&lt;p>200 和 304 的区别：&lt;/p>
&lt;ol>
&lt;li>200 是请求成功，一般用于 GET 和 POST&lt;/li>
&lt;li>304 是未修改，所请求的资源未修改，服务器返回此状态码时，不会返回任何资源，客户端通过缓存访问资源（协商缓存）。&lt;/li>
&lt;/ol>
&lt;h2 id="8-http-缓存机制">8 HTTP 缓存机制&lt;/h2>
&lt;ol>
&lt;li>强缓存：返回状态码为 200，不会向服务端发送请求，直接从缓存取资源。相关字段有 pragma、expires、cache-control（cache-control 优先级更高，pragma 优先级最高）。&lt;/li>
&lt;li>协商缓存：返回状态码为 304，会向服务端发送请求，通过服务器告知缓存是否可用。相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match&lt;/li>
&lt;/ol>
&lt;p>缓存流程：&lt;/p>
&lt;ol>
&lt;li>缓存是否过期：未过期，则从缓存读取（强缓存），否则下一步。&lt;/li>
&lt;li>Etag 值：True，向服务端发送带 If-None-Match 的请求，否则继续判断 Last-Modified&lt;/li>
&lt;li>Last-Modified 为 True，向服务端发送带 If-Modified-Since 的请求，否则正式发送请求，相应后缓存协商。。（无缓存）&lt;/li>
&lt;li>服务器根据 If-None-Match 和 If-Modified-Since 决策返回 200 还是 304，304 则从缓存读取（协商缓存），200 则走正常请求。&lt;/li>
&lt;/ol>
&lt;h2 id="9-xss-攻击和-csrf-攻击">9 XSS 攻击和 CSRF 攻击&lt;/h2>
&lt;p>XSS 攻击：跨站脚本攻击，盗取 Cookie，在返回的 HTML 中嵌入 js 脚本，防范方法：用户输入检查（过滤特殊字符等）、设置 set-cookie 的 httponly 属性。&lt;/p>
&lt;p>CSRF 攻击：跨站请求伪造，利用 Cookie，以用户的名义发送恶意请求。防范方法：验证码、检查 HTTPS 头部的 referer、使用 token。&lt;/p>
&lt;h2 id="10-http-常见请求头">10 HTTP 常见请求头&lt;/h2>
&lt;p>可以划分为：通用首部、请求首部、相应首部和实体首部&lt;/p>
&lt;p>通用首部：&lt;/p>
&lt;ol>
&lt;li>Accept：可接受的响应内容类型&lt;/li>
&lt;li>Accept-Encoding：可接受的响应内容编码形式&lt;/li>
&lt;li>Accept-Language：可接受的响应语言列表&lt;/li>
&lt;li>Cache-Control：是否使用强缓存&lt;/li>
&lt;li>Pragma：一般来说指，是否使用强缓存&lt;/li>
&lt;li>Connection：连接类型（keep-alive）&lt;/li>
&lt;li>User-Agent：浏览器的身份标识字符串&lt;/li>
&lt;li>Content-Length：8 进制标识的请求体的长度。&lt;/li>
&lt;li>Content-Type：请求体的 MIME 类型，用于 POST 和 GET&lt;/li>
&lt;li>Host：服务器的域名及监听端口号，80 则可以省略&lt;/li>
&lt;/ol>
&lt;p>请求首部：&lt;/p>
&lt;ol>
&lt;li>cookie&lt;/li>
&lt;li>Etag/If-None-Match&lt;/li>
&lt;li>Last-Modified/if-Modified-Since 等&lt;/li>
&lt;/ol>
&lt;p>响应首部：&lt;/p>
&lt;ol>
&lt;li>set-cookie 等&lt;/li>
&lt;/ol>
&lt;h2 id="11-http-常见请求方法">11 HTTP 常见请求方法&lt;/h2>
&lt;ol>
&lt;li>get：请求资源&lt;/li>
&lt;li>head：请求 header&lt;/li>
&lt;li>post：建立或修改资源。&lt;/li>
&lt;li>put：取代资源&lt;/li>
&lt;li>delete：删除指定资源&lt;/li>
&lt;li>connect：&lt;/li>
&lt;li>options：允许客户端查看服务端的性能&lt;/li>
&lt;li>trace：回显服务器收到的请求，用于测试和诊断&lt;/li>
&lt;li>patch：对 put 的补充，对已有资源局部更新。&lt;/li>
&lt;/ol>
&lt;h2 id="12-输入-url-到显示页面的过程">12 输入 URL 到显示页面的过程&lt;/h2>
&lt;ol>
&lt;li>首先需要找到这个 url 域名的服务器 ip，首先会寻找缓存中的记录，如果没有则查找本地的 hosts 文件是否有记录，如果没有则进行下一步。&lt;/li>
&lt;li>DNS 解析：首先，客户端通过发送 DHCP 请求报文获取网关路由器的 IP 地址，然后通过 ARP 协议获取网关路由器的 MAC 地址，接着向网关路由器发送 DNS 查询报文，到达 DNS 服务器后，在 DNS 数据库中查询域名解析后的 IP 地址。&lt;/li>
&lt;li>浏览器根据得到的 IP 地址及相应的端口号，构造一个 HTTP 请求报文，并将这个 HTTP 请求封装在一个 TCP 包中，依次经过传输层、网络层、数据链路层、物理层到达服务端，服务端解析这个请求来作出响应给浏览器。&lt;/li>
&lt;li>浏览器解析响应内容并渲染页面，结束连接。（DOM 树和 CSSOM 树）&lt;/li>
&lt;/ol>
&lt;h2 id="13-websocket">13 Websocket&lt;/h2>
&lt;p>WebSocket 是 HTML5 中的协议，支持持久连续，http 协议不支持持久性连接。Http1.0 和 HTTP1.1 都不支持持久性的链接，HTTP1.1 中的 keep-alive，将多个 http 请求合并为 1 个。&lt;/p>
&lt;p>HTTP 的生命周期通过 Request 来界定，也就是 Request 一个 Response，那么在 Http1.0 协议中，这次 Http 请求就结束了。在 Http1.1 中进行了改进，有一个 connection：Keep-alive，也就是说，在一个 Http 连接中，可以发送多个 Request，接收多个 Response。但是必须记住，在 Http 中一个 Request 只能对应有一个 Response，而且这个 Response 是被动的，不能主动发起。&lt;/p>
&lt;p>WebSocket 是基于 Http 协议的，或者说借用了 Http 协议来完成一部分握手，在握手阶段与 Http 是相同的。有 2 个相关的请求头，upgrade，connection。&lt;/p>
&lt;p>upgrade:websocket&lt;/p>
&lt;p>connection:upgrade&lt;/p>
&lt;h2 id="14-bom-对象">14 BOM 对象&lt;/h2>
&lt;p>浏览器对象，location、history 和 navigator&lt;/p>
&lt;p>常用属性和方法：&lt;/p>
&lt;ol>
&lt;li>history：go、back、forward&lt;/li>
&lt;li>navigator：userAgent、cookieEnabled&lt;/li>
&lt;li>location：
&lt;ol>
&lt;li>get 类型：href、search、hash、host、hostname、pathname、port、protocal&lt;/li>
&lt;li>set 类型：assgin（设置 url）、replace（设置 url，并且在 history 中移除）、reload&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="15-cors-跨域请求的方式">15 CORS 跨域请求的方式&lt;/h2>
&lt;p>cors：跨域资源共享，客服了 AJAX 只能同源使用的限制。&lt;/p>
&lt;p>只要同时满足以下两大条件，就属于简单请求&lt;/p>
&lt;ol>
&lt;li>请求方法为 head、get、post 之一&lt;/li>
&lt;li>请求头只有：Accepet、Accpet-Language、Content-Language、Last-Event-ID、Content-Type 这五种，并且 Content-type 只有 application/x-www-form-unlencoded、multipart/form-data、text/plain 这三种。&lt;/li>
&lt;/ol>
&lt;p>对于简单请求，浏览器直接发出 CORS 请求，在请求头加上 Origin 字段，用来说明来自哪个源，服务器根据这个值决定是否同意此次请求，同意则返回响应，响应头多出几个字段（以&lt;strong>Access-Control-&lt;strong>开头），否则返回一个正常的 HTTP 响应，但请求头&lt;/strong>不包含 Access-Control-Allow-Origin 字段&lt;/strong>，抛出一个错误。&lt;/p>
&lt;p>&lt;strong>withCredentials 属性&lt;/strong>&lt;/p>
&lt;p>CORS 请求默认不发送 Cookie 和 HTTP 认证信息，如果需要发送，一方面需要服务器同意，指定 Access-Control-Allow-Credentials 为 True，另一方面 ajax 请求要设置 withCredentials 属性为 true。此外，如果要发送 Cookie，Access-Control-Allow-Origin 就不能设置为星号，必须指定明确的、与明确网页一致的域名。同时，Cookie 依然遵循同源政策。&lt;/p>
&lt;p>&lt;strong>预检请求&lt;/strong>&lt;/p>
&lt;p>对于复杂请求的 CORS 请求，会在正式通信前，增加一次 HTTP 查询请求，称为预检请求，浏览器先询问服务器，如果同意才会发出正式的 XMLHttpRequest 请求，否则就报错。&lt;/p>
&lt;p>预检请求用的请求方法为 OPTIONS，请求头有 Origin、Access-Control-Request-Method、Access-Control-Request-Headers 这三个字段。&lt;/p>
&lt;p>一旦服务器通过了预检请求，以后每次浏览器正常的 CORS 请求，都跟正常请求一样，会有一个 OrIgin 请求头字段，服务器响应请求头会带有 Access-Control-Allow-Origin。&lt;/p>
&lt;h2 id="16-css-盒模型">16 CSS 盒模型&lt;/h2>
&lt;ol>
&lt;li>标准盒模型：box-sizing：content-box；width=content&lt;/li>
&lt;li>IE 盒模型：box-sizing：border-box；width=content+border+padding&lt;/li>
&lt;li>box-sizing：padding-box；width=content+padding&lt;/li>
&lt;/ol>
&lt;h2 id="17-link-标签和-import-标签的区别">17 link 标签和 import 标签的区别&lt;/h2>
&lt;ol>
&lt;li>link 属于 html 标签，@import 是 css 提供的。&lt;/li>
&lt;li>加载时机：页面加载时，link 会同时加载，而@import 引用的 css 会等到页面加载结束后加载。&lt;/li>
&lt;li>兼容性：@import 只有 IE5 以上才支持。&lt;/li>
&lt;li>优先级：link 大于@import&lt;/li>
&lt;/ol>
&lt;h2 id="18-transition-和-animation-的区别">18 transition 和 animation 的区别&lt;/h2>
&lt;ol>
&lt;li>大部分属性相同，都是随时间改变元素的属性值。&lt;/li>
&lt;li>transition 需要触发一个事件才能改变属性，而 animation 不需要触发任何事件。&lt;/li>
&lt;li>transition 为 2 帧，animation 可以一帧一帧。&lt;/li>
&lt;/ol>
&lt;h2 id="19-flex-布局">19 Flex 布局&lt;/h2>
&lt;p>弹性布局，用来为盒状模型提供最大的灵活性。&lt;/p>
&lt;p>划分：容器属性和元素属性&lt;/p>
&lt;p>容器属性：&lt;/p>
&lt;ol>
&lt;li>flex-direction：主轴方向&lt;/li>
&lt;li>flex-wrap：换行规则&lt;/li>
&lt;li>flew-flow：上面两者结合。&lt;/li>
&lt;li>justify-content：主轴对齐方式&lt;/li>
&lt;li>align-items：交叉轴对齐方式&lt;/li>
&lt;/ol>
&lt;p>元素属性：&lt;/p>
&lt;ol>
&lt;li>order：排列顺序&lt;/li>
&lt;li>flex-glow：放大比例&lt;/li>
&lt;li>flex-shrink：缩小比例&lt;/li>
&lt;li>flex-basis：占据空间&lt;/li>
&lt;li>flex：上面三者的缩写&lt;/li>
&lt;li>align-self：允许元素与其它项目的对齐方式不一样，默认 auto，继承父元素的 align-item&lt;/li>
&lt;/ol>
&lt;h2 id="20-bfc">20 BFC&lt;/h2>
&lt;p>BFC：块级格式化上下文，用于清除浮动，防止 margin 重叠等&lt;/p>
&lt;p>BFC 是页面上的一个独立容器，子元素不会影响到外面，计算 BFC 的高度时，浮动元素也会参与计算。&lt;/p>
&lt;p>会生成 BFC 的元素：&lt;/p>
&lt;ol>
&lt;li>float 不为 none 的元素&lt;/li>
&lt;li>position 为 fixed 和 absolute 的元素&lt;/li>
&lt;li>display 为 inline-block、table-cell、table-caption、flex、inline-flex 的元素。&lt;/li>
&lt;li>overflow 不为 visible 的元素&lt;/li>
&lt;/ol>
&lt;h2 id="21-块元素和行元素">21 块元素和行元素&lt;/h2>
&lt;ol>
&lt;li>块元素：独占一行，并且有自动填满父元素，可以设置 margin 和 padding 以及高度和宽度&lt;/li>
&lt;li>行元素：不会独占一行，width 和 height 会失效，并且在垂直方向的 padding 和 margin 会失效。&lt;/li>
&lt;/ol>
&lt;h2 id="22-html5-和-css3-的新元素">22 HTML5 和 CSS3 的新元素&lt;/h2>
&lt;ol>
&lt;li>HTML5 新增元素：
&lt;ol>
&lt;li>新标签：8 个语义标签（header、section、footer、aside、nav、main、article、figure）、mark 高亮、progress 进度、新表单控件(calendar、data、time、email、url、search)、新的 input 类型（color、date、datetime、datetime-local、email）&lt;/li>
&lt;li>canvas 绘图，支持内联 SVG，支持 MathML&lt;/li>
&lt;li>多媒体：audio、video、source、embed track&lt;/li>
&lt;li>本地离线存储：manifest 配置文件&lt;/li>
&lt;li>web 存储：localStorage、SessionStorage&lt;/li>
&lt;li>其它：web worker、websocket&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>CSS3 新元素
&lt;ol>
&lt;li>边框： border-radius、box-shadow&lt;/li>
&lt;li>背景：background-size、background-origin&lt;/li>
&lt;li>文本效果：text-shadow、word-wrap、word-break 等&lt;/li>
&lt;li>2D/3D 转换：transform&lt;/li>
&lt;li>动画：animation&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="23-重绘和重排">23 重绘和重排&lt;/h2>
&lt;p>DOM 的变化影响到了预算内宿的几何属性比如宽高，浏览器重新计算元素的几何属性，其他元素的几何属性也会受到影响，浏览器需要重新构造渲染树，这个过程称之为&lt;strong>重排&lt;/strong>，浏览器将受到影响的部分重新绘制在屏幕上的过程称为&lt;strong>重绘&lt;/strong>。&lt;/p>
&lt;p>重绘和重排的原因：&lt;/p>
&lt;ol>
&lt;li>添加或删除可见的 DOM 元素&lt;/li>
&lt;li>元素尺寸位置的改变&lt;/li>
&lt;li>浏览器页面初始化&lt;/li>
&lt;li>浏览器窗口大小发生改变。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>重排一定导致重绘，重绘不一定导致重排。&lt;/strong>&lt;/p>
&lt;p>减少重排，提高性能的方法：&lt;/p>
&lt;ol>
&lt;li>元素的多次样式修改合并成一次修改。&lt;/li>
&lt;li>如需进行对 DOM 节点进行多次操作，先将其脱离文本流之后再进行多次操作。&lt;/li>
&lt;li>table 布局的渲染与普通 DOM 节点的操作相比，性能消耗更大，如果可以，尽量减少 table 布局的使用。&lt;/li>
&lt;li>缓存常用的布局信息。&lt;/li>
&lt;/ol>
&lt;h2 id="24-闭包">24 闭包&lt;/h2>
&lt;p>闭包：当一个嵌套的内部函数引用了外部函数的变量或者函数时，外部函数在执行时就产生了闭包。&lt;/p>
&lt;p>典型的闭包：&lt;/p>
&lt;ol>
&lt;li>将函数作为灵一个函数的返回值&lt;/li>
&lt;li>将函数作为实参传给另一个函数调用&lt;/li>
&lt;/ol>
&lt;p>闭包特点：函数嵌套函数，内部函数引用外部函数的变量。&lt;/p>
&lt;p>闭包的作用：&lt;/p>
&lt;ol>
&lt;li>延长外部函数局部变量的生命周期，可以用于实现计数器。&lt;/li>
&lt;li>可以形成变量的局部作用域，实现函数封装。&lt;/li>
&lt;/ol>
&lt;p>闭包的缺点：函数定义的变量和数据会一直存在内存函数中，不会被及时释放，容易导致内存泄漏。&lt;/p>
&lt;h2 id="25-类的创建和继承">25 类的创建和继承&lt;/h2>
&lt;p>类的创建：new 一个 function，在这个 function 中的 prototype 里面添加属性和方法&lt;/p>
&lt;pre>&lt;code class="language-javascript">function Animal(name){
this.name = name || 'Animal';
//实例方法
this.sleep = function(){
console.log(this.name + &amp;quot;正在睡觉!&amp;quot;);
}
//原型方法
Animal.prototype.eat = function(food){
console.log(this.name + &amp;quot;正在吃&amp;quot; + food);
};
}
&lt;/code>&lt;/pre>
&lt;p>类的继承：4 种方式&lt;/p>
&lt;ol>
&lt;li>
&lt;p>原型链继承（new 一个空对象，空对象指向 Animal，缺点是无法多继承）&lt;/p>
&lt;pre>&lt;code class="language-javascript">function Cat(){
Cat.prototype = new Animal();
Cat.prototype.name = 'Cat';
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>构造继承（使用父亲的构造函数来增强子类实例，等于复制父亲的实例属性）&lt;/p>
&lt;pre>&lt;code class="language-javascript">function Cat(name){
Animal.call(this);
this.name = name || 'Tom';
}
&lt;/code>&lt;/pre>
&lt;p>优点：可以多继承&lt;/p>
&lt;p>缺点：只能继承实例属性和方法&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实例集成和拷贝继承：&lt;/p>
&lt;ol>
&lt;li>实例继承：为父亲实例添加新特性，作为子类实例返回&lt;/li>
&lt;li>拷贝继承：拷贝父亲元素上的属性和方法&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>组合继承：构造继承和原型链继承的组合&lt;/p>
&lt;pre>&lt;code class="language-javascript">function Cat(name){
Animal.call(this);
this.name = name || 'Tom';
}
Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;
&lt;/code>&lt;/pre>
&lt;p>通过调用父类构造，继承父亲的属性并保留传参的优点，然后通过将父亲实例作为子类原型，实现函数复用。&lt;/p>
&lt;p>特点：可以继承实例属性，也可以继承原型属性&lt;/p>
&lt;p>缺点：调用了两次父类构造函数，生成了两份实例&lt;/p>
&lt;/li>
&lt;li>
&lt;p>寄生组合继承：通过寄生方式，砍掉父亲的实例属性&lt;/p>
&lt;pre>&lt;code class="language-javascript">function Cat(name){
Animal.call(this);
this.name = name || 'Tom';
}
var Super = function(){};
Super.prototype = Animal.prototype;
Cat.prototype = new Super();
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>最常用的方法：&lt;/p>
&lt;pre>&lt;code class="language-javascript">Cat.prototype = Object.create(Animal.prototype);
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h2 id="26-promisegeneratorasyncawait">26 promise、generator、async/await&lt;/h2>
&lt;p>promise：CommonJS 工作组提出的一种规范，目的是为异步编程提供统一接口。每一个异步任务返回一个 Promise 对象，该对象有一个 then 方法，允许指定回调函数。有三个状态：等待（pending）、已完成（resolved，又称 fulfilled）、已拒绝（rejected）。promise 必须实现 then 方法（可以说，then 就是 promise 的核心），而且 then 必须返回一个 promise，同一个 promise 的 then 可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致。then 方法接受两个参数，第一个参数是成功时的回调，在 promise 由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在 promise 由“等待”态转换到“拒绝”态时调用。同时，then 可以接受另一个 promise 传入，也接受一个“类 then”的对象或方法，即 thenable 对象。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>使用举例：&lt;/p>
&lt;pre>&lt;code class="language-javascript">func(){
return new Promise((resolve,reject)=&amp;gt;{
work().then(res=&amp;gt;{
this.data = res.data;
resolve();
}).catch(error=&amp;gt;{
reject(error);
})
})
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;p>promise 的用处&lt;/p>
&lt;ol>
&lt;li>解决了回调函数的回调地狱问题，有时候我们的请求需要上一个请求返回的结果，会造成相互间回调函数的嵌套，使得代码的可读性和维护性很低。&lt;/li>
&lt;li>让代码变得扁平，可读性更好，then 返回一个 promise，可以把 then 串起来，then 返回的 promise 装载了由调用返回的值。&lt;/li>
&lt;li>在异步回调中，函数的执行栈与原函数分离开，导致外部无法抓住异常。在 promise 中我们可以使用 reject 捕获失败情况，和 catch 捕获执行异常。&lt;/li>
&lt;li>promise 只不过是一种更良好的编程风格。&lt;/li>
&lt;/ol>
&lt;p>promise 的缺点：&lt;/p>
&lt;ol>
&lt;li>不设置回调函数，promise 内部抛出的错误，无法返回到外部。&lt;/li>
&lt;li>处于 pending 状态时，无法得知进展到哪一个阶段。&lt;/li>
&lt;/ol>
&lt;p>async 和 await：&lt;/p>
&lt;ol>
&lt;li>async 函数返回一个 promise 对象，在没有 await 的情况下执行 async 函数，它会立即返回一个 promise 对象，并且，绝对不会注意后面语句的执行，await 关键字只能用在 aync 定义的函数内；
await 可以用于等待一个 async 函数的返回值，如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。async/await 使得异步代码看起来像同步代码，使代码简洁，可读性更好，避免嵌套。&lt;/li>
&lt;/ol>
&lt;h2 id="27-事件流">27 事件流&lt;/h2>
&lt;p>事件流：从页面接受事件的顺序，DOM2 级事件流包括下面几个阶段&lt;/p>
&lt;ol>
&lt;li>事件捕获阶段&lt;/li>
&lt;li>处于目标阶段&lt;/li>
&lt;li>事件冒泡阶段&lt;/li>
&lt;/ol>
&lt;p>addEventListener：DOM2 级事件新增的指定事件处理程序的操作，这个方法接受三个参数，要处理的事件名，作为事件处理程序的函数和一个布尔值（true 则在捕获阶段调用事件处理程序，否则在冒泡阶段调用）。IE 只支持事件冒泡。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>addEventListener 示例：&lt;/p>
&lt;pre>&lt;code class="language-javascript">var op = document.getElementById(&amp;quot;id&amp;quot;);
op.addEventListener('click', function(e){
//do something
}, false);
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h2 id="28-事件委托代理">28 事件委托（代理）&lt;/h2>
&lt;p>事件委托：事件委托指的是，不在事件的发生地（直接 dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM 的类型，来做出不同的响应。&lt;/p>
&lt;p>举例：最经典的就是 ul 和 li 标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在 li 标签上直接添加，而是在 ul 父元素上添加。&lt;/p>
&lt;p>优点：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。&lt;/p>
&lt;h2 id="29-事件循环">29 事件循环&lt;/h2>
&lt;p>事务队列中，在每一次事件循环中，宏任务只会提取一个执行，而微任务会一直提取，直到微任务队列为空为止。&lt;/p>
&lt;p>也就是说如果某个微任务任务被推入到执行中，那么当主线程任务执行完成后，会循环调用该队列任务中的下一个任务来执行，直到该任务队列到最后一个任务为止。而事件循环每次只会入栈一个宏任务,主线程执行完成该任务后又会检查微任务队列并完成里面的所有任务后再执行宏任务队列的任务。&lt;/p>
&lt;p>宏任务：setTimeOut、setInterval、setImmediate、IO、UI 渲染、主 JS、requestAnimationFrame 等。&lt;/p>
&lt;p>微任务：process.nextTick、promise.then()，Object.observe()等&lt;/p>
&lt;h2 id="30-图片懒加载和预加载">30 图片懒加载和预加载&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>懒加载：迟缓加载甚至不加载。（减少服务器的压力）&lt;/p>
&lt;ol>
&lt;li>实现方法：图片地址不放在 src，而是放在其它属性，页面加载后，根据 scrollTop 判断图片是否在用户视野内，如果在，则将 data-original 属性中的值放在 src。在滚动事件中重复判断图片是否进入视野。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>预加载：提前加载图片，当用户需要查看时直接从本地缓存中渲染。（会增大服务器的压力）&lt;/p>
&lt;ol>
&lt;li>
&lt;p>CSS 实现：background：url()&lt;/p>
&lt;/li>
&lt;li>
&lt;p>JS 实现：&lt;/p>
&lt;pre>&lt;code class="language-javascript">const img = new Image();
img.src = 'xxx';
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="31-new-操作符">31 new 操作符&lt;/h2>
&lt;p>new 操作符新建了一个空对象，这个对象原型指向构造函数的 prototype，执行构造函数后返回这个对象&lt;/p>
&lt;ul>
&lt;li>
&lt;p>实现一个 new 的方法：&lt;/p>
&lt;pre>&lt;code class="language-javascript">function Animal(){...}
//var a = new Animal();
function myNew(){
let obj = {}
let Constructor = [].shifit.apply(arguments);
//绑定原型
obj.__proto__ = Constructor.prototype;
//调用构造函数
let res = Constructor.apply(obj, arguments);
return typeof res === 'object' ? res : obj;
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h2 id="32-bindapplycall-的区别">32 bind、apply、call 的区别&lt;/h2>
&lt;ol>
&lt;li>apply 和 call 用来改变函数的 this 指向，它们两个函数的第一个参数都是一样的，表示要改变指向的那个对象，第二个参数，apply 中是数组，而 call 是 arg1,arg2&amp;hellip;的形式。&lt;/li>
&lt;li>bind 改变 this 作用域会返回一个新的函数，这个函数不会立即执行。&lt;/li>
&lt;/ol>
&lt;h2 id="33-节流和防抖">33 节流和防抖&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>防抖：持续拖动滚动条，只要不停止触发，就永远不会有输出。短时间内触发的事件，在某个时间期限内，函数只执行一次。&lt;/p>
&lt;pre>&lt;code class="language-javascript">function debounce(func, wait){
var timeout;
return function(){
clearTimeout(timeout);
timeout = setTimeout(func,wait);
}
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>节流：持续拖动滚动条，每间隔一段时间，就会输出反馈。相当于&lt;strong>技能冷却&lt;/strong>，执行之后，函数会失效一段时间，冷却之后，又会恢复，设置一个状态位，判断是否处于工作状态。（在防抖基础上，到达指定事件必须输出）&lt;/p>
&lt;pre>&lt;code class="language-javascript">function throttle(func, wait, mustRun){
var timeout, start = new Data();
return function(){
var context = this, args = arguments;
var cur = new Data();
clearTimeout(timeout);
if (cur - start &amp;gt;= mustRun){
func.apply(context, args);
start = cur;
} else {
timeout = setTimeout(func, wait);
}
}
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h2 id="34-深拷贝">34 深拷贝&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>简单深拷贝：JSON 序列化和反序列化&lt;/p>
&lt;pre>&lt;code class="language-javascript">function deepCopy(obj){
let __obj = JSON.stringify(obj);
return JSON.parse(_obj);
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>递归方法：&lt;/p>
&lt;pre>&lt;code class="language-javascript">function deepCopy(obj){
let res;
if (typeof obj === 'Object'){
if (Array.isArray(obj)){
res = []
for (let i in obj){
res.push(deepCopy(obj[i]))
}
} else if (obj == null){
res = null;
} else if (obj.constructor === 'RegExp'){
res = obj;
} else {
res = {}
for (let i in obj){
res[i] = deepCopy(obj[i])
}
}
} else {
res = obj;
}
return res;
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h2 id="35-对象属性改变监听-proxy">35 对象属性改变监听-Proxy&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>示例&lt;/p>
&lt;pre>&lt;code class="language-javascript">var user = new Proxy({}, {
set:function(target,key,value,receiver){
}
})
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h2 id="36-变量提升和暂时性死区">36 变量提升和暂时性死区&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>变量提升：var 定义变量，变量可以在声明前使用，值为 undefined；let 不会出现这个情况。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>暂时性死区 TDZ：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等待变量声明的那一行代码出现，才可以获取和使用该变量。&lt;/p>
&lt;p>&lt;strong>只要块级作用域内存在 let 和 const 命令，它所声明的变量就会绑定这个区域，不再受外部影响。&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="37-箭头函数">37 箭头函数&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>基本语法&lt;/p>
&lt;pre>&lt;code class="language-javascript">let func = value=&amp;gt;value;
//aka
let func = function(value){
return value;
};
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>与普通函数的区别&lt;/p>
&lt;ol>
&lt;li>箭头函数没有 this，如果普通函数包含箭头函数，那么 this 访问的就是最近一层普通函数的 this&lt;/li>
&lt;li>箭头函数是匿名函数，不能作为构造函数，不能使用 new&lt;/li>
&lt;li>箭头函数没有自己的 arguments 参数，虽然有 name 属性但是是空字符串，用&amp;hellip;扩展运算符。&lt;/li>
&lt;li>箭头函数通过 call()或 apply()方法调用一个函数时，只传入了一个参数，对 this 并没有影响。&lt;/li>
&lt;li>箭头函数没有原型属性 prototype&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="38-原型链">38 原型链&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>原型：prototype，是一个对象，作用是共享属性和方法&lt;/p>
&lt;/li>
&lt;li>
&lt;p>原型链：原型与原型层层连接的过程即为原型链&lt;/p>
&lt;p>假设 B 继承了 A，b 是 B 的实例，那么就有以下关系：&lt;/p>
&lt;p>（1）&lt;/p>
&lt;pre>&lt;code class="language-javascript">b.__proto__ = B.prototype
&lt;/code>&lt;/pre>
&lt;p>（2）B.prototype.constructor = B，A.prototype.constructor = A&lt;/p>
&lt;p>（3）&lt;/p>
&lt;pre>&lt;code class="language-javascript">B.__proto__ = A
&lt;/code>&lt;/pre>
&lt;p>（4）&lt;/p>
&lt;pre>&lt;code class="language-javascript">B.prototype.__proto__ = A.prototype
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h2 id="39-es6-新特性">39 ES6 新特性&lt;/h2>
&lt;ol>
&lt;li>let（解决了变量提升）、 const 常量，块级作用域（暂时性死区）。&lt;/li>
&lt;li>模板字符串：“xxx${}”&lt;/li>
&lt;li>箭头函数&lt;/li>
&lt;li>对象，数组解构赋值&lt;/li>
&lt;li>for in 和 for of&lt;/li>
&lt;li>class 类&lt;/li>
&lt;li>extend 类继承&lt;/li>
&lt;/ol>
&lt;h2 id="40-垂直居中的方法">40 垂直居中的方法&lt;/h2>
&lt;ol>
&lt;li>margin：auto，left、right、top、bottom 全设为 0&lt;/li>
&lt;li>display：flex，align-items:center，justify-content:center;&lt;/li>
&lt;/ol>
&lt;h2 id="41-前端性能优化">41 前端性能优化&lt;/h2>
&lt;ol>
&lt;li>降低请求量：合并资源、减少 HTTP 请求数、minify/gzip 压缩，webP，懒加载&lt;/li>
&lt;li>加快请求速度：预解析 DNS、减少域名数、并行加载、CDN 分发&lt;/li>
&lt;li>缓存：HTTP 协议缓存请求、离线缓存 manifest、离线数据缓存 localStorage&lt;/li>
&lt;li>渲染：JS/CSS 优化，加载顺序，服务端渲染，pipeline&lt;/li>
&lt;/ol>
&lt;h2 id="42-get-和-post-的区别">42 get 和 post 的区别&lt;/h2>
&lt;ol>
&lt;li>get 参数通过 url 传递，post 放在 request body 中&lt;/li>
&lt;li>get 请求在 url 中传递的参数有长度限制，post 没有&lt;/li>
&lt;li>get 参数暴露在 url，不安全。&lt;/li>
&lt;li>get 请求只能进行 url 编码，post 支持多种编码方式&lt;/li>
&lt;li>get 请求浏览器会主动缓存。&lt;/li>
&lt;li>get 请求参数会被完整保留在浏览历史记录。&lt;/li>
&lt;li>get 用来获取资源，post 用来增加或更新资源。&lt;/li>
&lt;/ol>
&lt;h2 id="43-web-worker">43 web worker&lt;/h2>
&lt;p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可响应的，直到脚本执行完成后，页面才变成可响应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面你的性能。并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。&lt;/p>
&lt;p>如何创建 web worker：&lt;/p>
&lt;p>检测浏览器对于 web worker 的支持性&lt;/p>
&lt;p>创建 web worker 文件（js，回传函数等）&lt;/p>
&lt;p>创建 web worker 对象&lt;/p>
&lt;h2 id="44-浮动清除">44 浮动清除&lt;/h2>
&lt;ol>
&lt;li>overflow:hidden/auto&lt;/li>
&lt;li>给浮动的元素的容器添加浮动&lt;/li>
&lt;/ol>
&lt;h2 id="45-css-选择器">45 CSS 选择器&lt;/h2>
&lt;p>ID 选择器、Class 选择器、标签选择器、伪元素选择器、伪类选择器&lt;/p>
&lt;p>优先级：&lt;/p>
&lt;ol>
&lt;li>引入了同类的选择器：排在后面的样式属性优先&lt;/li>
&lt;li>引入了不同的选择器：id&amp;gt;class&amp;gt;标签&lt;/li>
&lt;/ol></description></item></channel></rss>