<!DOCTYPE html>
<html lang="zh-cn">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='Spring Cloud Alibaba原理和实战读书笔记'><title>Spring Cloud Alibaba笔记</title>

<link rel='canonical' href='https://cuterwrite.top/p/spring-cloud-alibaba-1/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='Spring Cloud Alibaba笔记'>
<meta property='og:description' content='Spring Cloud Alibaba原理和实战读书笔记'>
<meta property='og:url' content='https://cuterwrite.top/p/spring-cloud-alibaba-1/'>
<meta property='og:site_name' content='cuterwrite'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='微服务' /><meta property='article:tag' content='Java' /><meta property='article:published_time' content='2021-04-07T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2021-04-07T00:00:00&#43;00:00'/><meta property='og:image' content='https://cuterwrite-1302252842.file.myqcloud.com/typora/image-hosting-master/image-hosting-master/20210503/dolomites-5076492_1920.5srkr3iefto0.jpg' />
<meta name="twitter:title" content="Spring Cloud Alibaba笔记">
<meta name="twitter:description" content="Spring Cloud Alibaba原理和实战读书笔记"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://cuterwrite-1302252842.file.myqcloud.com/typora/image-hosting-master/image-hosting-master/20210503/dolomites-5076492_1920.5srkr3iefto0.jpg' />
    <link rel="shortcut icon" href="/favicon.ico" />

    </head>
    <body class="">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.body.dataset.scheme = 'dark';
        } else {
            document.body.dataset.scheme = 'light';
        }
    })();
</script><div class="container main-container flex on-phone--column extended article-page with-toolbar">
            <aside class="sidebar left-sidebar sticky">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header class="site-info">
        
            <figure class="site-avatar">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hue4d14694a57c01a222a16c47db12c89c_369633_300x0_resize_box_3.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                

                
                    <span class="emoji">😉</span>
                
            </figure>
        
        <h1 class="site-name"><a href="https://cuterwrite.top">cuterwrite</a></h1>
        <h2 class="site-description">欢迎来到我的个人博客。我是cuterwrite，一个热爱生活、不断探索的人。在这里，我分享我的想法、经验和学习，希望可以帮助到你，也欢迎你与我分享你的看法。</h2>
    </header>

    <ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>首页</span>
            </a>
        </li>
        
        

        <li >
            <a href='/about'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>个人</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>文章</span>
            </a>
        </li>
        
        

        <li >
            <a href='/tags'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11 3L20 12a1.5 1.5 0 0 1 0 2L14 20a1.5 1.5 0 0 1 -2 0L3 11v-4a4 4 0 0 1 4 -4h4" />
  <circle cx="9" cy="9" r="2" />
</svg>



                
                <span>标签</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        

        
            <li id="dark-mode-toggle">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                <span>暗色模式</span>
            </li>
        
    </ol>
</aside>

            <main class="main full-width">
    <div id="article-toolbar">
        <a href="https://cuterwrite.top" class="back-home">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



            <span>Back</span>
        </a>
    </div>

    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/spring-cloud-alibaba-1/">
                
                    <img src="https://cuterwrite-1302252842.file.myqcloud.com/typora/image-hosting-master/image-hosting-master/20210503/dolomites-5076492_1920.5srkr3iefto0.jpg" loading="lazy" alt="Featured image of post Spring Cloud Alibaba笔记" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/spring-cloud-alibaba/" style="background-color: #fb7293; color: #fff;">
                Spring-Cloud-Alibaba
            </a>
        
            <a href="/categories/springboot/" style="background-color: #e062ae; color: #fff;">
                SpringBoot
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/spring-cloud-alibaba-1/">Spring Cloud Alibaba笔记</a>
    </h2>

    
    <h3 class="article-subtitle">
        Spring Cloud Alibaba原理和实战读书笔记
    </h3>
    <footer class="article-time">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <time class="article-time--published">2021-04-07</time>
    </footer></div>
</header>
    
    <div id="top"></div>
<section class="article-content">
    <!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><strong>Table of Contents</strong>  <em>generated with <a class="link" href="https://github.com/thlorenz/doctoc"  target="_blank" rel="noopener"
    >DocToc</a></em></p>
<ul>
<li><a class="link" href="#spring-cloud-alibaba%E7%AC%94%E8%AE%B0" >Spring Cloud alibaba笔记</a>
<ul>
<li><a class="link" href="#soa%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB" >SOA与微服务的区别：</a></li>
<li><a class="link" href="#spring-cloud-alibaba%E4%B8%8Espring-cloud-netflix%E7%9A%84%E5%AF%B9%E6%AF%94" >Spring Cloud Alibaba与Spring Cloud Netflix的对比</a></li>
<li><a class="link" href="#%E4%BB%80%E4%B9%88%E6%98%AFspring-boot" >什么是Spring Boot？</a></li>
<li><a class="link" href="#iocdi%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" >IOC/DI（控制反转与依赖注入）</a></li>
<li><a class="link" href="#spring%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B" >Spring发展过程</a></li>
<li><a class="link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E5%AE%9E%E7%8E%B0" >自动装配的实现</a></li>
<li><a class="link" href="#%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAstarter" >手写实现一个Starter</a>
<ul>
<li><a class="link" href="#1-starter%E7%9A%84%E5%8A%9F%E8%83%BD" >1 Starter的功能</a></li>
<li><a class="link" href="#2-starter%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83" >2 Starter的命名规范</a></li>
<li><a class="link" href="#3-%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ERedis%E7%9A%84starter" >3 实现基于Redis的Starter</a></li>
</ul>
</li>
<li><a class="link" href="#apache-dubbo" >Apache Dubbo</a></li>
<li><a class="link" href="#zookeeper" >Zookeeper</a></li>
<li><a class="link" href="#dubbo%E9%9B%86%E6%88%90zookeeper" >Dubbo集成Zookeeper</a>
<ul>
<li><a class="link" href="#1-%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98" >1 需要解决的问题</a></li>
<li><a class="link" href="#2-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4" >2 实现步骤</a></li>
<li><a class="link" href="#3-%E5%8E%9F%E7%90%86" >3 原理</a></li>
<li><a class="link" href="#4-%E5%AE%9E%E6%88%98dubbo-spring-cloud" >4 实战Dubbo Spring Cloud</a></li>
</ul>
</li>
<li><a class="link" href="#dubbo%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8" >Dubbo的高级应用</a>
<ul>
<li><a class="link" href="#1-%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99" >1 集群容错</a></li>
<li><a class="link" href="#2-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" >2 负载均衡</a></li>
<li><a class="link" href="#3-%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7" >3 服务降级</a></li>
</ul>
</li>
<li><a class="link" href="#%E4%B8%BB%E6%9C%BA%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99" >主机绑定规则</a></li>
<li><a class="link" href="#dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" >Dubbo源码分析</a>
<ul>
<li><a class="link" href="#1-%E6%A0%B8%E5%BF%83%E7%82%B9" >1 核心点</a></li>
<li><a class="link" href="#2-%E7%94%9F%E6%88%90ide%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%91%BD%E4%BB%A4" >2 生成IDE工程的命令</a></li>
<li><a class="link" href="#3-spiservice-provider-interface" >3 SPI(Service Provider Interface)</a></li>
<li><a class="link" href="#4-dubbo%E4%B8%AD%E7%9A%84spi%E6%80%9D%E6%83%B3" >4 Dubbo中的SPI思想</a></li>
<li><a class="link" href="#5-dubbo%E4%B8%AD%E7%9A%84spi%E5%8E%9F%E7%90%86" >5 Dubbo中的SPI原理</a></li>
<li><a class="link" href="#6-%E8%87%AA%E9%80%82%E5%BA%94%E6%89%A9%E5%B1%95%E7%82%B9" >6 自适应扩展点</a></li>
<li><a class="link" href="#7-protocol%E8%87%AA%E9%80%82%E5%BA%94%E6%89%A9%E5%B1%95%E7%82%B9%E6%BA%90%E7%A0%81" >7 Protocol自适应扩展点源码</a></li>
<li><a class="link" href="#8-ioc" >8 IOC</a></li>
<li><a class="link" href="#9-aop" >9 AOP</a></li>
<li><a class="link" href="#10-dubbo%E9%9B%86%E6%88%90spring%E6%9C%BA%E5%88%B6%E7%95%A5" >10 Dubbo集成Spring机制（略）</a></li>
</ul>
</li>
<li><a class="link" href="#%E4%BB%80%E4%B9%88%E6%98%AFnacos" >什么是Nacos？</a>
<ul>
<li><a class="link" href="#1-%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7" >1 关键特性</a></li>
<li><a class="link" href="#2-nacos%E9%9B%86%E7%BE%A4" >2 Nacos集群</a></li>
</ul>
</li>
<li><a class="link" href="#%E6%90%AD%E5%BB%BAnacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9" >搭建Nacos注册中心的注意点</a></li>
<li><a class="link" href="#nacos%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" >Nacos实现原理</a>
<ul>
<li><a class="link" href="#1-%E6%A8%A1%E5%9D%97%E7%BB%84%E6%88%90" >1 模块组成</a></li>
<li><a class="link" href="#2-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%8E%9F%E7%90%86" >2 注册中心的原理</a></li>
<li><a class="link" href="#3-nacos%E6%BA%90%E7%A0%81%E7%95%A5" >3 Nacos源码（略）</a></li>
</ul>
</li>
<li><a class="link" href="#nacos%E5%AE%9E%E7%8E%B0%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86" >Nacos实现统一配置管理</a>
<ul>
<li><a class="link" href="#1-nacos%E9%9B%86%E6%88%90spring-boot" >1 Nacos集成Spring Boot</a></li>
<li><a class="link" href="#2-nacos%E9%9B%86%E6%88%90spring-cloud" >2 Nacos集成Spring Cloud</a></li>
<li><a class="link" href="#3-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE" >3 动态更新配置</a></li>
<li><a class="link" href="#4-%E5%9F%BA%E4%BA%8Edataid%E9%85%8D%E7%BD%AEyaml%E7%9A%84%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D" >4 基于DataID配置yaml的文件扩展名</a></li>
<li><a class="link" href="#5-%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE%E5%88%87%E6%8D%A2" >5 不同环境的配置切换</a></li>
<li><a class="link" href="#6-%E8%87%AA%E5%AE%9A%E4%B9%89namespace%E5%92%8Cgroup" >6 自定义Namespace和Group</a></li>
</ul>
</li>
<li><a class="link" href="#nacos-config%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%95%A5" >Nacos Config实现原理（略）</a></li>
<li><a class="link" href="#spring-cloud%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8E%9F%E7%90%86%E7%95%A5" >Spring Cloud加载配置的原理（略）</a></li>
<li><a class="link" href="#nacos%E6%BA%90%E7%A0%81%E7%95%A5" >Nacos源码（略）</a></li>
<li><a class="link" href="#sentinel%E9%99%90%E6%B5%81%E5%8F%8A%E7%86%94%E6%96%AD" >Sentinel限流及熔断</a>
<ul>
<li><a class="link" href="#1-%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0" >1 服务限流的作用及实现</a></li>
<li><a class="link" href="#2-%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E5%92%8C%E9%99%8D%E7%BA%A7" >2 服务熔断和降级</a></li>
<li><a class="link" href="#3-sentinel%E7%9A%84%E7%89%B9%E6%80%A7" >3 Sentinel的特性</a></li>
<li><a class="link" href="#4-sentinel%E7%9A%84%E7%BB%84%E6%88%90" >4 Sentinel的组成：</a></li>
<li><a class="link" href="#5-sentinel%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8" >5 Sentinel基本应用：</a></li>
<li><a class="link" href="#6-sentinel%E8%B5%84%E6%BA%90%E4%BF%9D%E6%8A%A4%E8%A7%84%E5%88%99" >6 Sentinel资源保护规则</a>
<ul>
<li><a class="link" href="#1-qps%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%A1%8C%E4%B8%BA" >1 QPS流量控制行为</a></li>
</ul>
</li>
<li><a class="link" href="#7-sentinel%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD" >7 Sentinel实现服务熔断</a></li>
</ul>
</li>
<li><a class="link" href="#sentinel%E9%9B%86%E6%88%90spring-cloud" >Sentinel集成Spring Cloud</a></li>
<li><a class="link" href="#%E5%9F%BA%E4%BA%8Esentinel-dashboard%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%B5%81%E6%8E%A7%E9%85%8D%E7%BD%AE" >基于Sentinel Dashboard来实现流控配置</a></li>
<li><a class="link" href="#sentinel%E8%87%AA%E5%AE%9A%E4%B9%89url%E9%99%90%E6%B5%81%E5%BC%82%E5%B8%B8" >Sentinel自定义URL限流异常</a></li>
<li><a class="link" href="#sentinel%E5%AF%B9url%E8%B5%84%E6%BA%90%E6%B8%85%E6%B4%97" >Sentinel对URL资源清洗</a></li>
<li><a class="link" href="#sentinel%E9%9B%86%E6%88%90nacos%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99" >Sentinel集成Nacos实现动态流控规则</a></li>
<li><a class="link" href="#sentinel%E9%9B%86%E6%88%90nacos%E5%AE%9E%E7%8E%B0%E8%A7%84%E5%88%99%E5%90%8C%E6%AD%A5" >Sentinel集成Nacos实现规则同步</a>
<ul>
<li><a class="link" href="#1-sentinel-dashboard%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9" >1 Sentinel Dashboard源码修改：</a></li>
<li><a class="link" href="#2-sentinel-dashboard%E8%A7%84%E5%88%99%E5%90%8C%E6%AD%A5" >2 Sentinel Dashboard规则同步</a></li>
</ul>
</li>
<li><a class="link" href="#sentinel%E9%9B%86%E6%88%90dubbo%E5%AE%9E%E7%8E%B0%E9%99%90%E6%B5%81" >Sentinel集成Dubbo实现限流</a>
<ul>
<li><a class="link" href="#" >*</a></li>
<li><a class="link" href="#1-dubbo%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%85%A5sentinel-dashboard" >1 Dubbo服务接入Sentinel Dashboard</a></li>
<li><a class="link" href="#2-dubbo%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99" >2 Dubbo服务限流规则</a></li>
</ul>
</li>
<li><a class="link" href="#sentinel%E7%83%AD%E7%82%B9%E9%99%90%E6%B5%81" >Sentinel热点限流</a>
<ul>
<li><a class="link" href="#1-%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8" >1 热点参数限流的使用</a></li>
<li><a class="link" href="#2-sentinelresource" >2 @SentinelResource</a></li>
<li><a class="link" href="#3-%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E" >3 热点参数规则说明</a></li>
</ul>
</li>
<li><a class="link" href="#sentinel%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%95%A5" >Sentinel的工作原理（略）</a></li>
<li><a class="link" href="#spring-cloud-sentinel%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%95%A5" >Spring Cloud Sentinel工作原理（略）</a></li>
<li><a class="link" href="#sentinel%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%95%A5" >Sentinel核心源码分析（略）</a>
<ul>
<li><a class="link" href="#1-%E9%99%90%E6%B5%81%E7%9A%84%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0" >1 限流的源码实现</a></li>
<li><a class="link" href="#2-%E5%AE%9E%E6%97%B6%E6%8C%87%E6%A0%87%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1" >2 实时指标数据统计</a></li>
<li><a class="link" href="#3-%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" >3 服务降级的实现原理</a></li>
</ul>
</li>
<li><a class="link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1" >什么是分布式事务？</a>
<ul>
<li><a class="link" href="#1-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E7%9A%84%E7%90%86%E8%AE%BA%E6%A8%A1%E5%9E%8B" >1 分布式事务问题的理论模型</a>
<ul>
<li><a class="link" href="#1-xopen%E5%88%86%E5%B8%83%E5%BC%8F%E6%A8%A1%E5%9E%8B" >1 X/Open分布式模型</a></li>
<li><a class="link" href="#2-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE" >2 两阶段提交协议</a></li>
<li><a class="link" href="#3-%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE" >3 三阶段提交协议</a></li>
<li><a class="link" href="#4-cap%E5%AE%9A%E7%90%86%E5%92%8Cbase%E7%90%86%E8%AE%BA" >4 CAP定理和BASE理论</a></li>
</ul>
</li>
<li><a class="link" href="#2-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E7%9A%84%E5%B8%B8%E8%A7%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" >2 分布式事务问题的常见解决方案</a>
<ul>
<li><a class="link" href="#1-tcc%E8%A1%A5%E5%81%BF%E6%80%A7%E6%96%B9%E6%A1%88" >1 TCC补偿性方案</a></li>
<li><a class="link" href="#2-%E5%9F%BA%E4%BA%8E%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%B6%88%E6%81%AF%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88" >2 <strong>基于可靠性消息的最终一致性方案</strong></a></li>
<li><a class="link" href="#3-%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5%E5%9E%8B" >3 最大努力通知型</a></li>
</ul>
</li>
<li><a class="link" href="#3-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6seata" >3 分布式事务框架Seata</a>
<ul>
<li><a class="link" href="#1-at%E6%A8%A1%E5%BC%8F" >1 AT模式</a></li>
<li><a class="link" href="#2-saga%E6%A8%A1%E5%BC%8F" >2 Saga模式</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<h1 id="spring-cloud-alibaba笔记">Spring Cloud alibaba笔记</h1>
<h2 id="soa与微服务的区别">SOA与微服务的区别：</h2>
<ol>
<li>SOA关注的是服务的重用性及解决信息孤岛问题</li>
<li>微服务关注的是解耦，虽然解耦和可重用性从特定的角度来看是一样的，但本质上是有区别的，解耦是降低业务之间的耦合度，而重用性关注的是服务的复用。</li>
<li>微服务会更多地关注在DevOps的持续交付上，因为服务粒度细化之后使得开发运维变得更加重要，因此微服务与容器化技术的结合更加紧密。</li>
</ol>
<h2 id="spring-cloud-alibaba与spring-cloud-netflix的对比">Spring Cloud Alibaba与Spring Cloud Netflix的对比</h2>
<ol>
<li>Alibaba开源组件在没有织入Spring Cloud生态之前，已经在各大公司广泛应用，所以容易实现技术整合及迁移。</li>
<li>Alibaba开源组件在服务治理上和处理高并发的能力上有天然的优势。</li>
</ol>
<h2 id="什么是spring-boot">什么是Spring Boot？</h2>
<p>帮助开发者快速构建一个基于Spring Framework及Spring生态体系的应用解决方案，也是对于“约定优于配置”理念的最佳实践。</p>
<h2 id="iocdi控制反转与依赖注入">IOC/DI（控制反转与依赖注入）</h2>
<ol>
<li>IOC：把对象的生命周期托管到Spring容器中，而反转是指对象的获取方式被反转了。</li>
<li>当使用IOC容器之后，客户端类不需要通过new来创建这些对象，而是直接从IOC容器中获得。早期的Spring中，主要通过XML的方式来定义Bean，Spring会解析XML文件，把定义的Bean转载到IOC容器中。</li>
<li>DI：IOC容器在运行期间，动态地把某种依赖关系注入组件中。</li>
<li>DI的三种方法：接口注入、构造方法注入、setter方法注入；目前是基于注解的形式：有@Autowired、@Inject和@Resource</li>
</ol>
<h2 id="spring发展过程">Spring发展过程</h2>
<ol>
<li>J2EE的EJB时代</li>
<li>Spring XML配置文件时代</li>
<li>JavaConfig的无配置化注入时代</li>
<li>Spring Boot时代：约定优于配置，核心为：
<ol>
<li>Starter组件：开箱即用</li>
<li>自动装配：自动根据上下文完成Bean的装配</li>
<li>Actuator：应用监控</li>
<li>Spring Boot CLI：脚手架</li>
</ol>
</li>
</ol>
<h2 id="自动装配的实现">自动装配的实现</h2>
<ol>
<li>
<p>实现原理：@EnableAutoConfiguration，这个注解的声明在启动类注解@SpringBootApplication内。进一步又涉及到@Enable注解（本质上是对@Configuration和@Bean的封装）；使用Enable注解后，Spring会解析到@Import导入的配置类，从而根据这个配置类中的描述来实现Bean的装配。</p>
</li>
<li>
<p>例子：可以直接使用@Autowired来注入RedisTemplate实例。</p>
</li>
<li>
<p>EnableAutoConfiguration的原理</p>
<p>@Import：导入一个AutoConfigurationImportSelector类。</p>
<p>@AutoConfigurationPackage：把使用了该注解的类所在的类所在的包及子包下所有组件扫描到Spring IoC容器中</p>
</li>
<li>
<p>AutoConfigurationImportSelector：是ImportSelector的实现类，只有一个selectImports抽象方法，并且返回一个String数组，在这个数组中可以指定需要装配到IOC容器的类，当@Import中导入一个ImportSelectord的实现类后，会把该实现类中返回的Class名称都装载到IOC容器中。</p>
</li>
<li>
<p>ImportSelector与@Configuration的区别：前者可以实现批量装配，并且还可以通过逻辑处理来实现Bean的选择性装配，也就是根据上下文来决定哪些类能够被IOC容器初始化。</p>
</li>
<li>
<p>自动装配原理总结：</p>
<ol>
<li>通过@Import(AutoConfigurationImportSelector)实现配置类的导入</li>
<li>AutoConfigurationImportSelector类实现了ImportSelector接口，重写了方法selectImports，用于实现选择性批量配置类的装配。</li>
<li>通过Spring提供的SpringFactoriesLoader机制，扫描classpath路径下的META-INF/spring.factories，读取需要实现自动装配的配置类。</li>
<li>通过条件筛选的方式，把不符合条件的配置类移除，最终完成自动装配。</li>
</ol>
</li>
<li>
<p>@Conditional条件装配</p>
<p>是Spring Framework提供的一个核心注解，这个注解的作用是提供自动装配的条件约束，一般与@Configuration和**@Bean**配合使用。</p>
<p>简单来说，Spring在解析@Configuration配置类时，如果该配置类增加了@Conditional注解，那么就会根据该注解配置的条件来决定是否要实现Bean的装配。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Configuration</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConditionConfig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Conditional</span><span class="o">(</span><span class="n">GpCondition</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">ThirdClass</span> <span class="nf">thirdClass</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">ThirdClass</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>表示：如果GpCondition类中的matches返回true，则装载ThirdClass这个类。</p>
</li>
<li>
<p>@Conditional在Spring Boot中的扩展</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210224200015800.png" alt="image-20210224200015800"  /></p>
<p>常用装配注解：</p>
<p>@ConditionalOnBean</p>
<p>@ConditionalOnMissingBean</p>
<p>@ConditionalOnResource</p>
<p>@ConditionalOnProperties</p>
</li>
<li>
<p>spring-autoconfigure-metadata</p>
<p>用于实现批量自动装配条件配置，作用和@Conditional一致，只是把这些条件配置放在了配置文件中。</p>
<p>两个条件：</p>
<p>（1）配置文件的路径和名称必须是/META-INF/spring-autoconfigure-metadata.properties</p>
<p>（2）配置文件中key的配置格式：自动配置类的类全路径名.条件=值</p>
<p>好处：有效降低Spring Boot的启动时间，通过这种过滤方式可以减少配置类的加载数量，因为这个过滤发生在配置类的装载之前，所以它可以降低Spring Boot启动时装载Bean的耗时。</p>
</li>
</ol>
<h2 id="手写实现一个starter">手写实现一个Starter</h2>
<h3 id="1-starter的功能">1 Starter的功能</h3>
<ul>
<li>涉及相关组件的Jar包依赖</li>
<li>自动实现Bean的装配</li>
<li>自动声明并且加载application.properties文件中的属性配置。</li>
</ul>
<h3 id="2-starter的命名规范">2 Starter的命名规范</h3>
<p>Starter的命名主要分为官方命名和自定义组件命名两类，这种命名格式不是强制性的，也是一种约定俗成的方式。</p>
<ul>
<li>官方命名格式：spring-boot-starter-模块名称</li>
<li>自定义命名格式：模块名称-spring-boot-starter</li>
</ul>
<h3 id="3-实现基于redis的starter">3 实现基于Redis的Starter</h3>
<ul>
<li>创建一个工程，命名为redis-spring-boot-starter</li>
<li>添加Jar包依赖</li>
<li>定义属性类，实现在application.properties中配置Redis的连接参数，使用@ConfigurationProperties，把当前类中的属性和配置文件中的配置进行绑定，并且规定前缀。</li>
<li>定义需要自动装配的配置类，主要就是把RedissonClient装配到IOC容器中。</li>
</ul>
<h2 id="apache-dubbo">Apache Dubbo</h2>
<ol>
<li>
<p>什么是Dubbo：一个分布式服务框架，主要实现多个系统之间的高性能、透明化调用，简单来说就是一个RPC框架，但是和普通的RPC框架不同，它提供了服务治理功能，比如服务注册、监控、路由、容错等。</p>
</li>
<li>
<p>服务提供者开发流程：</p>
<ol>
<li>创建一个普通的Maven工程provider，并创建两个模块：api和provider，其中provider是一个Spring Boot工程</li>
<li>在api模块中定义接口，并且通过mvn install安装到本地仓库</li>
<li>在provider模块的pom文件中引入api和dubbo组件。</li>
<li>在provider中实现接口，并且使用@DubboService注解发布服务</li>
<li>在application.properties文件（或yml）中添加Dubbo服务的配置信息，包括application.name、protocal.name、protocol.port和registry.address</li>
<li>启动Spring Boot</li>
</ol>
</li>
<li>
<p>服务调用者的开发流程：</p>
<ol>
<li>创建一个Spring Boot项目consumer，添加Jar包依赖（Dubbo和api）</li>
<li>在application.properties中配置dubbo.application.name</li>
<li>使用@DubboReference注解获取一个远程代理对象。</li>
</ol>
</li>
</ol>
<h2 id="zookeeper">Zookeeper</h2>
<ol>
<li>
<p>Zookeeper是一个高性能的分布式协调中间件，基于Java编写。</p>
</li>
<li>
<p>Zookeeper的数据结构：数据模型和分布式文件系统类似，是一种层次化的属性结构，区别是：Zookeeper的数据是结构化存储的，并没有在物理上体现出文件和目录。Zookeeper树中的每个节点被称为Znode，Znode维护了一个stat状态信息，其中包含数据变化的时间和版本等。并且每个Znode可以设置一个value值，Zookeeper并不用于通用的数据库或者大容量的对象存储，它只是管理和协调有关的数据，所以value的数据大小不建议设置得非常大，否则会带来更大的网络开销。Zookeeper上的每一个节点的数据都是允许读和写的，读表示指定获得Znode上的value数据，写表示修改Znode上的value数据。另外，节点的创建规则和文件系统中文件的创建规则类似，必须按照层次创建。例如：创建/node/node1/node1-1，先要创建/node/node1这两个层次节点。</p>
</li>
<li>
<p>Zookeeper的特性：Znode在被创建后，需要指定节点的类型，节点类型分为：</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225003640228.png" alt=""  /></p>
</li>
<li>
<p>Watcher机制：</p>
<ol>
<li>
<p>Znode的订阅/通知机制：当Znode节点状态发生变化时或者Zookeeper客户端连接状态发生变化时，会触发事件通知。这个机制在服务注册与发现中，针对服务调用者及时感知到服务提供者的变化提供了非常好的解决方案。</p>
</li>
<li>
<p>Zookeeper提供的Java API中，提供了三种机制来针对Znode进行注册监听，分别是：</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225003945831.png" alt="image-20210225003945831"  /></p>
</li>
<li>
<p>常用应用场景分析</p>
<ol>
<li>分布式锁：（1）多线程中Synchronized和Lock用于解决共享资源访问的数据安全性问题，但范围是线程级别的。（2）在分布式架构中，多个进程对同一个共享资源的访问，也存在数据安全性问题，因此也需要使用锁的形式来解决这类问题，而解决分布式环境下多进程对于共享资源访问带来的安全性问题的方案就是使用分布式锁。锁的本质是排他性，也就是避免同一时刻多个进程同时访问某一个共享资源。（3）如果使用Zookeeper实现分布式锁来达到排他性的目的，只需要用到节点的特性：临时节点，以及同级节点的唯一性。（4）具体实现：a.获得锁的过程：所有客户端可以去Zookeeper服务器上/Exclusive_Locks节点下创建一个临时节点/lock。Zookeeper基于同级节点的唯一性，会保证所有客户端中只有一个客户端能创建成功，创建成功的客户端获得了排它锁，没有获得锁的客户端就需要通过Watcher机制监听/Exclusive_Locks节点下子节点的变更事件，用于实时监听/lock节点的变化情况以作出反应。 b.释放锁的过程：①获得锁的客户端因为异常断开了和服务端的连接，临时节点会自动删除。②获得锁的客户端执行完业务逻辑后，主动删除创建的lock节点。</li>
<li>Master选举：分布式系统中的集群模式，某一机器宕机后，其他节点会接替故障节点继续工作。（1）Zookeeper有两种方式来实现Master选举的场景。假设集群中有3个节点，需要选举出Master，那么三个节点同时去Zookeeper服务器上创建一个临时节点/master-election，由于节点的唯一性，只会有一个客户端创建成功，创建成功就称为Master。同时，其他没有创建成功的客户端，针对该节点注册Watcher事件，监控master，一旦/master-election节点被删除，其他客户端重新发起master选举。（2）方法二：利用临时有序节点的特性来实现。所有参与选举的节点在/master节点下创建一个临时有序节点，编号最小的节点表示master，后续的节点监听上一个节点的删除事件，用于触发重新选举。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="dubbo集成zookeeper">Dubbo集成Zookeeper</h2>
<h3 id="1-需要解决的问题">1 需要解决的问题</h3>
<ul>
<li>服务动态上下线感知：服务调用者要感知到服务提供者上下线的变化。</li>
<li>负载均衡</li>
</ul>
<h3 id="2-实现步骤">2 实现步骤</h3>
<ol>
<li>在provider模块中添加Zookeeper相关依赖</li>
<li>修改application.properties配置文件，修改dubbo的registry-addr为zookeeper服务器的地址，表示当前Dubbo服务需要注册到Zookeeper上。</li>
<li>consumer只需要修改application.properties，设置dubbo的registry-addr即可</li>
</ol>
<h3 id="3-原理">3 原理</h3>
<ol>
<li>
<p>Dubbo服务注册到Zookeeper上之后，可以在Zookeeper服务器上看到图下所示的树形结构。</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225005911001.png" alt="image-20210225005911001"  /></p>
</li>
<li>
<p>其中URL是临时节点，其他皆为持久化节点，如果注册该节点的服务器下线了，那么这个服务器的URL地址就会被移除。</p>
</li>
<li>
<p>当Dubbo服务消费者启动时，会对/providers下的子节点注册Watcher监听，这样就可以感知到服务提供方的上下线变化，从而防止请求发送到已经下线的服务器造成访问失败。同时，服务消费者会在/consumers下写入自己的URL，这样可以在监控平台上看到某个Dubbo服务正在被哪些服务调用。最重要的是，如果服务消费者需要调用一个服务，那么它会先去/providers路径下获得所有该服务的提供方URL列表，然后通过负载均衡算法计算出一个地址进行远程访问。</p>
</li>
<li>
<p>此外，Dubbo还可以针对不同的情况实现以下功能：</p>
<ol>
<li>基于临时节点的特性，当服务器宕机或者下线时，注册中心会自动删除该服务提供者的信息。</li>
<li>注册中心重启时，Dubbo能自动恢复注册数据及订阅请求。</li>
<li>为了保证节点操作的安全性，Zookeeper提供了ACL权限控制，在Dubbo中可以通过register.username和password来设置节点的验证信息。</li>
<li>注册中心默认的根节点为/dubbo，如果需要针对不同环境设置不同的根节点，可以使用registry.group修改根节点名称。</li>
</ol>
</li>
</ol>
<h3 id="4-实战dubbo-spring-cloud">4 实战Dubbo Spring Cloud</h3>
<ol>
<li>创建service-provider工程，创建两个子模块api和provider，前者为maven工程，后者为Spring Boot工程</li>
<li>在api中声明接口，并执行mvn install</li>
<li>在provider中添加api、Spring Boot、Spring Cloud和Spring Cloud Alibaba相关组件的依赖。（包括spring-cloud-starter、spring-cloud-starter-dubbo、api、discovery）</li>
<li>在父pom中显示声明dependencyManagement配置版本。</li>
<li>在provider中创建接口的实现类，并且声明@DubboService</li>
<li>在application.properties中配置Dubbo相关信息。</li>
<li>启动provider服务。</li>
<li>创建consumer，依赖与provider类似，同样在application.properties中配置Dubbo相关信息。注意：dubbo-cloud-subscribed-services表示服务调用者订阅的服务提供方的应用名称列表，如果有多个应用名称，可以通过&quot;,&ldquo;分开，默认值为“*”</li>
<li>使用@DubboReference消费服务，启动即可。</li>
</ol>
<h2 id="dubbo的高级应用">Dubbo的高级应用</h2>
<h3 id="1-集群容错">1 集群容错</h3>
<p>Dubbo默认提供6种容错模式，默认为Failover Cluster，此外可以根据实际需求自行扩展。</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225012015079.png" alt="image-20210225012015079"  /></p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225012046078.png" alt="image-20210225012046078"  /></p>
<ul>
<li>配置方式：在@DubboService中增加参数cluster=&ldquo;failfast&quot;即可。</li>
<li>推荐：查询语句容错策略建议使用默认的Failover Cluster，而增删改操作建议使用Failfast Cluster或者使用Failover Cluster(retries=0)，防止出现数据重复添加等其他问题！建议在设计接口的时候把查询接口方法单独做成一个接口提供查询。</li>
</ul>
<h3 id="2-负载均衡">2 负载均衡</h3>
<p>Dubbo提供了4种负载均衡策略，默认为random，也可以自行扩展（基于SPI机制）。</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225012419926.png" alt="image-20210225012419926"  /></p>
<h3 id="3-服务降级">3 服务降级</h3>
<p>服务降级是一种系统保护策略，当服务器访问压力较大时，可以根据当前业务情况对不重要的服务进行降级，以保证核心业务的正常运行。所谓的降级，就是把一些非必要的功能在流量较大的时间段暂时关闭，比如在双十一大促时，淘宝会把查看历史订单、商品评论等功能关闭。</p>
<p>降级的分类：</p>
<ul>
<li>是否自动化：人工降级、自动降级</li>
<li>功能划分：读服务降级和写服务降级</li>
</ul>
<p>自动降级更多来自于系统出现某些异常时自动触发“兜底的流畅”，比如：</p>
<ul>
<li>故障降级：调用的远程服务挂了，网络故障或者RPC服务返回异常。这类情况在业务情况下可以通过设置兜底数据响应给客户端。</li>
<li>限流降级：为了保护系统不被压垮，在系统中会针对核心业务进行限流，当请求流量达到阈值时，后续的请求会被拦截。</li>
</ul>
<p>Dubbo提供了一种Mock配置来实现服务降级，也就是当服务提供方出现网络异常无法访问时，客户端不抛出异常，步骤如下：</p>
<ol>
<li>在consumer中创建MockService，这个类只需要实现降级的接口即可，重写接口中的抽象方法实现本地数据的返回。</li>
<li>在@DubboReference中增加mock参数，制定MockService的位置。</li>
<li>在不启动Dubbo服务或者服务端的返回值超过默认的超时时间时，得到的数据就是MockService中的数据。</li>
</ol>
<h2 id="主机绑定规则">主机绑定规则</h2>
<p>主机绑定表示的是Dubbo服务对外发布的IP地址，默认情况下Dubbo会按照以下顺序来查找并绑定主机IP地址。</p>
<ul>
<li>
<p>查找环境变量DUBBO_IP_TO_BIND属性配置的IP地址。</p>
</li>
<li>
<p>查找dubbo.protocol.host属性的IP地址，默认是空，如果没有配置或者IP地址不合法则继续查找。</p>
</li>
<li>
<p>通过LocalHost.getHostAddress获取本机IP地址，获取失败则继续。</p>
</li>
<li>
<p>如果配置了注册中心的地址，则使用Socket通信连接到注册中心的地址后，使用for循环通过socket.getLocalAddress().getHostAddress()扫描各个网卡来获取网卡IP的地址。</p>
</li>
<li>
<p>建议：通过dubbo.protocal.host设置主机地址，防止注册错误的IP地址，使服务消费者无法调用。</p>
</li>
<li>
<p>docker部署解决方案：使用&ndash;net=host绑定网络，然后配置application.yml</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210301020007424.png" alt="image-20210301020007424"  /></p>
<p>配置inetutils下的两个参数</p>
</li>
</ul>
<h2 id="dubbo源码分析">Dubbo源码分析</h2>
<h3 id="1-核心点">1 核心点</h3>
<ul>
<li>SPI机制</li>
<li>自适应扩展点</li>
<li>IOC和AOP</li>
<li>Dubbo如何与Spring集成。</li>
</ul>
<h3 id="2-生成ide工程的命令">2 生成IDE工程的命令</h3>
<ul>
<li>mvn idea:idea</li>
<li>mvn eclipse:eclipse</li>
</ul>
<h3 id="3-spiservice-provider-interface">3 SPI(Service Provider Interface)</h3>
<ul>
<li>自适应扩展点：AdaptiveExtension</li>
<li>指定名称扩展点：Extension(name)</li>
<li>激活扩展点：ActivateExtension(url,key)</li>
</ul>
<p>SPI是JDK内置的一种服务提供发现机制，主要用于服务的扩展实现。SPI机制在很多场景中都有运用，比如数据库连接，JDK提供了Driver接口，这个驱动类由不同的数据库厂商来实现，然后JDK利用SPI机制从classpath下找到相应的驱动来获得指定数据库的连接。这种插拔式的扩展加载方式，也同样遵循一定的协议约定，比如所有的扩展点必须要放在resources/META-INF/services目录下，SPI机制会默认扫描这个路径下的属性文件以完成加载。</p>
<h3 id="4-dubbo中的spi思想">4 Dubbo中的SPI思想</h3>
<p>Dubbo或者SpringFactoriesLoader并没有使用JDK内置的SPI机制，只是利用了SPI的思想。Dubbo SPI的相关逻辑被封装在了ExtensionLoader类中，通过ExtensionLoader我们可以加载指定的实现类。</p>
<p>Dubbo的SPI扩展有两个规则：</p>
<ul>
<li>和JDK内置的SPI一样，需要在resources目录下创建任一目录结构：META-INF/dubbo、META-INF/dubbp/internal、META-INF/services，在对应的目录下创建以接口全路径名命名的文件，Dubbo会去三个目录下加载相应扩展点。</li>
<li>文件内容和JDK内置的SPI不一样，内容是key-value形式的数据，key是一个字符串，value是一个对应扩展点的实现，这样的方式可以按照需要加载指定的实现类。</li>
</ul>
<p>实现步骤如下：</p>
<ul>
<li>在一个依赖了Dubbo框架的工程中，创建一个扩展点及一个实现。其中，扩展点需要声明@SPI注解。</li>
<li>在resources/META-INF/dubbo目录下创建以SPI接口命名的文件</li>
<li>使用ExtensionLoader.getExtensionLoader.getExtension(key)获得指定名称的扩展点实现。</li>
</ul>
<h3 id="5-dubbo中的spi原理">5 Dubbo中的SPI原理</h3>
<p>（1）ExtensionLoader.getExtensionLoader：这个方法用于返回一个ExtensionLoader实例，逻辑如下：</p>
<ul>
<li>先从缓存中获取与扩展类对应的ExtensionLoader</li>
<li>缓存未命中，则创建一个新的实例，保存到eEXTENXION_LOADERS集合中缓存起来。</li>
<li>在ExtensionLoader构造方法中，初始化一个objectFactory</li>
</ul>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225020109248.png" alt="image-20210225020109248"  /></p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225020130724.png" alt="image-20210225020130724"  /></p>
<p>（2）getExtension：这个方法用于根据指定名称获取对应的扩展点并返回。</p>
<ul>
<li>name用于参数的判断，如果name=&ldquo;true&rdquo;，则返回一个默认的扩展实现。</li>
<li>创建一个Holder对象，用户缓存该扩展点的实例。</li>
<li>如果缓存中不存在，则通过createExtension(name)创建一个扩展点。</li>
</ul>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225020354825.png" alt="image-20210225020354825"  /></p>
<p>（3）createExtension()：去指定的路径下查找name对应的扩展点的实现。</p>
<ul>
<li>通过getExtensionClasses().get(name)获取一个扩展类</li>
<li>通过反射实例化之后缓存到EXTENSION_INSTANCES集合中。</li>
<li>injectExtension实例依赖注入</li>
<li>把扩展类对象通过Wrapper进行包装。</li>
</ul>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225020624033.png" alt="image-20210225020624033"  /></p>
<p>（4）getExtensionClasses()</p>
<ul>
<li>从缓存中换取已经被加载的扩展类</li>
<li>如果缓存未命中，则调用loadExtensionClasses加载扩展类。</li>
</ul>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225020823393.png" alt="image-20210225020823393"  /></p>
<p>（5）loadExtensionClasses()</p>
<ul>
<li>通过cacheDefaultExtensionName方法获取当且扩展接口的默认扩展对象，并且缓存。</li>
<li>调用loadDirectory方法加载指定文件目录下的配置文件。</li>
</ul>
<p>（6）cacheDefaultExtensionName()</p>
<ul>
<li>获得指定扩展接口的@SPI注解</li>
<li>得到@SPI注解中的名字，保存到cacheDefaultName属性中。</li>
</ul>
<h3 id="6-自适应扩展点">6 自适应扩展点</h3>
<p>Adaptive Extension：能够根据上下文动态匹配一个扩展类，使用方式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ExtensionLoader</span><span class="o">.</span><span class="na">getExtensionLoader</span><span class="o">(</span><span class="n">class</span><span class="o">).</span><span class="na">getAdaptiveExtension</span><span class="o">();</span>
</span></span></code></pre></div><p>自适应扩展点通过@Adaptive注解声明，有两种使用方式</p>
<p>（1）@Adaptive注解定义在类上面，表示当前类为自适应扩展点。</p>
<p>（2）@Adaptive注解定义上方法层面，会通过动态代理的方式生成一个动态字节码，进行自适应匹配。</p>
<h3 id="7-protocol自适应扩展点源码">7 Protocol自适应扩展点源码</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ExtensionLoader</span><span class="o">.</span><span class="na">getExtensionLoader</span><span class="o">(</span><span class="n">Protocol</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getAdaptiveExtension</span><span class="o">();</span>
</span></span></code></pre></div><p>首先是getExtensionLoader：</p>
<p>（1）从缓存中获取自适应扩展点实例。</p>
<p>（2）如果缓存未命中，则通过createAdaptiveExtension创建自适应扩展点。</p>
<p>然后是createAdaptiveExtension：</p>
<p>（1）getAdaptiveExtensionClass：获取一个自适应扩展类的实例。</p>
<p>（2）injectExtension完成依赖注入。</p>
<p>接着是getAdaptiveExtensionClass：</p>
<p>（1）通过<strong>getExtensionClasses</strong>方法加载当前传入类型的所有扩展点，缓存在一个集合中。</p>
<p>（2）如果cachedAdaptiveClass为空，则调用createAdaptiveExtensionClass进行创建。</p>
<h3 id="8-ioc">8 IOC</h3>
<p>上文中的injectExtension就是依赖注入的实现，整体逻辑为：</p>
<p>（1）遍历被加载的扩展类中的所有set方法。</p>
<p>（2）得到set方法中的参数类型，如果参数类型是对象类型，则获得这个set方法中的属性名称。</p>
<p>（3）使用自适应扩展点加载该属性名称对应的扩展类。</p>
<p>（4）调用set完成赋值。</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225192001158.png" alt="image-20210225192001158"  /></p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225192017631.png" alt="image-20210225192017631"  /></p>
<p>简单来说，injectExtension方法的主要功能是，如果当前加载的扩展类中存在一个成员对象，并且为它提供了set方法，那么就会通过自适应扩展点进行加载并赋值。</p>
<h3 id="9-aop">9 AOP</h3>
<p>面向切面编程，意图是把业务逻辑和功能逻辑分离，然后在运行期间或者类加载期间进行织入，可以降低代码的复杂性，以及提高重用性。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">instance</span> <span class="o">=</span> <span class="n">injectExtension</span><span class="o">((</span><span class="n">T</span><span class="o">)</span><span class="n">WrapperClass</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">(</span><span class="n">type</span><span class="o">).</span><span class="na">newInstance</span><span class="o">(</span><span class="n">instance</span><span class="o">));</span>
</span></span></code></pre></div><p>这段代码分别用到了依赖注入和AOP，AOP体现在基于Wrapper装饰器类实现对原有的扩展类instance进行包装。</p>
<h3 id="10-dubbo集成spring机制略">10 Dubbo集成Spring机制（略）</h3>
<p>p89</p>
<h2 id="什么是nacos">什么是Nacos？</h2>
<p>Nacos致力于解决微服务中的统一配置、服务注册与发现等问题。它提供了一组简单易用的特性集，帮助开发者快速实现动态服务发现、服务配置、服务元数据以及流量管理。</p>
<h3 id="1-关键特性">1 关键特性</h3>
<ul>
<li>
<p>服务发现和服务健康监测</p>
<p>Nacos基于DNS和基于RPC的服务发现。服务提供者通过原生SDK、OpenAPI或一个独立的Agent TODO注册Service后，服务消费者可以使用DNS或HTTP&amp;API查找和发现服务。</p>
<p>Nacos提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos支持传输层（PING或TCP）和应用层（如HTTP、MYSQL、用户自定义）的健康检查。对于复杂的云环境和网络拓扑环境（如VPC、边缘网络等）服务的健康检查，Nacos提供了<strong>agent上报</strong>和<strong>服务端主动监测</strong>两种健康检查模式。Nacos还提供了统一的健康检查仪表盘。</p>
</li>
<li>
<p>动态配置服务</p>
<p>业务服务一般都会维护一个本地配置文件，然后把一些常量配置到这个文件中。这种方式在某些场景会存在某些问题，比如配置变更时需要重新部署应用。而动态配置服务可以以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。</p>
</li>
<li>
<p>动态DNS服务</p>
<p>支持权重路由，让开发者更容易实现中间层负载均衡、更灵活的路由策略、流量控制，以及数据中心内网的简单DNS服务。</p>
</li>
<li>
<p>服务及其元数据管理</p>
</li>
</ul>
<h3 id="2-nacos集群">2 Nacos集群</h3>
<p>包含一个Leader节点和多个Follower节点。</p>
<p>数据一致性算法采用的Raft（Etcd、Redis哨兵选举也是这个算法）</p>
<p>3个或3个以上Nacos节点才能构成集群。</p>
<h2 id="搭建nacos注册中心的注意点">搭建Nacos注册中心的注意点</h2>
<ul>
<li>dubbo.scan.base-packages功能等同于@DubboComponentScan</li>
<li>dubbo.registry.address：Dubbo服务注册中心的配置地址，它的值spring-cloud://url表示挂载到Spring Cloud注册中心，不配置的话会提示没有配置注册中心的错误。</li>
<li>spring.cloud.nacos.discovery.server-addr：Nacos服务注册中心的地址。</li>
</ul>
<h2 id="nacos实现原理">Nacos实现原理</h2>
<h3 id="1-模块组成">1 模块组成</h3>
<ul>
<li>Provider App</li>
<li>Consumer App</li>
<li>Name Server</li>
<li>Nacos Server</li>
<li>Nacos Console</li>
</ul>
<p>整体来说，服务提供者通过Virtual IP访问Nacos Server高可用集群，基于Open API完成服务的注册和服务的查询。Nacos Server本身可以支持主备模式，所以底层会采用数据一致性算法来完成主从节点的整体同步。服务消费者也是如此。</p>
<h3 id="2-注册中心的原理">2 注册中心的原理</h3>
<p>服务注册的功能主要体现在：</p>
<ul>
<li>服务实例在启动时注册到服务注册表，并在关闭时注销。（Open API）</li>
<li>服务消费者查询服务注册表，获得可用实例。</li>
<li>服务注册中心需要调用服务实例的健康检查API来验证它是否能够处理请求。（心跳机制）</li>
</ul>
<h3 id="3-nacos源码略">3 Nacos源码（略）</h3>
<ul>
<li>服务注册</li>
<li>服务地址的获取</li>
<li>服务地址变化的感知</li>
</ul>
<h2 id="nacos实现统一配置管理">Nacos实现统一配置管理</h2>
<p>各个应用自己独立维护本地配置方式的不足：</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225222922897.png" alt="image-20210225222922897"  /></p>
<h3 id="1-nacos集成spring-boot">1 Nacos集成Spring Boot</h3>
<ul>
<li>在application.properties中配置nacos.config.server-addr</li>
<li>创建NacosConfigController，用于从Nacos Server动态读取配置。</li>
<li>@NacosPropertiesSource：用于加载dataId为example的配置源，autoRefreshed表示开启自动更新。</li>
<li>@NacosValue：设置属性的值，其中info表示key，而Local Hello World表示默认值。也就是说如果key不存在，则使用默认值。这是一种高可用的策略。</li>
</ul>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225223903497.png" alt="image-20210225223903497"  /></p>
<h3 id="2-nacos集成spring-cloud">2 Nacos集成Spring Cloud</h3>
<ul>
<li>spring.cloud.nacos.config.prefix表示Nacos配置中心上的DataID的前缀。</li>
<li>spring.cloud.nacos.config.server-addr表示Nacos配置中心的地址。</li>
<li>在Nacos Console创建配置</li>
<li>在启动类中，读取配置中心的数据。</li>
<li>注意坑：配置文件必须用bootstrap.yml这个名称，因为bootstrap加载顺序优于application，因为需要在bootstrap配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息。</li>
</ul>
<h3 id="3-动态更新配置">3 动态更新配置</h3>
<p>通过一个while循环不断读取info属性，当info属性发生变化时，控制台可以监听到。</p>
<h3 id="4-基于dataid配置yaml的文件扩展名">4 基于DataID配置yaml的文件扩展名</h3>
<p>DataID默认规则是${prefix}-${spring.profile.active}.${file-extension}</p>
<ul>
<li>在默认情况下，会去Nacos服务器上加载DataID以${spring.application.name}.${file-extension:properties}为前缀的基础配置。例如：在不通过spring.cloud.nacos.config.prefix指定DataID时，会默认读取DataID为nacos-config-demo.properties的配置信息。</li>
<li>如果明确指定了spring.cloud.nacos.config.prefix，则会加载DataID为指定值的配置。</li>
<li>spring.profile.active表示多环境支持。</li>
</ul>
<p>在实际应用中，<strong>如果使用YAML格式配置</strong>，则需要声明spring.cloud.nacos.config.file-extension=yaml</p>
<h3 id="5-不同环境的配置切换">5 不同环境的配置切换</h3>
<p>Spring Boot多环境支持配置步骤如下：</p>
<ul>
<li>在resource目录下根据不同环境创建不同的配置：
<ul>
<li>application-dev.properties</li>
<li>application-test.properties</li>
<li>application-prod.properties</li>
</ul>
</li>
<li>定义一个application.properties默认配置，在该配置中通过spring.profile.active=${env}来指定使用哪个环境的配置，如果${env}的值为prod，表示使用prod环境。</li>
<li>也可以通过设置 VM Options=-Dspring.profiles.active=prod来指定。</li>
</ul>
<p>Nacos Config配置步骤如下：</p>
<ul>
<li>在bootstrap.properties中声明spring.profiles.active=prod</li>
<li>在Nacos控制台新增DataID为nacos-config-demo-prod.properties的配置项。</li>
</ul>
<h3 id="6-自定义namespace和group">6 自定义Namespace和Group</h3>
<ul>
<li>Namespace：解决多环境及多租户数据的隔离问题。
<ul>
<li>使用：在bootstrap.properties里指定spring.cloud.nacos.config.namespace</li>
</ul>
</li>
<li>Group：用于分组管理Data ID
<ul>
<li>使用：在bootstrap.properties里指定spring.cloud.nacos.config.group</li>
</ul>
</li>
</ul>
<h2 id="nacos-config实现原理略">Nacos Config实现原理（略）</h2>
<ul>
<li>获取配置</li>
<li>监听配置</li>
<li>发布配置</li>
<li>删除配置</li>
</ul>
<p>分为两类：配置的CRUD和配置的动态监听</p>
<h2 id="spring-cloud加载配置的原理略">Spring Cloud加载配置的原理（略）</h2>
<h2 id="nacos源码略">Nacos源码（略）</h2>
<h2 id="sentinel限流及熔断">Sentinel限流及熔断</h2>
<h3 id="1-服务限流的作用及实现">1 服务限流的作用及实现</h3>
<p>主要作用：损失一部分用户的可用性，为大部分用户提供稳定可靠的服务。</p>
<ul>
<li>
<p>计算器算法：在制定周期内累加访问次数，当访问次数达到阈值时，触发限流策略。</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225232943900.png" alt="image-20210225232943900"  /></p>
</li>
<li>
<p>滑动窗口算法：源于TCP拥塞控制，原理是在固定窗口中分割出<strong>多个小时间窗口</strong>，分别在每个小时间窗口中记录访问次数，然后根据时间将窗口往前滑动并删除过期的小时间窗口。最终只需要统计滑动窗口范围内所有小时间窗口总的计数即可。（Sentinel的原理）</p>
</li>
<li>
<p>令牌桶算法：每一个请求，都需要从令牌桶中获取一个令牌，如果没有获得令牌，则触发限流策略。</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225233303914.png" alt="image-20210225233303914"  /></p>
<p>特性：短时间内新增的流量系统能够正常处理。</p>
</li>
<li>
<p>漏桶限流算法：用于控制数据注入网络的速度，平滑网络上的突发流量。</p>
</li>
</ul>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225233550970.png" alt="image-20210225233550970"  /></p>
<h3 id="2-服务熔断和降级">2 服务熔断和降级</h3>
<p>在微服务架构中，由于服务拆分粒度较细，会出现请求链路较长的情况，用户发起一个请求操作，需要调用多个微服务才能完成。</p>
<p><strong>雪崩效应</strong>：某个服务因为网络延迟或者请求超时等原因不可用时，就会导致当前请求阻塞，一旦某个链路上被依赖的服务不可用，很可能出现请求堆积而产生雪崩。</p>
<p>所以，服务熔断就是用来解决这个问题的方案，它指的是当某个服务提供者无法正常为服务调用者提供服务时，为了防止整个系统出现雪崩效应，暂时将出现故障的接口隔离出来，断绝与外部接口的联系，当触发熔断后，后续一段时间内该服务调用者的请求都会<strong>直接失败</strong>，直至目标服务恢复正常。</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210225234104602.png" alt="image-20210225234104602"  /></p>
<h3 id="3-sentinel的特性">3 Sentinel的特性</h3>
<ul>
<li>丰富的应用场景：秒杀、消息削峰填谷、集群流量控制等。</li>
<li>实时监控</li>
<li>开源生态支持</li>
<li>SPI扩展点支持</li>
</ul>
<h3 id="4-sentinel的组成">4 Sentinel的组成：</h3>
<ul>
<li>核心库（Java客户端）：不依赖任何框架与库，能够运行于所有Java运行时环境。</li>
<li>控制台（Dashboard）</li>
</ul>
<h3 id="5-sentinel基本应用">5 Sentinel基本应用：</h3>
<p>步骤如下：</p>
<p>（1）定义资源：限流保护的最基本元素，比如一个方法。</p>
<p>（2）定义限流规则</p>
<p>（3）检验规则是否生效</p>
<p><strong>限流规则</strong>：通过initFlowRules方法设置</p>
<ul>
<li>grade：限流阈值类型，有QPS模式和并发线程数模式。</li>
<li>count：限流阈值</li>
<li>resource：设置需要保护的资源</li>
</ul>
<h3 id="6-sentinel资源保护规则">6 Sentinel资源保护规则</h3>
<p>Sentinel支持多种保护规则：流量控制规则、熔断降级规则、系统保护规则、来源访问控制规则、热点参数规则。</p>
<ul>
<li>限流规则：先通过FlowRules来定义限流规则，然后通过FlowRuleManager.loadRules来加载规则列表。</li>
</ul>
<h4 id="1-qps流量控制行为">1 QPS流量控制行为</h4>
<p>通过controlBehavior设置，包含：</p>
<ul>
<li>直接拒接</li>
<li>Warm UP，冷启动</li>
<li>匀速排队</li>
<li>冷启动 + 匀速排队</li>
</ul>
<h3 id="7-sentinel实现服务熔断">7 Sentinel实现服务熔断</h3>
<p>通过DegradeRule实现：</p>
<ul>
<li>grade：熔断策略，支持秒级RT、秒级异常比例、分钟异常数。默认是秒级RT。</li>
<li>timeWindow：熔断降级的时间窗口，单位为s。也就是出发熔断降级之后多长时间内自动熔断。</li>
<li>rtSlowRequestAmount：在RT模式下，1s内持续多少个请求的平均RT超出阈值后出发熔断，默认值是5</li>
<li>minRequestAmout：触发的异常熔断最小请求数，请求数小于该值时即使异常比例超出阈值也不会触发熔断，默认值是5.</li>
</ul>
<p>三种熔断策略：</p>
<ul>
<li>平均响应时间RT：如果1s内持续进来5个请求，对应的平均响应时间都超过了阈值(count，单位为ms)，那么在接下来的时间窗口内，对这个方法的调用都会自动熔断，抛出DegradeException</li>
<li>异常比例</li>
<li>最近一分钟异常数：如果timeWindow小于60s，则结束熔断状态后仍然可能再进入熔断状态。</li>
</ul>
<h2 id="sentinel集成spring-cloud">Sentinel集成Spring Cloud</h2>
<p>步骤如下：</p>
<ul>
<li>
<p>创建项目，集成Spring Cloud依赖。</p>
</li>
<li>
<p>添加Sentinel依赖。</p>
</li>
<li>
<p>创建一个REST接口，并且通过@SentinelResource配置限流保护资源。</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210226000233876.png" alt="image-20210226000233876"  /></p>
</li>
<li>
<p>在上述代码中，配置限流资源有几种情况</p>
<ul>
<li>Sentinel starter在默认情况下会为所有的HTTP服务提供限流埋点，所以如果只想对HTTP服务进行限流，只需添加依赖即可。</li>
<li>如果想要对特定的方法进行限流或降级，则需要通过@SentinelResource注解来定义资源。</li>
<li>可以通过SphU.entry()方法来配置资源。</li>
</ul>
</li>
<li>
<p>手动配置流控规则，可以借助Sentinel的InitFunc SPI扩展接口来实现，只需要实现自己的InitFunc接口，并在init方法中编写规则加载的逻辑即可。</p>
</li>
</ul>
<h2 id="基于sentinel-dashboard来实现流控配置">基于Sentinel Dashboard来实现流控配置</h2>
<p>步骤如下：</p>
<ul>
<li>
<p>启动Sentinel Dashboard</p>
</li>
<li>
<p>在application.yml中增加以下配置</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210226000900895.png" alt="image-20210226000900895"  /></p>
</li>
<li>
<p>提供一个REST接口</p>
</li>
<li>
<p>进入Sentinel Dashboard中配置流控规则。</p>
</li>
<li>
<p>访问簇点链路，找到资源名称。</p>
</li>
<li>
<p>单机流控按钮设置流控规则</p>
</li>
</ul>
<p><strong>注意sentinel的坑：</strong></p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210226015008780.png" alt="image-20210226015008780"  /></p>
<h2 id="sentinel自定义url限流异常">Sentinel自定义URL限流异常</h2>
<p>默认情况下，URL触发限流后会返回Blocked by Sentinel字符串</p>
<p>在实际应用中，大都采用JSON格式，所以如果希望修改触发限流之后的返回结果形式，则可以通过自定义限流异常来处理，实现<strong>UrlBlockHandler</strong>并且重写blocked方法。</p>
<p>还有一种场景，当触发限流后，希望跳转到一个降级页面，可以通过下面这个配置来实现。</p>
<p>spring.cloud.sentinel.servlet.block-page={url}</p>
<h2 id="sentinel对url资源清洗">Sentinel对URL资源清洗</h2>
<p>Sentinel中HTTP服务的限流默认由Sentinel-Web-Servlet包中的CommonFilter来实现，这个Filter会把每个不同的URL都作为不同的资源来处理。</p>
<p>举例：</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210226194317550.png" alt="image-20210226194317550"  /></p>
<ul>
<li>限流统计不准确，实际需求是控制clean方法总的QPS，结果统计的是每个URL的QPS</li>
<li>导致Sentinel中资源数量过多，默认资源数量阈值为6000，对于多出的资源规则将不会生效。</li>
</ul>
<p>针对这个问题可以通过<strong>URLCleaner</strong>接口来实现资源清洗，也就是对于/clean/{id}这个URL，我们可以统一归集到/clean/*资源下，具体代码如下：</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210226194545852.png" alt="image-20210226194545852"  /></p>
<h2 id="sentinel集成nacos实现动态流控规则">Sentinel集成Nacos实现动态流控规则</h2>
<p>Sentinel的理念是只需要开发者关注资源的定义，默认会对资源进行流控。当然我们还需要自定义流控规则，前面有两种方式：</p>
<ul>
<li>通过FlowRuleManager.loadRules(List rules)手动加载流控规则</li>
<li>在Sentinel Dashboard上针对资源动态创建流控规则。</li>
</ul>
<p>针对第一种方式，如果接入Sentinel Dashboard，那么同样支持动态修改流控规则。但是，这里会存在一个问题，基于Sentinel Dashboard所配置的流控规则，都是保存在<strong>内存</strong>中的，一旦应用重启，这些规则都会被清除。为了解决这个问题，Sentinel提供了动态数据源支持。</p>
<p>目前，Sentinel支持Consul、Zookeeper、Redis、Nacos、Apollo、etcd等数据源的扩展，我们使用Nacos的方式来扩展。</p>
<p>步骤如下：</p>
<ul>
<li>
<p>添加Nacos数据源依赖包</p>
</li>
<li>
<p>创建一个REST接口用于测试。</p>
</li>
<li>
<p>在application.yml中添加数据源配置。</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210226195049493.png" alt="image-20210226195049493"  /></p>
<p>配置说明：</p>
<p>rule-type：flow、degrade、param-flow、gw-flow等</p>
<p>data-type：Spring Cloud Alibaba提供了JSON和XML两种格式。如果需要自定义，则可以将值配置为custom，并配置converter-class指向converter类。</p>
</li>
<li>
<p>登录Nacos控制台，创建流控配置规则，配置信息如下：</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210226195526683.png" alt="image-20210226195526683"  /></p>
</li>
<li>
<p>最后，登录Sentinel Dashboard，找到执行项目名称菜单下的“流控规则”，就可以看到在Nacos上所配置的流控规则已经被加载了。</p>
</li>
<li>
<p>当在Nacos控制台修改流控规则后，可以同步在Sentinel Dashboard上看到流控规则的变化。</p>
<ul>
<li>注意：在Sentinel Dashboard上修改无法同步到Nacos上。</li>
</ul>
</li>
<li>
<p><strong>强烈建议</strong>：不要在Nacos上修改流控规则，因为这种修改的危险系数很高。这就意味着流控规则的管理应该集中在Sentinel Dashboard上，所以我们需要实现Sentinel Dashboard来动态维护规则并同步到Nacos上，目前官方还没有提供支持，但可以自己实现。</p>
</li>
<li>
<p>这里有一个坑：出现了<strong>空指针异常</strong>org.springframework.beans.factory.BeanCreationException: Error creating bean with name &lsquo;ds1-sentinel-nacos-datasource&rsquo;: FactoryBean threw exception on object creation; nested exception is java.lang.NullPointerException，出现原因是Spring-Cloud-Alibaba与Sentinel的<strong>版本对应不上</strong>，解决办法是把Spring Cloud Alibaba的版本升到2.2.5.RELEASE即可。</p>
</li>
</ul>
<h2 id="sentinel集成nacos实现规则同步">Sentinel集成Nacos实现规则同步</h2>
<p>Sentinel Dashboard的“流控规则”下的所有操作，都会调用Sentinel源码中的FlowControllerV1类，这个类包含流控规则本地化的CRUD</p>
<p>另外，在com.alibaba.csp.sentinel.dashboard.controller.v2包下存在一个FlowControllerV2类，这个类同样提供流控规则的CRUD，和V1版本不同的是，它可以实现指定数据源的规则拉取和同步。</p>
<p>FlowControllerV2依赖以下两个非常重要的类</p>
<ul>
<li>DynamicRuleProvider：动态规则的拉取，从指定数据源中获取流控规则后在Sentinel Dashboard中展示。</li>
<li>DynamicRulePublisher：动态规则的发布，将在Sentinel Dashboard中修改的规则同步到指定数据源中。</li>
</ul>
<p>这里我们扩展这两个类，然后集成Nacos来实现Sentinel Dashboard规则的同步。</p>
<h3 id="1-sentinel-dashboard源码修改">1 Sentinel Dashboard源码修改：</h3>
<p>具体步骤如下：</p>
<ul>
<li>
<p>打开sentinel-dashboard工程，在pom.xml中把sentinel-datasource-nacos依赖的scope注释掉。</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210226220250575.png" alt="image-20210226220250575"  /></p>
</li>
<li>
<p>修改resouces/app/scripts/directives/sidebar/sidebar.html文件下的代码，将dashboard.flowV1改成dashboard.flow</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210226220240096.png" alt="image-20210226220240096"  /></p>
<p>修改之后，会调用FlowControllerV2中的接口。</p>
</li>
<li>
<p>在com.alibaba.csp.sentinel.dashboard.rule包中创建一个nacos包，并创建一个类用来加载外部化配置。</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210226220601939.png" alt="image-20210226220601939"  /></p>
</li>
<li>
<p>创建一个Nacos配置类NacosConfiguration</p>
<ul>
<li>注入Converter转换器，将FlowRuleEntity转化为FlowRule，以及反向转化。</li>
<li>注入Nacos配置服务ConfigService</li>
</ul>
</li>
<li>
<p>创建一个常量类NacosConstants，分别表示默认的GROUP_ID和DATA_ID的后缀。</p>
</li>
<li>
<p>实现动态从Nacos配置中心获取流控规则。</p>
</li>
<li>
<p>创建一个流控规则发布类，在Sentinel Dashboard上修改完配置后，需要调用该发布方法将数据持久化到Nacos中。</p>
</li>
<li>
<p>修改FlowControllerV2类，将上面配置的两个类注入进来，表示规则的拉取和规则的发布统一用我们前面自定义的两个实例。</p>
</li>
<li>
<p>在application.properties文件中添加nacos服务端的配置信息。</p>
</li>
<li>
<p>将代码打包成一个fat jar</p>
</li>
<li>
<p>详见https://blog.csdn.net/weixin_42073629/article/details/107117433 或者test包中的nacos代码</p>
</li>
</ul>
<h3 id="2-sentinel-dashboard规则同步">2 Sentinel Dashboard规则同步</h3>
<p>应用程序需要修改的地方比较少，只需注意配置文件中data-id的命名要以-sentinel-flow结尾即可。</p>
<h2 id="sentinel集成dubbo实现限流">Sentinel集成Dubbo实现限流</h2>
<p>Sentinel提供了与Dubbo整合的模块Sentinel Apache Dubbo Adapter，可以针对服务提供者和服务消费者进行流控，在使用的时候，只需要添加以下依赖。</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210227193606798.png" alt="image-20210227193606798"  /></p>
<p>添加后该依赖后，Dubbo服务中的接口和方法（包括服务端和消费端）就会成为Sentinel中的资源，只需针对指定资源配置流控规则就可以实现Sentinel流控功能。</p>
<p>Sentinel Apache Dubbo Adapter实现限流的核心原理是基于Dubbo的SPI机制实现Filter扩展，Dubbo的Filter机制是专门为服务提供者和服务消费者调用过程进行拦截设计的，每次执行远程方法，该拦截都会被执行。</p>
<p>同时，Sentinel Apache Dubbo Adapter还可以自定义开启或者关闭某个Filter的功能，下面表示关闭消费端的过滤器。</p>
<h3 id="image-20210227193903284httpscuterwrite-1302252842filemyqcloudcomimgimage-20210227193903284png"><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210227193903284.png" alt="image-20210227193903284"  /></h3>
<h3 id="1-dubbo服务接入sentinel-dashboard">1 Dubbo服务接入Sentinel Dashboard</h3>
<ul>
<li>
<p>引入sentinel-transport-simple-http依赖</p>
</li>
<li>
<p>添加启动参数</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210227194238456.png" alt="image-20210227194238456"  /></p>
</li>
<li>
<p>登录Sentinel Dashboard之后，进入“簇点链路”，就可以看到资源信息。</p>
</li>
<li>
<p>需要注意的是，限流可以通过服务接口或服务方法设置</p>
<ul>
<li>服务接口：resourceName为接口的全限定名（包+接口名）</li>
<li>服务方法：resourceName为接口全限定名：方法名（包+接口名:方法名）</li>
</ul>
</li>
</ul>
<h3 id="2-dubbo服务限流规则">2 Dubbo服务限流规则</h3>
<p>两种方式</p>
<ul>
<li>Sentinel Dashboard</li>
<li>FlowRuleManager.loadRules(List rules)</li>
</ul>
<p>Sentinel Apache Dubbo Adapter组件中没有实现规则持久化，因此有以下步骤来支持：</p>
<ul>
<li>在dubbo服务中添加sentinel-datasource-nacos依赖</li>
<li>通过Sentinel提供的InitFunc扩展点，实现Nacos数据源的配置</li>
</ul>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210227204336472.png" alt="image-20210227204336472"  /></p>
<ul>
<li>访问Sentinel Dashboard，在针对某个资源创建流控规则时，这个规则会同步保存到Nacos的配置中心，而当Nacos配置中心发生变化时，会触发事件机制通知Dubbo应用重新加载流控规则。</li>
</ul>
<h2 id="sentinel热点限流">Sentinel热点限流</h2>
<p>热点数据表示经常访问的数据，在有限场景中我们希望针对这些访问频次非常高的数据进行限流，比如针对一段时间内频繁访问的用户ID地址进行限流，或者针对频繁访问的某个用户ID进行限流。</p>
<p>Sentinel提供了热点参数限流的规则，它是一种特殊的限流，在普通限流的基础上对同一个受保护的资源区根据请求中的参数分别处理，该策略只对包含热点参数的资源调用生效。热点限流在<strong>以下场景</strong>使用较多：</p>
<ul>
<li>服务网关层：例如防止网络爬虫和恶意攻击，一种常用方法就是限制爬虫的IP地址。</li>
<li>写数据的服务：例如业务系统提供写数据的服务，数据会写入数据库之类的存储系统。存储系统的底层会加锁写磁盘上的文件，部分存储系统会将某一类数据写入同一个文件中。如果底层写同一文件，会出现抢占锁的情况，导致出现大量超时和失败。出现这种情况时一般有两种解决方法：修改存储设计、对热点参数限流。</li>
</ul>
<p>Sentinel通过<strong>LRU策略结合滑动窗口机制</strong>来实现热点参数的统计，其中LRU策略可以统计单位时间内最常访问的热点数据，滑动窗口机制可以协助统计每个参数的QPS。</p>
<h3 id="1-热点参数限流的使用">1 热点参数限流的使用</h3>
<ul>
<li>引用热点参数限流依赖包sentinel-parameter-flow-control</li>
<li>接下来创建一个REST接口，并定义限流埋点，此处针对参数ID配置热点限流规则。</li>
<li>针对不同的热点参数，需要通过SphU.entry(resourceName,EntryType.IN,1,id)方法设置，其最后一个参数是一个数组，有多个热点参数就按照次序依次传入，该配置表示后续会针对该参数进行热点限流。</li>
<li>通过ParamFlowRuleManager.loadRules加载热点参数规则。</li>
</ul>
<h3 id="2-sentinelresource">2 @SentinelResource</h3>
<p>如果是通过@SentinelResource注解来定义资源，当注解所配置得方法上有参数时，Sentinel会把这些参数传入SphU.entry中</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210227231844217.png" alt="image-20210227231844217"  /></p>
<h3 id="3-热点参数规则说明">3 热点参数规则说明</h3>
<ul>
<li>durationInSec：统计窗口时间长度，单位为s</li>
<li>maxQueueingTimeMS：最长排队等待时长，只有当流控为controlBehavior设置为匀速排队模式时生效。</li>
<li>paramIdx：热点参数的索引，属于必填项，对应的是SphU.entry中的参数索引位置。</li>
<li>paramFlowItemList：针对指定参数值单独设置限流阈值，不受count阈值的限制。</li>
</ul>
<h2 id="sentinel的工作原理略">Sentinel的工作原理（略）</h2>
<ul>
<li>工作流程：由各个Slot插槽组成（责任链模式）</li>
<li>p229</li>
</ul>
<h2 id="spring-cloud-sentinel工作原理略">Spring Cloud Sentinel工作原理（略）</h2>
<ul>
<li>starter自动装配</li>
<li>p232</li>
</ul>
<h2 id="sentinel核心源码分析略">Sentinel核心源码分析（略）</h2>
<ul>
<li>sentinel-adapter</li>
<li>sentinel-core</li>
<li>sentinel-dashboard</li>
<li>sentinel-demo</li>
<li>sentinel-extension</li>
<li>sentinel-transport</li>
</ul>
<h3 id="1-限流的源码实现">1 限流的源码实现</h3>
<h3 id="2-实时指标数据统计">2 实时指标数据统计</h3>
<h3 id="3-服务降级的实现原理">3 服务降级的实现原理</h3>
<h2 id="什么是分布式事务">什么是分布式事务？</h2>
<p>事务：作为单个逻辑工作单元执行的多个数据库操作，要么同时成功，要么同时失败，必须满足ACID特性。（单库多表）</p>
<p>在微服务架构下，随着业务服务的拆分及数据库的拆分，举例说，订单和库存分别拆分成两个独立的数据库，当客户端发起一个下单操作，需要在订单服务对应的数据库创建订单，同时基于RPC通信调用库存服务完成商品库存的扣减。</p>
<p>这样，原来的单库事务操作就变成了多个数据库的事务操作 =&gt; 数据不一致问题。</p>
<h3 id="1-分布式事务问题的理论模型">1 分布式事务问题的理论模型</h3>
<p>核心原因：存储资源的分布性</p>
<p>在实际应用中，应该尽可能从设计层面去避免分布式事务的问题。</p>
<h4 id="1-xopen分布式模型">1 X/Open分布式模型</h4>
<p>X/Open DTP是X/Open这个组织定义的一套分布式事务的标准。这个标准提出了<strong>两阶段提交</strong>（2PC，2-phase-commit）来保证分布式事务的完整性。X/Open DTP包含以下三种角色。</p>
<ul>
<li>AP：Application</li>
<li>RM：Resource Manager</li>
<li>TM：Transaction Manager</li>
</ul>
<p>如果TM需要能够管理多个数据库的事务，则实现步骤如下：</p>
<ul>
<li>配置TM，把多个RM注册到TM，相当于TM注册RM作为数据源。</li>
<li>AP从TM管理的RM中获取连接，如果RM是数据库则获取JDBC连接。</li>
<li>AP向TM发起一个全局事务，生成全局事务ID（XID），XID会通知各个RM。</li>
<li>AP通过第二步获得的连接直接操作RM完成数据库操作。这时，AP在每次操作会把XID传递给RM。</li>
<li>AP结束全局事务，TM会通知各个RM全局事务结束。</li>
<li>根据各个RM的事务执行结果，执行提交或者回滚操作。</li>
</ul>
<p>其中，TM和多个RM之间的事务控制，是基于XA协议来完成的。目前Oracle、MySQL、DB2都实现了XA接口，因此都能作为RM。</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210227233821400.png" alt="image-20210227233821400"  /></p>
<h4 id="2-两阶段提交协议">2 两阶段提交协议</h4>
<p>第一阶段：事务的准备阶段</p>
<p>第二阶段：事务的提交或回滚阶段</p>
<p>这两个阶段都是由事务管理器发起的，流程如下：</p>
<ul>
<li>准备阶段：TM通知RM准备分支事务，记录事务日志，并告知TM的准备结果。</li>
<li>提交/回滚阶段：如果所有的RM在准备阶段都明确返回成功，TM向所有RM发起提交指令完成数据的变更；反之，则TM向所有RM发送回滚指令。</li>
</ul>
<p>然而，它并不是完美的，也有缺点：</p>
<ul>
<li>同步阻塞：所有RM都是事务阻塞型的，对于任何一次指令都必须要有明确的响应才能进行下一步，否则会处于阻塞状态。</li>
<li>过于保守：任何一个节点失败都会导致数据回滚。</li>
<li>TM的单点故障：如果TM在第二阶段故障，则所有RM会一直处于锁定状态。</li>
<li>“脑裂”导致数据不一致问题：在第二阶段中，TM向所有RM发送commit请求后，发生局部网络异常导致只有一部分RM接受到commit，剩余未收到请求的则没提交，导致数据出现不一致问题。</li>
</ul>
<h4 id="3-三阶段提交协议">3 三阶段提交协议</h4>
<p>利用超时机制解决了同步阻塞的问题</p>
<ul>
<li>CanCommit（询问阶段）：TM向RM发送事务执行请求，询问是否可以完成指令，参与者只需回答是或者不是即可，不需要做真正的事务操作，这个阶段会有超时中止机制。</li>
<li>PreCommit（准备阶段）：TM根据RM的反馈结果决定是否继续，如果在询问阶段所有RM都能执行操作，则TM向所有RM发送PreCommit请求，RM收到请求后写redo和undo日志，执行事务操作但是不提交事务，然后返回ACK响应等待TM的下一步通知。如果询问阶段任意参与者返回不能执行操作的结果，则TM发送事务中断请求。</li>
<li>DoCommit（提交或回滚阶段）：根据上一步骤的执行结果，如果每个RM都返回成功，则TM发送事务提交指令，反之则中止。</li>
</ul>
<p>三阶段提交协议与二阶段提交协议的区别</p>
<ul>
<li>增加了一个CanCommit阶段，可以尽早发现无法执行操作而中止后续的行为。</li>
<li>在准备阶段之后，TM和RM都引入超时机制，一旦超时，TM和RM会继续提交事务，并且认为处于成功状态，因为这种情况下事务默认为成功的可能性比较大。</li>
</ul>
<p>实际上，一旦超时，在三阶段提交协议下仍然可能出现数据不一致的问题，当然概率是比较小的。另外，最大的好处是基于超时机制来避免资源的永久锁定。</p>
<h4 id="4-cap定理和base理论">4 CAP定理和BASE理论</h4>
<p>XA协议：二阶段提交和三阶段提交，数据一致性强，但可用性低。</p>
<p>CAP定理：布鲁尔定理，指在分布式系统中不可能同时满足一致性C、可用性A、分区容错性P，最多同时满足两个。</p>
<ul>
<li>C：数据在多个副本中要保持强一致</li>
<li>A：系统对外提供的服务必须一直处于可用状态。</li>
<li>P：在分布式系统中遇到任何网络分区故障，系统仍然能够正常对外提供服务。</li>
</ul>
<p><strong>在分布式系统中，要么满足CP，要么满足AP，不可能实现CAP或者CA，因为网络通信不是绝对可靠的。</strong></p>
<ul>
<li>AP：放弃强一致性，实现最终的一致。（很多互联网公司的主要选择）</li>
<li>CP：放弃高可用性，实现强一致性。（2PC和3PC，存在问题：用户完成一个操作可能会等待较长的时间，用户体验差）</li>
</ul>
<p>BASE理论：由于CAP中CA不可兼得衍生出来的一种新的思想。核心思想是：牺牲数据的强一致性来获得高可用性，有三个特性：</p>
<ul>
<li>Basically Avaliable（基本可用）：分布式系统出现故障时，允许损失一部分功能的可用性，保证核心功能的可用。</li>
<li>Soft State（软状态）：允许系统中的数据存在中间状态，这个状态不影响系统的可用性，也就是允许系统中不同节点的数据副本之间的同步存在延时。</li>
<li>Eventually Consistent（最终一致性）：中间状态的数据在经过一段时间之后，会达到一个最终的数据一致性。</li>
</ul>
<h3 id="2-分布式事务问题的常见解决方案">2 分布式事务问题的常见解决方案</h3>
<h4 id="1-tcc补偿性方案">1 TCC补偿性方案</h4>
<p>TCC（Try-Confirm-Cancel）是一种比较成熟的分布式数据一致性解决方案，它实际上是把一个完整的业务拆分为如下三个步骤</p>
<ul>
<li>Try：这个阶段主要是对数据的校验或者资源的预留。</li>
<li>Confirm：确定真正执行的任务，只操作Try阶段预留的资源。</li>
<li>Cancel：取消执行，释放Try阶段预留的资源。</li>
</ul>
<p>本质：二阶段提交的思想，第一阶段通过Try准备，第二阶段通过Confirm/Cancel</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210228000708843.png" alt="image-20210228000708843"  /></p>
<h4 id="2-基于可靠性消息的最终一致性方案">2 <strong>基于可靠性消息的最终一致性方案</strong></h4>
<p>基于可靠性消息的最终一致性方案是互联网公司比较常用的分布式数据一致性解决方案，它主要利用消息中间件（Kafka、RocketMQ或RabbitMQ）的可靠性机制来实现数据一致性的投递。</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/image-20210228001428049.png" alt="image-20210228001428049"  /></p>
<p>总结：消费者没有向消息中间件服务器发送确认之前，这个消息会被重复投递，确保消息的可靠性消费。</p>
<h4 id="3-最大努力通知型">3 最大努力通知型</h4>
<p>与基于可靠性消息的最终一致性方案实现类似，是一种比较简单的柔性事务解决方案。</p>
<p><strong>如果没有返回一个消息确认时，则不断进行重试，直到收到一个消息确认或者达到最大重试次数。</strong></p>
<h3 id="3-分布式事务框架seata">3 分布式事务框架Seata</h3>
<p>提供了AT、TCC、Saga和XA四种事务模式。</p>
<h4 id="1-at模式">1 AT模式</h4>
<p>Seata最主推的分布式事务解决方案，基于XA演进而来，分为TM、RM和TC，TC作为Seata的服务器独立部署。</p>
<h4 id="2-saga模式">2 Saga模式</h4>
<p>又称长事务解决方案，主要描述的是在没有2PC的情况下如何解决分布式事务问题。其核心思想是：把一个业务流程中的长事务拆分为多个本地短事务，业务流程中的每个参与者都提交真实提交给本地段事务，当其中一个参与者失败，则通过补偿机制补偿前面已经成功的参与者。</p>
<p>两种补偿恢复方式：</p>
<ul>
<li>向后恢复：如果任一子事务失败，则撤销执行结果。</li>
<li>向前恢复：不进行补偿，而是对失败的事务进行redo，这种方式比较适合于事务必须要执行成功的场景。</li>
</ul>
<p>优点：</p>
<ul>
<li>一阶段直接提交本地事务</li>
<li>没有锁等待，性能较高</li>
<li>在事件驱动的模式下，短事务可以异步执行。</li>
<li>补偿机制的实现比较简单。</li>
</ul>
<p>缺点：不提供原子性和隔离性支持</p>
<p>协调模式：</p>
<ul>
<li>事件/编排式</li>
<li>命令/协同式</li>
</ul>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>
        
            <a href="/tags/java/">Java</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
    integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
    integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
    integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="StackLaTeX()"></script>

<script>
    function StackLaTeX() {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });
    }
</script>
    

</article>

<a href="#" class="back-to-top"><span>回到顶部</span></a>

<script>
    window.addEventListener('scroll', function () {
        if (window.scrollY > 200) {
        document.querySelector('.back-to-top').style.display = 'block';
        } else {
        document.querySelector('.back-to-top').style.display = 'none';
        }
    });

    document.querySelector('.back-to-top').addEventListener('click', function (e) {
        e.preventDefault();
        
        
        const targetElement = document.getElementById('top');
        const targetRect = targetElement.getBoundingClientRect();
        const targetTop = window.pageYOffset + targetRect.top;
        
        
        window.scrollTo({ top: targetTop, behavior: 'smooth' });
    });
</script>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="has-image">
    <a href="/p/oauth2-guide/">
        
        
            <div class="article-image">
                
                    <img src="https://cuterwrite-1302252842.file.myqcloud.com/typora/image-hosting-master/image-hosting-master/store/image.rglemef8w74.png" loading="lazy" data-key="oauth2-guide" data-hash="https://cuterwrite-1302252842.file.myqcloud.com/typora/image-hosting-master/image-hosting-master/store/image.rglemef8w74.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Spring Cloud OAuth2从零开始实现用户认证和单点登录</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>


    
        
    <script src="https://utteranc.es/client.js" 
        repo="PKUcoldkeyboard/pkucoldkeyboard.github.io"
        issue-term="title"
        theme="preferred-color-scheme" 
        
        crossorigin="anonymous" 
        async>
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    let utterancesLoaded = false;
    window.addEventListener('onColorSchemeChange', (e) => {
        if (!utterancesLoaded) return;
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${e.detail}`
                },
                'https://utteranc.es'
            );
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2021 - 
        
        2023 cuterwrite
    </section>
    
    <section class="powerby">
        
            欢迎来到Cuterwrite的博客网站 <br/>
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="2.0.1">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>
      
      Array.from(document.getElementsByClassName("language-mermaid")).forEach(
        (el) => {
          el.parentElement.outerHTML = `<div class="mermaid">${el.innerText}</div>`;
        }
      );
    </script>
    <style>
       
      .mermaid svg {
        display: block;
        margin: auto;
      }
    </style>


            </main>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"
    integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin="anonymous"></script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
