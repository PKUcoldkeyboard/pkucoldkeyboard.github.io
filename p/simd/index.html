<!DOCTYPE html>
<html lang="zh-cn">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='本文深入探讨了SSE与AVX指令集的向量化编程优化，详述了寄存器的作用、自动向量化的原理、SSE/AVX在实际应用中的重要性，以及C&#43;&#43;编程框架如何充分发挥这些指令集的优势。此外，还探讨了Masking技术及条件加载的技巧，以及数据流控制的优化策略。通过丰富的示例和技术解析，读者将深入理解如何有效利用向量化优化来提升程序性能。'><title>SSE与AVE向量化编程</title>

<link rel='canonical' href='https://cuterwrite.top/p/simd/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='SSE与AVE向量化编程'>
<meta property='og:description' content='本文深入探讨了SSE与AVX指令集的向量化编程优化，详述了寄存器的作用、自动向量化的原理、SSE/AVX在实际应用中的重要性，以及C&#43;&#43;编程框架如何充分发挥这些指令集的优势。此外，还探讨了Masking技术及条件加载的技巧，以及数据流控制的优化策略。通过丰富的示例和技术解析，读者将深入理解如何有效利用向量化优化来提升程序性能。'>
<meta property='og:url' content='https://cuterwrite.top/p/simd/'>
<meta property='og:site_name' content='cuterwrite'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='向量化编程' /><meta property='article:tag' content='SIMD' /><meta property='article:tag' content='并行计算' /><meta property='article:published_time' content='2023-08-12T08:00:00&#43;00:00'/><meta property='article:modified_time' content='2023-08-12T08:00:00&#43;00:00'/><meta property='og:image' content='https://cuterwrite-1302252842.file.myqcloud.com/img/173b9c0b3728e5e9e05d12a4f6dda9a2a7560722.jpg@1256w_1776h_!web-article-pic.jpg' />
<meta name="twitter:title" content="SSE与AVE向量化编程">
<meta name="twitter:description" content="本文深入探讨了SSE与AVX指令集的向量化编程优化，详述了寄存器的作用、自动向量化的原理、SSE/AVX在实际应用中的重要性，以及C&#43;&#43;编程框架如何充分发挥这些指令集的优势。此外，还探讨了Masking技术及条件加载的技巧，以及数据流控制的优化策略。通过丰富的示例和技术解析，读者将深入理解如何有效利用向量化优化来提升程序性能。"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://cuterwrite-1302252842.file.myqcloud.com/img/173b9c0b3728e5e9e05d12a4f6dda9a2a7560722.jpg@1256w_1776h_!web-article-pic.jpg' />
    <link rel="shortcut icon" href="/favicon.ico" />

    </head>
    <body class="">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.body.dataset.scheme = 'dark';
        } else {
            document.body.dataset.scheme = 'light';
        }
    })();
</script><div class="container main-container flex on-phone--column extended article-page with-toolbar">
            <aside class="sidebar left-sidebar sticky">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header class="site-info">
        
            <figure class="site-avatar">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hue4d14694a57c01a222a16c47db12c89c_369633_300x0_resize_box_3.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                

                
                    <span class="emoji">😉</span>
                
            </figure>
        
        <h1 class="site-name"><a href="https://cuterwrite.top">cuterwrite</a></h1>
        <h2 class="site-description">欢迎来到我的个人博客。我是cuterwrite，一个热爱生活、不断探索的人。在这里，我分享我的想法、经验和学习，希望可以帮助到你，也欢迎你与我分享你的看法。</h2>
    </header>

    <ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>首页</span>
            </a>
        </li>
        
        

        <li >
            <a href='/about'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>个人</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>文章</span>
            </a>
        </li>
        
        

        <li >
            <a href='/tags'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11 3L20 12a1.5 1.5 0 0 1 0 2L14 20a1.5 1.5 0 0 1 -2 0L3 11v-4a4 4 0 0 1 4 -4h4" />
  <circle cx="9" cy="9" r="2" />
</svg>



                
                <span>标签</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        

        
            <li id="dark-mode-toggle">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                <span>暗色模式</span>
            </li>
        
    </ol>
</aside>

            <main class="main full-width">
    <div id="article-toolbar">
        <a href="https://cuterwrite.top" class="back-home">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



            <span>Back</span>
        </a>
    </div>

    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/simd/">
                
                    <img src="https://cuterwrite-1302252842.file.myqcloud.com/img/173b9c0b3728e5e9e05d12a4f6dda9a2a7560722.jpg@1256w_1776h_!web-article-pic.jpg" loading="lazy" alt="Featured image of post SSE与AVE向量化编程" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/" style="background-color: #ffdb5c; color: #fff;">
                高性能计算
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/simd/">SSE与AVE向量化编程</a>
    </h2>

    
    <h3 class="article-subtitle">
        本文深入探讨了SSE与AVX指令集的向量化编程优化，详述了寄存器的作用、自动向量化的原理、SSE/AVX在实际应用中的重要性，以及C&#43;&#43;编程框架如何充分发挥这些指令集的优势。此外，还探讨了Masking技术及条件加载的技巧，以及数据流控制的优化策略。通过丰富的示例和技术解析，读者将深入理解如何有效利用向量化优化来提升程序性能。
    </h3>
    <footer class="article-time">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <time class="article-time--published">2023-08-12</time>
    </footer></div>
</header>

    <section class="article-content">
    <!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><strong>Table of Contents</strong>  <em>generated with <a class="link" href="https://github.com/thlorenz/doctoc"  target="_blank" rel="noopener"
    >DocToc</a></em></p>
<ul>
<li><a class="link" href="#sse%E4%B8%8Eave%E5%90%91%E9%87%8F%E5%8C%96%E7%BC%96%E7%A8%8B" >SSE与AVE向量化编程</a>
<ul>
<li><a class="link" href="#%E4%B8%80-%E5%90%91%E9%87%8F%E5%8C%96%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B" >一、 向量化编程简介</a>
<ul>
<li><a class="link" href="#1-sseave%E5%AF%84%E5%AD%98%E5%99%A8" >1. SSE/AVE寄存器</a></li>
<li><a class="link" href="#2-ave%E6%93%8D%E4%BD%9C%E4%BE%8B%E5%AD%90" >2. AVE操作例子</a></li>
<li><a class="link" href="#3-%E5%85%88%E5%86%B3%E6%9D%A1%E4%BB%B6" >3. 先决条件</a></li>
</ul>
</li>
<li><a class="link" href="#%E4%BA%8C%E8%87%AA%E5%8A%A8%E5%90%91%E9%87%8F%E5%8C%96" >二、自动向量化</a>
<ul>
<li><a class="link" href="#1-gcc%E8%87%AA%E5%8A%A8%E5%90%91%E9%87%8F%E5%8C%96flag" >1. GCC自动向量化flag</a></li>
<li><a class="link" href="#2-%E5%BE%AA%E7%8E%AF%E5%90%91%E9%87%8F%E5%8C%96%E7%9A%84%E8%A6%81%E6%B1%82" >2. 循环向量化的要求</a></li>
</ul>
</li>
<li><a class="link" href="#%E4%B8%89sseavx%E7%9A%84%E4%BD%BF%E7%94%A8" >三、SSE/AVX的使用</a>
<ul>
<li><a class="link" href="#1-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0" >1. 内置函数</a></li>
<li><a class="link" href="#2-sseavx%E6%B2%A1%E6%9C%89%E6%8F%90%E4%BE%9B%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0" >2. SSE/AVX没有提供的内置函数</a></li>
<li><a class="link" href="#3-%E6%80%A7%E8%83%BD%E6%8D%9F%E5%A4%B1" >3. 性能损失</a></li>
<li><a class="link" href="#4-avx%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90%E8%AE%A1%E7%AE%97%E5%B9%B3%E6%96%B9%E6%A0%B9" >4. AVX使用例子：计算平方根</a></li>
</ul>
</li>
<li><a class="link" href="#%E5%9B%9Bc%E4%B8%AD%E7%9A%84sseavx%E6%A1%86%E6%9E%B6" >四、C++中的SSE/AVX框架</a>
<ul>
<li><a class="link" href="#1-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7" >1. 内置函数的复杂性</a></li>
<li><a class="link" href="#2-%E7%94%A8%E4%BA%8Esimd%E8%AE%A1%E7%AE%97%E7%9A%84c%E6%A1%86%E6%9E%B6" >2. 用于SIMD计算的C++框架</a></li>
</ul>
</li>
<li><a class="link" href="#%E4%BA%94masking%E4%B8%8Econditional-load" >五、Masking与Conditional Load</a>
<ul>
<li><a class="link" href="#1-%E5%90%91%E9%87%8F%E4%B8%AD%E7%9A%84%E6%8E%A9%E7%A0%81" >1. 向量中的掩码</a></li>
<li><a class="link" href="#2-%E6%9D%A1%E4%BB%B6%E5%8A%A0%E8%BD%BD" >2. 条件加载</a></li>
<li><a class="link" href="#3-%E6%80%A7%E8%83%BD" >3. 性能</a></li>
</ul>
</li>
<li><a class="link" href="#%E5%85%AD%E6%95%B0%E6%8D%AE%E6%B5%81%E6%8E%A7%E5%88%B6" >六、数据流控制</a>
<ul>
<li><a class="link" href="#1-%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E6%B5%81%E9%97%AE%E9%A2%98" >1. 共享数据流问题</a></li>
<li><a class="link" href="#2-%E9%81%BF%E5%85%8D%E6%89%A7%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%BC%80%E9%94%80%E5%BE%88%E5%A4%A7%E7%9A%84%E5%88%86%E6%94%AF" >2. 避免执行计算开销很大的分支</a></li>
</ul>
</li>
<li><a class="link" href="#%E4%B8%83%E6%80%BB%E7%BB%93" >七、总结</a></li>
<li><a class="link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" >参考资料</a></li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<h1 id="sse与ave向量化编程">SSE与AVE向量化编程</h1>
<h2 id="一-向量化编程简介">一、 向量化编程简介</h2>
<p>近年来，CPU已经达到了一些物理和功率限制，因此在GHz方面，CPU速度并没有显著提高。随着计算需求的不断增加，CPU设计人员决定用三种解决方案来解决这个问题：</p>
<ul>
<li><strong>增加更多核心</strong>。通过这种方式，操作系统可以在不同的内核之间分配正在运行的应用程序。此外，程序还可以创建多个线程来最大化核心使用率</li>
<li><strong>将向量化操作应用到每个核心</strong>。该解决方案允许CPU对数据向量执行相同的指令。这只能在应用程序级别完成</li>
<li><strong>多条指令的无序执行</strong>。如果现代CPU是独立的，那么它们最多可以同时执行四条指令。</li>
</ul>
<p>向量寄存器始于1997年的MMX指令集。MMX指令集具有80位的寄存器。之后发布了SSE指令集（从SSE1到SEE4.2有多个版本），具有128位寄存器。2011年，英特尔发布了采用AVX指令集（256位寄存器）的 Sandy Bridge架构。2016年，首款AVX-512 CPU发布，采用512位寄存器（最多16x 32位浮点矢量）。</p>
<p>本文将重点介绍SSE和AVX指令集，因为它们通常出现在最近的处理器中。AVX-512不在讨论范围内，但只需将256位寄存器更改为512位对应寄存器(ZMM寄存器)，即可将本文中的所有示例应用于AVX-512。</p>
<h3 id="1-sseave寄存器">1. SSE/AVE寄存器</h3>
<p>SSE和AVX各有16个寄存器。在SSE中，它们被称为XMM0-XMM15，而在AVX中，它们被称为YMM0-YMM15。XMM寄存器长度为128位，而YMM为256位。</p>
<p>SSE增加了三个类型定义： <code>__m128</code> 、 <code>__m128d</code> 和 <code>__m128i</code> 。分别为浮点型、双精度型(D)和整型(I)。</p>
<p>AVE增加了三个类型定义： <code>__m256</code> 、 <code>__m256d</code> 和 <code>__m256i</code> 。分别为浮点型、双精度型(D)和整型(I)。</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20230810233117.png" alt="20230810233117"  /></p>



<div class="notice notice-warning" >
    <div class="notice-title"><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 576 512"><path d="M570 440c18 32-5 72-42 72H48c-37 0-60-40-42-72L246 24c19-32 65-32 84 0l240 416zm-282-86a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z"/></svg></div><p>XMM和YMM是重叠的：XMM 寄存器被视为相应 YMM 寄存器的下半部分。这可能会在混合使用 SSE 和 AVX 代码时带来一些性能问题。</p></div>

<p>浮点数据类型（如__m128、__m128d、__m256和__m256d）在GCC编译器中被视为具有相同数据结构的类型。因此，GCC允许以数组的形式访问这些数据类型的组件。即：下面代码是合法的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">__m256</span> <span class="n">myvar</span> <span class="o">=</span> <span class="n">_mm256_set1_ps</span><span class="p">(</span><span class="mf">6.665f</span><span class="p">);</span>  <span class="c1">// Set all vector values to a single float
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">myvar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.22f</span><span class="p">;</span>                       <span class="c1">// This is valid in GCC compiler
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.4f</span> <span class="o">+</span> <span class="n">myvar</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">myvar</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span> <span class="c1">// This is valid in GCC compiler
</span></span></span></code></pre></div><p>例如，对于__m128类型的变量，可以通过索引来访问其中的四个单精度浮点数组件。对于__m128d类型的变量，可以通过索引来访问其中的两个双精度浮点数组件。类似地，对于__m256和__m256d类型的变量，可以通过索引来访问其中的八个单精度浮点数或四个双精度浮点数组件。</p>
<p>而在GCC编译器中，__m128i和__m256i是用于处理整数向量的数据类型。它们被定义为联合体（union），可以表示不同长度的整数向量。然而，由于联合体的特性，访问其中的具体数据成员可能会有一些困难。为了从整数向量中提取单个数据值，可以使用 <code>_mm_extract_epiXX()</code> 函数。这些函数允许从整数向量中提取指定位置的数据值，并将其作为标量返回。 <code>_mm_extract_epiXX()</code> 函数中的XX表示整数向量的位宽，例如， <code>_mm_extract_epi32()</code> 用于从32位整数向量中提取单个32位整数值。</p>
<h3 id="2-ave操作例子">2. AVE操作例子</h3>
<p>执行 AVX 指令的过程如下：</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20230810234918.png" alt="20230810234918"  /></p>
<p>所有操作同时进行。就性能而言，在AVX中对浮点数执行单个 <code>Add</code> 的消耗与在AVX中对8个浮点数执行 <code>VAdd</code> 的消耗近似。在<a class="link" href="https://www.agner.org/optimize/instruction_tables.pdf"  target="_blank" rel="noopener"
    >Agner Fog&rsquo;s instruction tables</a>中，可以获得更多有关指令延迟和吞吐量的信息。在 Sandy Bridge 架构上，<code>VADDPS/D</code> 的延迟为 3，吞吐量为 1，就像 <code>FADD(P)</code> 一样。</p>
<h3 id="3-先决条件">3. 先决条件</h3>
<p>SSE/AVX 需要目标机器具备相应的硬件支持。因此，为了确保程序在目标机器上能够正常运行，需要满足这些指令集扩展的先决条件。本文中的示例代码为了简化构建过程并确保程序在当前机器上正常运行，使用<code>-march=native</code> 编译选项。这个选项会自动检测当前机器的CPU能力，并使用相应的指令集扩展。这样可以充分利用目标机器的硬件能力，提高程序的性能和效率。</p>



<div class="notice notice-info" >
    <div class="notice-title"><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M256 8a248 248 0 100 496 248 248 0 000-496zm0 110a42 42 0 110 84 42 42 0 010-84zm56 254c0 7-5 12-12 12h-88c-7 0-12-5-12-12v-24c0-7 5-12 12-12h12v-64h-12c-7 0-12-5-12-12v-24c0-7 5-12 12-12h64c7 0 12 5 12 12v100h12c7 0 12 5 12 12v24z"/></svg></div><p>注意：编译后的二进制文件在没有 AVX 功能的计算机上将失败。如果需要适应不同CPU的二进制代码，则需要利用CPU Flag并调用不同的函数，或者针对不同的指令集生成不同的二进制代码。</p></div>

<p>由于操作系统、编译器和 CPU 都必须允许 SSE/AVX 扩展。我们可以运行以下脚本来检测系统功能：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">#CPU flag detection </span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> -e <span class="s2">&#34;\e[32m&gt;&gt;&gt; Getting CPU flag capabilities and number of cores\e[0m&#34;</span> 
</span></span><span class="line"><span class="cl">cat /proc/cpuinfo <span class="p">|</span> egrep <span class="s2">&#34;(flags|model name|vendor)&#34;</span> <span class="p">|</span> sort <span class="p">|</span> uniq -c 
</span></span><span class="line"><span class="cl"><span class="c1">#Compiler capabilities. -march=native is required! </span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> -e <span class="s2">&#34;\e[32m&gt;&gt;&gt; Getting GCC capabilities\e[0m&#34;</span> 
</span></span><span class="line"><span class="cl">gcc -march<span class="o">=</span>native -dM -E - &lt; /dev/null <span class="p">|</span> egrep <span class="s2">&#34;SSE|AVX&#34;</span> <span class="p">|</span> sort 
</span></span><span class="line"><span class="cl"><span class="c1">#OS kernel version </span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> -e <span class="s2">&#34;\e[32m&gt;&gt;&gt; Getting OS Kernel Version\e[0m&#34;</span> 
</span></span><span class="line"><span class="cl">uname -a
</span></span></code></pre></div><p>在 CPU Flag 中，我们可以看到 SSE 和 AVX 的支持。我们将搜索 avx 标志。这表明 CPU 兼容 AVX。如果有 avx2，则表示 CPU 允许 AVX2 扩展。AVX 足以支持 8x32 位浮点矢量。AVX2 为整数增加了 256 位向量（例如 8x32 位整数）。尽管如此，256 位整数向量的执行速度似乎与两个 128 位向量相同，因此与 SSE 128 位整数向量相比，性能并没有显著提高。</p>
<p>在 GCC 的输出中，我们可以看到 #define __AVX__ 1 等。这表明 GCC 允许使用 AVX 指令集扩展。</p>



<div class="notice notice-info" >
    <div class="notice-title"><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M256 8a248 248 0 100 496 248 248 0 000-496zm0 110a42 42 0 110 84 42 42 0 010-84zm56 254c0 7-5 12-12 12h-88c-7 0-12-5-12-12v-24c0-7 5-12 12-12h12v-64h-12c-7 0-12-5-12-12v-24c0-7 5-12 12-12h64c7 0 12 5 12 12v100h12c7 0 12 5 12 12v24z"/></svg></div><p>记住始终使用 -march=native 或 -mavx， 如果运行 GCC 时没有使用正确的 march，就不会得到 <strong>AVX</strong> 标志！ 默认的 GCC 参数是通用的，如果没有该标记，即使 CPU 支持 AVX，也无法启用 AVX。</p></div>

<p>最后，我们需要再次检查 Linux 内核是否为 2.6.30 或更高版本。理想的内核是 4.4.0 或更高版本。</p>
<p>有了所有这些先决条件，我们就可以开始编写第一个 AVX 向量程序了。</p>
<h2 id="二自动向量化">二、自动向量化</h2>
<h3 id="1-gcc自动向量化flag">1. GCC自动向量化flag</h3>
<p>GCC 是一种高级编译器，使用优化标志 -O3 或 -ftree-vectorize 时，编译器会搜索循环向量化（需要指定-mavx flag）。在源代码保持不变的情况下，GCC 编译出来的代码会完全不同。</p>
<p>除非启用某些标志，否则GCC不会记录任何有关自动向量化的内容。如果需要自动向量化结果的详细信息，可以使用以下编译器flag</p>
<ul>
<li><code>-fopt-info-vec</code> 或 <code>-fopt-info-vec-optimized</code>：编译器将记录哪些循环（按行号）正在进行向量化优化。</li>
<li><code>-fopt-info-vec-missed</code>：关于未被向量化的循环的详细信息，以及许多其他详细信息。</li>
<li><code>-fopt-info-vec-note</code>：关于所有循环和正在进行的优化的详细信息。</li>
<li><code>-fopt-info-vec-all</code>：所有以上的选项放在一起。</li>
</ul>



<div class="notice notice-info" >
    <div class="notice-title"><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M256 8a248 248 0 100 496 248 248 0 000-496zm0 110a42 42 0 110 84 42 42 0 010-84zm56 254c0 7-5 12-12 12h-88c-7 0-12-5-12-12v-24c0-7 5-12 12-12h12v-64h-12c-7 0-12-5-12-12v-24c0-7 5-12 12-12h64c7 0 12 5 12 12v100h12c7 0 12 5 12 12v24z"/></svg></div><p>注意：还有类似的 -fopt-info-[options]-optimized 标志用于其他编译器优化，如内联： -fopt-info-inline-optimized</p></div>

<p>在以下示例中，我们将使用 -O3 和 -fopt-info-vec-optimized 启用 GCC 自动向量化。当然也可以更改编译器标志以查看不同的日志记录选项。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// autovector.cpp
</span></span></span><span class="line"><span class="cl"><span class="c1">// compile: g++ -fopt-info-vec-optimized -o autovector autovector.cpp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#pragma GCC optimize(&#34;O3&#34;, &#34;unroll-loops&#34;, &#34;omit-frame-pointer&#34;, &#34;inline&#34;)  </span><span class="c1">// 优化选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#pragma GCC option(&#34;arch=native&#34;, &#34;tune=native&#34;, &#34;no-zero-upper&#34;)           </span><span class="c1">// 启用AVX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#pragma GCC target(&#34;avx&#34;)                                                   </span><span class="c1">// 启用AVX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;x86intrin.h&gt;  // AVX/SSE指令集</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="n">N</span>        <span class="o">=</span> <span class="mi">200000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="n">numTests</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 数据初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1335f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.50f</span> <span class="o">*</span> <span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.9383f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.33f</span> <span class="o">*</span> <span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1172f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numTests</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">end</span>      <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">).</span><span class="n">count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mf">2.0f</span> <span class="o">+</span> <span class="mf">0.1335f</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.50f</span> <span class="o">*</span> <span class="mf">2.0f</span> <span class="o">+</span> <span class="mf">0.9383f</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.33f</span> <span class="o">*</span> <span class="mf">2.0f</span> <span class="o">+</span> <span class="mf">0.1172f</span><span class="p">)</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                            <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="kt">float</span><span class="p">)(</span><span class="n">numTests</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;CG&gt; message -channel </span><span class="se">\&#34;</span><span class="s">results</span><span class="se">\&#34;</span><span class="s"> Time used: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">duration</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="s">&#34;s, N * numTests=&#34;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">numTests</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果一切正常，将看到编译器测试结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">autovector.cpp:15:23: optimized: loop vectorized using 32 byte vectors
</span></span></code></pre></div><ul>
<li>将编译选项更改为 <code>-fopt-info-vec-all</code>，可以看到更多的信息，包括向量化的循环的行号。</li>
<li>在 autovector.cpp 第 1 行，将 O3 改为 O2 , 然后重新运行。将不会看到 loop vectorized ，而且非向量化编译会比向量化编译慢。</li>
</ul>
<h3 id="2-循环向量化的要求">2. 循环向量化的要求</h3>
<p>并非所有循环都能进行向量化。要进行向量化，对循环有一些严格的要求。</p>
<ul>
<li>一旦循环开始，循环计数就不能改变。这意味着，循环的终点可以是一个动态变量，可以随意增加或减少其值，但一旦循环开始，它就必须保持不变。</li>
<li>使用 break 或 continue 句子会有一些限制。有时编译器会很聪明地让它起作用，但在某些情况下，循环不会被向量化。</li>
<li>在循环内调用外部函数有一些限制</li>
<li>循环不应该有数据依赖关系。</li>
<li>条件句 (if/Else) 可以在不改变控制流的情况下使用，并且只用于有条件地将 A 或 B 值加载到 C 变量中。选择 A 或 B 是在编译器中使用掩码完成的，因此它同时计算分支 A 和 B ，而 C 将存储一个或另一个值：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">s</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0f</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">   <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0f</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span></code></pre></div><p>这是一个可向量循环。控制流从未改变，x[i] 和 y[i] 值总是设置为其中一个或另一个值。</p>
<p>有关自动向量化的更多信息，请阅读<a class="link" href="https://software.intel.com/sites/default/files/m/4/8/8/2/a/31848-CompilerAutovectorizationGuide.pdf"  target="_blank" rel="noopener"
    >Intel C++编译器的矢量化</a>。该文档虽然面向Intel编译器，但它提供了有关自动向量化的有趣而完整的信息。</p>
<p>自动向量化的好处是，它是自动完成的。编译器会尝试向量化循环，开发人员不需要做任何事情。但是有时(尤其是在高性能计算应用中)需要微调循环和向量化，通过使用手动AVX向量化来确保最大吞吐量。</p>
<h2 id="三sseavx的使用">三、SSE/AVX的使用</h2>
<p>支持SSE/AVX的CPU具有用于操作XMM和YMM寄存器的汇编指令。但在大多数编译器中，通过使用内置函数简化了这一过程，因此开发人员不需要直接使用汇编。</p>
<h3 id="1-内置函数">1. 内置函数</h3>
<p>编译器将汇编指令封装为函数，使用它们就像调用带有正确参数的函数一样简单。有时，如果 CPU 不支持指令集，些内置函数就会被模拟。</p>
<p>SSE/AVX内置函数使用以下命名约定：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">_</span><span class="o">&lt;</span><span class="n">vector_size</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">intrin_op</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">suffix</span><span class="o">&gt;</span>
</span></span></code></pre></div><ul>
<li><code>&lt;vector_size&gt;</code> 是指向量的大小。对于 128 位的 SSE， 它为 <code>mm</code>，对于 256 位的 AVX/AVX2，它为 <code>mm256</code>，对于512位的 AVX512， 它为 <code>mm512</code> 。</li>
<li><code>&lt;intrin_op&gt;</code> 是指内置函数的名称，例如 <code>add</code> 或 <code>sub</code>，<code>mul</code>等 。</li>
<li><code>&lt;suffix&gt;</code> 是指内置函数的参数类型，例如 <code>ps</code> 表示 float ，<code>pd</code> 表示 double ，<code>epi8</code> 表示 int8_t，<code>epi32</code> 表示 int32_t , <code>epu16</code> 表示 uint16_t 等。</li>
</ul>
<p>你可以在<a class="link" href="https://software.intel.com/sites/landingpage/IntrinsicsGuide"  target="_blank" rel="noopener"
    >Intel Intrinsics Guide</a>中找到所有内置函数，它是SSE/AVX中提供的任何内置函数的完整参考。此外，还有一份 <a class="link" href="https://db.in.tum.de/~finis/x86-intrin-cheatsheet-v2.2.pdf?lang=en"  target="_blank" rel="noopener"
    >x86 内置函数Cheet Sheet</a>，但由于内容更为复杂，阅读起来比较困难。</p>
<h3 id="2-sseavx没有提供的内置函数">2. SSE/AVX没有提供的内置函数</h3>
<ul>
<li>
<p><strong>缺少整数除法</strong>：由于某些原因，SSE和AVX缺少整数除法运算符。有一些方法可以克服这一点：</p>
<ul>
<li>在线性代码中通过计算除法来完成操作。首先，从向量中取出单个数据，然后进行除法运算，最后将结果再次存储回向量中。然而，这种方法速度较慢。</li>
<li>将整数向量转换为浮点数，将它们相除，然后再次转换为整数。</li>
<li>对于编译时的已知除数，有一些魔法数（magic number）可以将常量除法转换为乘法运算。可以参考<a class="link" href="https://libdivide.com/"  target="_blank" rel="noopener"
    >libdivide</a>。</li>
<li>对于 2 的幂除法，使用位移操作。除以整数 2 等于右移。只有当所有向量都被相同的 2 的幂整除时，才能进行右移操作。不过对有符号数进行右移时要注意！需要使用符号位移。</li>
</ul>
</li>
<li>
<p><strong>缺少三角函数</strong>：内置函数中没有三角函数。可能的解决办法是用线性代码计算（对每个向量值逐一计算），或创建近似函数。泰勒级数和 Remez 近似函数的效果很好。</p>
</li>
<li>
<p><strong>缺少随机数生成器</strong>：此外，没有随机数生成器。但是从线性版本重新创建一个好的伪随机生成器是很简单的。只需确定伪随机数生成器中使用的位即可。填充向量首选32位或64位RNG。</p>
</li>
</ul>
<h3 id="3-性能损失">3. 性能损失</h3>
<ul>
<li>
<p><strong>数据对齐</strong>： 旧的CPU架构不能使用向量化，除非数据在内存中与向量大小一致。其他一些CPU可以使用未对齐的数据，但性能会有所损失。在最近的处理器中，这种影响似乎可以忽略不计。但为了安全起见，如果不增加过多的开销，对齐数据可能是个好主意。有关数据对齐的资料，可参考<a class="link" href="https://lemire.me/blog/2012/05/31/data-alignment-for-speed-myth-or-reality/"  target="_blank" rel="noopener"
    >Data alignment for speed: myth or reality?</a></p>
<ul>
<li>在 GCC 中，可以使用以下变量属性进行数据对齐： <code>__attribute__((aligned(16)))</code>、<code>__attribute__((aligned(32)))</code></li>
<li>最简单的变量对齐声明：<code>#define ALIGN __attribute__((aligned(32)))</code></li>
</ul>
</li>
<li>
<p><strong>SSE/AVX转换损失</strong>： 将传统的 SSE 库与新的 AVX 架构混合使用还有一个大问题。由于 XMM 和 YMM 共享低 128 位，在 AVX 和 SSE 之间转换可能导致高 128 位出现未定义的值。为了解决这个问题，编译器需要保存高128位，清除它，执行旧的SSE操作，然后恢复旧值。但是这显著增加了AVX操作的开销，导致性能下降。</p>
</li>
</ul>



<div class="notice notice-tip" >
    <div class="notice-title"><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M504 256a248 248 0 11-496 0 248 248 0 01496 0zM227 387l184-184c7-6 7-16 0-22l-22-23c-7-6-17-6-23 0L216 308l-70-70c-6-6-16-6-23 0l-22 23c-7 6-7 16 0 22l104 104c6 7 16 7 22 0z"/></svg></div><p>注意：这个问题并不意味着不能同时使用__m128和__m256而不影响性能。AVX有一个针对__m128的新指令集，带有VEX前缀。这些新的VEX指令与__M256指令相结合没有任何问题。当非 VEX __m128 指令与 __m256 指令结合使用时，就会产生转换代价。当使用旧的 SSE 库链接到新的启用 AVX 的程序时，就会发生这种情况。</p></div>

<ul>
<li>
<p>为了避免转换损失，编译器可以使用 <code>-mvzeroupper</code> 参数自动添加对 <code>VZEROUPPER</code> (清除高128位)或 <code>VZEROALL</code>（清除所有 YMM 寄存器）的调用，程序员也可以手动添加。如果不使用外部 SSE 库，且确定所有代码都启用了 VEX 并在编译时启用了 AVX 扩展，则可以使用 <code>-mvzeroupper</code> 参数指示编译器避免添加 <code>VZEROUPPER</code> 调用： <code>-mno-vzeroupper</code>。更多关于SSE/AVX转换损失的资料，可参考<a class="link" href="https://software.intel.com/en-us/articles/avoiding-avx-sse-transition-penalties"  target="_blank" rel="noopener"
    >Avoiding AVX-SSE Transition Penalties</a> 和 <a class="link" href="https://stackoverflow.com/questions/41303780/why-is-this-sse-code-6-times-slower-without-vzeroupper-on-skylake"  target="_blank" rel="noopener"
    >Why is this SSE code 6 times slower without VZEROUPPER on Skylake?</a>。</p>
</li>
<li>
<p><strong>数据移动成本</strong>：在 AVX 寄存器中来回移动数据的成本很高。在某些情况下，如果有一些数据存储在线性结构中，那么将这些数据发送到 AVX 向量、执行一些操作并恢复这些数据的成本要比简单地执行线性计算高。因此，开发时必须考虑到数据加载和卸载的开销。请记住，在某些情况下，这将成为性能瓶颈。</p>
</li>
</ul>
<h3 id="4-avx使用例子计算平方根">4. AVX使用例子：计算平方根</h3>
<ul>
<li>下面程序是对浮点数的SQRT计算进行向量化，显式使用 <code>__m256</code> 数据类型来存储浮点数，从而减少数据加载的开销。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// vectorized_sqrt.cpp
</span></span></span><span class="line"><span class="cl"><span class="c1">// compile: g++ -o vectorized_sqrt vectorized_sqrt.cpp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#pragma GCC optimize(&#34;O3&#34;, &#34;unroll-loops&#34;, &#34;omit-frame-pointer&#34;, &#34;inline&#34;)  </span><span class="c1">// 优化选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#pragma GCC option(&#34;arch=native&#34;, &#34;tune=native&#34;, &#34;no-zero-upper&#34;)           </span><span class="c1">// 启用AVX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#pragma GCC target(&#34;avx&#34;)                                                   </span><span class="c1">// 启用AVX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;x86intrin.h&gt;  // AVX/SSE指令集</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">64000000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">V</span> <span class="o">=</span> <span class="n">N</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">linear</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 禁用自动向量化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">__attribute__</span><span class="p">((</span><span class="n">optimize</span><span class="p">(</span><span class="s">&#34;no-tree-vectorize&#34;</span><span class="p">)))</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">normal_sqrt</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">linear</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrtf</span><span class="p">(</span><span class="n">linear</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">__m256</span> <span class="n">ALIGN</span> <span class="n">vectorized</span><span class="p">[</span><span class="n">V</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">avx_sqrt</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">vectorized</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_mm256_sqrt_ps</span><span class="p">(</span><span class="n">vectorized</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define TIME                                                   \
</span></span></span><span class="line"><span class="cl"><span class="cp">    std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;( \
</span></span></span><span class="line"><span class="cl"><span class="cp">        std::chrono::high_resolution_clock::now() - now)       \
</span></span></span><span class="line"><span class="cl"><span class="cp">        .count()
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 数据初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">linear</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1335f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">vectorized</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">float</span><span class="p">)(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">v</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.1335f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// normal_sqrt benchmark
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">normal_sqrt</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">linear_time</span> <span class="o">=</span> <span class="n">TIME</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Normal sqrtf: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">linear_time</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// AVX sqrt benchmark
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">avx_sqrt</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">avx_time</span> <span class="o">=</span> <span class="n">TIME</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;AVX sqrtf: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">avx_time</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Check Values
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">linear</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">v</span><span class="p">]</span> <span class="o">-</span> <span class="n">vectorized</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.00001f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Error: AVX sqrtf is not equal to normal sqrtf!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;linear[&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;] = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">linear</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">v</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;vectorized[&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;][&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;] = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">vectorized</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                          <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Linear to AVX improvement : &#34;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">linear_time</span> <span class="o">/</span> <span class="n">avx_time</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;%&#34;</span>
</span></span><span class="line"><span class="cl">          <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>可能会看到 600% 或更高的性能提升。也就是说，一旦加载了数据，AVX 的运行速度将是普通 sqrtf 的 7 倍。理论极限是 800%，但很少能达到。一般来说可以预期平均提高 300% 到 600%。运行结果如下：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Normal sqrtf: 1.51901
</span></span><span class="line"><span class="cl">AVX sqrtf: 0.374871
</span></span><span class="line"><span class="cl">Linear to AVX improvement : 405.209%
</span></span></code></pre></div><ul>
<li>可以看到：运行速度提高了 405%。</li>
</ul>
<h2 id="四c中的sseavx框架">四、C++中的SSE/AVX框架</h2>
<h3 id="1-内置函数的复杂性">1. 内置函数的复杂性</h3>
<p>直接使用内置函数会使代码编写和维护变得复杂。问题在于内置函数名很长，比如算术运算用函数符号书写：<code>add(a,b)</code> 而不是 <code>a + b</code>。导致下面的代码很难阅读：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="n">_mm256_div_ps</span><span class="p">(</span><span class="n">_mm256_add_ps</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">_mm256_sqrt_ps</span><span class="p">(</span><span class="n">_mm256_sub_ps</span><span class="p">(</span><span class="n">_mm256_mul_ps</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"> <span class="n">_mm256_mul_ps</span><span class="p">(</span><span class="n">_mm256_mul_ps</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl"> <span class="n">_mm256_set1_ps</span><span class="p">(</span><span class="mf">4.0f</span><span class="p">)))))</span> <span class="p">,</span> <span class="n">_mm256_mul_ps</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">_mm256_set1_ps</span><span class="p">(</span><span class="mf">2.0f</span><span class="p">)));</span>
</span></span></code></pre></div><p>而以下封装版本的可读性非常好：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span> <span class="o">*</span> <span class="mf">4.0f</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="mf">2.0f</span><span class="p">);</span>
</span></span></code></pre></div><h3 id="2-用于simd计算的c框架">2. 用于SIMD计算的C++框架</h3>
<p>现有的一些框架在新的类中封装了向量数据类型。然后，它们重载算术、逻辑和赋值运算符，以简化计算。其中，可以使用这两个框架：</p>
<ul>
<li><a class="link" href="http://www.agner.org/optimize/#vectorclass"  target="_blank" rel="noopener"
    >Agner Fog&rsquo;s C++ vector class library</a>： 内容完整，定期更新。而且还包含了三角函数。</li>
<li><a class="link" href="https://gain-performance.com/ume/"  target="_blank" rel="noopener"
    >Unified Multicore Environment</a>：一个较新的库</li>
<li><a class="link" href="https://github.com/xtensor-stack/xsimd"  target="_blank" rel="noopener"
    >xsimd Wrapper</a>：一个比较好用的C++ Wrapper。</li>
</ul>
<p>不过，这些库的体积都比较大，在代码大小有限（小于100kb）的情况下，可以使用以下简单的封装版本，只需要关注一两种类型。</p>
<div class="github">
    <div class="logo">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M2 2.5C2 1.83696 2.26339 1.20107 2.73223 0.732233C3.20108 0.263392 3.83696 0 4.5 0L13.25 0C13.4489 0 13.6397 0.0790176 13.7803 0.21967C13.921 0.360322 14 0.551088 14 0.75V13.25C14 13.4489 13.921 13.6397 13.7803 13.7803C13.6397 13.921 13.4489 14 13.25 14H10.75C10.5511 14 10.3603 13.921 10.2197 13.7803C10.079 13.6397 10 13.4489 10 13.25C10 13.0511 10.079 12.8603 10.2197 12.7197C10.3603 12.579 10.5511 12.5 10.75 12.5H12.5V10.5H4.5C4.30308 10.5 4.11056 10.5582 3.94657 10.6672C3.78257 10.7762 3.65442 10.9312 3.57816 11.1128C3.50191 11.2943 3.48096 11.4943 3.51793 11.6878C3.5549 11.8812 3.64816 12.0594 3.786 12.2C3.92524 12.3422 4.0023 12.5338 4.00024 12.7328C3.99818 12.9318 3.91716 13.1218 3.775 13.261C3.63285 13.4002 3.4412 13.4773 3.24222 13.4752C3.04325 13.4732 2.85324 13.3922 2.714 13.25C2.25571 12.7829 1.99929 12.1544 2 11.5V2.5ZM12.5 1.5V9H4.5C4.144 9 3.806 9.074 3.5 9.208V2.5C3.5 2.23478 3.60536 1.98043 3.79289 1.79289C3.98043 1.60536 4.23478 1.5 4.5 1.5H12.5ZM5 12.25V15.5C5 15.5464 5.01293 15.5919 5.03734 15.6314C5.06175 15.6709 5.09667 15.7028 5.1382 15.7236C5.17972 15.7444 5.22621 15.7532 5.27245 15.749C5.31869 15.7448 5.36286 15.7279 5.4 15.7L6.85 14.613C6.89328 14.5805 6.94591 14.563 7 14.563C7.05409 14.563 7.10673 14.5805 7.15 14.613L8.6 15.7C8.63714 15.7279 8.68131 15.7448 8.72755 15.749C8.77379 15.7532 8.82028 15.7444 8.8618 15.7236C8.90333 15.7028 8.93826 15.6709 8.96266 15.6314C8.98707 15.5919 9 15.5464 9 15.5V12.25C9 12.1837 8.97366 12.1201 8.92678 12.0732C8.87989 12.0263 8.81631 12 8.75 12H5.25C5.1837 12 5.12011 12.0263 5.07322 12.0732C5.02634 12.1201 5 12.1837 5 12.25Z"/></svg>
        <a class="name" href=https://github.com/marchete/Course-SSE-and-AVX-Vectorization-ES/tree/master/projects/avx/framework target="_blank">SIMD-Framework</a>
    </div>
    <div class="description">Vector wrappers that are reduced in size, just focused on one or two types (for example, __m256 8x float and __m128i 8x short, to work with a vector size of 8, both on floats and on integers).</div> 
    <div class="language">
        <span class="language-color" style="background-color: #f34b7d"></span>
        <span class="language-name">C&#43;&#43;</span>
    </div>
</div>
<ul>
<li>除了内置函数，该封装版本还封装了一些特殊的函数：</li>
<li><strong>Blend-based functions</strong>：blend是根据掩码有条件地加载向量值的过程，这类函数用于混合两个向量的函数。
<ul>
<li><code>if_select(mask,value_true,value_false)</code> ：根据掩码对向量进行有条件加载。如果掩码为真，则返回 value_true，否则返回 value_false。</li>
<li><code>if_add(mask,value,add_when_true)</code> ：条件加法。返回 <code>value + (mask? add_when_true:0)</code> ，对于每个向量分量。</li>
<li><code>if_sub, if_mul, if_div</code> ：与 if_add 类似，只是算术运算方式不同。</li>
</ul>
</li>
<li><strong>Horizontal functions</strong>：Horizontal表示这些函数通过计算某些逻辑值或算术值，在单个向量变量内运行。
<ul>
<li><code>horizontal_or(mask)</code> ：如果掩码中的任何向量分量为 true。返回布尔值。</li>
<li><code>horizontal_add(vector)</code> ：返回向量的所有分量的总和。返回值是一个数字(浮点型、双精度型或整型，具体取决于向量类型)。</li>
</ul>
</li>
</ul>
<h2 id="五masking与conditional-load">五、Masking与Conditional Load</h2>
<h3 id="1-向量中的掩码">1. 向量中的掩码</h3>
<p>掩码是向量之间逻辑运算的结果。它与布尔运算有许多相似之处（它们是对单个数字或其他布尔运算的逻辑运算结果），但在内部，每个掩码组件必须全部为 0 位或全部为 1 位。</p>
<p>让我们比较具有大于运算符的两个AVX浮点向量：</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20230811173734.png" alt="20230811173734"  /></p>
<p>输入是两个带有浮点分量的向量。逻辑运算的输出也是一个带浮点分量的向量，但其值的位数被设置为全 0 或全 1。全 1 表示 &ldquo;真&rdquo;，全 0 表示 &ldquo;假&rdquo;。对于浮点数，全 1 的值打印为-nan，对于整数，则打印为-1。存储的实际值并不重要。我们只需要知道它保存的是真值和假值。</p>
<ul>
<li>
<p><strong>逻辑运算符的结果(&gt;、&lt;、==、&amp;&amp;、||等</strong>：以逻辑&amp;&amp;运算符为例：</p>
<ul>
<li><code>vector &amp;&amp; vector = mask</code></li>
<li><code>mask &amp;&amp; mask == mask</code></li>
<li><code>vector &amp;&amp; mask == ?????</code></li>
</ul>
</li>
<li>
<p>最后一种情况，可能会有意想不到的结果，这就像试图做 3 &gt; false，也许在 C++ 中这是可行的，但在逻辑意义上这是不正确的。</p>
</li>
</ul>



<div class="notice notice-info" >
    <div class="notice-title"><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M256 8a248 248 0 100 496 248 248 0 000-496zm0 110a42 42 0 110 84 42 42 0 010-84zm56 254c0 7-5 12-12 12h-88c-7 0-12-5-12-12v-24c0-7 5-12 12-12h12v-64h-12c-7 0-12-5-12-12v-24c0-7 5-12 12-12h64c7 0 12 5 12 12v100h12c7 0 12 5 12 12v24z"/></svg></div><p>注意：与布尔运算不同，并非零以外的任何数字都是 TRUE。只有所有位都设置为 1 的矢量成分才被视为 TRUE。不要使用其他值作为掩码。否则会失败，或得到意想不到的结果。</p></div>

<h3 id="2-条件加载">2. 条件加载</h3>
<p>掩码可用于有条件地将值加载到向量中。比如可以使用掩码来有条件地控制值向量的加载：<code>if_select(mask,value_true,value_false)</code> 可以表示为：</p>
<p><img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20230811174342.png" alt="20230811174342"  /></p>
<ul>
<li>当掩码设置为 <code>FALSE</code> 时，数据从 <code>value_false</code> 向量加载；当设置为 <code>TRUE</code> 时，数据从 <code>value_true</code> 向量加载。这个概念简单而有效。</li>
</ul>



<div class="notice notice-note" >
    <div class="notice-title"><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z"/></svg></div><p>代码示例1：使用掩码和 SIMD-Framework 中的 v8f.h 实现条件加载。（主要使用 if_select(mask,value_true,value_false) 方法，该函数是 _mm256_blendv_ps的封装）</p></div>

<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#pragma GCC optimize(&#34;O3&#34;, &#34;unroll-loops&#34;, &#34;omit-frame-pointer&#34;, &#34;inline&#34;)  
</span></span></span><span class="line"><span class="cl"><span class="cp">#pragma GCC option(&#34;arch=native&#34;, &#34;tune=native&#34;, &#34;no-zeroupper&#34;)           
</span></span></span><span class="line"><span class="cl"><span class="cp">#pragma GCC target(&#34;avx&#34;)                                                   
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;                                                   </span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;x86intrin.h&gt;                                                    </span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;v8f.h&#34;                                                            </span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="n">v8f</span> <span class="nf">testConditions</span><span class="p">(</span><span class="k">const</span> <span class="n">v8f</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">if_select</span><span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mf">3.0f</span> <span class="o">||</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mf">3.7f</span> <span class="o">&amp;&amp;</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mf">15.0f</span><span class="p">),</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0f</span> <span class="o">*</span> <span class="n">value</span> <span class="o">+</span> <span class="mf">1.5f</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                     <span class="p">(</span><span class="o">-</span><span class="mf">2.0f</span> <span class="o">*</span> <span class="n">value</span> <span class="o">-</span> <span class="mf">8.7f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">validate</span><span class="p">(</span><span class="k">const</span> <span class="n">v8f</span> <span class="o">&amp;</span><span class="n">test</span><span class="p">,</span> <span class="k">const</span> <span class="n">v8f</span> <span class="o">&amp;</span><span class="n">vector</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">value</span> <span class="o">=</span> <span class="n">test</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">expected</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mf">3.0f</span> <span class="o">||</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mf">3.7f</span> <span class="o">&amp;&amp;</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mf">15.0f</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">expected</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0f</span> <span class="o">*</span> <span class="n">value</span> <span class="o">+</span> <span class="mf">1.5f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">expected</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">2.0f</span> <span class="o">*</span> <span class="n">value</span> <span class="o">-</span> <span class="mf">8.7f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">expected</span> <span class="o">-</span> <span class="n">vector</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.00001f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Assert Error:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">expected</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">vector</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">validTests</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">TotalTests</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TotalTests</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="mf">500.0f</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1000.0f</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="n">TotalTests</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">v8f</span> <span class="n">test</span><span class="p">(</span><span class="mf">1.4f</span><span class="p">,</span> <span class="mf">3.3f</span><span class="p">,</span> <span class="o">-</span><span class="mf">12.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">33.4f</span><span class="p">,</span> <span class="mf">7.9f</span><span class="p">,</span> <span class="o">-</span><span class="mf">70.2f</span><span class="p">,</span> <span class="mf">15.1f</span><span class="p">,</span> <span class="mf">22.6f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">test</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">v8f</span> <span class="n">result</span> <span class="o">=</span> <span class="n">testConditions</span><span class="p">(</span><span class="n">test</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">validate</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">validTests</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Valid Tests:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">validTests</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;/&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">TotalTests</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; (&#34;</span>
</span></span><span class="line"><span class="cl">         <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">validTests</span> <span class="o">/</span> <span class="n">TotalTests</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;%)&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">validTests</span> <span class="o">!=</span> <span class="n">TotalTests</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="3-性能">3. 性能</h3>
<p>使用掩码的条件加载不是真正的分支，因此它们不会有误预测，并且CPU可以更好地利用无序执行。但这是有代价的。因为它们是无分支的，并且所有条件执行都是通过掩码操作完成的，所以总是计算和执行这两个分支。如果要对 <code>value_false</code> 进行非常复杂的计算，那么即使只有 0.00001% 的时间会发生，也会一直进行计算。如果代码中有些部分很少需要，但计算成本很高，这可能会导致性能问题。在下一章数据流控制中，可以通过控制数据流的方法，根据某些条件提前退出循环。</p>
<h2 id="六数据流控制">六、数据流控制</h2>
<h3 id="1-共享数据流问题">1. 共享数据流问题</h3>
<p>在线性编程中，创建条件分支if、switch、continue 和 break）来控制数据流没有任何问题。你只需创建一个无限循环，并在条件满足时跳出循环即可。但是一个向量不仅有一个条件结果，而且同时有 N 个条件结果。向量的一部分可以准备退出循环(因为向量数据已达到退出条件)，但其余数据在退出之前仍有活动工作要做。</p>



<div class="notice notice-info" >
    <div class="notice-title"><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M256 8a248 248 0 100 496 248 248 0 000-496zm0 110a42 42 0 110 84 42 42 0 010-84zm56 254c0 7-5 12-12 12h-88c-7 0-12-5-12-12v-24c0-7 5-12 12-12h12v-64h-12c-7 0-12-5-12-12v-24c0-7 5-12 12-12h64c7 0 12 5 12 12v100h12c7 0 12 5 12 12v24z"/></svg></div><p>如果向量分量已经计算完成，请冻结它以避免对其进行任何进一步的计算。具体做法是在任何数值赋值中屏蔽已完成的分量。未完成的向量分量会不断更新，但已完成的分量不会。因此，如果我有一个 8x 浮点矢量，而分量 0、1、4 和 7 已达到结束状态，我就需要在每次数据加载时加上一个掩码[false,false,true,true,false,true,false]</p></div>

<h3 id="2-避免执行计算开销很大的分支">2. 避免执行计算开销很大的分支</h3>
<p>要节省 CPU 时间，最简单的方法是检查掩码内的所有值是否相同，要么全部为 &ldquo;true&rdquo;，要么全部为 &ldquo;false&rdquo;。当掩码内的所有值都相同时，我们就得到了一个简单的布尔值，要么为真，要么为假。这可以用来跳过部分代码，或使用普通的条件分支：if、switch、continue 和 break 等。</p>
<p>在SIMD-Framework中，使用的是 <code>horizontal_or(mask)</code>函数（封装了<code>_xxx_testz_xx</code>）。该函数检查掩码内是否有任何值为真，如果存在真值则返回true，否则返回false。</p>



<div class="notice notice-note" >
    <div class="notice-title"><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z"/></svg></div><p>代码示例2：使用 horizontal_or(mask) 函数判断掩码内是否有任何值为真，减少分支计算</p></div>

<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">v8f</span> <span class="nf">result</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">v8f</span> <span class="nf">test</span><span class="p">(</span><span class="mf">1.4f</span><span class="p">,</span> <span class="mf">3.3f</span><span class="p">,</span> <span class="o">-</span><span class="mf">12.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">33.4f</span><span class="p">,</span> <span class="mf">7.9f</span><span class="p">,</span> <span class="o">-</span><span class="mf">70.2f</span><span class="p">,</span> <span class="mf">15.1f</span><span class="p">,</span> <span class="mf">22.6f</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="n">test</span> <span class="o">+=</span> <span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">horizontal_or</span><span class="p">(</span><span class="n">test</span> <span class="o">&gt;=</span> <span class="mf">38.0f</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span> <span class="o">+=</span> <span class="n">if_select</span><span class="p">(</span><span class="n">test</span> <span class="o">&gt;=</span> <span class="mf">38.0f</span><span class="p">,</span> <span class="n">slowFunction</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">test</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 全为false，不需要执行slowFunction，直接加上test向量即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">result</span> <span class="o">+=</span> <span class="n">test</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>通过使用 <code>horizontal_or</code> ，还可以提前跳出循环。自动向量化无法实现这种优化，但手动向量化可以，而且是首选。</li>
</ul>



<div class="notice notice-note" >
    <div class="notice-title"><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z"/></svg></div><p>代码示例3：使用 horizontal_or提前跳出循环，该程序需要同时进行 8 次并行模拟，以 200 个回合为限，计算最大连击得分。一旦在任何一次并行模拟中得分超过 1700 分，就结束模拟，并返回最大得分（一个浮点数值，不是包含所有得分的整个向量，只是最大值）和获得该得分的回合。</p></div>

<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#pragma GCC optimize(&#34;O3&#34;, &#34;unroll-loops&#34;, &#34;omit-frame-pointer&#34;, &#34;inline&#34;)  
</span></span></span><span class="line"><span class="cl"><span class="cp">#pragma GCC option(&#34;arch=native&#34;, &#34;tune=native&#34;, &#34;no-zeroupper&#34;)           
</span></span></span><span class="line"><span class="cl"><span class="cp">#pragma GCC target(&#34;avx&#34;)                                                  
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;                                                    </span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;x86intrin.h&gt;                                                      </span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;v8f.h&#34;                                                            </span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">validateResult</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">turn</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">bestScore</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Turn:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">turn</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;  bestScore:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">bestScore</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">133</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ERROR, Expected turn exit at 133 != &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">turn</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">bestScore</span> <span class="o">!=</span> <span class="mf">1707.318481f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ERROR, Expected a bestScore of 1707.318481f != &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">             <span class="o">&lt;&lt;</span> <span class="n">bestScore</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">v8f</span> <span class="n">Scores</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">3.0f</span><span class="p">,</span> <span class="mf">7.0f</span><span class="p">,</span> <span class="mf">13.4f</span><span class="p">,</span> <span class="mf">22.7f</span><span class="p">,</span> <span class="mf">0.01f</span><span class="p">,</span> <span class="mf">4.556f</span><span class="p">,</span> <span class="mf">9.7f</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">turn</span> <span class="o">&lt;</span> <span class="mi">200</span><span class="p">;</span> <span class="o">++</span><span class="n">turn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Scores</span> <span class="o">+=</span> <span class="p">((</span><span class="kt">float</span><span class="p">)(</span><span class="n">turn</span><span class="p">)</span> <span class="o">/</span> <span class="mf">15.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">turn</span> <span class="o">==</span> <span class="mi">40</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Scores</span> <span class="o">*=</span> <span class="n">Scores</span> <span class="o">/</span> <span class="mf">15.0f</span> <span class="o">+</span> <span class="mf">2.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">turn</span> <span class="o">==</span> <span class="mi">70</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Scores</span> <span class="o">+=</span> <span class="n">if_select</span><span class="p">(</span><span class="n">Scores</span> <span class="o">&lt;</span> <span class="mf">430.0f</span><span class="p">,</span> <span class="mf">850.0f</span><span class="p">,</span> <span class="mf">120.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 利用 horizontal_or 提前退出循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">horizontal_or</span><span class="p">(</span><span class="n">Scores</span> <span class="o">&gt;=</span> <span class="mf">1700.0f</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Scores: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Scores</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">bestScore</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历获取最大分量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">score</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="n">Scores</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">bestScore</span> <span class="o">&lt;</span> <span class="n">score</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">bestScore</span> <span class="o">=</span> <span class="n">score</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">validateResult</span><span class="p">(</span><span class="n">turn</span><span class="p">,</span> <span class="n">bestScore</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="七总结">七、总结</h2>
<p>本文主要介绍了SIMD的基本概念，以及SIMD的优化思路，最后通过一些简单的示例代码，介绍了SIMD的使用方法。主要内容如下：</p>
<ul>
<li>在代码中使用SSE和AVX指令的硬件和软件要求。</li>
<li>可用的向量数据类型。</li>
<li>有关如何检查自动向量化使用情况的信息，以及有关可自动向量化的循环的提示。</li>
<li>C++中的SSE/AVX框架。</li>
<li>掩码和条件加载。</li>
<li>数据流控制。</li>
</ul>
<p>SIMD的优势和劣势：</p>
<p><strong>优势</strong></p>
<ul>
<li>与线性代码相比，潜在的性能提升300%到600%。</li>
<li>与在GPU级别进行向量化编程的CUDA相似。</li>
</ul>
<p><strong>劣势</strong></p>
<ul>
<li>性能取决于运行硬件。</li>
<li>当存在大量数据加载和卸载时，性能不佳。</li>
<li>数据流会变得很难控制，而且向量内每个值的执行时间都会影响整个向量的执行时间。在所有值都满足退出条件之前，不能提前退出。</li>
<li>编码复杂。</li>
<li>缺乏内置函数： 三角函数、随机数、整数除法等。</li>
</ul>
<p>总的来说，SIMD的优势远大于劣势，SIMD的使用可以大大提高程序的性能，但是需要注意的是，SIMD的使用需要编码复杂，而且需要硬件支持，所以在使用SIMD之前，需要对程序进行分析，判断是否有必要使用SIMD。</p>
<h2 id="参考资料">参考资料</h2>
<p>[1] <a class="link" href="https://www.codeproject.com/Articles/874396/Introduction-to-SIMD-instructions"  target="_blank" rel="noopener"
    >Introduction to SIMD instructions</a></p>
<p>[2] <a class="link" href="https://www.agner.org/optimize/instruction_tables.pdf"  target="_blank" rel="noopener"
    >Agner Fog&rsquo;s instruction tables</a></p>
<p>[3] <a class="link" href="https://software.intel.com/sites/default/files/m/4/8/8/2/a/31848-CompilerAutovectorizationGuide.pdf"  target="_blank" rel="noopener"
    >Intel C++编译器的矢量化</a></p>
<p>[4] <a class="link" href="https://software.intel.com/sites/landingpage/IntrinsicsGuide"  target="_blank" rel="noopener"
    >Intel Intrinsics Guide</a></p>
<p>[5] <a class="link" href="https://db.in.tum.de/~finis/x86-intrin-cheatsheet-v2.2.pdf?lang=en"  target="_blank" rel="noopener"
    >x86 内置函数Cheet Sheet</a></p>
<p>[6] <a class="link" href="https://libdivide.com/"  target="_blank" rel="noopener"
    >libdivide</a></p>
<p>[7] <a class="link" href="https://software.intel.com/en-us/articles/avoiding-avx-sse-transition-penalties"  target="_blank" rel="noopener"
    >Avoiding AVX-SSE Transition Penalties</a></p>
<p>[8] <a class="link" href="https://stackoverflow.com/questions/41303780/why-is-this-sse-code-6-times-slower-without-vzeroupper-on-skylake"  target="_blank" rel="noopener"
    >Why is this SSE code 6 times slower without VZEROUPPER on Skylake?</a></p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E5%90%91%E9%87%8F%E5%8C%96%E7%BC%96%E7%A8%8B/">向量化编程</a>
        
            <a href="/tags/simd/">SIMD</a>
        
            <a href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/">并行计算</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
    integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
    integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
    integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="StackLaTeX()"></script>

<script>
    function StackLaTeX() {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });
    }
</script>
    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="has-image">
    <a href="/p/mpi-tutorial/5/">
        
        
            <div class="article-image">
                
                    <img src="https://cuterwrite-1302252842.file.myqcloud.com/img/9a5806864623b04c918b9d8bee35c49fc2790c52.jpg@1256w_828h_!web-article-pic.avif" loading="lazy" data-key="mpi-tutorial/5" data-hash="https://cuterwrite-1302252842.file.myqcloud.com/img/9a5806864623b04c918b9d8bee35c49fc2790c52.jpg@1256w_828h_!web-article-pic.avif"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MPI与并行计算（五）：MPI扩展</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/mpi-tutorial/4/">
        
        
            <div class="article-image">
                
                    <img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20230720120242.png" loading="lazy" data-key="mpi-tutorial/4" data-hash="https://cuterwrite-1302252842.file.myqcloud.com/img/20230720120242.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MPI与并行计算（四）：数据类型</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/mpi-tutorial/3/">
        
        
            <div class="article-image">
                
                    <img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20230720002052.png" loading="lazy" data-key="mpi-tutorial/3" data-hash="https://cuterwrite-1302252842.file.myqcloud.com/img/20230720002052.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MPI与并行计算（三）：集合通信</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/mpi-tutorial/2/">
        
        
            <div class="article-image">
                
                    <img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20230719212254.png" loading="lazy" data-key="mpi-tutorial/2" data-hash="https://cuterwrite-1302252842.file.myqcloud.com/img/20230719212254.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MPI与并行计算（二）：点到点通信</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/mpi-tutorial/1/">
        
        
            <div class="article-image">
                
                    <img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20230719012753.png" loading="lazy" data-key="mpi-tutorial/1" data-hash="https://cuterwrite-1302252842.file.myqcloud.com/img/20230719012753.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MPI与并行计算（一）：并行环境及编程模型</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>


    
        
    <script src="https://utteranc.es/client.js" 
        repo="PKUcoldkeyboard/pkucoldkeyboard.github.io"
        issue-term="title"
        theme="preferred-color-scheme" 
        
        crossorigin="anonymous" 
        async>
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${e.detail}`
                },
                'https://utteranc.es'
            );
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2021 - 
        
        2023 cuterwrite
    </section>
    
    <section class="powerby">
        
            欢迎来到Cuterwrite的博客网站 <br/>
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="2.0.1">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>
      
      Array.from(document.getElementsByClassName("language-mermaid")).forEach(
        (el) => {
          el.parentElement.outerHTML = `<div class="mermaid">${el.innerText}</div>`;
        }
      );
    </script>
    <style>
       
      .mermaid svg {
        display: block;
        margin: auto;
      }
    </style>


            </main>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"
    integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin="anonymous"></script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
