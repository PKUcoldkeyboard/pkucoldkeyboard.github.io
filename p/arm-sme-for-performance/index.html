<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="本文介绍了 Arm 架构中的 Scalable Matrix Extension (SME)，重点解析了其 Streaming SVE 模式下高效的矩阵运算能力，以及利用 ZA array 进行大规模数据存储和灵活访问的机制，为高性能计算应用提供了强大的硬件加速支持。"><title>Arm 矩阵加速：可伸缩矩阵扩展 SME</title>
<link rel=canonical href=https://cuterwrite.top/p/arm-sme-for-performance/><link rel=stylesheet href=/scss/style.min.9e9a820f30d9af5db6f416de7ab0f7a731a8bcab6669edcbd5a489a07906aa5d.css><meta property='og:title' content="Arm 矩阵加速：可伸缩矩阵扩展 SME"><meta property='og:description' content="本文介绍了 Arm 架构中的 Scalable Matrix Extension (SME)，重点解析了其 Streaming SVE 模式下高效的矩阵运算能力，以及利用 ZA array 进行大规模数据存储和灵活访问的机制，为高性能计算应用提供了强大的硬件加速支持。"><meta property='og:url' content='https://cuterwrite.top/p/arm-sme-for-performance/'><meta property='og:site_name' content="Cuterwrite's Blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='SIMD'><meta property='article:tag' content='向量化编程'><meta property='article:tag' content='并行计算'><meta property='article:published_time' content='2024-08-13T22:44:00+00:00'><meta property='article:modified_time' content='2024-08-13T22:44:00+00:00'><meta property='og:image' content='https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-14_117622407_p0_master1200.webp'><meta name=twitter:title content="Arm 矩阵加速：可伸缩矩阵扩展 SME"><meta name=twitter:description content="本文介绍了 Arm 架构中的 Scalable Matrix Extension (SME)，重点解析了其 Streaming SVE 模式下高效的矩阵运算能力，以及利用 ZA array 进行大规模数据存储和灵活访问的机制，为高性能计算应用提供了强大的硬件加速支持。"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-14_117622407_p0_master1200.webp'><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><script async src=https://analytics.cuterwrite.top/uma.js data-website-id=b13594a2-4d15-4a4e-a020-5e3cc1d88c12 data-domains=cuterwrite.top></script><link rel=manifest href=/manifest.json></head><body class="article-page
line-numbers"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hue4d14694a57c01a222a16c47db12c89c_369633_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>😉</span></figure><div class=site-meta><h1 class=site-name><a href=/>Cuterwrite's Blog</a></h1><h2 class=site-description>Cuterwrite 的技术博客, 专注于高性能计算、操作系统、全栈开发、人工智能等领域的深度探讨和经验分享。</h2></div></header><ol class=menu-social><li><a href=https://analytics.cuterwrite.top/share/Ji0gm9OaLDk8gco7 target=_blank title=Analytics rel=me><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 5H7A2 2 0 005 7v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"/><rect x="9" y="3" width="6" height="4" rx="2"/><path d="M9 17v-5"/><path d="M12 17v-1"/><path d="M15 17v-3"/></svg></a></li><li><a href=https://stats.uptimerobot.com/6NVhRHkSAQ target=_blank title=Uptime rel=me><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-chart-line"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 19h16"/><path d="M4 15l4-6 4 2 4-5 4 4"/></svg></a></li><li><a href=/index.xml target=_blank title=RSS rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li><li><a href=https://github.com/PKUcoldkeyboard target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.zhihu.com/people/kong-tiao-cheng-tai-lang-30-57 target=_blank title=zhihu rel=me><svg t="1705591931290" class="icon" viewBox="0 0 1280 1024" xmlns="http://www.w3.org/2000/svg" p-id="21048" width="32" height="32"><path d="M341.08 296.26v435.08l46.86.02 15.42 52.74 84.02-52.74h99.06V296.26H341.08zm195.5 387.86H480.7l-55.8 35.02-10.16-34.94-23.8-.08V343.5h145.64v340.62zM299.66 495.34H195c3.48-54.2 4.4-103.18 4.4-146.92h102.32s3.94-45.12-17.16-44.62h-177c6.98-26.24 15.74-53.32 26.24-81.34.0.0-48.14.0-64.54 43.14-6.78 17.8-26.42 86.28-61.4 156.24 11.78-1.28 50.74-2.36 73.68-44.42 4.22-11.78 5.02-13.32 10.28-29.06h57.74c0 21-2.4 133.76-3.36 146.88H41.66c-23.48.0-31.12 47.24-31.12 47.24H141.7C132.9 642.2 85.66 726.24.0 792.68c40.98 11.7 81.82-1.86 102-19.8.0.0 45.96-41.8 71.18-138.5L281.1 764.26s15.82-53.78-2.48-79.98c-15.16-17.84-56.12-66.12-73.58-83.62L175.8 623.9c8.72-27.96 13.98-55.1 15.74-81.34h123.3s-.18-47.24-15.18-47.24v.02zm824.04-3.2c41.66-51.28 89.96-117.14 89.96-117.14s-37.3-29.6-54.76-8.12c-12 16.3-73.66 96.4-73.66 96.4l38.46 28.86zM823.52 373.96c-18.02-16.5-51.82 4.26-51.82 4.26s79.04 110.08 82.24 114.9l38.92-27.46s-51.34-75.22-69.32-91.72h-.02zM1280 516.7c-39.56.0-261.82 1.86-262.12 1.86v-202c9.62.0 24.84-.8 45.7-2.4 81.76-4.82 140.26-8 175.54-9.62.0.0 24.44-54.38-1.18-66.88-6.14-2.36-46.34 9.16-46.34 9.16s-330.44 32.98-464.72 36.1c3.2 17.64 15.24 34.16 31.56 39.1 26.62 6.96 45.38 3.4 98.3 1.78 49.66-3.2 87.36-4.86 113.02-4.86v199.62H702.82s5.64 44.62 51.02 45.7h215.88V706.1c0 27.94-22.38 43.98-48.96 42.24-28.16.22-52.16-2.3-83.38-3.62 3.98 7.94 12.66 28.78 38.62 43.68 19.76 9.62 32.34 13.14 52.04 13.14 59.12.0 91.34-34.56 89.78-90.62V564.28h244.72c19.36.0 17.4-47.56 17.4-47.56l.06-.02z" fill="#707070" p-id="21049"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页 | Home</span></a></li><li><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于 | About</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档 | Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索 | Search</span></a></li><li><a href=https://cuterwrite.top/image-hosting target=_blank><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-album"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 4m0 2a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2z"/><path d="M12 4v7l2-2 2 2V4"/></svg>
<span>图册 | Gallery</span></a></li><li><a href=https://draw.cuterwrite.top target=_blank><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-artboard"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M8 8m0 1a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H9a1 1 0 01-1-1z"/><path d="M3 8h1"/><path d="M3 16h1"/><path d="M8 3v1"/><path d="M16 3v1"/><path d="M20 8h1"/><path d="M20 16h1"/><path d="M8 20v1"/><path d="M16 20v1"/></svg>
<span>画板 | Canvas</span></a></li><li><a href=https://it-tools.tech target=_blank><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-tools"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 21h4L20 8a1.5 1.5.0 00-4-4L3 17v4"/><path d="M14.5 5.5l4 4"/><path d="M12 8 7 3 3 7l5 5"/><path d="M7 8 5.5 9.5"/><path d="M16 12l5 5-4 4-5-5"/><path d="M16 17l-1.5 1.5"/></svg>
<span>工具 | Tools</span></a></li><li class=menu-bottom-section><ol class=menu><li id=i18n-switch><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language title=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://cuterwrite.top/ selected>中文</option><option value=https://cuterwrite.top/en/>English</option></select></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ul><li><a href=#1-sme-简介>1. SME 简介</a></li><li><a href=#2-streaming-sve-模式>2. Streaming SVE 模式</a></li><li><a href=#3-切换-non-streaming-和-streaming-sve-模式>3. 切换 Non-streaming 和 Streaming SVE 模式</a></li><li><a href=#4-sme-架构状态>4. SME 架构状态</a></li><li><a href=#5-za-array>5. ZA array</a><ul><li><a href=#51-za-array-vector-访问>5.1 ZA array vector 访问</a></li><li><a href=#52-za-tiles>5.2 ZA tiles</a></li><li><a href=#53-za-tile-slices>5.3 ZA tile slices</a></li></ul></li><li><a href=#6-steaming-sve-模式下支持的指令>6. Steaming SVE 模式下支持的指令</a></li><li><a href=#7-sme-指令>7. SME 指令</a><ul><li><a href=#71-外积并累加或累减指令>7.1 外积并累加或累减指令</a><ul><li><a href=#711-fp32-fp64-外积并累加或累减指令>7.1.1 FP32, FP64 外积并累加或累减指令</a></li><li><a href=#712-fp16-bf16-int16-int8-i16i64-类型的外积并累加或累减指令>7.1.2 FP16, BF16, INT16, INT8, I16I64 类型的外积并累加或累减指令</a></li></ul></li><li><a href=#72-带-predication-的-sme-指令>7.2 带 Predication 的 SME 指令</a></li><li><a href=#73-za-tile-与一个-z-向量的加运算>7.3 ZA tile 与一个 Z 向量的加运算</a></li><li><a href=#74-tile-load-store-move-指令>7.4 Tile load, store, move 指令</a><ul><li><a href=#741-tile-slice-load-和-store-指令>7.4.1 Tile slice load 和 store 指令</a></li><li><a href=#742-tile-slice-move-指令>7.4.2 Tile slice move 指令</a></li></ul></li><li><a href=#75-za-array-vector-loadstore-指令>7.5 ZA array vector load/store 指令</a></li><li><a href=#76-za-tile-清零指令>7.6 ZA tile 清零指令</a></li><li><a href=#77-新的-sve2-指令>7.7 新的 SVE2 指令</a><ul><li><a href=#771-psel-指令>7.7.1 PSEL 指令</a></li></ul></li></ul></li><li><a href=#参考文献>参考文献</a></li></ul></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/arm-sme-for-performance/><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-14_117622407_p0_master1200.webp loading=lazy alt="Featured image of post Arm 矩阵加速：可伸缩矩阵扩展 SME"></a></div><div class=article-details><header class=article-category><a href=/categories/hpc/ style=background-color:#ffb900;color:#fff>高性能计算</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/arm-sme-for-performance/>Arm 矩阵加速：可伸缩矩阵扩展 SME</a></h2><h3 class=article-subtitle>本文介绍了 Arm 架构中的 Scalable Matrix Extension (SME)，重点解析了其 Streaming SVE 模式下高效的矩阵运算能力，以及利用 ZA array 进行大规模数据存储和灵活访问的机制，为高性能计算应用提供了强大的硬件加速支持。</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2024-08-13</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 16 分钟</time></div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-keyboard"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M2 6m0 2a2 2 0 012-2h16a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2z"/><path d="M6 10v.01"/><path d="M10 10v.01"/><path d="M14 10v.01"/><path d="M18 10v.01"/><path d="M6 14v.01"/><path d="M18 14v.01"/><path d="M10 14l4 .01"/></svg>
<time class=article-time--wordcount>字数统计: 7576 字</time></div></footer><footer class=article-translations><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg><div><a href=https://cuterwrite.top/en/p/arm-sme-for-performance/ class=link>English</a></div></footer></div></header><section class=article-content><h1 id=arm-矩阵加速可伸缩矩阵扩展-sme><a href=#arm-%e7%9f%a9%e9%98%b5%e5%8a%a0%e9%80%9f%e5%8f%af%e4%bc%b8%e7%bc%a9%e7%9f%a9%e9%98%b5%e6%89%a9%e5%b1%95-sme class=header-anchor>#</a>
Arm 矩阵加速：可伸缩矩阵扩展 SME</h1><h2 id=1-sme-简介><a href=#1-sme-%e7%ae%80%e4%bb%8b class=header-anchor>#</a>
1. SME 简介</h2><p>可伸缩矩阵扩展 SME (Scalable Matrix Extension) SME 是在可伸缩向量扩展（Scalable Vector Extensions， SVE 和 SVE2）的基础上建立的，并增加了有效处理矩阵的能力，主要功能包括：</p><ul><li>计算 SVE 向量的外积（Outer product）</li><li>矩阵块（tile） 存储</li><li>tile 向量的加载、存储、插入和提取（包括动态转置）</li><li>Streaming SVE 模式</li></ul><p>下表总结了 SME、SVE 和 SVE2 的主要功能：</p><div class=table-wrapper><table><thead><tr><th>SME</th><th>SVE</th><th>SVE2</th></tr></thead><tbody><tr><td>Streaming SVE 模式</td><td>NEON DSP++</td><td>可伸缩向量</td></tr><tr><td>动态矩阵转置</td><td>多精度算术</td><td>per-lane predication</td></tr><tr><td>向量外积</td><td>匹配检测和直方图</td><td>Gather-load 与 Scatter-store</td></tr><tr><td>加载、存储、插入和提取矩阵向量</td><td>非时间性 scatter/gather</td><td>预测向量化</td></tr><tr><td></td><td>按位置换（bitwise permute）</td><td>ML 扩展（FP16 + DOT）</td></tr><tr><td></td><td>AE、SHA3、SM4、Crypto</td><td>V8.6 BF16, FP 与 Int8 支持</td></tr></tbody></table></div><p>SME 定义了以下新功能：</p><ul><li>新的架构状态，可以用来存储二维矩阵 tile</li><li>Streaming SVE 模式，支持执行向量长度与 tile 长度匹配的 SVE2 指令。</li><li>将两个向量的外积累加（或累减）到一个矩阵 tile 中的新指令。</li><li>新的加载、存储和移动指令：可以将向量写入到矩阵 tile 的一行或一列，也可以将矩阵 tile 的一行或一列读取到向量。</li></ul><p>与 SVE2 类似，SME 也是一种支持可伸缩向量长度的扩展，可实现向量长度无关性 (VLA)、per-lane predication、predication 驱动的循环控制和管理功能。</p><h2 id=2-streaming-sve-模式><a href=#2-streaming-sve-%e6%a8%a1%e5%bc%8f class=header-anchor>#</a>
2. Streaming SVE 模式</h2><p>SME 引入了 Streaming SVE 模式，该模式实现了 SVE2 指令集的一个子集，并增加了新的 SME 专用指令。</p><p>Streaming SVE 模式支持对大型数据集进行高吞吐量地流式数据处理，流式数据通常具有简单的循环控制流和有限的条件性。</p><p>在 Non-streaming SVE 模式下，支持完整的 SVE2 指令集，通常处理复杂的数据结构和复杂的判断。</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-14_3443.webp alt="Streaming SVE 模式与 Non-streaming SVE 模式" width=80% loading=lazy><figcaption><h4>Streaming SVE 模式与 Non-streaming SVE 模式</h4></figcaption></figure><p>大多数 SME 指令仅在 Streaming SVE 模式下可用。Streaming SVE 模式下的流向量长度（SVL）可能与非流向量长度（NSVL）不同。</p><p>预期是：SVL 要比 NSVL 更长或是相同，也就是 SVL >= NSVL。例如，NSVL 的长度可以为 128-bit , 而 SVL 的长度可以为 512-bit 。</p><p>SME 的 SVL 可以是 128-bit , 256-bit , 512-bit, 1024-bit 或是 2048-bit 。SVL 需要是 2 的次幂，而 NSVL 需要是 128 的整数倍。</p><p>与 SVE2 类似，软件可以控制 <code>SMCR_ELx.LEN</code> 寄存器位来设置 EL1, EL2, EL3 想用的有效 SVL 长度（可以设置为比硬件支持的 SVL 更短）。</p><p>有关 Streaming SVE 模式的更多信息，请参阅《Arm 架构参考手册》第 B1.4.6 节（A-profile 架构）。</p><h2 id=3-切换-non-streaming-和-streaming-sve-模式><a href=#3-%e5%88%87%e6%8d%a2-non-streaming-%e5%92%8c-streaming-sve-%e6%a8%a1%e5%bc%8f class=header-anchor>#</a>
3. 切换 Non-streaming 和 Streaming SVE 模式</h2><p>如果 CPU 硬件实现既支持 Streaming SVE 模式的 SME ，又支持 Non-streaming SVE 模式的 SVE2 ，应用程序可以根据自己的需求动态切换这两个操作模式。</p><p>为 SME 提供一个独立的操作模式，使 CPU 硬件实现可以为同一应用提供不同的向量长度。比如 CPU 硬件实现可以选择支持一个更长的 Streaming SVE 模式向量长度，并针对适用于高吞吐量的流操作对硬件进行优化。</p><p>应用程序很容易在 Streaming SVE 模式和 Non-streaming SVE 模式之间动态切换。SME 引入的 <code>PSTATE.{SM, ZA}</code> 位可以可启用和禁用 Streaming SVE 模式和 SME ZA 存储：</p><ul><li>SM: 启用与禁用 Streaming SVE 模式</li><li>ZA：启用和禁用 ZA 存储访问</li></ul><p>可以通过 <code>MSR/MRS</code> 指令操作 Streaming Vector Control Register (SVCR) 来设置和读取 <code>PSTATE.{SM, ZA}</code> 位，具体操作如下：</p><ul><li><code>MSR SVCRSM, #&lt;imm> MSR SVCRSM，#</code></li><li><code>MSR SVCRZA, #&lt;imm></code></li><li><code>MSR SVCRSMZA, #&lt;imm></code></li></ul><p>SMSTART 指令是设置 <code>PSTATE.SM</code> 和 <code>PSTATE.ZA</code> 的 <code>MSR</code> 指令的别名</p><ul><li><code>SMSTART</code>：同时启用 Streaming SVE 模式和 ZA 存储访问</li><li><code>SMSTART SM</code>：启用 Streaming SVE 模式</li><li><code>SMSTART ZA</code>：启用 ZA 存储访问</li></ul><p>SMSTOP 指令则是清除 <code>PSTATE.SM</code> 和 <code>PSTATE.ZA</code> 的 <code>MSR</code> 指令的别名。</p><ul><li><code>SMSTOP</code>：同时禁用 Streaming SVE 模式和 ZA 存储访问</li><li><code>SMSTOP SM</code>：禁用 Streaming SVE 模式</li><li><code>SMSTOP ZA</code>：禁用 ZA 存储访问</li></ul><p>下图展示了应用程序是如何在 Streaming SVE 模式和 Non-streaming SVE 模式之间切换的：</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-15_Scalable_Matrix_p1.webp alt="应用程序切换 Streaming SVE 模式和 Non-streaming SVE 模式" width=50% loading=lazy><figcaption><h4>应用程序切换 Streaming SVE 模式和 Non-streaming SVE 模式</h4></figcaption></figure><p>有关使用 SMSTART 和 SMSTOP 在 Streaming SVE 模式和 Non-Streaming SVE 模式之间切换的更多信息，请参阅《Arm 架构参考手册》中有关 A-profile 架构的 C6.2.327 和 C6.2.328 节。</p><h2 id=4-sme-架构状态><a href=#4-sme-%e6%9e%b6%e6%9e%84%e7%8a%b6%e6%80%81 class=header-anchor>#</a>
4. SME 架构状态</h2><p>与 SVE2 类似，在 Streaming SVE 模式，它有 <code>Z0-Z31</code> 向量寄存器，和 <code>P0-P15</code> Predicate 寄存器。</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-15_4130_ARM2799_3_Scalable_Matrix_p1.webp alt="Streaming mode registers" width=70% loading=lazy></figure><p>SVE 向量寄存器的最低编号位 <code>Zn</code> 也保存着固定长度的 <code>Vn、Qn、Dn、Sn、Hn</code> 和 <code>Bn</code> 寄存器。</p><p>进入 Streaming SVE 模式（ <code>PSTATE.SM</code> 由 0 变为 1）或退出 Streaming SVE 模式（ <code>PSTATE.SM</code> 由 1 变为 0）时，所有这些寄存器都将置零。</p><p>大多数 Non-streaming SVE2 指令可用于 Streaming SVE 模式，但<strong>可能使用不同的向量长度</strong>（流模式使用 VSL 长度，非流模式使用 NVSL 长度）。可以使用 <code>RDSVL</code> 指令读取当前的有效向量长度 VL。</p><pre><code class=language-armasm>//Read multiple of Streaming SVE vector register size to Xd

RDSVL &lt;Xd&gt;, #&lt;imm&gt;
</code></pre><div class="notice notice-info"><div class=notice-title><svg t="1705940100069" class="icon notice-icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="6252" width="200" height="200"><path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4.0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4.0 8 3.6 8 8v272zm-32-344c-26.5.0-48-21.5-48-48s21.5-48 48-48 48 21.5 48 48-21.5 48-48 48z" p-id="6253" fill="#fff"/></svg></div><p>因为 SME 支持 Vector Length Agnostic (VLA) ，在 Streaming SVE 模式下，软件很少需要明确读 SVL 向量长度。在 Non-streaming SVE 模式下，通常使用 RDSVL 指令来确定 SVL 的值。</p></div><h2 id=5-za-array><a href=#5-za-array class=header-anchor>#</a>
5. ZA array</h2><p>SME 新引入的 ZA (Z Array, ZA Storage) 是一个二维（2D）正方形数组，大小是 SVL x SVL。之所以叫 Z Array，也是因为它行与列的长度与 Streaming SVE 模式下的 Zn 寄存器一致。</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-15_4314_ARM2799_4_Scalable_Matrix_p1.webp alt="ZA array" width=50% loading=lazy><figcaption><h4>ZA array</h4></figcaption></figure><p>例如：如果 Streaming SVE 模式下的向量长度为 256-bit，即 Zn 寄存器的长度为 256-bit，那么 ZA 的大小为 256-bit x 256-bit。</p><p>ZA array 可以通过以下方式访问：</p><ul><li>ZA array vector 访问</li><li>ZA tiles</li><li>ZA tile slices</li></ul><h3 id=51-za-array-vector-访问><a href=#51-za-array-vector-%e8%ae%bf%e9%97%ae class=header-anchor>#</a>
5.1 ZA array vector 访问</h3><p>ZA array 的一行可以当成一个 SVL 长度的向量来访问，这个向量可以放数据类型长度为 8-bit, 16-bit, 32-bit, 64-bit 或 128-bit 的元素，比如 32-bit 的 fp32 浮点数。</p><pre><code class=language-c>ZA.B[N], ZA.H[N], ZA.S[N], ZA.D[N], ZA.Q[N]
</code></pre><p>其中 <code>B，H，S，D，Q</code> 分别表示 8-bit , 16-bit , 32-bit , 64-bit , 128-bit。</p><p>ZA array vector 的数量与 SVL 中的字节数相同，例如，如果 SLV 是 256-bit ，那么 ZA array vector 的数量是 32 个，N 的范围是 0 到 31。</p><p>为了支持上下文切换，SME 引入了新的 <code>LDR</code> 和 <code>STR</code> 指令，用于从内存加载和存储一个 ZA array vector。</p><pre><code class=language-armasm>LDR ZA[&lt;Wv&gt;, &lt;imm&gt;], [&lt;Xn|SP&gt;{, #&lt;imm&gt;, MUL VL}]
STR ZA[&lt;Wv&gt;, &lt;imm&gt;], [&lt;Xn|SP&gt;{, #&lt;imm&gt;, MUL VL}]
</code></pre><h3 id=52-za-tiles><a href=#52-za-tiles class=header-anchor>#</a>
5.2 ZA tiles</h3><p>ZA tile 是在 ZA 中的正方形的二维子矩阵。ZA tile 的宽度始终是 SVL，与 ZA array 的宽度相同。</p><p>ZA 可以分成多少个可用的 ZA tile 是由元素的数据类型大小决定的：</p><div class=table-wrapper><table><thead><tr><th>元素数据类型大小</th><th>tile 数量</th><th>tile 名称</th></tr></thead><tbody><tr><td>8-bit</td><td>1</td><td>ZA0.B</td></tr><tr><td>16-bit</td><td>2</td><td>ZA0.H-ZA1.H</td></tr><tr><td>32-bit</td><td>4</td><td>ZA0.S-ZA3.S</td></tr><tr><td>64-bit</td><td>8</td><td>ZA0.D-ZA7.D</td></tr><tr><td>128-bit</td><td>16</td><td>ZA0.Q-ZA15.Q</td></tr></tbody></table></div><ul><li>当元素数据类型为 8-bit 时，ZA 只能作为一个 ZA tile (ZA0.B) 被访问。</li><li>当元素数据类型为 16-bit 时，ZA 可以作为 2 个 ZA tile (ZA0.H 和 ZA1.H) 被访问。</li><li>当元素数据类型为 32-bit 时，ZA 可以作为 4 个 ZA tile (ZA0.S 到 ZA3.S) 被访问。</li><li>当元素数据类型为 64-bit 时，ZA 可以作为 8 个 ZA tile (ZA0.D 到 ZA7.D) 被访问。</li><li>当元素数据类型为 128-bit 时，ZA 可以作为 16 个 ZA tile (ZA0.Q 到 ZA15.Q) 被访问。</li></ul><p>例如，如果 SVL 为 256-bit，元素数据类型大小为 8-bit，则 ZA 可以视为 ZA0.B，也可视为 32 个向量（32 行，每行大小为 32 x 8-bit，即每行 32 个元素）。</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-15_ZA0B.webp alt=ZA0.B width=50% loading=lazy></figure><p>如果 SVL 为 256-bit，元素数据类型大小为 16-bit，则 ZA 可以视为 2 个 ZA tile (ZA0.H 和 ZA1.H)，每个 tile 视为 16 个向量（16 行，每行大小为 16 x 16-bit，即每行 16 个元素）。</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-15_ZA0H_ZA1H.webp alt="ZA0.H 和 ZA1.H" width=40% loading=lazy></figure><p>这样做的好处是充分利用了 ZA storage，在实际应用中，比如说当 SVL 为 256-bit，元素数据类型大小为 32-bit，ZA 的大小为 256-bit x 256-bit 时，<strong>要对两个 Z 寄存器里的向量做外积运算</strong>，计算得到的外积结果是 8 x 8 的二维浮点数数组，这个外积只需要 ZA 的 1/4 的存储空间。将 ZA 分成 4 个 ZA tile，这样就可以充分利用 ZA storage。</p><h3 id=53-za-tile-slices><a href=#53-za-tile-slices class=header-anchor>#</a>
5.3 ZA tile slices</h3><p>一个 ZA tile 可以作为一个整体来访问，也可以以一个个 ZA tile slice 的方式访问。</p><p>当作为一个整体访问时，指令可以使用 tile 的名字访问：</p><pre><code class=language-text>ZA0.B, ZA0.H-ZA1.H, ZA0.S-ZA3.S, ZA0.D-ZA7.D or ZA0.Q-ZA15.Q
</code></pre><p>一个 ZA tile slice 是由其 ZA tile 中<strong>水平方向或是垂直方向的连续元素组成的一维数组</strong>，即在 ZA tile 中的一行或是一列。</p><p>对一个 ZA tile 的向量访问即是读写一个 ZA tile slice ：</p><ul><li>水平或垂直方向的 ZA tile slice 访问，由 ZA tile 名字后的 <code>H</code> 或 <code>V</code> 后缀来表示。</li><li>具体的 ZA tile slice 由一个索引来表示，由 ZA tile 名字后的切片索引 <code>[N]</code> 来表示。</li></ul><p>例如，如果 SVL 为 128 位，元素数据类型大小为 8-bit，那么其水平的和垂直的 ZA tile slice 可由下图所示：</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-15_6724_ARM2799_7_Scalable_Matrix_p1.webp alt="ZA tile slices" width=50% loading=lazy></figure><p>再例如，如果 SVL 为 128 位，元素数据类型大小为 16-bit，那么其水平的和垂直的 ZA tile slice 可由下图所示：</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-15_6888_ARM2799_8_Scalable_Matrix_p1.webp alt="ZA tile slices" width=50% loading=lazy></figure><p>为了提高硬件访问 ZA tile 和 ZA tile slices 的效率，ZA tile 的 ZA tile slices 是交错排列的。</p><p>下图显示了这种交错排列的示例。在此示例中，SVL 为 256 位，元素数据类型大小为 16 位。这意味着，ZA 可被视为两个 ZA tile（ZA0H 和 ZA1H），并具有交错的水平 tile slices ：</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-15_4885_SME_interleave.webp alt="ZA tile slices" width=auto loading=lazy></figure><p>下图展示了不同的元素数据类型大小的水平和垂直方向 ZA tile slice 的混合视图:</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-15_7673_SME_V_H.webp alt="ZA tile slices" width=auto loading=lazy></figure><p>左侧各栏显示了 ZA 存储器每一行的不同处理方式。</p><p>设 SIZE 为向量元素的大小，其中 SIZE 为 1、2、4、8、16，分别代表数据类型 B、H、S、D 或 Q。</p><p>设 NUM_OF_ELEMENTS 为向量中的元素个数，即 bytes_of(SVL)/SIZE。</p><p>水平 tile slice， <code>ZAnH.&lt;B|H|S|D|Q>[m]</code> 访问一个向量，该向量包含 ZA storage 中的整行（m x SIZE + n）。该向量包含数据类型为 B、H、S、D 或 Q 的元素。</p><p>垂直 tile slice，<code>ZAnV.&lt;B|H|S|D|Q>[m] </code>访问一个向量，该向量包含 ZA storage 中的整列（m x SIZE）。该向量包含数据类型为 B、H、S、D 或 Q 的元素。</p><p><code>ZAnV.[m] </code>访问一个包含列（m x SIZE）和行元素（i x SIZE + n）的向量，其中 i 为 0 ~ NUM_OF_ELEMENTS-1。该向量包含数据类型为 B、H、S、D 或 Q 的元素。</p><p>使用混合元素数据类型大小以及水平和垂直 tile slice 的应用应小心处理重叠。</p><p>有关 ZA Array、ZA array vectors、tile 和 tile slices 的更多信息，请参阅《Arm 架构参考手册》中有关 A-profile 架构的 B1.4.8 至 B1.4.12 节。</p><h2 id=6-steaming-sve-模式下支持的指令><a href=#6-steaming-sve-%e6%a8%a1%e5%bc%8f%e4%b8%8b%e6%94%af%e6%8c%81%e7%9a%84%e6%8c%87%e4%bb%a4 class=header-anchor>#</a>
6. Steaming SVE 模式下支持的指令</h2><p>某些指令在 Streaming SVE 模式下有限制：</p><ul><li>一些 SVE/SVE2 指令变为非法执行<ul><li>Gathed-load 和 Scatter-store 指令</li><li>使用 First Fault 寄存器的 SVE2 指令</li></ul></li><li>大多的 NEON 指令变为 UNDEFINED</li></ul><p>有关受 Streaming SVE 模式影响的指令的更多信息，请参阅文档 《Arm 架构参考手册》。</p><p>SME 增加了几条新指令，其中包括：</p><ul><li>矩阵外积和累加或减法指令，包括 FMOPA、UMOPA 和 BFMOPA。<ul><li>SVE2 向量寄存器（Z0-Z31）作为外积运算的行和列输入。</li><li>ZA storage 保存二维矩阵 tile 的输出结果。</li></ul></li><li>将 SVE2 Z 向量与 ZA 的行或列做加法运算的指令</li><li>对 ZA tiles 的清零操作指令</li><li>增加了一些在 Streaming 和 Non-streaming 模式下都能使用的指令</li></ul><h2 id=7-sme-指令><a href=#7-sme-%e6%8c%87%e4%bb%a4 class=header-anchor>#</a>
7. SME 指令</h2><p>操作 ZA storage 的 SME 指令主要包括：</p><ul><li>计算两个向量的外积，并累加或累减，然后将结果放入一个 ZA tile 的指令</li><li>将 SVE 向量（Z 寄存器）存入或取出 ZA tile 的行或列的指令</li><li>水平或垂直方向上，一个 SVE 向量与 ZA tile 的加法指令</li><li>给一个标量寄存器加上 Streaming SVE 模式下向量长度的倍数的指令</li></ul><h3 id=71-外积并累加或累减指令><a href=#71-%e5%a4%96%e7%a7%af%e5%b9%b6%e7%b4%af%e5%8a%a0%e6%88%96%e7%b4%af%e5%87%8f%e6%8c%87%e4%bb%a4 class=header-anchor>#</a>
7.1 外积并累加或累减指令</h3><p>为了帮助理解外积并累加或累减指令，让我们看看如何使用外积操作来做矩阵乘法。</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-16_2313_Picture1_png-1280x960.webp alt="Outer product" width=auto loading=lazy></figure><p>计算两个向量 a 和 b 的外积会得到一个包含外积的结果矩阵 C：</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-16_1665_Picture2_png-1280x960.webp alt="Outer product" width=auto loading=lazy></figure><p>现在考虑两个矩阵 a 和 b 的矩阵乘运算：</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-16_8117_Picture3_png-1280x960.webp alt="Matrix multiplication" width=auto loading=lazy></figure><p>这个矩阵乘可以通过计算两次外积操作和两个结果矩阵的累加来实现（就是常用的手写计算的方法），如下图所示：</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-16_3731_Picture4_png-1280x960.webp alt="Matrix multiplication with outer product" width=auto loading=lazy></figure><p>SME 为以下数据类型引入了高效的外积并累加或减法指令：</p><ul><li>8-bit, 16-bit 整数</li><li>FP16, BF16, FP32 和 FP64 浮点数</li></ul><p>这些指令计算两个 Z 向量寄存器（Zn 和 Zm）中两个向量的外积，将结果数组与一个 ZA tile（ZAda）中已有数据进行累加或累减，并将结果存入同一 ZA tile（ZAda）中。每个源向量由相应的控制 predicate 寄存器（Pn 和 Pm）独立地 predicate。</p><div class=table-wrapper><table><thead><tr><th>输出数组</th><th>输入向量</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>INT32</td><td>INT8, INT8</td><td>将四个 INT8 外积之和存入每个 INT32 元素</td><td>SMOPA 或 SMOPS 或 UMOPA 或 UMOPS：带符号或无符号整数外积和，并累加或累减。例如： <code>UMOPS &lt;ZAda>.S, &lt;Pn>/M, &lt;Pm>/M, &lt;Zn>.B, &lt;Zm>.B</code></td></tr><tr><td>INT32</td><td>INT16, INT16</td><td>将两个 INT16 外积之和存入每个 INT32 元素</td><td>SMOPA 或 SMOPS 或 UMOPA 或 UMOPS：带符号或无符号整数外积和，并累加或累减。例如： <code>UMOPS &lt;ZAda>.S, &lt;Pn>/M, &lt;Pm>/M, &lt;Zn>.H, &lt;Zm>.H</code></td></tr><tr><td>INT64</td><td>INT16, INT16</td><td>如果实现了 FEAT_SME_I16I64，则将四个 INT16 外积之和存入每个 INT64 元素</td><td>SMOPA 或 SMOPS 或 UMOPA 或 UMOPS：带符号或无符号整数外积和，并累加或累减。例如： <code>UMOPS &lt;ZAda>.D, &lt;Pn>/M, &lt;Pm>/M, &lt;Zn>.H, &lt;Zm>.H</code></td></tr><tr><td>FP32</td><td>BF16, BF16</td><td>将两个 BF16 外积之和存入每个 FP32 元素</td><td>BFMOPA 或 BFMOPS：BFloat16 外积和，并累加或累减。例如： <code>BFMOPS &lt;ZAda>.S, &lt;Pn>/M, &lt;Pm>/M, &lt;Zn>.H, &lt;Zm>.H</code></td></tr><tr><td>FP32</td><td>FP16, FP16</td><td>将两个 FP16 外积之和存入每个 FP32 元素</td><td>FMOPA 或 FMOPS：半精度浮点外积和，并累加或累减。例如： <code>FMOPS &lt;ZAda>.S, &lt;Pn>/M, &lt;Pm>/M, &lt;Zn>.H, &lt;Zm>.H</code></td></tr><tr><td>FP32</td><td>FP32, FP32</td><td>简单的 FP32 外积</td><td>FMOPA 或 FMOPS：浮点外积和，并累加或累减。例如： <code>FMOPS &lt;ZAda>.S, &lt;Pn>/M, &lt;Pm>/M, &lt;Zn>.S, &lt;Zm>.S</code></td></tr><tr><td>FP64</td><td>FP64, FP64</td><td>如果实现了 FEAT_SME_F64F64，则进行简单的 FP64 外积</td><td>FMOPA 或 FMOPS：浮点外积和，并累加或累减。例如： <code>FMOPS &lt;ZAda>.D, &lt;Pn>/M, &lt;Pm>/M, &lt;Zn>.D, &lt;Zm>.D</code></td></tr></tbody></table></div><h4 id=711-fp32-fp64-外积并累加或累减指令><a href=#711-fp32-fp64-%e5%a4%96%e7%a7%af%e5%b9%b6%e7%b4%af%e5%8a%a0%e6%88%96%e7%b4%af%e5%87%8f%e6%8c%87%e4%bb%a4 class=header-anchor>#</a>
7.1.1 FP32, FP64 外积并累加或累减指令</h4><p>那些输入向量和输出数组有同样数据类型（FP32， FP64）的指令相对简单。</p><p>下例展示了 FP32 类型的外积并累加或累减指令。</p><pre><code class=language-armasm>FMOPA &lt;ZAda&gt;.S, &lt;Pn&gt;/M, &lt;Pm&gt;/M, &lt;Zn&gt;.S, &lt;Zm&gt;.S
FMOPS &lt;ZAda&gt;.S, &lt;Pn&gt;/M, &lt;Pm&gt;/M, &lt;Zn&gt;.S, &lt;Zm&gt;.S
</code></pre><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-16_3613751670-667e5f923c64.webp alt="FMOPA and FMOPS" width=auto loading=lazy></figure><p>这个例子中，假设 SVL 向量长度为 128，<code>Zn.S</code> 和 <code>Zm.S</code> 中存放了 4 个 FP32 数组成的向量，此指令计算 <code>Zn.S</code> 和 <code>Zm.S</code> 的外积，外积结果为图中灰色的矩阵，然后将此外积结果累加或累减 <code>ZAda.S</code> 这个 ZA tile 中原有的值，将结果存入同一 ZA tile。</p><h4 id=712-fp16-bf16-int16-int8-i16i64-类型的外积并累加或累减指令><a href=#712-fp16-bf16-int16-int8-i16i64-%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%a4%96%e7%a7%af%e5%b9%b6%e7%b4%af%e5%8a%a0%e6%88%96%e7%b4%af%e5%87%8f%e6%8c%87%e4%bb%a4 class=header-anchor>#</a>
7.1.2 FP16, BF16, INT16, INT8, I16I64 类型的外积并累加或累减指令</h4><p>由于这些指令会扩大计算结果数据类型，因此这些操作不像前面 FP32，FP64 类型指令那么简单明了。</p><ul><li>BF16 指令计算两个 BF16 的外积的和，扩大结果类型为 FP32, 然后将结果与目标 tile 进行破坏性相加或相减。</li><li>INT8 指令计算四个 INT8 的外积的和，扩大结果类型为 INT32，然后将结果与目标 tile 进行破坏性相加或相减。</li><li>INT16 指令计算两个 INT16 的外积的和，扩大结果类型为 INT32，然后将结果与目标 tile 进行破坏性相加或相减。</li><li>FP16 指令计算两个 FP16 的外积的和，扩大结果类型为 FP32，然后将结果与目标 tile 进行破坏性相加或相减。</li><li>如果实现了 FEAT_SME_I16I64，I16I64 指令计算四个 INT16 的外积的和，扩大结果类型为 INT64, 然后将结果与目标 tile 进行破坏性相加或相减。</li></ul><p>以下例子展示了 SVL 向量长度为 128 的 INT8 UMOPA 指令进行的操作：</p><pre><code class=language-armasm>UMOPA &lt;ZAda&gt;.S, &lt;Pn&gt;/M, &lt;Pm&gt;/M, &lt;Zn&gt;.B, &lt;Zm&gt;.B
</code></pre><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-16_1030_Picture6_png-1280x960.webp alt="INT8 UMOPA" width=auto loading=lazy></figure><p>每个输入寄存器（<code>Zn.B</code>、<code>Zm.B</code>）都被视为一个包含 4x4 元素的矩阵，可以看作是 4 个连续元素组成的块（如图中红线所标）被转置了。</p><p>在这个例子中，因为 SVL 向量长度为 128-bit：</p><ul><li>第一源向量 <code>Zn.B</code> ，包含一个无符号 8-bit 整数的 4x4 子矩阵。</li><li>第二源向量 <code>Zm.B</code> ，包含一个无符号 8-bit 整数的 4x4 子矩阵。</li><li>UMOPA 指令计算出 4x4 扩大了的 32-bit 整数外积的和，然后破坏性地累加上目标 tile（ZAda）中的整数。</li></ul><p>更笼统地说，UMOPA 指令是将第一个源向量中的子矩阵与第二个源向量中的子矩阵相乘。每个源向量包含一个(SVL/32) x 4 的无符号 8-bit 整数的子矩阵。然后将得到的 (SVL/32) x (SVL/32)扩大了的 32-bit 整数外积和破坏性地加上一个 32-bit 整数目标 tile。</p><p>下面的例子展示了 SVL 为 128-bit 的 BF16 BFMOPA 进行的操作：</p><pre><code class=language-armasm>BFMOPA &lt;ZAda&gt;.S, &lt;Pn&gt;/M, &lt;Pm&gt;/M, &lt;Zn&gt;.H, &lt;Zm&gt;.H
</code></pre><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-16_6545_Picture7_png-1280x960.webp alt="BF16 BFMOPA" width=auto loading=lazy></figure><p>在这个例子中，因为 SVL 向量长度为 128-bit：</p><ul><li>第一源向量 <code>Zn.H</code> ，包含一个 BF16 整数的 4x2 子矩阵，它被扩大成单精度浮点数。</li><li>第二源向量 <code>Zm.H</code> ，包含一个 BF16 整数的 2x4 子矩阵，它被扩大成单精度浮点数。</li><li>BMOPA 指令计算出 4x4 单精度外积的和，然后破坏性地累加上目标 tile（ZAda）中的单精度浮点数。</li></ul><p>更笼统地说，BFMOPA 指令扩大了存放在第一源向量里的(SVL/32) x2 BF16 子矩阵的类型为单精度，扩大了存放在第二源向量里的 2x (SVL/32) BF16 子矩阵的类型为单精度，将这两个子矩阵相乘。然后将得到的 (SVL/32) x (SVL/32)单精度外积和破坏性地加上一个单精度目标 tile。</p><p>以下表格显示了几种数据类型和 SVL 长度的一条外积并累加或累减指令所做的对应数据类型的 MAC(乘累加)数量：</p><div class=table-wrapper><table><thead><tr><th></th><th>128-bit</th><th>256-bit</th><th>512-bit</th></tr></thead><tbody><tr><td>FP32</td><td>16</td><td>64</td><td>256</td></tr><tr><td>FP64</td><td>4</td><td>16</td><td>64</td></tr><tr><td>INT8</td><td>64</td><td>256</td><td>1024</td></tr><tr><td>INT16</td><td>32</td><td>128</td><td>512</td></tr><tr><td>BF16</td><td>32</td><td>128</td><td>512</td></tr><tr><td>FP16</td><td>32</td><td>128</td><td>512</td></tr></tbody></table></div><h3 id=72-带-predication-的-sme-指令><a href=#72-%e5%b8%a6-predication-%e7%9a%84-sme-%e6%8c%87%e4%bb%a4 class=header-anchor>#</a>
7.2 带 Predication 的 SME 指令</h3><p>每个源向量都可以被其相应的控制 predicate 寄存器独立地 predicate:</p><ul><li>外积并累加或累减指令使用 Pn/M 和 Pn/M (没有/Z 形式)：Inactive 的源元素被当成具有 0 值。</li><li>Slice move 指令使用 Pg/M: 目标 slice 中 Inactive 的元素保持不变。</li><li>Tile slice load 指令使用 Pg/Z: 目标 tile slice 中的 Inactive 元素被设置为 0。</li><li>Tile slice store 指令使用 Pg: Inactive 的元素不会写入内存。</li></ul><p>Predication 让矩阵的维数不是 SVL 的倍数的情况更容易处理。</p><p>例如下图的指令：</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-16_2656_Picture12_png-600x0.webp alt="SME predication" width=auto loading=lazy></figure><p>输入向量 <code>Z0</code> 被 <code>P0</code> predicate，<code>Z1</code> 被 <code>P1</code> predicate。</p><p>在这个例子中：</p><ul><li>SVL 向量长度为 512-bit。</li><li>Z 寄存器中包含 16 个 FP32 数组成的向量。</li><li><code>P0</code> 中最后两个元素是 inactive 的。</li><li><code>P1</code> 中最后一个元素是 inactive 的。</li></ul><p>这条指令更新 <code>ZA0.S</code> 中 (16-2) x (16-1) 个 FP32 元素，因为使用了 <code>Pn/M</code> , <code>ZA0.S</code> 中剩下的元素保持不变。</p><p>下图展示了更多的 predicated 外积并累加或累减的例子。图中被划线的文字表示被 inactive predicate 元素影响的计算部分。</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-16_2072_Picture14_png-1280x960.webp alt="SME predication FMOPA" width=auto loading=lazy></figure><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-16_3513_Picture16_png-1280x960.webp alt="SME predication UMOPA" width=auto loading=lazy></figure><h3 id=73-za-tile-与一个-z-向量的加运算><a href=#73-za-tile-%e4%b8%8e%e4%b8%80%e4%b8%aa-z-%e5%90%91%e9%87%8f%e7%9a%84%e5%8a%a0%e8%bf%90%e7%ae%97 class=header-anchor>#</a>
7.3 ZA tile 与一个 Z 向量的加运算</h3><p>SME 包括 ZA tile 的行或列都加上一个向量的指令，这些指令也有 predication 的支持。</p><div class=table-wrapper><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>ADDHA</td><td>将源向量添加到 ZA tile 的每个水平 slice 上</td></tr><tr><td>ADDVA</td><td>将源向量添加到 ZA tile 的每个垂直 slice 上</td></tr></tbody></table></div><p>例如：</p><pre><code class=language-armasm>ADDHA ZA0.S, P0/M, P1/M, Z1.S
</code></pre><p>将执行以下操作：</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-16_ARM2799_9_Scalable_Matrix_p2_png-1200x0.webp alt="SME ADDHA" width=auto loading=lazy></figure><p>这个 ADDHA 指令将源向量 Z1 中的每个元素加上 ZA0.S tile 每一水平 slice 的相应 active 元素。</p><p>Tile 中元素被一对 governing predicate 进行 predicate。 一个水平 slice 中的一个元素在下面情况下可以认为是 active：</p><ul><li>它在第二 governing predicate 对应的元素是 TRUE, 并且</li><li>它在第一 governing predicate 对应的水平 slice 行号也为 TRUE,目标 tile 中 inactive 元素保持不变。</li></ul><h3 id=74-tile-load-store-move-指令><a href=#74-tile-load-store-move-%e6%8c%87%e4%bb%a4 class=header-anchor>#</a>
7.4 Tile load, store, move 指令</h3><p>SME tile load, store, move 指令可以：</p><ul><li>从内存读取数据，放入 ZA tile 的行或列</li><li>将 ZA tile 的行或列写入内存</li><li>将 ZA tile 的行移动到 SVE Z 向量寄存器</li><li>将 SVE Z 向量寄存器移动到 ZA tile 行或列</li></ul><h4 id=741-tile-slice-load-和-store-指令><a href=#741-tile-slice-load-%e5%92%8c-store-%e6%8c%87%e4%bb%a4 class=header-anchor>#</a>
7.4.1 Tile slice load 和 store 指令</h4><p>LD1B、LD1H、LD1S、LD1D 和 LD1Q 指令分别将连续内存值加载到具有 8-bit、16-bit、32-bit、64-bit 或 128-bit 元素的 ZA tile slice 中。</p><p>ST1B、ST1H、ST1S、ST1D 和 ST1Q 指令分别将包含 8-bit、16-bit、32-bit、64-bit 或 128-bit 元素的 ZA tile slice 存储到连续内存中。</p><p>这些指令也支持 predication ，例如：</p><pre><code class=language-armasm>LD1B ZA0H.B[W0, #imm], P0/Z, [X1, X2]
</code></pre><p>此 LD1B 指令执行 predicated 的连续 byte 读取，它从地址为(X1+X2)的内存读取数据到 ZA0 中行号为（W0+imm）的这个水平 tile slice 中。目标 tile slice 中 Inactive 的元素被设置为 0。</p><pre><code class=language-armasm>ST1H ZA1V.H[W0, #imm], P2, [X1, X2, LSL #1]
</code></pre><p>此 ST1H 指令执行 predicated 连续 halfword 的存操作，它将 ZA1 中列号为（W0+imm）的垂直 tile slice 存到地址为（X1+X2*2）的内存， tile slice 中 Inactive 的元素不写入内存。</p><h4 id=742-tile-slice-move-指令><a href=#742-tile-slice-move-%e6%8c%87%e4%bb%a4 class=header-anchor>#</a>
7.4.2 Tile slice move 指令</h4><p>MOV 指令（MOVA 指令的别名）将一个 Z 向量寄存器的值移动到一个 ZA tile slice，或将一个 ZA tile slice 中的值移动到一个 Z 向量寄存器。这条指令操作带指定元素大小的 ZA tile 的单个水平或垂直 tile slice。 Slice 的行号/列号由 slice 的检索寄存器加上立即数偏移指定。目标 slice 中 Inactive 的元素保持不变。</p><p>例如：</p><pre><code class=language-armasm>MOV     ZA0H.B[W0, #imm],  P0/M, Z0.B
</code></pre><p>或</p><pre><code class=language-armasm>MOVA  ZA0H.B[W0, #imm],  P0/M, Z0.B
</code></pre><p>此指令将向量寄存器 <code>Z0.B</code> 中的值移动到 <code>ZA0H.B[W0,#imm]</code> 这个水平 ZA tile slice 中，使用 <code>P0</code> 作为 predication 寄存器。目标 tile slice 中 Inactive 的元素保持不变。</p><h3 id=75-za-array-vector-loadstore-指令><a href=#75-za-array-vector-loadstore-%e6%8c%87%e4%bb%a4 class=header-anchor>#</a>
7.5 ZA array vector load/store 指令</h3><p>SME LDR 指令从内存读取数据到一个 ZA array 向量，SME STR 指令将一个 ZA array 向量中的值存入内存。
这些指令是不带 predication 功能的。它们主要是为了软件的 context switching 时对 ZA storage 进行 save/restore。SME LDR/STR 指令也可以在 Non-streaming SVE 模式下，当 PSTATE.ZA 使能的情况下使用。
例如，下面的 STR 指令的 ZA array 向量是由一个向量选择寄存器 Wv（标量寄存器 W）加上可选的立即数（Wv+Imm）指定。访问内存的地址为：一个标量寄存器作为 base，加上相同的可选立即数偏移乘以当前向量长度 byte 数。</p><pre><code class=language-armasm>STR ZA[&lt;Wv&gt;, &lt;imm&gt;], [&lt;Xn|SP&gt;{, #&lt;imm&gt;, MUL VL}]
</code></pre><h3 id=76-za-tile-清零指令><a href=#76-za-tile-%e6%b8%85%e9%9b%b6%e6%8c%87%e4%bb%a4 class=header-anchor>#</a>
7.6 ZA tile 清零指令</h3><p>SME ZERO 指令可以清零一组 64-bit ZA tile:</p><pre><code class=language-armasm>ZERO { &lt;mask&gt;}
</code></pre><p>ZERO 指令可以清零多到 8 个名为 <code>ZA0.D</code> 到 <code>ZA8.D</code> 的 ZA tile，那些 tile 要清零由指令中的 mask 指定，剩下的其他 tile 保持不变。</p><p>这条指令也可以在 Non-streaming SVE 模式，当 <code>PSTATE.ZA</code> 开启的情况下使用。</p><p>如果要清零整个 ZA array, 可以使用一个指令别名，<code>ZERO {ZA}</code> 。</p><h3 id=77-新的-sve2-指令><a href=#77-%e6%96%b0%e7%9a%84-sve2-%e6%8c%87%e4%bb%a4 class=header-anchor>#</a>
7.7 新的 SVE2 指令</h3><p>SME 构架扩展加入了一些新的 SVE2 指令，这些指令也可以在 PE 实现了 SVE2, 处于 Non-streaming SVE 模式时使用。这些指令包括：</p><ul><li>选择一个 predicate 寄存器或是 all-false 的 Predicate select 指令</li><li>翻转（Reverse）64-bit double word 元素的指令</li><li>有符号/无符号钳位为更小/更大值向量的指令</li></ul><p>下面介绍以下 Predicate select 指令。</p><h4 id=771-psel-指令><a href=#771-psel-%e6%8c%87%e4%bb%a4 class=header-anchor>#</a>
7.7.1 PSEL 指令</h4><p>PSEL 指令选择一个 predicate 寄存器或是 all-false 到目标 predicate 寄存器，如下所示：</p><pre><code class=language-armasm>PSEL &lt;Pd&gt;, &lt;Pn&gt;, &lt;Pm&gt;.&lt;T&gt;[&lt;Wv&gt;, &lt;imm&gt;]
</code></pre><p>如果指令中第二源 predicate 寄存器（Pm）中指定的元素为 True, 这条指令将第一源 predicate 寄存器(Pn)的内容放到目标 predicate 寄存器(Pd), 否者设置目标 predicate 寄存器的值全部为 false。
例如以下指令，假设 W12 的值为 0：</p><pre><code class=language-armasm>PSEL P0, P1, P2.B[W12, #0]
</code></pre><p>第二源 predicate 寄存器的[W12+0]即[0]个元素为 False, 因此目标寄存器 P0 被设置为全 0（all-false），如下图所示：</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-16_4401_Picture10_png-1280x960.webp alt="SME PSEL" width=auto loading=lazy></figure><p>现在看看如下指令，仍然假设 W12 的值为 0，但这次立即数偏移为 1：</p><pre><code class=language-armasm>PSEL P0, P1, P2.B[W12, #1]
</code></pre><p>第二源 predicate 寄存器的[W12+1]即[1]个元素为 True, 因此选择第一源 predicate 寄存器的值到目标寄存器 P0，如下图所示：</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-16_0116_Picture11_png-1280x960.webp alt="SME PSEL" width=auto loading=lazy></figure><h2 id=参考文献><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae class=header-anchor>#</a>
参考文献</h2><ul><li><a class=link href=https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/arm-scalable-matrix-extension-introduction target=_blank rel=noopener>Arm Scalable Matrix Extension (SME) Introduction
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></li><li><a class=link href=https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/arm-scalable-matrix-extension-introduction-p2 target=_blank rel=noopener>Arm Scalable Matrix Extension (SME) Instructions
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/simd/>SIMD</a>
<a href=/tags/vectorized-programming/>向量化编程</a>
<a href=/tags/parallel-computing/>并行计算</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><script type=text/javascript src=/js/prism.js async></script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/arm-sve-for-performance/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-29_117622464_p0_master1200.webp loading=lazy data-key=arm-sve-for-performance data-hash=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-29_117622464_p0_master1200.webp></div><div class=article-details><h2 class=article-title>Arm 性能优化：可伸缩向量扩展 SVE</h2></div></a></article><article class=has-image><a href=/p/simd/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/blog/173b9c0b3728e5e9e05d12a4f6dda9a2a7560722.jpg@1256w_1776h_!web-article-pic.webp loading=lazy data-key=simd data-hash=https://cuterwrite-1302252842.file.myqcloud.com/blog/173b9c0b3728e5e9e05d12a4f6dda9a2a7560722.jpg@1256w_1776h_!web-article-pic.webp></div><div class=article-details><h2 class=article-title>SSE 与 AVE 向量化编程</h2></div></a></article><article class=has-image><a href=/p/openmp-intro/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/c17b7451a44c1d4370d5ba2b966298ea195413_crop-2024-02-19.webp loading=lazy data-key=openmp-intro data-hash=https://cuterwrite-1302252842.file.myqcloud.com/img/c17b7451a44c1d4370d5ba2b966298ea195413_crop-2024-02-19.webp></div><div class=article-details><h2 class=article-title>OpenMP 简介</h2></div></a></article><article class=has-image><a href=/p/openmpi-with-ucx/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/cropped_2024010204-2024-02-03.webp loading=lazy data-key=openmpi-with-ucx data-hash=https://cuterwrite-1302252842.file.myqcloud.com/img/cropped_2024010204-2024-02-03.webp></div><div class=article-details><h2 class=article-title>编译安装 UCX 1.15.0 与 OpenMPI 5.0.0：详尽指南</h2></div></a></article><article class=has-image><a href=/p/false-sharing/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/blog/6c3f8961290e41f894f5a1cbb768aba9-2023-12-02.webp loading=lazy data-key=false-sharing data-hash=https://cuterwrite-1302252842.file.myqcloud.com/blog/6c3f8961290e41f894f5a1cbb768aba9-2023-12-02.webp></div><div class=article-details><h2 class=article-title>性能刺客之伪共享</h2></div></a></article></div></div></aside><script src=https://unpkg.com/twikoo@1.6.39/dist/twikoo.all.min.js></script><div id=tcomment></div><style>.twikoo{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}:root[data-scheme=dark]{--twikoo-body-text-color-main:rgba(255, 255, 255, 0.9);--twikoo-body-text-color:rgba(255, 255, 255, 0.7)}.twikoo .el-input-group__prepend,.twikoo .tk-action-icon,.twikoo .tk-time,.twikoo .tk-comments-count{color:var(--twikoo-body-text-color)}.twikoo .el-input__inner,.twikoo .el-textarea__inner,.twikoo .tk-preview-container,.twikoo .tk-content,.twikoo .tk-nick,.twikoo .tk-send{color:var(--twikoo-body-text-color-main)}.twikoo .el-button{color:var(--twikoo-body-text-color)!important}.OwO .OwO-body{background-color:var(--body-background)!important;color:var(--body-text-color)!important}</style><script>twikoo.init({envId:"https://comment.cuterwrite.top",el:"#tcomment",lang:"zh-CN"})</script><footer class=site-footer><section class=copyright>&copy;
2021 -
2024 cuterwrite</section><section class=running-time>本博客已稳定运行
<span id=runningdays class=running-days></span></section><section class=totalcount>发表了73篇文章 ·
总计323.00k字</section><section class=powerby>Welcome to cuterwrite's blog!<br>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.27.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计<br><span>基于 <a href=https://github.com/CaiJimmy/hugo-theme-stack/tree/v3.27.0 target=_blank rel=noopener><b style=color:#9e8f9f>v3.27.0</b></a> 分支版本修改</span><br></section></footer><script>let s1="2021-4-17";s1=new Date(s1.replace(/-/g,"/"));let s2=new Date,timeDifference=s2.getTime()-s1.getTime(),days=Math.floor(timeDifference/(1e3*60*60*24)),hours=Math.floor(timeDifference%(1e3*60*60*24)/(1e3*60*60)),minutes=Math.floor(timeDifference%(1e3*60*60)/(1e3*60)),result=days+"天"+hours+"小时"+minutes+"分钟";document.getElementById("runningdays").innerHTML=result</script><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://libs.jshub.com/photoswipe/4.1.3/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://libs.jshub.com/photoswipe/4.1.3/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://libs.jshub.com/photoswipe/4.1.3/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://libs.jshub.com/photoswipe/4.1.3/photoswipe.min.css crossorigin=anonymous></main></div><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.font.im/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><meta name=apple-mobile-web-app-capable content="yes"><meta name=theme-color content="#ffffff"><script>"serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("/sw.js").then(e=>{console.log("Service worker registered with scope: ",e.scope)},e=>{console.log("Service worker registration failed: ",e)})})</script></body></html>