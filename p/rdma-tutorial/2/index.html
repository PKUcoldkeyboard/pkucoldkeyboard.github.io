<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="本文是关于 RDMA 技术及其编程方法的指导。文章主要介绍了 libibverbs 的简介和 Verbs API 的详解，包括 Verbs 对象创建层次和两个动态库。此外，还介绍了 Connection Manager 的建立过程和抽象类型 RDMACM。最后，文章通过解析被动方和主动方的 RDMACM 程序，以及基于 RDMA 的 client-server 程序的实战，来帮助读者更好地理解和应用 RDMA 技术。"><title>RDMA 技术及其编程方法（二）：编程指导</title><link rel=canonical href=https://cuterwrite.top/p/rdma-tutorial/2/><link rel=stylesheet href=/scss/style.min.a12f6d9475ee73ef9c178bbeaa53a124a4b4932c2611bf01f2801729abfd2d8c.css><meta property="og:title" content="RDMA 技术及其编程方法（二）：编程指导"><meta property="og:description" content="本文是关于 RDMA 技术及其编程方法的指导。文章主要介绍了 libibverbs 的简介和 Verbs API 的详解，包括 Verbs 对象创建层次和两个动态库。此外，还介绍了 Connection Manager 的建立过程和抽象类型 RDMACM。最后，文章通过解析被动方和主动方的 RDMACM 程序，以及基于 RDMA 的 client-server 程序的实战，来帮助读者更好地理解和应用 RDMA 技术。"><meta property="og:url" content="https://cuterwrite.top/p/rdma-tutorial/2/"><meta property="og:site_name" content="Cuterwrite's Blog"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="RDMA"><meta property="article:tag" content="计算机网络"><meta property="article:published_time" content="2023-07-27T01:00:00+00:00"><meta property="article:modified_time" content="2023-07-27T01:00:00+00:00"><meta property="og:image" content="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230725145210.webp"><meta name=twitter:title content="RDMA 技术及其编程方法（二）：编程指导"><meta name=twitter:description content="本文是关于 RDMA 技术及其编程方法的指导。文章主要介绍了 libibverbs 的简介和 Verbs API 的详解，包括 Verbs 对象创建层次和两个动态库。此外，还介绍了 Connection Manager 的建立过程和抽象类型 RDMACM。最后，文章通过解析被动方和主动方的 RDMACM 程序，以及基于 RDMA 的 client-server 程序的实战，来帮助读者更好地理解和应用 RDMA 技术。"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cuterwrite-1302252842.file.myqcloud.com/blog/20230725145210.webp"><link rel="shortcut icon" href=/favicon.ico></head><body class="article-page
line-numbers"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hue4d14694a57c01a222a16c47db12c89c_369633_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>😉</span></figure><div class=site-meta><h1 class=site-name><a href=/>Cuterwrite's Blog</a></h1><h2 class=site-description>欢迎来到我的个人博客。我是cuterwrite，一个热爱生活、不断探索的人。在这里，我分享我的想法、经验和学习，希望可以帮助到你，也欢迎你与我分享你的看法。</h2></div></header><ol class=social-menu><li><a href=https://github.com/PKUcoldkeyboard target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://cuterwrite.top/index.xml target=_blank title=rss rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li><li><a href=https://www.zhihu.com/people/kong-tiao-cheng-tai-lang-30-57 target=_blank title=zhihu rel=me><svg t="1705591931290" class="icon" viewBox="0 0 1280 1024" xmlns="http://www.w3.org/2000/svg" p-id="21048" width="32" height="32"><path d="M341.08 296.26v435.08l46.86.02 15.42 52.74 84.02-52.74h99.06V296.26H341.08zm195.5 387.86H480.7l-55.8 35.02-10.16-34.94-23.8-.08V343.5h145.64v340.62zM299.66 495.34H195c3.48-54.2 4.4-103.18 4.4-146.92h102.32s3.94-45.12-17.16-44.62h-177c6.98-26.24 15.74-53.32 26.24-81.34.0.0-48.14.0-64.54 43.14-6.78 17.8-26.42 86.28-61.4 156.24 11.78-1.28 50.74-2.36 73.68-44.42 4.22-11.78 5.02-13.32 10.28-29.06h57.74c0 21-2.4 133.76-3.36 146.88H41.66c-23.48.0-31.12 47.24-31.12 47.24H141.7C132.9 642.2 85.66 726.24.0 792.68c40.98 11.7 81.82-1.86 102-19.8.0.0 45.96-41.8 71.18-138.5L281.1 764.26s15.82-53.78-2.48-79.98c-15.16-17.84-56.12-66.12-73.58-83.62L175.8 623.9c8.72-27.96 13.98-55.1 15.74-81.34h123.3s-.18-47.24-15.18-47.24v.02zm824.04-3.2c41.66-51.28 89.96-117.14 89.96-117.14s-37.3-29.6-54.76-8.12c-12 16.3-73.66 96.4-73.66 96.4l38.46 28.86zM823.52 373.96c-18.02-16.5-51.82 4.26-51.82 4.26s79.04 110.08 82.24 114.9l38.92-27.46s-51.34-75.22-69.32-91.72h-.02zM1280 516.7c-39.56.0-261.82 1.86-262.12 1.86v-202c9.62.0 24.84-.8 45.7-2.4 81.76-4.82 140.26-8 175.54-9.62.0.0 24.44-54.38-1.18-66.88-6.14-2.36-46.34 9.16-46.34 9.16s-330.44 32.98-464.72 36.1c3.2 17.64 15.24 34.16 31.56 39.1 26.62 6.96 45.38 3.4 98.3 1.78 49.66-3.2 87.36-4.86 113.02-4.86v199.62H702.82s5.64 44.62 51.02 45.7h215.88V706.1c0 27.94-22.38 43.98-48.96 42.24-28.16.22-52.16-2.3-83.38-3.62 3.98 7.94 12.66 28.78 38.62 43.68 19.76 9.62 32.34 13.14 52.04 13.14 59.12.0 91.34-34.56 89.78-90.62V564.28h244.72c19.36.0 17.4-47.56 17.4-47.56l.06-.02z" fill="#707070" p-id="21049"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>主页 | Home</span></a></li><li><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>关于 | About</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>归档 | Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>搜索 | Search</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ul><li><a href=#一libibverbs-简介>一、libibverbs 简介</a></li><li><a href=#二verbs-api-详解>二、Verbs API 详解</a><ul><li><a href=#1-简介>1. 简介</a></li><li><a href=#2-verbs-对象创建层次>2. Verbs 对象创建层次</a></li><li><a href=#3-两个动态库>3. 两个动态库</a></li></ul></li><li><a href=#三connection-manager>三、Connection Manager</a><ul><li><a href=#1-连接的建立>1. 连接的建立</a></li><li><a href=#2-cm-的抽象类型rdmacm>2. CM 的抽象类型（RDMACM）</a></li></ul></li><li><a href=#四-rdmacm-程序解析被动方>四、 RDMACM 程序解析——被动方</a><ul><li><a href=#1-创建事件-channel>1. 创建事件 channel</a></li><li><a href=#2-创建连接-id>2. 创建连接 ID</a></li><li><a href=#3-绑定地址>3. 绑定地址</a></li><li><a href=#4-创建-listener返回端口地址>4. 创建 Listener，返回端口/地址</a></li><li><a href=#5-等待连接请求>5. 等待连接请求</a></li><li><a href=#6-创建-pdcq-和-send-receive-qp>6. 创建 PD、CQ 和 Send-Receive QP</a></li><li><a href=#7-最后的操作>7. 最后的操作</a></li></ul></li><li><a href=#五-rdmacm-程序解析主动方>五、 RDMACM 程序解析——主动方</a><ul><li><a href=#1-创建事件-channel-1>1. 创建事件 channel</a></li><li><a href=#2-创建连接-id-1>2. 创建连接 ID</a></li><li><a href=#3-绑定地址-1>3. 绑定地址</a></li><li><a href=#4-创建-qp>4. 创建 QP</a></li><li><a href=#5-解析路由>5. 解析路由</a></li><li><a href=#6-建立连接>6. 建立连接</a></li><li><a href=#7-最后的操作-1>7. 最后的操作</a></li></ul></li><li><a href=#六实战基于-rdma-的-client-server-程序>六、实战：基于 RDMA 的 client-server 程序</a><ul><li><a href=#1-server-端>1. server 端</a></li><li><a href=#2-client-端>2. client 端</a></li><li><a href=#3-项目实现>3. 项目实现</a></li><li><a href=#4-补充rdma-应用程序标准流程>4. 补充：RDMA 应用程序标准流程</a></li></ul></li><li><a href=#参考文献>参考文献</a></li></ul></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/rdma-tutorial/2/><img src=https://cuterwrite-1302252842.file.myqcloud.com/blog/20230725145210.webp loading=lazy alt="Featured image of post RDMA 技术及其编程方法（二）：编程指导"></a></div><div class=article-details><header class=article-category><a href=/categories/hpc/ style=background-color:#ffd06f;color:#fff>高性能计算</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/rdma-tutorial/2/>RDMA 技术及其编程方法（二）：编程指导</a></h2><h3 class=article-subtitle>本文是关于 RDMA 技术及其编程方法的指导。文章主要介绍了 libibverbs 的简介和 Verbs API 的详解，包括 Verbs 对象创建层次和两个动态库。此外，还介绍了 Connection Manager 的建立过程和抽象类型 RDMACM。最后，文章通过解析被动方和主动方的 RDMACM 程序，以及基于 RDMA 的 client-server 程序的实战，来帮助读者更好地理解和应用 RDMA 技术。</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>2023-07-27</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 9 分钟</time></div></footer></div></header><section class=article-content><h1 id=rdma-技术及其编程方法二编程指导>RDMA 技术及其编程方法（二）：编程指导</h1><h2 id=一libibverbs-简介>一、libibverbs 简介</h2><ul><li>libibverbs 由 Roland Dreier 自 2006 年开始开发和维护，实际上是*nix 中的 Verbs API 标准<ul><li>开源</li><li>Verbs 的核心部分自 2005 年起集成到 Linux 内核中&ndash;内核 2.6.11</li><li>Inbox in several *nix distributions</li><li>目前有多个硬件供应商提供的级别较低的库</li></ul></li><li>对所有启用 RDMA 的传输协议使用相同的 API<ul><li><strong>InfiniBand</strong>： 支持 RDMA 的网络体系结构<ul><li>需要支持它的网卡和 InfiniBand 交换机。</li></ul></li><li><strong>RoCE</strong>：基于以太网/IP 帧的 RDMA 数据包封装<ul><li>需要支持它的网卡和标准以太网交换机</li></ul></li><li><strong>iWARP</strong>：提供基于流控制传输协议(SCTP)和传输控制协议(TCP)的 RDMA<ul><li>需要支持它的网卡和标准以太网交换机</li></ul></li></ul></li><li>libibverbs 是完全线程安全的<ul><li>libibverbs 本身是线程安全的</li><li>用户态空间低级驱动程序库也是线程安全的</li><li>应用程序可以在多线程中使用 RDMA 资源</li></ul></li></ul><div class="notice notice-warning"><div class=notice-title><svg t="1705945674099" class="icon notice-icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="16953" width="200" height="200"><path d="M512 106.666667A405.333333 405.333333.0 10917.333333 512 405.333333 405.333333.0 00512 106.666667zm120.533333 489.6a25.621333 25.621333.0 010 36.266666 25.749333 25.749333.0 01-36.266666.0L512 548.266667l-84.266667 84.266666a25.749333 25.749333.0 01-36.266666.0 25.621333 25.621333.0 010-36.266666L475.733333 512l-84.266666-84.266667a25.642667 25.642667.0 0136.266666-36.266666L512 475.733333l84.266667-84.266666a25.642667 25.642667.0 0136.266666 36.266666L548.266667 512z" fill="#fff" p-id="16954"/></svg></div><p>销毁一个线程中的资源并在另一个线程中使用它将导致 segmentation fault，这个问题在非多线程代码中也会发生</p></div><ul><li>使用 libibverbs 的基本须知<div class=table-wrapper><table><thead><tr><th style=text-align:left>tips</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left>头文件引入</td><td style=text-align:left>#include&lt;infiniband/verbs.h></td></tr><tr><td style=text-align:left>编译时链接</td><td style=text-align:left>-libverbs</td></tr><tr><td style=text-align:left>所有的 input structures 需要为 zeroed</td><td style=text-align:left>使用 memset()或结构初始化、如果该 structure 有扩充的需求，则零值将保留遗留行为</td></tr><tr><td style=text-align:left>大多数资源句柄都是指针，因此使用错误的句柄可能会导致分段错误</td><td style=text-align:left>使用 NULL 检查句柄</td></tr><tr><td style=text-align:left>返回指针的 Verbs 成功时返回有效值，失败时返回 NULL</td><td style=text-align:left>检查返回值</td></tr><tr><td style=text-align:left>返回整形变量的 Verbs 如果成功则返回零，如果成功则返回-1 或 errno</td><td style=text-align:left>检查返回值</td></tr></tbody></table></div></li></ul><h2 id=二verbs-api-详解>二、Verbs API 详解</h2><h3 id=1-简介>1. 简介</h3><ul><li>在内核和用户态空间均可使用</li><li>Verbs 中的类<ul><li>资源管理：Qps、CQs、SRQs 等等</li><li>WR 处理：post send, 轮询 CQ 等等</li><li>内存注册</li><li>地址句柄</li></ul></li><li>Verbs 中的操作<ul><li>Device 操作</li><li>上下文操作</li><li>PD 操作</li><li>QP bringup</li><li>活跃 QP 操作</li></ul></li></ul><h3 id=2-verbs-对象创建层次>2. Verbs 对象创建层次</h3><ol><li>获取 devide 列表</li><li>打开请求的 device</li><li>查询 device 功能</li><li>分配 PD 内存空间</li><li>注册内存域 MR</li><li>关联并创建完成队列 CQ</li><li>创建 QP</li><li>Bring up a QP</li><li>Post WR 并且轮询 CQ</li><li>清理资源<figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/blog/20230724235009.webp alt=20230724235009 width=90% loading=lazy></figure></li></ol><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/blog/20230724235116.webp alt=20230724235116 width=90% loading=lazy></figure><h3 id=3-两个动态库>3. 两个动态库</h3><ul><li>libibverbs.so<ul><li>用于直接通过用户态空间访问 InfiniBand 硬件的库</li><li>Infiniband(根据 Infiniband 规范)和 iWarp(iWARP 动词规范)的 RDMA Verbs 的实现</li><li>它处理创建、修改、查询和销毁资源的控制路径，如保护域(PD)、完成队列(CQ)、队列对(QP)、共享接收队列(SRQ)、地址句柄(AH)、内存区域(MR)</li><li>它还处理发送和接收发布到 QPS 和 SRQ 的数据，使用轮询和完成事件从 CQs 获取完成</li></ul></li><li>librdmacm.so<ul><li>用户态空间的 RDMA 连接管理器</li><li>使用 Socket 语义的 RDMA(InfiniBand、ROCE 和 iWARP)通信管理库</li></ul></li></ul><h2 id=三connection-manager>三、Connection Manager</h2><h3 id=1-连接的建立>1. 连接的建立</h3><ul><li><p>基于 Infiniband 通信管理(CM)协议（在通用服务接口(GSI)上定义的协议 QP：QP1）</p></li><li><p>提供以下服务</p><ul><li>在对等 RC 和 QP 之间交换必要的参数，使它们为通信做好准备<ul><li>初始化器请求连接到远程上的服务 ID（服务 ID 映射）</li><li>类 TCP 握手：请求/响应/即用消息</li></ul></li><li>查找给定服务 ID 的远程 UD 和 QP 序号<ul><li>服务 ID 请求/响应消息</li></ul></li><li>加载备用路径</li></ul></li><li><p>连接管理器（Connection Manager，CM）是一个用户态空间的库，它提供了一个通用的接口，用于在 RDMA 网络中建立连接。它可以用于建立连接，也可以用于查找远程 QP 的地址，以便在不建立连接的情况下发送数据。</p><ul><li>需要在对等 QP 之间交换信息</li><li>负责 RC、UC、RD 连接的建立</li><li>应用程序使用 SA 来获取其他信息(例如路径记录)</li><li>SIDR 用于 UD</li></ul></li></ul><h3 id=2-cm-的抽象类型rdmacm>2. CM 的抽象类型（RDMACM）</h3><ul><li>类似于 Socket 连接模式的语义</li><li>对 IB 和 ROCE 都使用基于 IP 的寻址模式</li></ul><div class=table-wrapper><table><thead><tr><th style=text-align:left>类</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left><strong>rdma_create/destroy_id</strong></td><td style=text-align:left>creates/destroys a connection identifier (equivalent to a socket)</td></tr><tr><td style=text-align:left><strong>rdma_create/destroy_qp</strong></td><td style=text-align:left>allocate/destroy a qp for communication</td></tr><tr><td style=text-align:left><strong>rdma_bind_addr</strong></td><td style=text-align:left>set local port to listen on</td></tr><tr><td style=text-align:left><strong>rdma_resolve_addr</strong></td><td style=text-align:left>obtain local RDMA device to reach remote address</td></tr><tr><td style=text-align:left><strong>rdma_resolve_route</strong></td><td style=text-align:left>determine route to remote address</td></tr><tr><td style=text-align:left><strong>rdma_get_src_port</strong></td><td style=text-align:left>query local port</td></tr><tr><td style=text-align:left><strong>rdma_get_local_addr</strong></td><td style=text-align:left>query local ip</td></tr><tr><td style=text-align:left><strong>rdma_get_peer_addr</strong></td><td style=text-align:left>query remote ip</td></tr><tr><td style=text-align:left><strong>rdma_connect/disconnect</strong></td><td style=text-align:left>connect/disconnect rc qps, or resolve service id to qp for ud qps</td></tr><tr><td style=text-align:left><strong>rdma_listen</strong></td><td style=text-align:left>listen for incoming connections</td></tr><tr><td style=text-align:left><strong>rdma_accept/reject</strong></td><td style=text-align:left>accept/reject incoming connection requests</td></tr><tr><td style=text-align:left><strong>rdma_create/destroy_event_channel</strong></td><td style=text-align:left>allocate/destroy an event channel</td></tr><tr><td style=text-align:left><strong>rdma_get_cm_event</strong></td><td style=text-align:left>get next event</td></tr><tr><td style=text-align:left><strong>rdma_ack_cm_event</strong></td><td style=text-align:left>acknowledge event(s) to rdmacm</td></tr><tr><td style=text-align:left><strong>rdma_join/leave_multicast</strong></td><td style=text-align:left>join/leave multicast addresses</td></tr></tbody></table></div><ul><li>使用 rdmacm 的基本须知<div class=table-wrapper><table><thead><tr><th style=text-align:left>tips</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left>头文件引入</td><td style=text-align:left>#include&lt;rdma/rdma_cma.h></td></tr><tr><td style=text-align:left>编译时链接</td><td style=text-align:left>-lrdmacm</td></tr></tbody></table></div></li></ul><h2 id=四-rdmacm-程序解析被动方>四、 RDMACM 程序解析——被动方</h2><p>流程如下：</p><ol><li>创建事件 channel，以便我们可以接收 rdmacm 事件，如连接请求和连接建立通知。</li><li>创建连接 ID 并绑定到地址。</li><li>创建 Listener 并返回端口/地址。</li><li>等待连接请求</li><li>创建 PD、CQ 和 Send-Receive QP</li><li>接受连接请求</li><li>等待建立连接</li><li>视情况发布操作</li></ol><h3 id=1-创建事件-channel>1. 创建事件 channel</h3><ul><li>打开用于报告通信事件的 channel。异步事件将通过事件 channel 报告给用户，对应方法为<code>struct rdma_event_channel * rdma_create_event_channel(void)</code>。</li><li>事件 channel 用于定向 rdma_cm_id 上的所有事件。对于许多客户端来说，单个事件 channel 可能就足够了，然而，当管理大量的连接或 cm_id 时，用户可能会发现将不同 cm_id 的事件定向到不同的 channel 进行处理是有用的。</li><li>必须通过调用<code>rdma_destroy_event_channel</code> 销毁所有创建的事件 channel。用户应该调用<code>rdma_get_cm_event</code> 来检索事件 channel 上的事件。</li></ul><pre><code class=language-c>struct rdma_event_channel *channel = rdma_create_event_channel();
if (!channel) {
    perror(&quot;rdma_create_event_channel&quot;);
    return -1;
}
struct rdma_cm_event* event;
// 此处会阻塞，直到有事件发生
int err = rdma_get_cm_event(channel, &amp;event);
if (err) {
    perror(&quot;rdma_get_cm_event&quot;);
    return err;
}
// 中间处理代码...
rdma_destroy_event_channel(channel);
</code></pre><ul><li>每个事件 channel 都映射到一个文件描述符。可以像使用和操作任何其他 FD 一样使用和操作关联的文件描述符，以更改其行为。</li></ul><h3 id=2-创建连接-id>2. 创建连接 ID</h3><ul><li>创建用于跟踪通信信息的标识符，对应方法为<code>int rdma_create_id(struct rdma_event_channel *channel, struct rdma_cm_id **id, void *context, enum rdma_port_space ps)</code>。</li><li>输入参数：<ul><li>channel：事件 channel</li><li>id：指向 rdma_cm_id 指针的指针，用于返回新创建的 rdma_cm_id</li><li>context：用户上下文，将在事件中返回给用户</li><li>ps：RDMA 端口空间，指定要使用的端口空间</li></ul></li><li>rdma_cm_id 在概念上等同于用于 RDMA 通信的套接字。不同之处在于，RDMA 通信需要显式绑定到指定的 RDMA 设备，然后才能进行通信，并且大多数操作本质上是异步的。</li><li>端口空间<ul><li>RDMA_PS_TCP：提供可靠、面向连接的 QP 通信。与 TCP 不同，RDMA 端口空间提供基于消息的通信，而不是基于流的通信。</li><li>RDMA_PS_UDP：提供不可靠、无连接的 QP 通信。支持数据报和组播通信。</li></ul></li><li>销毁：在调用此函数并确认相关事件之前，用户必须释放任何与 rdma_cm_id 相关的 QP。</li></ul><pre><code class=language-c>struct rdma_cm_id *listen_id;
int err = rdma_create_id(channel, &amp;listen_id, NULL, RDMA_PS_TCP);
if (err) {
    perror(&quot;rdma_create_id&quot;);
    return err;
}
// 中间处理代码...
rdma_destroy_id(listen_id);
</code></pre><h3 id=3-绑定地址>3. 绑定地址</h3><ul><li>将源地址与 rdma_cm_id 相关联。对应方法为<code>int rdma_bind_addr(struct rdma_cm_id *id, struct sockaddr *addr)</code>。<ul><li>地址中可以包含通配符。</li><li>如果绑定到特定本地地址，则 rdma_cm_id 也将绑定到本地 RDMA 设备。</li><li>通常，在调用<code>rdma_listen</code> 以绑定到特定端口号之前调用此函数，但也可以在调用<code>rdma_resolve_addr</code> 以绑定到特定地址之前在主动方调用该函数。</li><li>如果用于绑定到端口 0，rdma_cm 将选择一个可用端口，可以使用<code>rdma_get_src_port</code> 检索该端口。</li></ul></li></ul><pre><code class=language-c>/*  sockaddr_in 是 IPV4 的地址结构体
*   AF_INET：IPV4
*   htons：将主机字节序转换为网络字节序（小端存储）, 20079 是端口号
*   INADDR_ANY：表示任意地址
*/
struct sockaddr_in addr = {
    .sin_family = AF_INET,
    .sin_port = htons(20079),
    .sin_addr = { .s_addr = INADDR_ANY },
};
err = rdma_bind_addr(listen_id, (struct sockaddr *)&amp;addr);
if (err) {
    perror(&quot;rdma_bind_addr&quot;);
    return err;
}
</code></pre><h3 id=4-创建-listener返回端口地址>4. 创建 Listener，返回端口/地址</h3><ul><li>初始化传入连接请求或数据报服务查找的 Listener。对应方法为<code>int rdma_listen(struct rdma_cm_id *id, int backlog)</code>。<ul><li>侦听将被限制为本地绑定源地址</li><li>在调用此函数之前，用户必须已通过调用<code>rdma_bind_addr</code> 将<code>rdma_cm_id</code> 绑定到本地地址。</li><li>如果<code>rdma_cm_id</code> 绑定到特定的 IP 地址，则侦听将仅限于该地址和关联的 RDMA 设备。</li><li>如果<code>rdma_cm_id</code> 仅绑定到 RDMA 端口号，则将在所有 RDMA 设备上进行侦听。</li></ul></li><li>返回已绑定到本地地址的<code>rdma_cm_id</code> 的本地端口号。对应方法为<code>uint16_t rdma_get_src_port(struct rdma_cm_id *id)</code>。</li><li>返回已绑定到本地设备的<code>rdma_cm_id</code> 的本地 IP 地址。对应方法为<code>struct sockaddr * rdma_get_local_addr(struct rdma_cm_id *id)</code>。</li><li>解析目的节点和服务地址，并返回建立通信所需的信息。提供与 getaddrinfo 等效的 RDMA 功能(配合<code>rdma_create_ep</code> 使用)。对应方法为<code>int rdma_getaddrinfo (char *node, char *service, struct rdma_addrinfo *hints, struct rdma_addrinfo **res)</code>。<ul><li>node: 可选，目的节点的主机名，或者点分十进制的 IPv4/IPv6 十六进制地址</li><li>service：地址的服务名称或端口号。</li><li>hints：一个包含有关调用方支持的服务类型的提示的 rdma_addrinfo 结构的引用。</li><li>res：指向包含响应信息的 rdma_addrinfo 结构的 LinkedList 的指针。</li></ul></li></ul><pre><code class=language-c>// 等待连接请求的最大数量
int backlog = 10;
err = rdma_listen(listen_id, backlog);
if (err) {
    perror(&quot;rdma_listen&quot;);
    return err;
}

uint16_t port = rdma_get_src_port(listen_id);
port = ntohs(port);
printf(&quot;listening on port %u.\n&quot;, port);

struct sockaddr *local_addr = rdma_get_local_addr(listen_id);
if (local_addr-&gt;sa_family == AF_INET) {
    struct sockaddr_in *sin = (struct sockaddr_in *)local_addr;
    char ip[INET_ADDRSTRLEN];
    // 需要加上头文件 #include &lt;arpa/inet.h&gt;
    inet_ntop(AF_INET, &amp;(sin-&gt;sin_addr), ip, INET_ADDRSTRLEN);
    printf(&quot;Local IP address is: %s\n&quot;, ip);
    printf(&quot;Local port is: %d\n&quot;, ntohs(sin-&gt;sin_port));
}

struct rdma_addrinfo hints;
memset(&amp;hints, 0, sizeof(hints));
hints.ai_flags = RAI_PASSIVE;
hints.ai_port_space = RDMA_PS_TCP;

struct rdma_addrinfo *res;
err = rdma_getaddrinfo(NULL, &quot;20079&quot;, &amp;hints, &amp;res);

if (err) {
    perror(&quot;rdma_getaddrinfo&quot;);
    return err;
}
// do something with struct rdma_addrinfo *cur = res...
</code></pre><h3 id=5-等待连接请求>5. 等待连接请求</h3><ul><li>检索通信事件。如果没有挂起的事件，默认情况下，调用将阻塞，直到接收到事件。对应方法为<code>int rdma_get_cm_event(struct rdma_event_channel *channel, struct rdma_cm_event **event)</code>。</li><li>通过修改与给定通道相关联的文件描述符，可以更改此函数的默认同步行为。</li><li>所有报告的事件都必须通过调用<code>rdma_ack_cm_event</code> 进行确认。</li><li><code>rdma_cm_id</code> 的销毁将被阻塞，直到相关事件被确认。</li></ul><pre><code class=language-c>struct rdma_cm_event* event;
// 此处会阻塞，直到有事件发生
err = rdma_get_cm_event(channel, &amp;event);
</code></pre><h3 id=6-创建-pdcq-和-send-receive-qp>6. 创建 PD、CQ 和 Send-Receive QP</h3><ul><li>分配与指定的<code>rdma_cm_id</code> 相关联的 QP，并将其转换为用于发送和接收。对应方法为<code>int rdma_create_qp(struct rdma_cm_id *id, struct ibv_pd *pd, struct ibv_qp_init_attr *qp_init_attr)</code>。</li><li>在调用此函数之前，<code>rdma_cm_id</code> 必须绑定到本地 RDMA 设备，且保护域 PD 必须用于同一设备。</li><li>被分配给<code>rdma_cm_id</code> 的 QP 会由 librdmacm 自动转换状态.</li><li>分配完毕后，QP 将准备就绪，处理接收信息的发布。如果 QP 未连接，它将准备好发布发送。</li></ul><pre><code class=language-c>pd = ibv_alloc_pd(cm_client_id-&gt;verbs);
if (!pd) {
    perror(&quot;Failed to allocate a protection domain&quot;);
    return -1;
}

io_completion_channel = ibv_create_comp_channel(cm_client_id-&gt;verbs);
if (!io_completion_channel) {
    perror(&quot;Failed to create an I/O completion event channel&quot;);
    return -1;
}

cq = ibv_create_cq(cm_client_id-&gt;verbs, 10, NULL, io_completion_channel, 0);
if (!cq) {
    perror(&quot;Failed to create a completion queue&quot;);
    return -1;
}

ret = ibv_req_notify_cq(cq, 0);
if (ret) {
    perror(&quot;Failed to request notifications&quot;);
    return -1;
}

bzero(&amp;qp_init_attr, sizeof(qp_init_attr));
qp_init_attr.qp_type = IBV_QPT_RC;
qp_init_attr.cap.max_send_wr = 10;
qp_init_attr.cap.max_recv_wr = 10;
qp_init_attr.cap.max_send_sge = 1;
qp_init_attr.cap.max_recv_sge = 1;
qp_init_attr.send_cq = cq;
qp_init_attr.recv_cq = cq;

ret = rdma_create_qp(cm_client_id, pd, &amp;qp_init_attr);
if (ret) {
    perror(&quot;Failed to create QP&quot;);
    return -1;
}

client_qp = cm_client_id-&gt;qp;
</code></pre><h3 id=7-最后的操作>7. 最后的操作</h3><ol><li>Accept 请求连接</li><li>等待连接建立</li><li>发布操作</li></ol><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/blog/20230725224928.webp alt=20230725224928 width=90% loading=lazy></figure><h2 id=五-rdmacm-程序解析主动方>五、 RDMACM 程序解析——主动方</h2><h3 id=1-创建事件-channel-1>1. 创建事件 channel</h3><ul><li>与被动方相同</li></ul><h3 id=2-创建连接-id-1>2. 创建连接 ID</h3><ul><li>与被动方相同</li></ul><h3 id=3-绑定地址-1>3. 绑定地址</h3><ul><li>将目的地址和可选源地址从 IP 地址解析为 RDMA 地址。如果成功，则指定的 rdma_cm_id 将绑定到本地设备。对应方法为<code>int rdma_resolve_addr (struct rdma_cm_id *id, struct sockaddr *src_addr, struct sockaddr *dst_addr, int timeout_ms)</code>。</li><li>此方法用于将给定的目标 IP 地址映射到可用的 RDMA 地址。</li><li>IP 到 RDMA 地址的映射使用本地路由表或通过 ARP 完成。</li><li>如果给定源地址，则将<code>rdma_cm_id</code> 绑定到该地址，就像调用<code>rdma_ind_addr</code> 一样。</li><li>如果没有给出源地址，并且<code>rdma_cm_id</code> 尚未绑定到设备，则<code>rdma_cm_id</code> 将根据本地路由表绑定到源地址。</li><li>在此方法调用之后，<code>rdma_cm_id</code> 将绑定到 RDMA 设备。</li><li>该方法调用通常在调用 <code>rdma_resolve_route</code> 和 <code>rdma_connect</code> 之前在主动方上进行。</li></ul><div class="notice notice-note"><div class=notice-title><svg t="1705946198814" class="icon notice-icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="23141" width="200" height="200"><path d="M195.541333 739.029333C151.594667 692.352 128 640 128 555.136c0-149.333333 104.832-283.178667 257.28-349.354667L423.381333 264.576C281.088 341.546667 253.269333 441.429333 242.176 504.405333c22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642667 148.864A149.333333 149.333333.0 01312.789333 789.333333a165.162667 165.162667.0 01-117.248-50.304zm426.666667.0C578.261333 692.352 554.666667 640 554.666667 555.136c0-149.333333 104.832-283.178667 257.28-349.354667L850.048 264.576c-142.293333 76.970667-170.112 176.853333-181.205333 239.829333 22.912-11.861333 52.906667-16 82.304-13.269333 76.970667 7.125333 137.642667 70.314667 137.642666 148.864A149.333333 149.333333.0 01739.456 789.333333a165.162667 165.162667.0 01-117.248-50.304z" p-id="23142" fill="#fff"/></svg></div><p>InfiniBand 特定</p></div><ul><li>此方法还会将目标 IP 地址和源 IP 地址(如果给定)映射到 GID。</li><li>为了执行映射，IPoIB 必须同时在本地和远程节点上运行。</li></ul><h3 id=4-创建-qp>4. 创建 QP</h3><ul><li>与被动方相同</li></ul><h3 id=5-解析路由>5. 解析路由</h3><ul><li>解析指向目标地址的 RDMA 路由，以建立连接。目标地址必须已通过调用 rdma_resolve_addr 解析。对应方法为<code>int rdma_resolve_route (struct rdma_cm_id *id, int timeout_ms);</code></li></ul><h3 id=6-建立连接>6. 建立连接</h3><ul><li><p>对应方法为<code>int rdma_connect (struct rdma_cm_id *id, struct rdma_conn_param *conn_param);</code></p><ul><li>id：指向 rdma_cm_id 的指针</li><li>conn_param：指向 rdma_conn_param 结构的指针，包含连接参数</li></ul></li><li><p>对于 <code>RDMA_PS_TCP</code> 类型的 <code>rdma_cm_id</code>，该调用会向远程目的地发起连接请求</p></li><li><p>对于 <code>RDMA_PS_UDP</code> 类型的 <code>rdma_cm_id</code>，它会启动对提供数据报服务的远程 QP 的查询</p></li></ul><h3 id=7-最后的操作-1>7. 最后的操作</h3><ol><li>等待连接建立</li><li>发布操作</li></ol><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/blog/20230725225927.webp alt=20230725225927 width=90% loading=lazy></figure><hr><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/blog/20230725225943.webp alt=20230725225943 width=90% loading=lazy></figure><h2 id=六实战基于-rdma-的-client-server-程序>六、实战：基于 RDMA 的 client-server 程序</h2><h3 id=1-server-端>1. server 端</h3><ul><li>工作流程：<ol><li>初始化 RDMA 资源</li><li>等待 client 连接</li><li>分配并固定服务器缓冲区 buffer</li><li>接受客户端连接</li><li>将有关本地服务器缓冲区的信息发送到客户端</li><li>等待断开连接</li></ol></li></ul><h3 id=2-client-端>2. client 端</h3><ul><li>工作流程：<ol><li>初始化 RDMA 资源</li><li>连接 server</li><li>通过发送/接收 exchange 接收服务器端缓冲区信息</li><li>从（第一个）本地缓冲区向服务器缓冲区进行 RDMA 写入。</li><li>进行 RDMA 读取，将服务器缓冲区的内容读入第二个本地缓冲区。</li><li>比较第一缓冲区和第二缓冲区的内容，并进行匹配</li><li>断开连接</li></ol></li></ul><h3 id=3-项目实现>3. 项目实现</h3><div class=github><div class=logo><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M2 2.5c0-.66304.26339-1.29893.73223-1.767767C3.20108.263392 3.83696.0 4.5.0h8.75c.1989.0.3897.0790176.5303.21967C13.921.360322 14 .551088 14 .75v12.5C14 13.4489 13.921 13.6397 13.7803 13.7803 13.6397 13.921 13.4489 14 13.25 14h-2.5C10.5511 14 10.3603 13.921 10.2197 13.7803 10.079 13.6397 10 13.4489 10 13.25S10.079 12.8603 10.2197 12.7197C10.3603 12.579 10.5511 12.5 10.75 12.5H12.5v-2h-8C4.30308 10.5 4.11056 10.5582 3.94657 10.6672 3.78257 10.7762 3.65442 10.9312 3.57816 11.1128 3.50191 11.2943 3.48096 11.4943 3.51793 11.6878 3.5549 11.8812 3.64816 12.0594 3.786 12.2c.13924.142200000000001.2163.3338.21424.5328C3.99818 12.9318 3.91716 13.1218 3.775 13.261 3.63285 13.4002 3.4412 13.4773 3.24222 13.4752 3.04325 13.4732 2.85324 13.3922 2.714 13.25c-.45829-.4671-.71471-1.0956-.714-1.75v-9zm10.5-1V9h-8C4.144 9 3.806 9.074 3.5 9.208V2.5c0-.26522.10536-.51957.29289-.70711C3.98043 1.60536 4.23478 1.5 4.5 1.5h8zM5 12.25V15.5C5 15.5464 5.01293 15.5919 5.03734 15.6314 5.06175 15.6709 5.09667 15.7028 5.1382 15.7236 5.17972 15.7444 5.22621 15.7532 5.27245 15.749 5.31869 15.7448 5.36286 15.7279 5.4 15.7l1.45-1.087C6.89328 14.5805 6.94591 14.563 7 14.563S7.10673 14.5805 7.15 14.613L8.6 15.7C8.63714 15.7279 8.68131 15.7448 8.72755 15.749 8.77379 15.7532 8.82028 15.7444 8.8618 15.7236 8.90333 15.7028 8.93826 15.6709 8.96266 15.6314 8.98707 15.5919 9 15.5464 9 15.5V12.25C9 12.1837 8.97366 12.1201 8.92678 12.0732 8.87989 12.0263 8.81631 12 8.75 12H5.25C5.1837 12 5.12011 12.0263 5.07322 12.0732 5.02634 12.1201 5 12.1837 5 12.25z"/></svg><a class=name href=https://github.com/PKUcoldkeyboard/RDMA-examples target=_blank>RDMA-examples</a></div><div class=description>RDMA-examples: A repository of practical code examples showcasing the fundamental concepts and usage of RDMA (Remote Direct Memory Access) technology.</div><div class=language><span class=language-color style=background-color:#555></span>
<span class=language-name>C</span></div></div><h3 id=4-补充rdma-应用程序标准流程>4. 补充：RDMA 应用程序标准流程</h3><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/blog/20230729185145.webp alt=20230729185145 width=90% loading=lazy></figure><h2 id=参考文献>参考文献</h2><ul><li>Mellanox Technologies, Inc. (2017). RDMA Aware Networks Programming User Manual. Mellanox Technologies, Inc.</li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/rdma/>RDMA</a>
<a href=/tags/computer-network/>计算机网络</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer><script type=text/javascript src=/js/prism.js async></script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/rdma-element/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/73c30b990886bf6988c97858a3e16011195413_crop-2024-02-04.webp loading=lazy data-key=rdma-element data-hash=https://cuterwrite-1302252842.file.myqcloud.com/img/73c30b990886bf6988c97858a3e16011195413_crop-2024-02-04.webp></div><div class=article-details><h2 class=article-title>RDMA 基本元素</h2></div></a></article><article class=has-image><a href=/p/ethernet-vs-rdma/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/cropped_2024010202-2024-02-03.webp loading=lazy data-key=ethernet-vs-rdma data-hash=https://cuterwrite-1302252842.file.myqcloud.com/img/cropped_2024010202-2024-02-03.webp></div><div class=article-details><h2 class=article-title>比较基于传统以太网与 RDMA 技术的通信</h2></div></a></article><article class=has-image><a href=/p/rdma-overview/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/crop_65b36f302c1d3715061e824224dcc9ca195413.jpg@1256w_1806h_!web-article-pic-2024-01-14.webp loading=lazy data-key=rdma-overview data-hash=https://cuterwrite-1302252842.file.myqcloud.com/img/crop_65b36f302c1d3715061e824224dcc9ca195413.jpg@1256w_1806h_!web-article-pic-2024-01-14.webp></div><div class=article-details><h2 class=article-title>RDMA 概述</h2></div></a></article><article class=has-image><a href=/p/rdma-tutorial/1/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/blog/20230722162905.webp loading=lazy data-key=rdma-tutorial/1 data-hash=https://cuterwrite-1302252842.file.myqcloud.com/blog/20230722162905.webp></div><div class=article-details><h2 class=article-title>RDMA 技术及其编程方法（一）：RDMA 简介与原理</h2></div></a></article><article class=has-image><a href=/p/openmpi-with-ucx/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/cropped_2024010204-2024-02-03.webp loading=lazy data-key=openmpi-with-ucx data-hash=https://cuterwrite-1302252842.file.myqcloud.com/img/cropped_2024010204-2024-02-03.webp></div><div class=article-details><h2 class=article-title>编译安装 UCX 1.15.0 与 OpenMPI 5.0.0：详尽指南</h2></div></a></article></div></div></aside><script>(function(){if(/^localhost|^127/.test(location.hostname))return;let e=document.createElement("script");e.src="https://giscus.app/client.js",e.dataset.repo="PKUcoldkeyboard/pkucoldkeyboard.github.io",e.dataset.repoId="MDEwOlJlcG9zaXRvcnkzMzU4NzI5OTI=",e.dataset.category="Comments",e.dataset.categoryId="DIC_kwDOFAUD4M4CZV4F",e.dataset.mapping="title",e.dataset.strict="0",e.dataset.reactionsEnabled="1",e.dataset.emitMetadata="0",e.dataset.inputPosition="top",e.dataset.theme="light",e.dataset.lang="zh-CN",e.dataset.loading="lazy",e.crossOrigin="anonymous",e.async=!0;let t=document.querySelector(".main"),n=t.childNodes[t.childNodes.length-1];t.insertBefore(e,n.nextSibling)})();function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){if(/^localhost|^127/.test(location.hostname))return;addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"light":"dark_dimmed")}})()</script><footer class=site-footer><section class=copyright>&copy;
2021 -
2024 cuterwrite</section><section class=running-time>本博客已稳定运行
<span id=runningdays class=running-days></span></section><section class=totalcount>发表了55篇文章 ·
总计239.78k字</section><section class=powerby>Welcome to cuterwrite's blog!<br>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.17.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><script>let s1="2021-4-17";s1=new Date(s1.replace(/-/g,"/"));let s2=new Date,timeDifference=s2.getTime()-s1.getTime(),days=Math.floor(timeDifference/(1e3*60*60*24)),hours=Math.floor(timeDifference%(1e3*60*60*24)/(1e3*60*60)),minutes=Math.floor(timeDifference%(1e3*60*60)/(1e3*60)),result=days+"天"+hours+"小时"+minutes+"分钟";document.getElementById("runningdays").innerHTML=result</script><script>(function(){var t,e=window;if(e.ChannelIO)return e.console.error("ChannelIO script included twice.");t=function(){t.c(arguments)},t.q=[],t.c=function(e){t.q.push(e)},e.ChannelIO=t;function n(){if(e.ChannelIOInitialized)return;e.ChannelIOInitialized=!0;var n,t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src="https://cdn.channel.io/plugin/ch-plugin-web.js",n=document.getElementsByTagName("script")[0],n.parentNode&&n.parentNode.insertBefore(t,n)}document.readyState==="complete"?n():(e.addEventListener("DOMContentLoaded",n),e.addEventListener("load",n))})(),ChannelIO("boot",{pluginKey:"3182ceac-0382-4734-98f5-1e6fec11c935"})</script><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.bootcdn.net/ajax/libs/photoswipe/4.1.3/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.bootcdn.net/ajax/libs/photoswipe/4.1.3/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.bootcdn.net/ajax/libs/photoswipe/4.1.3/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.bootcdn.net/ajax/libs/photoswipe/4.1.3/photoswipe.min.css crossorigin=anonymous></main></div><script type=text/javascript src=/ts/main.js defer></script><script async src=https://umami-gamma-virid.vercel.app/uma data-website-id=635c2011-51a9-4ffc-b360-f5572bb94276></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.font.im/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>