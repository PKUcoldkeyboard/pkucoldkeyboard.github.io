<!DOCTYPE html>
<html lang="zh-cn">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='Java并发知识点笔记'><title>Java并发知识点笔记</title>

<link rel='canonical' href='https://cuterwrite.top/p/java-concurrent/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='Java并发知识点笔记'>
<meta property='og:description' content='Java并发知识点笔记'>
<meta property='og:url' content='https://cuterwrite.top/p/java-concurrent/'>
<meta property='og:site_name' content='cuterwrite (Pang S.Z)'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='Java' /><meta property='article:published_time' content='2021-05-04T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2021-05-04T00:00:00&#43;00:00'/><meta property='og:image' content='https://cdn.jsdelivr.net/gh/PKUcoldkeyboard/image-hosting@master/20210503/santorini-1578440_1920.3ldusy6rm1k0.jpg' />
<meta name="twitter:title" content="Java并发知识点笔记">
<meta name="twitter:description" content="Java并发知识点笔记"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://cdn.jsdelivr.net/gh/PKUcoldkeyboard/image-hosting@master/20210503/santorini-1578440_1920.3ldusy6rm1k0.jpg' />
    <link rel="shortcut icon" href="/favicon.ico" />

    </head>
    <body class="">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.body.dataset.scheme = 'dark';
        } else {
            document.body.dataset.scheme = 'light';
        }
    })();
</script><div class="container main-container flex on-phone--column extended article-page with-toolbar">
            <aside class="sidebar left-sidebar sticky">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header class="site-info">
        
            <figure class="site-avatar">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hue4d14694a57c01a222a16c47db12c89c_369633_300x0_resize_box_2.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                

                
            </figure>
        
        <h1 class="site-name"><a href="https://cuterwrite.top">cuterwrite (Pang S.Z)</a></h1>
        <h2 class="site-description">本网站主要用来记录一些本人感兴趣的东西，佛系更新</h2>
    </header>

    <ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>首页</span>
            </a>
        </li>
        
        

        <li >
            <a href='/about'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>个人</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>文章</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        

        
            <li id="dark-mode-toggle">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                <span>暗色模式</span>
            </li>
        
    </ol>
</aside>

            <main class="main full-width">
    <div id="article-toolbar">
        <a href="https://cuterwrite.top" class="back-home">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



            <span>Back</span>
        </a>
    </div>

    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/java-concurrent/">
                
                    <img src="https://cdn.jsdelivr.net/gh/PKUcoldkeyboard/image-hosting@master/20210503/santorini-1578440_1920.3ldusy6rm1k0.jpg" loading="lazy" alt="Featured image of post Java并发知识点笔记" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF%E6%A0%88/" style="background-color: #32c5e9; color: #fff;">
                综合技术栈
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/java-concurrent/">Java并发知识点笔记</a>
    </h2>

    
    <h3 class="article-subtitle">
        Java并发知识点笔记
    </h3>
    <footer class="article-time">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <time class="article-time--published">2021-05-04</time>
    </footer></div>
</header>

    <section class="article-content">
    <!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><strong>Table of Contents</strong>  <em>generated with <a class="link" href="https://github.com/thlorenz/doctoc"  target="_blank" rel="noopener"
    >DocToc</a></em></p>
<ul>
<li><a class="link" href="#java%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0" >Java并发知识点笔记</a>
<ul>
<li><a class="link" href="#1-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95" >1 使用线程的方法</a></li>
<li><a class="link" href="#2-%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6" >2 基础线程机制</a>
<ul>
<li><a class="link" href="#21-executor" >2.1 Executor</a></li>
<li><a class="link" href="#22-daemon" >2.2 Daemon</a></li>
<li><a class="link" href="#23-sleep" >2.3 sleep()</a></li>
<li><a class="link" href="#24-yield" >2.4 yield()</a></li>
</ul>
</li>
<li><a class="link" href="#3-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD" >3 线程中断</a>
<ul>
<li><a class="link" href="#31-interruptedexception" >3.1 InterruptedException</a></li>
<li><a class="link" href="#32-interrupted" >3.2 interrupted()</a></li>
<li><a class="link" href="#33-executor-%E7%9A%84%E4%B8%AD%E6%96%AD%E6%93%8D%E4%BD%9C" >3.3 Executor 的中断操作</a></li>
</ul>
</li>
<li><a class="link" href="#4-%E4%BA%92%E6%96%A5%E9%94%81" >4 互斥锁</a>
<ul>
<li><a class="link" href="#41-synchronized" >4.1 synchronized</a></li>
<li><a class="link" href="#42-reentrantlock" >4.2 ReentrantLock</a></li>
<li><a class="link" href="#43-%E6%AF%94%E8%BE%83" >4.3 比较</a></li>
<li><a class="link" href="#44-%E9%80%89%E6%8B%A9" >4.4 选择</a></li>
</ul>
</li>
<li><a class="link" href="#5-%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C" >5 线程协作</a>
<ul>
<li><a class="link" href="#51-join" >5.1 join</a></li>
<li><a class="link" href="#52-waitnotify" >5.2 wait/notify</a></li>
<li><a class="link" href="#53-awaitsignal" >5.3 await/signal</a></li>
</ul>
</li>
<li><a class="link" href="#6-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81" >6 线程状态</a></li>
<li><a class="link" href="#7-juc%E5%8C%85aqs" >7 JUC包/AQS</a>
<ul>
<li><a class="link" href="#71-countdownlatch" >7.1 CountDownLatch</a></li>
<li><a class="link" href="#72-cyclicbarrier" >7.2 CyclicBarrier</a></li>
<li><a class="link" href="#73-semaphore" >7.3 Semaphore</a></li>
</ul>
</li>
<li><a class="link" href="#8-juc%E5%8C%85%E5%85%B6%E5%AE%83%E7%BB%84%E4%BB%B6" >8 JUC包其它组件</a>
<ul>
<li><a class="link" href="#81-futuretask" >8.1 FutureTask</a></li>
<li><a class="link" href="#82-blockingqueue" >8.2 BlockingQueue</a></li>
<li><a class="link" href="#83-forkjoin" >8.3 ForkJoin</a></li>
</ul>
</li>
<li><a class="link" href="#9-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B" >9 内存模型</a>
<ul>
<li><a class="link" href="#91-%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98" >9.1 主内存与工作内存</a></li>
<li><a class="link" href="#92-%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C" >9.2 内存间交互操作</a></li>
<li><a class="link" href="#93-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7" >9.3 内存模型三大特性</a>
<ul>
<li><a class="link" href="#931-%E5%8E%9F%E5%AD%90%E6%80%A7" >9.3.1. 原子性</a></li>
<li><a class="link" href="#932-%E5%8F%AF%E8%A7%81%E6%80%A7" >9.3.2. 可见性</a></li>
<li><a class="link" href="#933-%E6%9C%89%E5%BA%8F%E6%80%A7" >9.3.3. 有序性</a></li>
</ul>
</li>
<li><a class="link" href="#94-%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99" >9.4 先行发生原则</a></li>
</ul>
</li>
<li><a class="link" href="#10-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5" >10 线程安全策略</a>
<ul>
<li><a class="link" href="#101-%E4%B8%8D%E5%8F%AF%E5%8F%98" >10.1 不可变</a></li>
<li><a class="link" href="#102-%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5" >10.2 互斥同步</a></li>
<li><a class="link" href="#103-%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5" >10.3 非阻塞同步</a></li>
<li><a class="link" href="#104-%E6%97%A0%E5%90%8C%E6%AD%A5" >10.4 无同步</a>
<ul>
<li><a class="link" href="#1041-%E6%A0%88%E5%B0%81%E9%97%AD" >10.4.1 栈封闭</a></li>
<li><a class="link" href="#1042-%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8" >10.4.2 线程本地存储</a></li>
<li><a class="link" href="#1043-%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A3%E7%A0%81" >10.4.3 可重入代码</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="link" href="#11-%E9%94%81%E4%BC%98%E5%8C%96" >11 锁优化</a>
<ul>
<li><a class="link" href="#111-%E8%87%AA%E6%97%8B%E9%94%81" >11.1 自旋锁</a></li>
<li><a class="link" href="#112-%E9%94%81%E6%B6%88%E9%99%A4" >11.2 锁消除</a></li>
<li><a class="link" href="#113-%E9%94%81%E7%B2%97%E5%8C%96" >11.3 锁粗化</a></li>
<li><a class="link" href="#114-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81" >11.4 轻量级锁</a></li>
<li><a class="link" href="#115-%E5%81%8F%E5%90%91%E9%94%81" >11.5 偏向锁</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<h1 id="java并发知识点笔记">Java并发知识点笔记</h1>
<h2 id="1-使用线程的方法">1 使用线程的方法</h2>
<ul>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口；</li>
<li>继承 Thread 类。</li>
</ul>
<h2 id="2-基础线程机制">2 基础线程机制</h2>
<h3 id="21-executor">2.1 Executor</h3>
<p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>
<p>主要有三种 Executor：</p>
<ul>
<li>CachedThreadPool：一个任务创建一个线程；</li>
<li>FixedThreadPool：所有任务只能使用固定大小的线程；</li>
<li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li>
</ul>
<h3 id="22-daemon">2.2 Daemon</h3>
<p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p>
<p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p>
<p>main() 属于非守护线程。</p>
<p>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。</p>
<h3 id="23-sleep">2.3 sleep()</h3>
<p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p>
<p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p>
<h3 id="24-yield">2.4 yield()</h3>
<p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p>
<h2 id="3-线程中断">3 线程中断</h2>
<p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p>
<h3 id="31-interruptedexception">3.1 InterruptedException</h3>
<p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p>
<h3 id="32-interrupted">3.2 interrupted()</h3>
<p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p>
<p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<h3 id="33-executor-的中断操作">3.3 Executor 的中断操作</h3>
<p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p>
<h2 id="4-互斥锁">4 互斥锁</h2>
<p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<h3 id="41-synchronized">4.1 synchronized</h3>
<ul>
<li>同步代码块：锁对象</li>
<li>同步一个方法：锁对象</li>
<li>同步一个类：锁整个类</li>
<li>同步一个静态方法：锁整个类</li>
</ul>
<h3 id="42-reentrantlock">4.2 ReentrantLock</h3>
<p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p>
<p>通过lock和unlock操作</p>
<h3 id="43-比较">4.3 比较</h3>
<p><strong>1. 锁的实现</strong></p>
<p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p>
<p><strong>2. 性能</strong></p>
<p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>
<p><strong>3. 等待可中断</strong></p>
<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
<p>ReentrantLock 可中断，而 synchronized 不行。</p>
<p><strong>4. 公平锁</strong></p>
<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>
<p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>
<p><strong>5. 锁绑定多个条件</strong></p>
<p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p>
<h3 id="44-选择">4.4 选择</h3>
<p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<h2 id="5-线程协作">5 线程协作</h2>
<h3 id="51-join">5.1 join</h3>
<p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p>
<h3 id="52-waitnotify">5.2 wait/notify</h3>
<p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p>
<p>它们都属于 Object 的一部分，而不属于 Thread。</p>
<p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。</p>
<p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁</p>
<p><strong>wait() 和 sleep() 的区别</strong></p>
<ul>
<li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li>
<li>wait() 会释放锁，sleep() 不会。</li>
</ul>
<h3 id="53-awaitsignal">5.3 await/signal</h3>
<p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p>
<p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p>
<p>使用 Lock 来获取一个 Condition 对象。</p>
<h2 id="6-线程状态">6 线程状态</h2>
<ul>
<li>new</li>
<li>runable</li>
<li>blocked</li>
<li>waiting</li>
<li>timed_waiting</li>
<li>terminated</li>
</ul>
<h2 id="7-juc包aqs">7 JUC包/AQS</h2>
<h3 id="71-countdownlatch">7.1 CountDownLatch</h3>
<p>用来控制一个或者多个线程等待多个线程。</p>
<p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p>
<!-- raw HTML omitted -->
<h3 id="72-cyclicbarrier">7.2 CyclicBarrier</h3>
<p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p>
<p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p>
<p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p>
<p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png" alt=""  /></p>
<h3 id="73-semaphore">7.3 Semaphore</h3>
<p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p>
<h2 id="8-juc包其它组件">8 JUC包其它组件</h2>
<h3 id="81-futuretask">8.1 FutureTask</h3>
<p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future&lt;V&gt; 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future&lt;V&gt; 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p>
<p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</p>
<h3 id="82-blockingqueue">8.2 BlockingQueue</h3>
<p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p>
<ul>
<li><strong>FIFO 队列</strong>  ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li>
<li><strong>优先级队列</strong>  ：PriorityBlockingQueue</li>
</ul>
<p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。</p>
<h3 id="83-forkjoin">8.3 ForkJoin</h3>
<p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</p>
<p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</p>
<h2 id="9-内存模型">9 内存模型</h2>
<p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
<h3 id="91-主内存与工作内存">9.1 主内存与工作内存</h3>
<p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p>
<p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942ca0d2-9d5c-45a4-89cb-5fd89b61913f.png" alt=""  /></p>
<p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p>
<p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15851555-5abc-497d-ad34-efed10f43a6b.png" alt=""  /></p>
<h3 id="92-内存间交互操作">9.2 内存间交互操作</h3>
<p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8b7ebbad-9604-4375-84e3-f412099d170c.png" alt=""  /></p>
<ul>
<li>read：把一个变量的值从主内存传输到工作内存中</li>
<li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li>
<li>use：把工作内存中一个变量的值传递给执行引擎</li>
<li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store：把工作内存的一个变量的值传送到主内存中</li>
<li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li>
<li>lock：作用于主内存的变量</li>
<li>unlock</li>
</ul>
<h3 id="93-内存模型三大特性">9.3 内存模型三大特性</h3>
<h4 id="931-原子性">9.3.1. 原子性</h4>
<p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p>
<p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。</p>
<p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。</p>
<p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2797a609-68db-4d7b-8701-41ac9a34b14f.jpg" alt=""  /></p>
<p>AtomicInteger 能保证多个线程修改的原子性。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dd563037-fcaa-4bd8-83b6-b39d93a12c77.jpg" alt=""  /></p>
<p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。</p>
<h4 id="932-可见性">9.3.2. 可见性</h4>
<p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p>
<p>主要有三种实现可见性的方式：</p>
<ul>
<li>volatile</li>
<li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li>
<li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li>
</ul>
<p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</p>
<h4 id="933-有序性">9.3.3. 有序性</h4>
<p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p>
<p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p>
<h3 id="94-先行发生原则">9.4 先行发生原则</h3>
<p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p>
<ol>
<li>单一线程原则：在一个线程内，在程序前面的操作先行发生于后面的操作。</li>
<li>管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</li>
<li>volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</li>
<li>线程启动规则：Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</li>
<li>线程加入规则：Thread 对象的结束先行发生于 join() 方法返回。</li>
<li>线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</li>
<li>对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</li>
<li>传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</li>
</ol>
<h2 id="10-线程安全策略">10 线程安全策略</h2>
<h3 id="101-不可变">10.1 不可变</h3>
<p>不可变的类型：</p>
<ul>
<li>final 关键字修饰的基本数据类型</li>
<li>String</li>
<li>枚举类型</li>
<li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li>
</ul>
<p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p>
<h3 id="102-互斥同步">10.2 互斥同步</h3>
<p>synchronized 和 ReentrantLock。</p>
<h3 id="103-非阻塞同步">10.3 非阻塞同步</h3>
<ul>
<li>CAS</li>
<li>AtomicInteger</li>
</ul>
<p>ABA问题：如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p>
<p>解决方法：J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h3 id="104-无同步">10.4 无同步</h3>
<h4 id="1041-栈封闭">10.4.1 栈封闭</h4>
<p>多个线程访问同一个方法的<strong>局部变量</strong>时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p>
<h4 id="1042-线程本地存储">10.4.2 线程本地存储</h4>
<p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围<strong>限制在同一个线程之内</strong>，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
<p>它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作的自己本地内存里面的变量，从而避免了线程安全问题</p>
<p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p>
<p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p>
<h4 id="1043-可重入代码">10.4.3 可重入代码</h4>
<p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p>
<p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<h2 id="11-锁优化">11 锁优化</h2>
<h3 id="111-自旋锁">11.1 自旋锁</h3>
<p>自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于<strong>共享数据的锁定状态很短</strong>的场景。</p>
<p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
<h3 id="112-锁消除">11.2 锁消除</h3>
<p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p>
<p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>
<h3 id="113-锁粗化">11.3 锁粗化</h3>
<p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。</p>
<h3 id="114-轻量级锁">11.4 轻量级锁</h3>
<p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p>
<p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p>
<h3 id="115-偏向锁">11.5 偏向锁</h3>
<p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p>
<hr>
<p>本文转载自：<a class="link" href="https://github.com/CyC2018/CS-Notes"  target="_blank" rel="noopener"
    >https://github.com/CyC2018/CS-Notes</a>，用于个人复习。</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/java/">Java</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
    integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
    integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
    integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="StackLaTeX()"></script>

<script>
    function StackLaTeX() {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });
    }
</script>
    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="has-image">
    <a href="/p/java-stream/">
        
        
            <div class="article-image">
                
                    <img src="https://cdn.jsdelivr.net/gh/PKUcoldkeyboard/image-hosting@master/20210503/bridge-5621201_1920.6p53ez4buso0.jpg" loading="lazy" data-key="java-stream" data-hash="https://cdn.jsdelivr.net/gh/PKUcoldkeyboard/image-hosting@master/20210503/bridge-5621201_1920.6p53ez4buso0.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Java-Stream常见用法</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/jvm/">
        
        
            <div class="article-image">
                
                    <img src="https://cdn.jsdelivr.net/gh/PKUcoldkeyboard/image-hosting@master/20210503/naples-122698_1920.2vb750rs8te0.jpg" loading="lazy" data-key="jvm" data-hash="https://cdn.jsdelivr.net/gh/PKUcoldkeyboard/image-hosting@master/20210503/naples-122698_1920.2vb750rs8te0.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">JVM知识点笔记</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/java-se/">
        
        
            <div class="article-image">
                
                    <img src="https://cdn.jsdelivr.net/gh/PKUcoldkeyboard/image-hosting@master/20210503/river-6021951_1920.4hwe8w8ugb20.jpg" loading="lazy" data-key="java-se" data-hash="https://cdn.jsdelivr.net/gh/PKUcoldkeyboard/image-hosting@master/20210503/river-6021951_1920.4hwe8w8ugb20.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">JavaSE知识点笔记</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/java-collection/">
        
        
            <div class="article-image">
                
                    <img src="https://cdn.jsdelivr.net/gh/PKUcoldkeyboard/image-hosting@master/20210503/antarctica-1987579_1920.4sf6q29twew0.jpg" loading="lazy" data-key="java-collection" data-hash="https://cdn.jsdelivr.net/gh/PKUcoldkeyboard/image-hosting@master/20210503/antarctica-1987579_1920.4sf6q29twew0.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Java容器知识点笔记</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/arraylist-source-code/">
        
        
            <div class="article-image">
                
                    <img src="https://cdn.jsdelivr.net/gh/PKUcoldkeyboard/image-hosting@master/20210503/man-5640540_1920.5mr5hqwq7xc0.jpg" loading="lazy" data-key="arrayList-source-code" data-hash="https://cdn.jsdelivr.net/gh/PKUcoldkeyboard/image-hosting@master/20210503/man-5640540_1920.5mr5hqwq7xc0.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">ArrayList源码分析</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>


    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2021 cuterwrite (Pang S.Z)
    </section>
    
    <section class="powerby">
        
            欢迎来到Cuterwrite的博客网站 <br/>
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="2.0.1">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css">
            </main>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"
    integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin="anonymous"></script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
