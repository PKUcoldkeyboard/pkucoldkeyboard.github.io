<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Pure 是一种新的编程模型和运行时系统，旨在在基于消息传递接口（增强使用任务利用空闲核心能力）的环境中充分利用节点内部的共享内存。Pure 通过两种方式利用共享内存：(1) 允许 rank 在等待消息到达时从彼此那里窃取工作；(2) 利用高效无锁的数据结构实现节点内各进程间高性能的消息传递和集合操作。研究者通过 micro benchmark 测试评估了 Pure 的关键消息传递和集合特性，并展示了在 CoMD 分子动力学和 miniAMR 自适应网格细化应用中，当扩展到 4096 个 rank 时，Pure 可实现高达 2.1x 的应用加速。"><title>笔记：Pure - 改进消息传递以更好地利用节点内的共享内存</title><link rel=canonical href=https://cuterwrite.top/p/pure/><link rel=stylesheet href=/scss/style.min.f34f8dc3751b7004db1c9e3cfb8c6531eac30e9af473ebc4d5858fd1775e3014.css><meta property="og:title" content="笔记：Pure - 改进消息传递以更好地利用节点内的共享内存"><meta property="og:description" content="Pure 是一种新的编程模型和运行时系统，旨在在基于消息传递接口（增强使用任务利用空闲核心能力）的环境中充分利用节点内部的共享内存。Pure 通过两种方式利用共享内存：(1) 允许 rank 在等待消息到达时从彼此那里窃取工作；(2) 利用高效无锁的数据结构实现节点内各进程间高性能的消息传递和集合操作。研究者通过 micro benchmark 测试评估了 Pure 的关键消息传递和集合特性，并展示了在 CoMD 分子动力学和 miniAMR 自适应网格细化应用中，当扩展到 4096 个 rank 时，Pure 可实现高达 2.1x 的应用加速。"><meta property="og:url" content="https://cuterwrite.top/p/pure/"><meta property="og:site_name" content="Cuterwrite's Blog"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:published_time" content="2024-03-03T01:16:00+00:00"><meta property="article:modified_time" content="2024-03-03T01:16:00+00:00"><meta property="og:image" content="https://cuterwrite-1302252842.file.myqcloud.com/img/crop_e9af4c445d695be5002248c7c814c67d195413-2024-03-04.webp"><meta name=twitter:title content="笔记：Pure - 改进消息传递以更好地利用节点内的共享内存"><meta name=twitter:description content="Pure 是一种新的编程模型和运行时系统，旨在在基于消息传递接口（增强使用任务利用空闲核心能力）的环境中充分利用节点内部的共享内存。Pure 通过两种方式利用共享内存：(1) 允许 rank 在等待消息到达时从彼此那里窃取工作；(2) 利用高效无锁的数据结构实现节点内各进程间高性能的消息传递和集合操作。研究者通过 micro benchmark 测试评估了 Pure 的关键消息传递和集合特性，并展示了在 CoMD 分子动力学和 miniAMR 自适应网格细化应用中，当扩展到 4096 个 rank 时，Pure 可实现高达 2.1x 的应用加速。"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cuterwrite-1302252842.file.myqcloud.com/img/crop_e9af4c445d695be5002248c7c814c67d195413-2024-03-04.webp"><link rel="shortcut icon" href=/favicon.ico></head><body class="article-page
line-numbers"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hue4d14694a57c01a222a16c47db12c89c_369633_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>😉</span></figure><div class=site-meta><h1 class=site-name><a href=/>Cuterwrite's Blog</a></h1><h2 class=site-description>欢迎来到我的个人博客。我是cuterwrite，一个热爱生活、不断探索的人。在这里，我分享我的想法、经验和学习，希望可以帮助到你，也欢迎你与我分享你的看法。</h2></div></header><ol class=social-menu><li><a href=https://github.com/PKUcoldkeyboard target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://cuterwrite.top/index.xml target=_blank title=rss rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li><li><a href=https://www.zhihu.com/people/kong-tiao-cheng-tai-lang-30-57 target=_blank title=zhihu rel=me><svg t="1705591931290" class="icon" viewBox="0 0 1280 1024" xmlns="http://www.w3.org/2000/svg" p-id="21048" width="32" height="32"><path d="M341.08 296.26v435.08l46.86.02 15.42 52.74 84.02-52.74h99.06V296.26H341.08zm195.5 387.86H480.7l-55.8 35.02-10.16-34.94-23.8-.08V343.5h145.64v340.62zM299.66 495.34H195c3.48-54.2 4.4-103.18 4.4-146.92h102.32s3.94-45.12-17.16-44.62h-177c6.98-26.24 15.74-53.32 26.24-81.34.0.0-48.14.0-64.54 43.14-6.78 17.8-26.42 86.28-61.4 156.24 11.78-1.28 50.74-2.36 73.68-44.42 4.22-11.78 5.02-13.32 10.28-29.06h57.74c0 21-2.4 133.76-3.36 146.88H41.66c-23.48.0-31.12 47.24-31.12 47.24H141.7C132.9 642.2 85.66 726.24.0 792.68c40.98 11.7 81.82-1.86 102-19.8.0.0 45.96-41.8 71.18-138.5L281.1 764.26s15.82-53.78-2.48-79.98c-15.16-17.84-56.12-66.12-73.58-83.62L175.8 623.9c8.72-27.96 13.98-55.1 15.74-81.34h123.3s-.18-47.24-15.18-47.24v.02zm824.04-3.2c41.66-51.28 89.96-117.14 89.96-117.14s-37.3-29.6-54.76-8.12c-12 16.3-73.66 96.4-73.66 96.4l38.46 28.86zM823.52 373.96c-18.02-16.5-51.82 4.26-51.82 4.26s79.04 110.08 82.24 114.9l38.92-27.46s-51.34-75.22-69.32-91.72h-.02zM1280 516.7c-39.56.0-261.82 1.86-262.12 1.86v-202c9.62.0 24.84-.8 45.7-2.4 81.76-4.82 140.26-8 175.54-9.62.0.0 24.44-54.38-1.18-66.88-6.14-2.36-46.34 9.16-46.34 9.16s-330.44 32.98-464.72 36.1c3.2 17.64 15.24 34.16 31.56 39.1 26.62 6.96 45.38 3.4 98.3 1.78 49.66-3.2 87.36-4.86 113.02-4.86v199.62H702.82s5.64 44.62 51.02 45.7h215.88V706.1c0 27.94-22.38 43.98-48.96 42.24-28.16.22-52.16-2.3-83.38-3.62 3.98 7.94 12.66 28.78 38.62 43.68 19.76 9.62 32.34 13.14 52.04 13.14 59.12.0 91.34-34.56 89.78-90.62V564.28h244.72c19.36.0 17.4-47.56 17.4-47.56l.06-.02z" fill="#707070" p-id="21049"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>主页 | Home</span></a></li><li><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>关于 | About</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>归档 | Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>搜索 | Search</span></a></li><li><a href=/image-hosting/ target=_blank><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 1024 1024" stroke-width="2" stroke="currentcolor" fill="currentcolor" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M160.01219 128C142.336 128 128 142.336 128 160.01219v704C128 881.664 142.336 896 160.01219 896h298.666667c17.65181.0 31.98781-14.336 31.98781-32.01219V160.036571c0-17.67619-14.336-32.01219-32.012191-32.01219H160.01219zm26.648381 58.660571H432.030476v650.678858H186.660571V186.660571zM565.345524 128c-17.67619.0-32.01219 14.336-32.012191 32.01219v298.666667c0 17.65181 14.336 31.98781 32.012191 31.98781H864.01219c17.65181.0 31.98781-14.336 31.98781-32.012191V160.01219c0-17.65181-14.336-31.98781-32.01219-31.987809H565.321143zm26.648381 58.660571h245.345524V432.030476H591.969524V186.660571zM533.333333 565.345524c0-17.67619 14.336-32.01219 32.012191-32.012191H864.01219c17.65181.0 31.98781 14.336 31.98781 32.012191V864.01219C896 881.664 881.664 896 863.98781 896H565.321143a31.98781 31.98781.0 01-31.98781-32.01219V565.321143zm58.660572 271.993905h245.345524V591.969524H591.969524v245.345524z"/></svg><span>图册 | Gallery</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ul><li><a href=#citation>Citation</a></li><li><a href=#关键词>关键词</a></li><li><a href=#摘要>摘要</a></li><li><a href=#1-引言>1. 引言</a></li><li><a href=#2-pure-使用示例>2. Pure 使用示例</a></li><li><a href=#3-编程模型>3. 编程模型</a><ul><li><a href=#消息传递和集合通信操作>消息传递和集合通信操作</a></li><li><a href=#pure-task>Pure Task</a></li></ul></li><li><a href=#4-运行时系统>4. 运行时系统</a><ul><li><a href=#rank-初始化与映射>Rank 初始化与映射</a></li><li><a href=#spin-steal-waiting-loop-ssw-loop>Spin-Steal Waiting Loop (SSW-Loop)</a></li><li><a href=#实现复杂度>实现复杂度</a></li><li><a href=#点对点通信>点对点通信</a></li><li><a href=#集合通信>集合通信</a></li><li><a href=#任务调度器>任务调度器</a></li></ul></li><li><a href=#评估>评估</a><ul><li><a href=#nas-dt-基准测试>NAS DT 基准测试</a></li><li><a href=#comd-和-miniamr-基准测试>CoMD 和 miniAMR 基准测试</a></li><li><a href=#集合通信性能>集合通信性能</a></li></ul></li><li><a href=#相关工作>相关工作</a></li><li><a href=#总结>总结</a></li></ul></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/pure/><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/crop_e9af4c445d695be5002248c7c814c67d195413-2024-03-04.webp loading=lazy alt="Featured image of post 笔记：Pure - 改进消息传递以更好地利用节点内的共享内存"></a></div><div class=article-details><header class=article-category><a href=/categories/research/ style=background-color:#acb6d2;color:#fff>科研相关</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/pure/>笔记：Pure - 改进消息传递以更好地利用节点内的共享内存</a></h2><h3 class=article-subtitle>Pure 是一种新的编程模型和运行时系统，旨在在基于消息传递接口（增强使用任务利用空闲核心能力）的环境中充分利用节点内部的共享内存。Pure 通过两种方式利用共享内存：(1) 允许 rank 在等待消息到达时从彼此那里窃取工作；(2) 利用高效无锁的数据结构实现节点内各进程间高性能的消息传递和集合操作。研究者通过 micro benchmark 测试评估了 Pure 的关键消息传递和集合特性，并展示了在 CoMD 分子动力学和 miniAMR 自适应网格细化应用中，当扩展到 4096 个 rank 时，Pure 可实现高达 2.1x 的应用加速。</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>2024-03-03</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 19 分钟</time></div></footer></div></header><section class=article-content><h1 id=笔记pure-改进消息传递以更好地利用节点内的共享内存>笔记：Pure: 改进消息传递以更好地利用节点内的共享内存</h1><h2 id=citation>Citation</h2><p>James Psota and Armando Solar-Lezama. 2024. Pure: Evolving Message Passing To Better Leverage Shared Memory Within Nodes. In Proceedings of the 29th ACM SIGPLAN Annual Symposium on Principles and Practice of Parallel Programming (<strong>PPoPP &lsquo;24</strong>). Association for Computing Machinery, New York, NY, USA, 133–146. <a class=link href=https://doi.org/10.1145/3627535.3638503 target=_blank rel=noopener>https://doi.org/10.1145/3627535.3638503
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><h2 id=关键词>关键词</h2><p>parallel programming models; distributed runtime systems; task-based parallelism; concurrent data structures; lock-free data structures</p><h2 id=摘要>摘要</h2><p>Pure 是一种新的编程模型和运行时系统，旨在在基于消息传递接口（增强使用任务利用空闲核心能力）的环境中充分利用节点内部的共享内存。Pure 通过两种方式利用共享内存：(1) 允许 rank 在等待消息到达时从彼此那里窃取工作；(2) 利用高效无锁的数据结构实现节点内各进程间高性能的消息传递和集合操作。研究者通过 micro benchmark 测试评估了 Pure 的关键消息传递和集合特性，并展示了在 CoMD 分子动力学和 miniAMR 自适应网格细化应用中，当扩展到 4096 个 rank 时，Pure 可实现高达 <strong>2.1x</strong> 的应用加速。</p><h2 id=1-引言>1. 引言</h2><p>在过去的几十年里，高性能计算从大型向量机转向由单处理器机器组成的集群并通过网络连接。MPI 成为分布式内存机器上并行编程的标准方法。随着硬件发展为多核集群，节点内的核心共享内存并通过网络通信，社区一直在寻找新范式以更充分地利用现代集群。目前主要有两种方法：一是保持统一的 MPI 编程方法，改进 MPI 运行时系统以更好地利用共享内存；二是采用 MPI+X 等混合编程方法，在节点内部使用共享内存并行性，而在节点之间仍使用 MPI。<strong>然而，这些方法要么可能受限于 MPI 标准对接口行为的规定而无法充分发挥性能，要么给程序员带来管理优化两个编程模型的挑战</strong>。</p><p>社区已经尝试了许多其他方法，其中包括<strong>PGAS</strong>模型，它提供了一种集群范围内的共享内存假象，以及诸如<strong>Legion、Chapel</strong>和<strong>X10</strong>等隐式并行编程语言，这些语言为程序员提供了更高级别的抽象，并试图自动有效地协调应用程序。尽管取得了进展且新方法不断涌现，但现代 HPC 应用中仍有相当一部分仍在使用 MPI。<strong>MPC</strong>和<strong>AMPI</strong>也同样将线程作为 MPI Rank，并努力利用内部的共享内存来提高性能。</p><p>然而，仅使用 MPI 的方法往往胜过混合编程方法。这很大程度上可能由于接口的局限性以及无法充分利用节点内的共享内存，导致 MPI 未能发挥出很多潜在性能。因此，论文提出的 Pure 系统建立在 MPI-everywhere 方法之上，打破了一些 MPI 的假设，更有效地利用共享内存，同时不需要对程序进行重大重写。它是一个与 MPI 相似的编程模型，从而能够利用上 HPC 社区现有的 MPI 知识和现有应用程序基础。</p><p>Pure 设计灵感来源于 MPI，其编程模型本质上是消息传递，并可选择性地利用任务。不过，Pure 打破了对使用进程级别 rank 以及支持旧版语言的限制，使用线程作为 rank 而不是进程，如此一来能够高效地运用轻量级、无锁同步机制，在同一节点内各线程间进行协调。基于线程化的 rank，Pure 构建了高效的节点内部集体操作功能，利用高效的无锁算法实现这一目标。此外，Pure 允许应用程序的部分并行代码块以标准 C++ lambda 表达式形式运行，这些表达式可以被拥有 rank 和其他空闲 rank 自动且并发地执行，所有这一切均由 Pure Runtime 运行时系统自动调度。将 Pure Runtime 运行时系统的职责扩展至包括可选的并发任务执行具有重要价值，因为它使得 Pure Runtime 运行时系统能够在无需程序员编排的情况下，高效地自动化重叠通信与计算过程。</p><p>论文提出的优化策略包括：</p><ul><li>小消息和大数据消息都适用的无锁消息传递方法。</li><li>用于实现集合通信算法的无锁数据结构。</li><li>允许空闲线程从其他线程高效窃取工作的无锁任务调度器。</li></ul><p>作者采用标准 C++库以确保广泛兼容性，并展示出相较于高度优化的 MPI 基准有显著的性能提升。同时，作者也证明了 Pure 编程模型在语义上与 MPI 相似，这意味着学习并从现有应用程序迁移至 Pure 十分直接简便，并且展示了源码到源码的转换工具 mpi2pure 。总的来说，论文的主要贡献如下：</p><ol><li>引入一种编程模型及运行时系统，它有效地整合了消息传递与任务并行性，利用标准 C++特性实现。</li><li>展示了现代 C++如何帮助支持更灵活的并行运行时系统应用接口。</li><li>描述了一种设计良好的无锁、多线程和分布式运行时系统，相比 MPI，在节点内部获得了显著的速度提升。</li><li>证明仅需要对现有 MPI 应用程序进行最小程度的源代码修改，就能在 micro benchmark 测试和三个实际应用中获得相较于最先进的 MPI 实现的显著性能提升。</li></ol><h2 id=2-pure-使用示例>2. Pure 使用示例</h2><p>首先通过一个简单的示例程序来说明如何使用 Pure。尽管该应用程序是一个简单的 1-D stencil 算法，但通过这个例子可以展示出 Pure 的基本原理及其与 MPI 的共同之处，从而帮助开发者编写更复杂的应用程序。</p><p>在 MPI 版本的实现代码 <code>rand_stencil_mpi</code> 中，大部分计算工作集中在函数 <code>random_work</code> 中执行。简单来说，<code>rand_stencil_mpi</code> 函数首先会进入一个循环，迭代次数为 <code>iters</code> ，在数组 <code>a</code> 的每个元素上计算 <code>random_work</code> 。值得注意的是，<code>random_work</code> 执行的时间长度是可变且未知的，因此会引入负载不平衡。此外，<code>random_work</code> 不会修改数组 <code>a</code> 的内容，而是接着通过对相邻元素求平均值更新数组 <code>a</code> 。最后，程序利用 <code>MPI_Send</code> 和 <code>MPI_Recv</code> 交换 <code>temp</code> 数组的首尾元素，以便计算数组 <code>a</code> 的首尾元素。由于 <code>random_work</code> 所需时间长短不一，某些处理单元会提前完成任务，有时会在等待发送方较慢的 <code>MPI_Recv</code> 调用时陷入阻塞状态。</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/1D_stencil-2024-03-14.webp alt=1D_stencil-2024-03-14 width=auto loading=lazy></figure><div class="notice notice-info"><div class=notice-title><svg t="1705940100069" class="icon notice-icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="6252" width="200" height="200"><path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4.0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4.0 8 3.6 8 8v272zm-32-344c-26.5.0-48-21.5-48-48s21.5-48 48-48 48 21.5 48 48-21.5 48-48 48z" p-id="6253" fill="#fff"/></svg></div><p>示例 1：1-D Stencil with Random Work, MPI Version</p></div><pre><code class=language-cpp>void rand_stencil_mpi(double* const a, size_t arr_sz, size_t iters, int my_rank,
                      int n_ranks) {
  double temp[arr_sz];
  for (auto it = 0; it &lt; iters; ++it) {
    for (auto i = 0; i &lt; arr_sz; ++i) {
      temp[i] = random_work(a[i]);
    }
    for (auto i = 1; i &lt; arr_sz - 1; ++i) {
      a[i] = (temp[i - 1] + temp[i] + temp[i + 1]) / 3.0;
    }
    if (my_rank &gt; 0) {
      MPI_Send(&amp;temp[0], 1, MPI_DOUBLE, my_rank - 1, 0, MPI_COMM_WORLD);
      double neighbor_hi_val;
      MPI_Recv(&amp;neighbor_hi_val, 1, MPI_DOUBLE, my_rank - 1, 0, MPI_COMM_WORLD,
               MPI_STATUS_IGNORE);
      a[0] = (neighbor_hi_val + temp[0] + temp[1]) / 3.0;
    }  // ends if not first rank
    if (my_rank &lt; n_ranks - 1) {
      MPI_Send(&amp;temp[arr_sz - 1], 1, MPI_DOUBLE, my_rank + 1, 0,
               MPI_COMM_WORLD);
      double neighbor_lo_val;
      MPI_Recv(&amp;neighbor_lo_val, 1, MPI_DOUBLE, my_rank + 1, 0, MPI_COMM_WORLD,
               MPI_STATUS_IGNORE);
      a[arr_sz - 1] =
          (temp[arr_sz - 2] + temp[arr_sz - 1] + neighbor_lo_val) / 3.0;
    }  // ends if not last rank
  }    // ends for all iterations
}

</code></pre><p>示例 2 则展示了实现同样功能的 Pure 版本。其中存在一些关键差异。首先，消息调用函数接口不同，使用的是相应的 Pure 消息传递函数 <code>pure_send_msg</code> 和 <code>pure_recv_msg</code> ，而非 MPI 调用，但参数实质上与 MPI 对应函数基本相同。Pure 的消息传递语义类似于 MPI：发送端缓冲区被复制到接收端缓冲区。实现区别主要在于：Pure 在<strong>节点内部采用了轻量级的消息传递方法</strong>，从而在节点内的消息传递比 MPI 的延迟更低。</p><div class="notice notice-info"><div class=notice-title><svg t="1705940100069" class="icon notice-icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="6252" width="200" height="200"><path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4.0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4.0 8 3.6 8 8v272zm-32-344c-26.5.0-48-21.5-48-48s21.5-48 48-48 48 21.5 48 48-21.5 48-48 48z" p-id="6253" fill="#fff"/></svg></div><p>示例 2：Pure 版本</p></div><pre><code class=language-cpp>void rand_stencil_pure(double* a, const int arr_sz, const int n_iter,
                       const int my_rank, const int n_ranks) {
  double temp[arr_sz];
  PureTask rand_work_task = [a, temp, arr_sz, my_rank](
                                chunk_id_t start_chunk, chunk_id_t end_chunk,
                                std::optinal&lt;void&gt; cont_params) {
    auto [min_idx, max_idx] =
        pure_aligned_idx_range&lt;double&gt;(arr_sz, start_chunk, end_chunk);
    for (auto i = min_idx; i &lt; max_idx; i++) {
      temp[i] = random_work(a[i]);
    }
  };  // ends definding the Pure Task for rand_work_task
  for (auto it = 0; it &lt; n_iter; it++) {
    rand_work_task.execute();  // execute all chunks of rank_work_task
    for (auto i = 1; i &lt; arr_sz - 1; ++i) {
      a[i] = (temp[i - 1] + temp[i] + temp[i + 1]) / 3.0;
    }
    if (my_rank &gt; 0) {
      pure_send_msg(&amp;temp[0], 1, MPI_DOUBLE, my_rank - 1, 0, PURE_COMM_WORLD);
      double neighbor_hi_val;
      pure_recv_msg(&amp;neighbor_hi_val, 1, MPI_DOUBLE, my_rank - 1, 0,
                    PURE_COMM_WORLD);
      a[0] = (neighbor_hi_val + temp[0] + temp[1]) / 3.0;
    }  // ends if not first rank
    if (my_rank &lt; n_ranks - 1) {
      pure_send_msg(&amp;temp[arr_sz - 1], 1, MPI_DOUBLE, my_rank + 1, 0,
                    PURE_COMM_WORLD);
      double neighbor_lo_val;
      pure_recv_msg(&amp;neighbor_lo_val, 1, MPI_DOUBLE, my_rank + 1, 0,
                    PURE_COMM_WORLD);
      a[arr_sz - 1] =
          (temp[arr_sz - 2] + temp[arr_sz - 1] + neighbor_lo_val) / 3.0;
    }  // ends if not last rank
  }    // ends definding the Pure Task for rand_work_task
}

</code></pre><p>更重要的差异在于 Pure 中增加的 <strong>Pure Task</strong> ，用带有一组特定参数定义的 lambda 表达式，其利用 lambda 的捕获参数特性，允许外部于 lambda 体内的变量以值或引用形式被捕获并在 lambda 执行时使用。Pure Task 可以被视为由 Pure Runtime 运行时系统负责执行应用程序代码片段，可以通过多线程并发执行。因此，Pure 任务应结构化为类似数据并行的形式。此外，PureTask 需要由程序员保证线程安全。</p><p>在以上 Pure 实现中，程序员可以利用 chunk ranges 来描述并发性。这些子范围或 chunk 是通过 <code>start_chunk</code> 和 <code>end_chunk</code> 参数传递给 Pure Task 的，而它们是由 Pure Runtime 运行时系统提供。Pure Runtime 运行时系统负责确保所有工作顺利完成。由于可能涉及到不同的多个线程，Pure Runtime 运行时系统会通过追踪哪些 chunk 已分配和完成来实现这一点。</p><p>其次，程序员需要将 Pure Runtime 运行时系统提供的 <code>start_chunk</code> 和 <code>end_chunk</code> 参数映射到与应用计算相关的具体内容上。在这里，代码使用了 <code>pure_aligned_idx_range</code> 辅助函数将其转化为循环索引子范围。这个辅助函数考虑到了缓存行，所以有利于避免伪共享问题。</p><p>由于 <code>random_work</code> 引入了负载不平衡，因此某些 rank 不可避免地会等待其他 rank 发送消息。Pure 任务调度器自动利用这些空闲 rank ，在同一节点内执行待执行的 Pure 任务块。以下图中在同一节点内的三个 rank 为例：<strong>rank 0</strong> 正在执行一个被划分为 6 个 chunks 的 Pure Task，而 <strong>rank 1</strong> 和 <strong>rank 2</strong> 因为接收消息而阻塞。</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/timeline-2024-03-14.png alt=timeline-2024-03-14 width=auto loading=lazy><figcaption><h4>示例 Pure 代码的时间线示意图</h4></figcaption></figure><p>可以观察到：</p><ul><li>rank 0 首先处理 chunk 0 。</li><li>rank 1 窃取且并行执行 chunk 1 。</li><li>Pure 任务调度器接着将 chunk 2 分配给 rank 0，把 chunk 3 分配给 rank 1 。</li><li>rank 2 尝试窃取 task 并得到 chunk 4 。由于 <code>random_work</code> 的随机特性，chunk 2 和 chunk 4 事实上是耗时较长的任务量。</li><li>chunk 5 被分配给 rank 0，这部分任务量较小，以至于 rank 2 完成 chunk 4 之前就已经结束。</li><li>调度器确保所有 chunks 都完成之前，rank 0 不会返回。这里直到 chunk 4 完成之后 rank 0 才会返回。</li><li>当 rank 1 和 rank 2 还处于阻塞状态时，它们会继续尝试从任何其它 rank 中窃取更多的 chunks。</li><li>由于 lambda 支持变量捕获，因此可以在不同 rank 之间高效共享上下文信息。</li></ul><p>实验结果表明，在单节点上使用 32 个 rank 运行的 Pure 版本时，由于更快的消息传递速度和 Pure Task 的使用，Pure 版本相比 MPI 版本获得了 10% 的速度提升，并且在存在负载不均衡的情况下实现了超过 200% 的加速。尽管这些提升取决于负载不均衡的程度，但在实际应用中，Pure 也能取得类似的性能提升。这是因为 Pure Runtime 运行时系统能够自动识别并有效利用闲置计算资源。</p><h2 id=3-编程模型>3. 编程模型</h2><p>Pure 的编程模型可以概述为”带有可选任务的消息传递“。Pure 的消息传递和集合通信操作在语义上与 MPI 等效，只是存在一些语法上的细微差异。</p><p>尽管在节点内使用了线程，Pure 的 rank 命名空间在整个节点间仍是非层级结构的。此外，在 Pure 程序的生命周期内，rank 的数量不会发生改变。</p><p>Pure 采用 C++ 编写，并通过 SPMD 方式运行，其内部实现了多线程化。同一节点内的所有 rank 都是通过内核线程来实现。</p><p><strong>Pure 应用程序并不支持全局变量</strong>，所以应当移除或者使用 thread_local 关键字来限制变量的作用域，从而保证线程安全。</p><p>针对包含负载不均衡问题的应用程序，程序员可在满足以下条件的部分应用中使用 Pure Task：</p><ol><li>计算密集型热点区域</li><li>可以被构造为并发执行</li></ol><h3 id=消息传递和集合通信操作>消息传递和集合通信操作</h3><p>Pure 消息传递中的 <code>pure_send_msg</code> 和 <code>pure_recv_msg</code> 函数与 MPI 中的 <code>MPI_Send</code> 和 <code>MPI_Recv</code> 函数类似。同时，Pure 也提供了非阻塞版本。</p><p>Pure Runtime 运行时系统会保证消息最终会送达且按发送顺序交付。而且，Pure 还实现以下集合通信操作：</p><ul><li>Reduce</li><li>All-Reduce</li><li>Barrier</li><li>Broadcast</li></ul><p>除此之外，Pure 还设计了通信子的概念，可以通过 <code>pure_comm_split</code> 函数将通信子分割为更小的子集。</p><p>Pure 应用程序应当使用现代 C++ 编写，必须指定 <code>std=c++11</code> 或更高版本来对其进行编译。Pure 的分发包中包含了一个基于 Make 的构建系统，其自动设置了恰当的编译器选项，并且链接好了 Pure Runtime 运行时系统，即 <code>libpure</code> ，定义了一系列用于调试和性能分析的 Target。</p><h3 id=pure-task>Pure Task</h3><p>首先，Pure Task 允许程序员描述应用程序中的计算部分如何能够被分解为 chunks ，这些 chunks 可以由 Pure Runtime 运行时系统自动地并发执行。</p><p>需要注意的是，Pure Task 并不是一个必须选项，只有当任务能被划分为多个小块且有助于解决负载不均衡问题时，才应该使用 Pure Task。</p><p>其次，Pure Task 使用 C++ Lambda 表达式实现，并且拥有该任务的 rank 调用 <code>execute</code> 方法时同步执行。任何给定的 rank 在同一时间内至多只能执行一个任务。由于 C++ Lambda 表达式支持变量捕获，因此可以高效地在执行任务不同 chunks 的不同 rank 之间共享上下文信息。通常情况下，同一个任务在应用程序运行过程中定义一次并多次执行，如科学应用中每一个时间步的迭代。</p><p>再次，Pure Task 在定义时需要指定 chunk 的数量，以及来自应用程序的额外参数。任务间还必须避免依赖关系，但由于它们会在 <code>execute</code> 调用期间完全执行，因此它们的执行不会与任务外部的代码发生竞争。</p><p>此外，Pure Task 具有一个名为 <code>execute</code> 的方法，该方法由应用程序代码调用，并接受一个 <code>optional&lt;void*> per_exe_args</code> 参数，运行时将其传递给任务进行每一次的调用。当任务主体的输入值在连续执行任务时发生变化时，这个功能会非常有用。例如，程序员可以在堆栈上定义一个局部结构体，并将指向它的指针传递给 <code>execute</code> 方法。</p><p>另外，Pure Task 的前两个参数是无符号整数 <code>start_chunk</code> 和 <code>end_chunk</code> ，用于指定要执行的 chunk 的范围。chunk 参数则由 Pure Runtime 运行时系统分配以确保所有 chunks 仅被精确地执行一次，即使这些 chunks 可能同时并发执行且乱序。</p><p>值得一提的是，Pure Task 使用 chunk 范围赋予调度程序灵活性，以便一次性分配多个 chunk。chunks 数量由 Pure 任务调度器决定，但是不会超过 Makefile 文件中定义的 <code>PURE_MAX_TASK_CHUNKS</code> 。</p><p>除此之外，当前实现的接口需要手动将 chunk 编号转换为数组索引，这对于多维数组来说这项工作尤为繁琐。因此作者的目标是扩展当前接口，提供更简洁、更高级的接口，类似于 TBB 的 <code>parallel_for</code> 。</p><p>最后，程序员需要确保在 Pure Task 定义内部的实现线程安全，以防止同一任务的多个并发执行的 chunk 相互竞争。在后续的 CoMD 分子动力学 Benchmark 中，就不得不处理多个线程同时写入同一内存位置的问题，因此需要使用 <code>std::atomic</code> 数组代替 <code>int</code> 数组。</p><h2 id=4-运行时系统>4. 运行时系统</h2><p>Pure 的运行时系统实现为一个多线程和分布式运行时的动态库。Pure 应用程序开发时需要引入 <code>pure.h</code> 头文件，并使用 C++17 编译选项构建，然后链接 <code>libpure</code> 库。Pure 运行时系统会自动寻找并透明地利用计算与通信的重叠机会，这通常发生在高延迟通信事件期间。</p><p>总的来说，Pure 运行时系统的职责为：</p><ul><li>创建并绑定必要的进程以及线程，启动应用程序。</li><li>管理节点内各个 rank 之间的通信和集合操作。</li><li>管理内部的内存缓冲区和数据结构。</li><li>如果定义了 Pure Task，则需要负责调度和执行这些任务。</li></ul><h3 id=rank-初始化与映射>Rank 初始化与映射</h3><p>Pure rank 作为 MPI 进程的内核线程实现。在内部机制上，Pure 在多节点应用中运行 MPI 以支持跨节点通信，而在单节点运行时则完全不使用 MPI ，但 Pure 应用程序不能直接调用 MPI 函数。Pure 程序可通过 Makefile 配置，使其在一个节点或 NUMA 节点上运行一个 MPI 进程，并按每个节点或 NUMA 节点的核心数来运行相同数量的线程。应用程序程序员只知道非层次结构的 rank 命名空间，而节点、线程、MPI 进程、可变延迟等概念均被抽象化，对程序员不可见。</p><p>类似于 MPI ，Pure 支持任意方式将 rank 映射到节点上。默认情况下，Pure 采用 SMP 风格的分配策略放置 rank ，但同时支持任意 rank 到节点再到核心的映射。Pure 还支持 CrayPAT 的 rank 重排文件。虽然这些层次化的硬件细节从程序员角度看已被抽象，但 Pure 在内部会利用这些信息优化关键功能。</p><p>当 Pure 应用程序启动时，并不会直接调用应用程序原始的 <code>main</code> 函数。底层的 MPI 程序包含了定义在 Pure 运行时系统中的 <code>main</code> 函数。这个函数首先初始化 Pure 核心的数据结构，然后 fork 并绑定线程，这些线程各自运行一个 <code>original_main</code> 函数，这是从应用程序代码中原始 <code>main</code> 函数的改名版本。当应用程序完成执行后，该应用程序的 <code>__original_main</code> 函数返回至 Pure 运行时系统，后者接着完成 MPI 的终止过程，清理资源。</p><h3 id=spin-steal-waiting-loop-ssw-loop>Spin-Steal Waiting Loop (SSW-Loop)</h3><p>当 Pure rank 遇到阻塞事件，例如等待消息到达时，它必须进行等待。然而，在 Pure 中，它会执行<strong>自旋、窃取等待循环（SSW-Loop）</strong>，而非简单地放弃或空闲等待。这个循环会检查阻塞条件，例如消息是否已到达，如若未到达，则尝试窃取其它 rank 的任务。若该被阻塞的 rank 能够帮助其进程中恰好处于并发执行状态的其它线程完成任务，那么就会进行协助。</p><p>鉴于线程固定在 CPU ，并且每个 rank 仅运行一个应用程序，我们选择主动进行自旋等待而非让出 CPU 。SSW-Loop 使得计算中的 rank 具备“多态性”，一方面既要作为主程序的计算节点，另一方面也要协助其它 rank 执行窃取到的任务 chunk ，然后再检查其自身所关注的阻塞事件。</p><p>Pure 采取优先处理 rank 拥有的窃取到的任务负载的策略，遵循以任务负载优先的调度策略。</p><p>相对于利用辅助线程来实现工作负载窃取或通信的系统，Pure 的独特之处在于由应用级别的计算节点直接执行窃取操作。</p><h3 id=实现复杂度>实现复杂度</h3><p>Pure 使用 C++17 标准库进行编写。Pure 运行时系统包含 21,000 行源代码，而 Pure 工具则另外包含大约 14,000 行源代码。Pure 已经在笔记本电脑和集群上进行了测试，所需环境仅为支持 C++17 的编译器、类 Unix 操作系统以及 MPI 。Pure 的源代码可从 <a class=link href=https://github.com/psota/pure target=_blank rel=noopener>https://github.com/psota/pure
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a>获取。</p><h3 id=点对点通信>点对点通信</h3><p>Pure 实现了阻塞和非阻塞的点对点消息传递，语义上等同于 MPI 的消息传递。</p><p>在 Pure 内部，消息传递有三种不同的策略，具体采用哪种方法取决于消息的大小以及发送方和接收方是否位于同一节点内。</p><p>对于整个生命周期，Pure 会分配一个持久存在的 Channel 对象，该对象存储在运行时系统中并会在整个程序中复用。内部 Channel Manager 会将消息参数映射到合适的数据结构，按需创建。</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/strategy-2024-03-15.webp alt=strategy-2024-03-15 width=auto loading=lazy><figcaption><h4>Pure 消息传递策略</h4></figcaption></figure><ul><li>对于同一节点内的短消息（&lt;8KB）<ul><li>实现了一种带有 acquire-release 内存语义的无锁循环队列。发送线程在空间可用时将消息复制到 PureBufferQueue（PBQ）中，接收线程在消息可用时将其拷贝出来。<ul><li>在短消息传递中，拷贝的开销相对较小，这样可以让发送方调用返回后立即执行执行其它有用的工作。</li></ul></li><li>两个线程均采用 SSW-Loop 进行等待，尽可能地实现计算与通信的自动重叠。</li><li>使用一个连续的缓冲区来存储所有消息的 slot ，并通过简单指针算术使其每个 slot 对齐缓存行边界，以避免写入的发送线程与读取的接收线程之间产生伪共享。</li></ul></li><li>对于同一节点内的大消息（>=8KB）<ul><li>采取类似于 PBQ 的策略，但采用从发送方直接到接收方的单次内存拷贝，灵感来源于 MPI 的 rendezvous 模式。</li><li>无锁的固定大小循环缓冲区来存储接收方的接收调用参数，</li><li>发送方通过 SSW-Loop 等待元数据队列项，然后直接将消息有效负载复制到接收方期望的缓冲区中。发送方通过插入传输的字节数量到不同的无锁队列中，以此通知接收方完成传输。</li></ul></li><li>不同节点间的消息<ul><li>透明地调用 MPI 接口</li><li>在 Pure 初始化期间使用分布式一致性算法创建一个 <code>thread-rank-process-node</code> 映射数据结构，用于将 Pure rank 转换为给定通信器内的 MPI rank。</li><li>为了确保接收节点上的正确接收线程接收到对应消息，需要在 <code>MPI_TAG</code> 中编码发送线程号和接收线程号以解决多线程路由问题。</li></ul></li></ul><h3 id=集合通信>集合通信</h3><p>Pure 中的集体通信操作语义与 MPI 等效，且在节点内采用自下而上构建的数据结构实现。尽管跨节点使用 MPI 集合操作，但在单节点和多节点基准测试中仍实现了显著的速度提升。</p><p>Pure 的方案是有一个领导者线程（leader）协调集体过程，利用其它线程协助计算并按需调用 MPI 集合函数。</p><ul><li>Pure 采用静态领导者选举方法，优于基于比较和交换的“首先进入”方法。</li></ul><p>以下仅以 All-Reduce 为例子，其它集合通信操作思想类似。</p><p>对于小数据的 All-Reduce 操作，Pure 设计了名为 Sequenced Per-Thread Dropbox (SPTD) 的并发数据结构，提供了一种高效的无锁机制，用于在领导线程和其他非领导线程之间对偶同步和可选共享数据。</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/SPTD-2024-03-15.webp alt=SPTD-2024-03-15 width=auto loading=lazy><figcaption><h4>Sequenced Per-Thread Dropbox (SPTD)</h4></figcaption></figure><p>该方法借鉴了 flat-combinding 技术，将通信器中的线程 0 作为领导者线程。</p><ul><li>对于大小不超过 2KB 的数组<ul><li>首先每个非领导者线程将其数据复制到 SPTD 中，然后与领导者线程一对一同步以表明其输入值已准备就绪（使用原子序列号，而不是共享原子计数器）。</li><li>领导者线程执行针对所有输入数组的逐元素 Reduce 计算。</li><li>每个节点上的领导者线程利用 <code>MPI_Allreduce</code> 函数对该节点内的 Reduce 结果进一步进行全局 Reduce 。</li><li>领导者线程进行同步，各个非领导者线程将最终 Reduce 值分别拷贝到各自的私有结果缓冲区。</li><li>所有线程在等待时会进行 SSW-Loop 操作。</li></ul></li><li>对于大小超过 2KB 的数组，实际的 Reduce 计算开始成为性能瓶颈，因而需要尽可能利用所有线程并发执行 Reduce 计算，并通过共享内存直接从每个线程的输入输出缓冲区拉取数据或将 Reduce 结果写入缓冲区。<ul><li>Reduce 工作被划分为大致相等的块，避免伪共享并实现向量化计算。</li><li>线程使用 SPTD 报告消息已准备就绪，并通过原子序列号指示计算完成。</li><li>领导者线程使用 <code>MPI_Allreduce</code> 执行跨节点 All-Reduce 操作，并通过另一个原子序列号传播最终 Reduce 后的值。</li></ul></li></ul><h3 id=任务调度器>任务调度器</h3><p>Pure 运行时系统会在共享内存中维护一个名为 <code>active_tasks</code> 的数组，其中包含指向正在执行任务的原子指针，每节点每个 rank 有一个条目，并初始化为 <code>nullptr</code> 。当一个任务被执行时，运行时会初始化相应的状态并以原子方式更新拥有该任务的 rank 在 <code>active_tasks</code> 中的条目。当 <code>active_tasks</code> 包含非空指针时，它向其他线程表明这个任务是“可供窃取的”。</p><p>当任务被初始化后，拥有该任务的 rank 开始执行多个 chunk ，其他线程在其 SSL-Loop 期间探测 <code>active_tasks</code> ，通过原子加载操作寻找非空条目。</p><p>任务的 chunk 始终由拥有者 rank 及其可能的窃取者 rank 执行。两个原子整数值 <code>curr_chunk</code> 和 <code>chunks_done</code> 驱动着整个并发执行过程。owner rank 和 thief ranks 运行相同的并发执行函数，尽管窃取者线程只执行一个 chunk 然后返回，而拥有者线程会一直执行直到所有 chunk 完成。线程使用 <code>fetch_add</code> 确定要执行哪个 chunk ，但如果其值已大于总 chunk 数量，则它们会返回。</p><p>线程还会在成功完成任何 chunk 时原子性地增加 <code>chunks_done</code> 的值；拥有者线程仅将其本地存储以避免缓存未命中。最后，拥有者 rank 等待直至所有 chunk 都执行完毕。</p><p>值得注意的是，任务的 chunk 与应用程序 rank 在同一硬件线程上执行；每一个硬件线程都分配给 Pure 应用的 rank 。目前 Pure 尚不利用硬件加速器硬件（例如 GPU）来加速任务执行，但作者相信 Pure 架构能够支持这一点。</p><p>Pure 任务调度器具有不同的 chunk 执行模式和窃取算法。例如，作者实现了单 chunk 模式和一种引导式自调度模式，这是一种工作划分算法，按照先分配（窃取）较大的工作块，随后分配（窃取）较小的工作块的方式进行。</p><p>任务调度器还具有 NUMA 感知窃取模式（优先从同一 NUMA 节点上的受害者线程窃取任务）以及一种“黏性”窃取模式，窃取者线程会返回它们最近窃取且仍处于活跃状态的任务。</p><h2 id=评估>评估</h2><p>评估实验采用的 HPC 集群是伯克利的 NERSC Cori，一共 2388 个节点，每个节点有 2 个插槽，16 核心 128GB 内存，节点互联使用了 Cray Aires。然后开启了超线程，采用了 256 位的向量宽度，实验在每个节点运行 2 个进程，32 个线程。工具链则使用的是 Intel 编译器，以及高度优化的 Cray MPICH 作为 baseline。</p><h3 id=nas-dt-基准测试>NAS DT 基准测试</h3><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/nasdt-2024-03-15.webp alt=nasdt-2024-03-15 width=auto loading=lazy></figure><ul><li>只采用更快的消息传递，则有 11%至 25%的加速比</li><li>引入 PureTasks，则能达到 1.7 倍到 2.6 倍的加速比。</li><li>辅助线程能小幅提高性能，不过仅限于剩余未使用的 CPU 核心才能使用。在这里，除了 80 个 rank 的情况下空闲了 24 个核心，其它情况下都充分利用了 CPU 核心。</li></ul><h3 id=comd-和-miniamr-基准测试>CoMD 和 miniAMR 基准测试</h3><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/benchmark-pure-2024-03-15.webp alt=benchmark-pure-2024-03-15 width=auto loading=lazy></figure><ul><li>在 CoMD 分子动力学应用上，如果没有负载不均衡的情况，可以看到 Pure 的性能在各个 rank 数下都优于 MPI 以及 MPI+OpenMP 的性能，分别达到 7%至 25%，以及 35%至 50%的加速比</li><li>在 miniAMR 自适应网格细化应用中，则实现了最少 20%，最多 50%的加速比。</li></ul><h3 id=集合通信性能>集合通信性能</h3><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/benchmark-pure-msg-2024-03-15.webp alt=benchmark-pure-msg-2024-03-15 width=auto loading=lazy></figure><h2 id=相关工作>相关工作</h2><div class=table-wrapper><table><thead><tr><th style=text-align:center>类别</th><th style=text-align:left>相关工作</th><th style=text-align:left>Pure 的优势</th></tr></thead><tbody><tr><td style=text-align:center>MPI</td><td style=text-align:left>1. 利用多核节点内的共享内存提高性能；2. XPMEM 显著提升节点内性能； 3. ch4 网络库改进了 MPI 的共享内存性能；4. 优化 MPI 集合通信；5. MPI DMAPP 库优化集合通信，但仅支持部分集合和 8B 负载；6. 优化大规模全对全集合通信；7. MPI 单边消息 API 解耦；8. 数据移动和进程同步</td><td style=text-align:left>1. 为利用共享内存做了大量工作，但 Pure 在所有集合和负载大小上都很快；2. 单边消息 API 提供了通信计算重叠的机制，但 Pure 提供了更高层的机制</td></tr><tr><td style=text-align:center>MPI 多线程</td><td style=text-align:left>1. 通过 MPI_THREAD_MULTIPLE 模式支持 rank 内多线程； 2. 大多数 MPI 实现使用全局锁来支持线程安全，导致线程序列化；3. MPI 4.0 标准通过 MPI+X 方法加强了对多线程的支持；4. MPI Fine-points 和 MPI Endpoints 引入了线程和 MPI+X 的概念</td><td style=text-align:left>1. 程序员认为在多线程代码中进行 MPI 调用很重要；2. MPI+X 方法的性能和可编程性尚不清楚；3. 与 MPI+OpenMP 相比，Pure 允许程序员使用统一的编程模型，在需要的地方引入任务</td></tr><tr><td style=text-align:center>AMPI</td><td style=text-align:left>1. 基于 Charm++构建的 MPI 兼容库；2. 提供了更高层次的并行编程抽象；3. 通过最小的源代码更改提供性能提升</td><td style=text-align:left>1. Pure 在实验中优于 AMPI，可能是由于优化的消息传递和集合，以及更细粒度和低开销的负载均衡；2. AMPI SMP 也是基于线程的，但需要每个节点至少一个工作线程</td></tr><tr><td style=text-align:center>PGAS 语言和并行框架</td><td style=text-align:left>1. PGAS 语言提供全局内存地址空间的抽象；2. Chapel 和 X10 扩展了 PGAS 方法，支持本地和远程异步任务创建；3. HPX 扩展了现代 C++标准以支持分布式操作；4. Legion 是一种数据中心并行编程系统；5. Kokkos, STAPL, BCL 等框架在应用程序和机器之间提供抽象层</td><td style=text-align:left>1. 与 Pure 类似，PGAS 模型采用 SPMD 编程风格，提供统一的编程模型，并通过引用局部性提高性能；2. 这些框架 通常利用现代 C++特性，但使用它们通常需要对现有应用程序进行重大重写</td></tr></tbody></table></div><h2 id=总结>总结</h2><p>数十年来，由于其相对的简单性和性能优势，消息传递一直被视为并行编程的标准模型。然而，本文表明，消息传递与共享内存并非不可兼容。实际上，通过设计合适的库，可以在不牺牲大多数消息传递优点的前提下充分利用共享内存。</p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer><script type=text/javascript src=/js/prism.js async></script>
<link rel=stylesheet href=https://cdn.bootcdn.net/ajax/libs/KaTeX/0.15.6/katex.min.css integrity="sha256-J+iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s=" crossorigin=anonymous><script src=https://cdn.bootcdn.net/ajax/libs/KaTeX/0.15.6/katex.min.js integrity="sha256-InsNdER1b2xUewP+pKCUJpkhiqwHgqiPXDlIk7GzBu4=" crossorigin=anonymous defer></script><script src=https://cdn.bootcdn.net/ajax/libs/KaTeX/0.15.6/contrib/auto-render.min.js integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI=" crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/science-plot/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/crop_ee40c9cb9e33ffe888365e66e0a104dc195413-2024-02-28.webp loading=lazy data-key=science-plot data-hash=https://cuterwrite-1302252842.file.myqcloud.com/img/crop_ee40c9cb9e33ffe888365e66e0a104dc195413-2024-02-28.webp></div><div class=article-details><h2 class=article-title>科研图表绘制</h2></div></a></article></div></div></aside><script>(function(){if(/^localhost|^127/.test(location.hostname))return;let e=document.createElement("script");e.src="https://giscus.app/client.js",e.dataset.repo="PKUcoldkeyboard/pkucoldkeyboard.github.io",e.dataset.repoId="MDEwOlJlcG9zaXRvcnkzMzU4NzI5OTI=",e.dataset.category="Comments",e.dataset.categoryId="DIC_kwDOFAUD4M4CZV4F",e.dataset.mapping="title",e.dataset.strict="0",e.dataset.reactionsEnabled="1",e.dataset.emitMetadata="0",e.dataset.inputPosition="top",e.dataset.theme="light",e.dataset.lang="zh-CN",e.dataset.loading="lazy",e.crossOrigin="anonymous",e.async=!0;let t=document.querySelector(".main"),n=t.childNodes[t.childNodes.length-1];t.insertBefore(e,n.nextSibling)})();function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){if(/^localhost|^127/.test(location.hostname))return;addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"light":"dark_dimmed")}})()</script><footer class=site-footer><section class=copyright>&copy;
2021 -
2024 cuterwrite</section><section class=running-time>本博客已稳定运行
<span id=runningdays class=running-days></span></section><section class=totalcount>发表了60篇文章 ·
总计259.35k字</section><section class=powerby>Welcome to cuterwrite's blog!<br>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.17.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><script>let s1="2021-4-17";s1=new Date(s1.replace(/-/g,"/"));let s2=new Date,timeDifference=s2.getTime()-s1.getTime(),days=Math.floor(timeDifference/(1e3*60*60*24)),hours=Math.floor(timeDifference%(1e3*60*60*24)/(1e3*60*60)),minutes=Math.floor(timeDifference%(1e3*60*60)/(1e3*60)),result=days+"天"+hours+"小时"+minutes+"分钟";document.getElementById("runningdays").innerHTML=result</script><script>(function(){var t,e=window;if(e.ChannelIO)return e.console.error("ChannelIO script included twice.");t=function(){t.c(arguments)},t.q=[],t.c=function(e){t.q.push(e)},e.ChannelIO=t;function n(){if(e.ChannelIOInitialized)return;e.ChannelIOInitialized=!0;var n,t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src="https://cdn.channel.io/plugin/ch-plugin-web.js",n=document.getElementsByTagName("script")[0],n.parentNode&&n.parentNode.insertBefore(t,n)}document.readyState==="complete"?n():(e.addEventListener("DOMContentLoaded",n),e.addEventListener("load",n))})(),ChannelIO("boot",{pluginKey:"3182ceac-0382-4734-98f5-1e6fec11c935"})</script><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.bootcdn.net/ajax/libs/photoswipe/4.1.3/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.bootcdn.net/ajax/libs/photoswipe/4.1.3/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.bootcdn.net/ajax/libs/photoswipe/4.1.3/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.bootcdn.net/ajax/libs/photoswipe/4.1.3/photoswipe.min.css crossorigin=anonymous></main></div><script type=text/javascript src=/ts/main.js defer></script><script async src=https://umami-gamma-virid.vercel.app/uma data-website-id=635c2011-51a9-4ffc-b360-f5572bb94276></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.font.im/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>