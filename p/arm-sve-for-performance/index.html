<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="本文介绍了 Arm 推出的可伸缩向量扩展 (SVE) 及其增强版 SVE2。它们通过提供可变长度的向量寄存器、灵活的 per-lane predication 以及丰富的指令集，显著提升了数据密集型应用（如 HPC 和 ML）的性能，并通过软件二进制兼容性保证了跨不同硬件平台的可移植性。此外，SVE 提供了 ACLE (ARM C Language Extensions) 来帮助开发者进行编程，可以通过调用 arm_sve.h 头文件中的内部函数直接在 C/C++ 代码中使用 SVE 指令，实现高效的向量化运算。"><title>Arm 性能优化：可伸缩向量扩展 SVE</title>
<link rel=canonical href=https://cuterwrite.top/p/arm-sve-for-performance/><link rel=stylesheet href=/scss/style.min.f27ff8f216d1ab53c73c3d36a92d11d7d5ec61749f9289cd87e50b909668cef6.css><meta property='og:title' content="Arm 性能优化：可伸缩向量扩展 SVE"><meta property='og:description' content="本文介绍了 Arm 推出的可伸缩向量扩展 (SVE) 及其增强版 SVE2。它们通过提供可变长度的向量寄存器、灵活的 per-lane predication 以及丰富的指令集，显著提升了数据密集型应用（如 HPC 和 ML）的性能，并通过软件二进制兼容性保证了跨不同硬件平台的可移植性。此外，SVE 提供了 ACLE (ARM C Language Extensions) 来帮助开发者进行编程，可以通过调用 arm_sve.h 头文件中的内部函数直接在 C/C++ 代码中使用 SVE 指令，实现高效的向量化运算。"><meta property='og:url' content='https://cuterwrite.top/p/arm-sve-for-performance/'><meta property='og:site_name' content="Cuterwrite's Blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='SIMD'><meta property='article:tag' content='向量化编程'><meta property='article:tag' content='并行计算'><meta property='article:published_time' content='2024-08-11T02:13:00+00:00'><meta property='article:modified_time' content='2024-08-11T02:13:00+00:00'><meta property='og:image' content='https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-29_117622464_p0_master1200.webp'><meta name=twitter:title content="Arm 性能优化：可伸缩向量扩展 SVE"><meta name=twitter:description content="本文介绍了 Arm 推出的可伸缩向量扩展 (SVE) 及其增强版 SVE2。它们通过提供可变长度的向量寄存器、灵活的 per-lane predication 以及丰富的指令集，显著提升了数据密集型应用（如 HPC 和 ML）的性能，并通过软件二进制兼容性保证了跨不同硬件平台的可移植性。此外，SVE 提供了 ACLE (ARM C Language Extensions) 来帮助开发者进行编程，可以通过调用 arm_sve.h 头文件中的内部函数直接在 C/C++ 代码中使用 SVE 指令，实现高效的向量化运算。"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-29_117622464_p0_master1200.webp'><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><script async src=https://analytics.cuterwrite.top/uma.js data-website-id=b13594a2-4d15-4a4e-a020-5e3cc1d88c12 data-domains=cuterwrite.top></script><link rel=manifest href=/manifest.json></head><body class="article-page
line-numbers"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu7627246953874065940.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>😉</span></figure><div class=site-meta><h1 class=site-name><a href=/>Cuterwrite's Blog</a></h1><h2 class=site-description>Cuterwrite 的技术博客, 专注于高性能计算、操作系统、全栈开发、人工智能等领域的深度探讨和经验分享。</h2></div></header><ol class=menu-social><li><a href=https://analytics.cuterwrite.top/share/Ji0gm9OaLDk8gco7 target=_blank title=Analytics rel=me><svg width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 5H7A2 2 0 005 7v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"/><rect x="9" y="3" width="6" height="4" rx="2"/><path d="M9 17v-5"/><path d="M12 17v-1"/><path d="M15 17v-3"/></svg></a></li><li><a href=https://stats.uptimerobot.com/6NVhRHkSAQ target=_blank title=Uptime rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-chart-line"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 19h16"/><path d="M4 15l4-6 4 2 4-5 4 4"/></svg></a></li><li><a href=/index.xml target=_blank title=RSS rel=me><svg class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li><li><a href=https://github.com/PKUcoldkeyboard target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.zhihu.com/people/kong-tiao-cheng-tai-lang-30-57 target=_blank title=zhihu rel=me><svg t="1705591931290" class="icon" viewBox="0 0 1280 1024" p-id="21048" width="32" height="32"><path d="M341.08 296.26v435.08l46.86.02 15.42 52.74 84.02-52.74h99.06V296.26H341.08zm195.5 387.86H480.7l-55.8 35.02-10.16-34.94-23.8-.08V343.5h145.64v340.62zM299.66 495.34H195c3.48-54.2 4.4-103.18 4.4-146.92h102.32s3.94-45.12-17.16-44.62h-177c6.98-26.24 15.74-53.32 26.24-81.34.0.0-48.14.0-64.54 43.14-6.78 17.8-26.42 86.28-61.4 156.24 11.78-1.28 50.74-2.36 73.68-44.42 4.22-11.78 5.02-13.32 10.28-29.06h57.74c0 21-2.4 133.76-3.36 146.88H41.66c-23.48.0-31.12 47.24-31.12 47.24H141.7C132.9 642.2 85.66 726.24.0 792.68c40.98 11.7 81.82-1.86 102-19.8.0.0 45.96-41.8 71.18-138.5L281.1 764.26s15.82-53.78-2.48-79.98c-15.16-17.84-56.12-66.12-73.58-83.62L175.8 623.9c8.72-27.96 13.98-55.1 15.74-81.34h123.3s-.18-47.24-15.18-47.24v.02zm824.04-3.2c41.66-51.28 89.96-117.14 89.96-117.14s-37.3-29.6-54.76-8.12c-12 16.3-73.66 96.4-73.66 96.4l38.46 28.86zM823.52 373.96c-18.02-16.5-51.82 4.26-51.82 4.26s79.04 110.08 82.24 114.9l38.92-27.46s-51.34-75.22-69.32-91.72h-.02zM1280 516.7c-39.56.0-261.82 1.86-262.12 1.86v-202c9.62.0 24.84-.8 45.7-2.4 81.76-4.82 140.26-8 175.54-9.62.0.0 24.44-54.38-1.18-66.88-6.14-2.36-46.34 9.16-46.34 9.16s-330.44 32.98-464.72 36.1c3.2 17.64 15.24 34.16 31.56 39.1 26.62 6.96 45.38 3.4 98.3 1.78 49.66-3.2 87.36-4.86 113.02-4.86v199.62H702.82s5.64 44.62 51.02 45.7h215.88V706.1c0 27.94-22.38 43.98-48.96 42.24-28.16.22-52.16-2.3-83.38-3.62 3.98 7.94 12.66 28.78 38.62 43.68 19.76 9.62 32.34 13.14 52.04 13.14 59.12.0 91.34-34.56 89.78-90.62V564.28h244.72c19.36.0 17.4-47.56 17.4-47.56l.06-.02z" fill="#707070" p-id="21049"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页 | Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于 | About</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档 | Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索 | Search</span></a></li><li><a href=https://cuterwrite.top/image-hosting target=_blank><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-album"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 4m0 2a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2z"/><path d="M12 4v7l2-2 2 2V4"/></svg>
<span>图册 | Gallery</span></a></li><li><a href=https://draw.cuterwrite.top target=_blank><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-artboard"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M8 8m0 1a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H9a1 1 0 01-1-1z"/><path d="M3 8h1"/><path d="M3 16h1"/><path d="M8 3v1"/><path d="M16 3v1"/><path d="M20 8h1"/><path d="M20 16h1"/><path d="M8 20v1"/><path d="M16 20v1"/></svg>
<span>画板 | Canvas</span></a></li><li><a href=https://it-tools.tech target=_blank><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-tools"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 21h4L20 8a1.5 1.5.0 00-4-4L3 17v4"/><path d="M14.5 5.5l4 4"/><path d="M12 8 7 3 3 7l5 5"/><path d="M7 8 5.5 9.5"/><path d="M16 12l5 5-4 4-5-5"/><path d="M16 17l-1.5 1.5"/></svg>
<span>工具 | Tools</span></a></li><li class=menu-bottom-section><ol class=menu><li id=i18n-switch><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language title=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://cuterwrite.top/ selected>中文</option><option value=https://cuterwrite.top/en/>English</option></select></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ul><li><a href=#1-sve-介绍>1. SVE 介绍</a></li><li><a href=#2-sve-架构基础>2. SVE 架构基础</a><ul><li><a href=#21-可伸缩向量寄存器>2.1 可伸缩向量寄存器</a></li><li><a href=#22-可伸缩-predicate-寄存器>2.2 可伸缩 Predicate 寄存器</a></li><li><a href=#23-可伸缩向量系统控制寄存器>2.3 可伸缩向量系统控制寄存器</a></li><li><a href=#24-sve-汇编语法>2.4 SVE 汇编语法</a></li><li><a href=#25-sve-架构特性>2.5 SVE 架构特性</a></li></ul></li><li><a href=#3-sve2-新增特性>3. SVE2 新增特性</a></li><li><a href=#4-使用-sve-编程>4. 使用 SVE 编程</a><ul><li><a href=#41-软件和库支持>4.1 软件和库支持</a></li><li><a href=#42-如何使用-sve2-编程>4.2 如何使用 SVE2 编程</a><ul><li><a href=#421-编写-sve-汇编代码>4.2.1 编写 SVE 汇编代码</a></li><li><a href=#422-使用-sve-instruction-函数intrinsics>4.2.2 使用 SVE instruction 函数（Intrinsics）</a></li><li><a href=#423-自动向量化>4.2.3 自动向量化</a></li><li><a href=#424-使用-svesve2-优化库>4.2.4 使用 SVE/SVE2 优化库</a></li></ul></li><li><a href=#43-如何运行-svesve2-程序>4.3 如何运行 SVE/SVE2 程序</a></li></ul></li><li><a href=#5-acle-intrinsics>5. ACLE Intrinsics</a><ul><li><a href=#51-acle-简介>5.1 ACLE 简介</a></li><li><a href=#52-如何使用-acle>5.2 如何使用 ACLE</a></li><li><a href=#53-sve-acle>5.3 SVE ACLE</a></li><li><a href=#54-sve-常用-intrinsics>5.4 SVE 常用 Intrinsics</a></li><li><a href=#55-sve-结构体-intrinsics>5.5 SVE 结构体 Intrinsics</a></li><li><a href=#56-sve-条件选择>5.6 SVE 条件选择</a></li><li><a href=#57-sve-向量化循环交织>5.7 SVE 向量化循环交织</a></li></ul></li><li><a href=#参考文献>参考文献</a></li></ul></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/arm-sve-for-performance/><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-06-29_117622464_p0_master1200.webp loading=lazy alt="Featured image of post Arm 性能优化：可伸缩向量扩展 SVE"></a></div><div class=article-details><header class=article-category><a href=/categories/hpc/ style=background-color:#ffb900;color:#fff>高性能计算</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/arm-sve-for-performance/>Arm 性能优化：可伸缩向量扩展 SVE</a></h2><h3 class=article-subtitle>本文介绍了 Arm 推出的可伸缩向量扩展 (SVE) 及其增强版 SVE2。它们通过提供可变长度的向量寄存器、灵活的 per-lane predication 以及丰富的指令集，显著提升了数据密集型应用（如 HPC 和 ML）的性能，并通过软件二进制兼容性保证了跨不同硬件平台的可移植性。此外，SVE 提供了 ACLE (ARM C Language Extensions) 来帮助开发者进行编程，可以通过调用 arm_sve.h 头文件中的内部函数直接在 C/C++ 代码中使用 SVE 指令，实现高效的向量化运算。</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2024-08-11</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 16 分钟</time></div><div><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-keyboard"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M2 6m0 2a2 2 0 012-2h16a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2z"/><path d="M6 10v.01"/><path d="M10 10v.01"/><path d="M14 10v.01"/><path d="M18 10v.01"/><path d="M6 14v.01"/><path d="M18 14v.01"/><path d="M10 14l4 .01"/></svg>
<time class=article-time--wordcount>字数统计: 7898 字</time></div></footer><footer class=article-translations><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg><div><a href=https://cuterwrite.top/en/p/arm-sve-for-performance/ class=link>English</a></div></footer></div></header><section class=article-content><h1 id=arm-性能优化可伸缩向量扩展-sve><a href=#arm-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e5%8f%af%e4%bc%b8%e7%bc%a9%e5%90%91%e9%87%8f%e6%89%a9%e5%b1%95-sve class=header-anchor>#</a>
Arm 性能优化：可伸缩向量扩展 SVE</h1><h2 id=1-sve-介绍><a href=#1-sve-%e4%bb%8b%e7%bb%8d class=header-anchor>#</a>
1. SVE 介绍</h2><p>继固定 128 位向量长度指令集的 Neon 架构扩展之后，Arm 设计了可伸缩向量扩展 (SVE) 作为 AArch64 的下一代 SIMD 扩展。SVE 引入可伸缩概念，允许灵活的向量长度实现，并在 CPU 实现中提供一系列可能的值。向量长度可以从最小 128 位到最大 2048 位不等，以 128 位为增量。<strong>SVE 设计保证相同的应用程序可以在支持 SVE 的不同实现上运行，而无需重新编译代码</strong>。SVE 提高了该架构对高性能计算 (HPC) 和机器学习 (ML) 应用程序的适用性，这些应用程序需要非常大量的数据处理。SVE2 是 SVE 和 Neon 的超集。SVE2 允许在数据级并行中使用更多功能域。SVE2 继承了 SVE 的概念、向量寄存器和操作原理。SVE 和 SVE2 定义了 32 个可伸缩向量寄存器。芯片合作伙伴可以选择合适的向量长度设计实现，硬件可在 128 位到 2048 位之间（以 128 位为增量）变化。SVE 和 SVE2 的优势在于，只有一个向量指令集使用可伸缩变量。</p><p>SVE 设计理念使开发人员能够编写和构建一次软件，然后在具有各种 SVE 向量长度实现的不同 AArch64 硬件上运行相同的二进制文件。二进制文件的可移植性意味着开发人员不必知道其系统的向量长度实现。消除了重建二进制文件的需求，使软件更容易移植。除了可伸缩向量之外，SVE 和 SVE2 还包括：</p><ul><li>per-lane predication</li><li>Gather Load/Scatter Store</li><li>推测性向量化</li></ul><p>这些特性有助于在处理大型数据集时对循环进行向量化和优化。</p><p>SVE2 和 SVE 的主要区别在于指令集的功能覆盖范围。SVE 专为 HPC 和 ML 应用而设计。SVE2 扩展了 SVE 指令集，使其能够加速 HPC 和 ML 以外领域的数据处理。SVE2 指令集还可以加速以下应用中使用的常见算法：</p><ul><li>计算机视觉</li><li>多媒体</li><li>LTE 基处理</li><li>基因组学</li><li>内存数据库</li><li>Web 服务</li><li>通用软件</li></ul><p>SVE 和 SVE2 都支持收集和处理大量数据。SVE 和 SVE2 不是 Neon 指令集的扩展。相反，SVE 和 SVE2 经过重新设计，以提供比 Neon 更好的数据并行性。但是，SVE 和 SVE2 的硬件逻辑覆盖了 Neon 硬件的实现。当微架构支持 SVE 或 SVE2 时，它也支持 Neon。要使用 SVE 和 SVE2，在该微架构上运行的软件必须首先支持 Neon。</p><h2 id=2-sve-架构基础><a href=#2-sve-%e6%9e%b6%e6%9e%84%e5%9f%ba%e7%a1%80 class=header-anchor>#</a>
2. SVE 架构基础</h2><p>本节介绍 SVE 和 SVE2 共享的基本架构特性。与 SVE 一样，SVE2 也基于可扩展向量。除了 Neon 提供的现有寄存器库之外，SVE 和 SVE2 还添加了以下寄存器：</p><ul><li>32 个可伸缩向量寄存器，<code>Z0-Z31</code></li><li>16 个可伸缩 Predicate 寄存器，<code>P0-P15</code><ul><li>1 个 首故障 Predicate 寄存器，<code>FFR</code></li></ul></li><li>可伸缩向量系统控制寄存器, <code>ZCR_ELx</code></li></ul><h3 id=21-可伸缩向量寄存器><a href=#21-%e5%8f%af%e4%bc%b8%e7%bc%a9%e5%90%91%e9%87%8f%e5%af%84%e5%ad%98%e5%99%a8 class=header-anchor>#</a>
2.1 可伸缩向量寄存器</h3><p>可伸缩向量寄存器 <code>Z0-Z31</code> 可以在微架构中实现为 128-2048 位。最低的 128 位与 Neon 的固定 128 位向量 <code>V0-V31</code> 共享。</p><p>下图显示了可伸缩向量寄存器 <code>Z0-Z31</code>：</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_Z-register.webp alt="Z 寄存器-2024-08-13" width=auto loading=lazy><figcaption><h4>可伸缩向量寄存器 Z0-Z31</h4></figcaption></figure><p>可伸缩向量：</p><ul><li>可以容纳 64、32、16 和 8 位元素</li><li>支持整数、双精度、单精度和半精度浮点元素</li><li>可以针对每个异常级别（EL）配置向量长度</li></ul><h3 id=22-可伸缩-predicate-寄存器><a href=#22-%e5%8f%af%e4%bc%b8%e7%bc%a9-predicate-%e5%af%84%e5%ad%98%e5%99%a8 class=header-anchor>#</a>
2.2 可伸缩 Predicate 寄存器</h3><p>为了控制哪些活动元素参与运算，Predicate 寄存器（简称为 P 寄存器）在许多 SVE 指令中用作掩码，这也为向量运算提供了灵活性。下图显示了可伸缩 Predicate 寄存器 <code>P0-P15</code> ：</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_Predicate-register.webp alt="P 寄存器-2024-08-12" width=auto loading=lazy><figcaption><h4>可伸缩 Predicate 寄存器 P0-P15</h4></figcaption></figure><p>P 寄存器通常用作数据操作的位掩码：</p><ul><li>每个 P 寄存器是 Z 寄存器长度的 1/8</li><li><code>P0-P7</code> 用于加载、存储和算术运算</li><li><code>P8-P15</code> 用于循环管理</li><li>FFR 是一个特殊的 P 寄存器，由 first-fault vector load 指令和 store 指令设置，用于指示每个元素的加载和存储操作的成功情况。FFR 旨在支持推测性内存访问，这使得在许多情况下向量化更容易和更安全。</li></ul><h3 id=23-可伸缩向量系统控制寄存器><a href=#23-%e5%8f%af%e4%bc%b8%e7%bc%a9%e5%90%91%e9%87%8f%e7%b3%bb%e7%bb%9f%e6%8e%a7%e5%88%b6%e5%af%84%e5%ad%98%e5%99%a8 class=header-anchor>#</a>
2.3 可伸缩向量系统控制寄存器</h3><p>下图展示了可伸缩向量系统控制寄存器 <code>ZCR_ELx</code> ：</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_ZCR_Elx.webp alt=ZCR_Elx-2024-08-12 width=auto loading=lazy><figcaption><h4>可伸缩向量系统控制寄存器 ZCR_Elx</h4></figcaption></figure><p>可伸缩向量系统控制寄存器指示 SVE 实现特性：</p><ul><li><code>ZCR_Elx.LEN</code> 字段用于当前和较低异常级别的向量长度。</li><li>大多数位当前保留供将来使用。</li></ul><h3 id=24-sve-汇编语法><a href=#24-sve-%e6%b1%87%e7%bc%96%e8%af%ad%e6%b3%95 class=header-anchor>#</a>
2.4 SVE 汇编语法</h3><p>SVE 汇编语法格式由操作码、目标寄存器、P 寄存器（如果指令支持 Predicate 掩码）和输入操作数组成。以下指令示例将详细说明此格式。</p><p>示例 1:</p><pre><code class=language-armasm>LDFF1D {&lt;Zt&gt;.D}, &lt;Pg&gt;/Z, [&lt;Xn|SP&gt;, &lt;Zm&gt;.D, LSL #3]
</code></pre><p>其中：</p><ul><li><code>&lt;Zt></code> 是 Z 寄存器, <code>Z0-Z31</code></li><li><code>&lt;Zt></code>.D 和 <code>&lt;Zm>.D</code> 指定目标和操作数向量的元素类型，不需要指定元素的数量。</li><li><code>&lt;Pg></code> 是 P 寄存器, <code>P0-P15</code></li><li><code>&lt;Pg>/Z</code> 是对 P 寄存器归零。</li><li><code>&lt;Zm></code> 指定 Gather Load 地址模式的偏移量。</li></ul><p>示例 2:</p><pre><code class=language-armasm>ADD &lt;Zdn&gt;.&lt;T&gt;, &lt;Pg&gt;/M, &lt;Zdn&gt;.&lt;T&gt;, &lt;Zm&gt;.&lt;T&gt;
</code></pre><p>其中：</p><ul><li><code>&lt;Pg>/M</code> 是合并 P 寄存器。</li><li><code>&lt;Zdn></code> 既是目标寄存器，也是输入操作数之一。指令语法在两个位置都显示 <code>&lt;Zdn></code> ，是为了方便起见。在汇编编码中，为了简化，它们只被编码一次。</li></ul><p>示例 3:</p><pre><code class=language-armasm>ORRS &lt;Pd&gt;.B, &lt;Pg&gt;.Z, &lt;Pn&gt;.B, &lt;Pm&gt;.B
</code></pre><ul><li><code>S</code> 是 P 寄存器条件标志 <code>NZCV</code> 的新解释。</li><li><code>&lt;Pg></code> 控制 P 寄存器在示例操作中充当位掩码。</li></ul><h3 id=25-sve-架构特性><a href=#25-sve-%e6%9e%b6%e6%9e%84%e7%89%b9%e6%80%a7 class=header-anchor>#</a>
2.5 SVE 架构特性</h3><p>SVE 包括以下关键架构特性：</p><ul><li>per-lane predication</li></ul><p>为了允许对所选元素进行灵活的操作，SVE 引入了 16 个 P 寄存器， <code>P0-P15</code> ，用于指示对向量活动通道的有效操作。例如：</p><pre><code class=language-armasm>ADD Z0.D, P0/M, Z0.D, Z1.D
</code></pre><p>活动元素 <code>Z0</code> 和 <code>Z1</code> 相加并将结果放入 <code>Z0</code> 中，<code>P0</code> 指示操作数的哪些元素是活动的和非活动的。<code>P0</code> 后面的 <strong>M</strong> 表示 Merging ，表示将非活动元素合并，因此 <code>Z0</code> 的非活动元素在 <code>ADD</code> 操作后将保持其初始值。如果 <code>P0</code> 后面是 <strong>Z</strong> ，则非活动元素将被清零，目标寄存器的非活动元素将在操作后归零。</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_Per-lane_Predication.webp alt=Per-lane_Predication-2024-08-13 width=auto loading=lazy><figcaption><h4>Per-lane predication merging</h4></figcaption></figure><p>如果使用的是 <strong>\Z</strong> ，则非活动元素将被清零，目标寄存器的非活动元素将在操作后归零。例如</p><pre><code class=language-armasm>CPY Z0.B, P0/Z, #0xFF
</code></pre><p>表示将有符号整数 0xFF 复制到 <code>Z0</code> 的活动通道中，而非活动通道将被清零。</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_Per-lane_Predicate_Zeroing.webp alt=Per-lane_Predicate_Zeroing-2024-08-13 width=auto loading=lazy><figcaption><h4>Per-lane predication zeroing</h4></figcaption></figure><blockquote class="alert-blockquote alert-note"><p class=alert-heading><svg viewBox="0 0 16 16" width="16" height="16"><path d="M0 8a8 8 0 1116 0A8 8 0 010 8zm8-6.5a6.5 6.5.0 100 13 6.5 6.5.0 000-13zM6.5 7.75A.75.75.0 017.25 7h1a.75.75.0 01.75.75v2.75h.25a.75.75.0 010 1.5h-2a.75.75.0 010-1.5h.25v-2h-.25a.75.75.0 01-.75-.75zM8 6a1 1 0 110-2 1 1 0 010 2z"/></svg>
<span>注释</span></p><p>并非所有指令都具有 Predicate 选项。此外，并非所有 Predicate 操作都同时具有合并和清零选项。您必须参考 <a class=link href=https://developer.arm.com/documentation/ddi0487/latest/t target=_blank rel=noopener>AArch64 SVE Supplement
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span>
</a>以了解每个指令的规范细节。</p></blockquote><ul><li>Gather Load 和 Scatter Store</li></ul><p>SVE 中的寻址模式允许将向量用作 Gather Load 和 Scatter Store 指令中的基地址和偏移量，这使得能够访问非连续的内存位置。例如：</p><pre><code class=language-armasm>LD1SB Z0.S, P0/Z, [Z1.S] // 将有符号字节从由 32 位向量基地址 Z1 生成的内存地址 Gather Load 到 Z0 的活动 32 位元素中。

LD1SB Z0.D, P0/Z, [X0, Z1.D] // 将有符号字节从由 64 位标量基地址 X0 加上 Z1.D 中的向量索引生成的内存地址 Gather Load 到 Z0 的活动元素中。
</code></pre><p>以下示例显示了加载操作 <code>LD1SB Z0.S, P0/Z, [Z1.S]</code> ，其中 <code>P0</code> 包含所有真元素，<code>Z1</code> 包含分散的地址。加载后，<code>Z0.S</code> 的每个元素的低位字节将用从分散内存位置获取的数据更新。</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_gather-load_and_scatter_store_example.webp alt=gather-load_and_scatter_store_example-2024-08-13 width=auto loading=lazy><figcaption><h4>Gather-load 与 Scatter-store 示例</h4></figcaption></figure><ul><li>P 寄存器驱动的循环控制和管理</li></ul><p>作为 SVE 的一项关键特性，P 寄存器不仅可以灵活地控制向量运算的各个元素，还可以实现 P 寄存器驱动的循环控制。P 寄存器驱动的循环控制和管理使循环控制高效且灵活。此功能通过在 P 寄存器中注册活动和非活动元素索引，消除了处理部分向量的额外循环头和尾的开销。P 寄存器驱动的循环控制和管理意味着，在接下来的循环迭代中，只有活动元素才会执行预期的操作。例如：</p><pre><code class=language-armasm>WHILEL0 P0.S, x8, x9  // 在 P0 中生成一个谓词，从最低编号的元素开始，当第一个无符号标量操作数 X8 的递增值小于第二个标量操作数 X9 时为真，之后为假，直到最高编号的元素。

B.FIRST Loop_start     // B.FIRST（等效于 B.MI）或 B.NFRST（等效于 B.PL）通常用于根据上述指令测试结果进行分支，判断 P0 的第一个元素是真还是假，作为循环的结束或继续条件。
</code></pre><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_Predicate-driver_loop_control_and_management_example.webp alt=Predicate-driver_loop_control_and_management_example-2024-08-13 width=auto loading=lazy><figcaption><h4>P 寄存器驱动的循环控制和管理示例</h4></figcaption></figure><ul><li>用于软件管理推测的向量分区</li></ul><p>推测性加载可能会给传统向量的内存读取带来挑战，<strong>如果在读取过程中某些元素发生错误，则难以逆转加载操作并跟踪哪些元素加载失败</strong>。Neon 不允许推测性加载。为了允许对向量进行推测性加载（例如 LDRFF），SVE 引入了 first-fault vector load 指令。为了允许向量访问跨越无效页面，SVE 还引入了 FFR 寄存器。<strong>使用 first-fault vector load 指令加载到 SVE 向量时，FFR 寄存器会更新每个元素的加载成功或失败结果</strong>。当发生加载错误时，FFR 会立即注册相应的元素，将其余元素注册为 0 或 false，并且不会触发异常。通常，RDFFR 指令用于读取 FFR 状态。当第一个元素为假时，RDFFR 指令结束迭代。如果第一个元素为真，RDFFR 指令继续迭代。FFR 的长度与 P 向量相同。可以使用 SETFFR 指令初始化该值。以下示例使用 LDFF1D 从内存中读取数据，FFR 会相应地更新：</p><pre><code class=language-armasm>LDFF1D Z0.D, P0/Z, [Z1.D, #0] // 使用首个故障行为将双字从由向量基地址 Z1 加 0 生成的内存地址收集加载到 Z0 的活动元素中。非活动元素不会读取设备内存或发出故障信号，并在目标向量中设置为零。从有效内存成功加载将 FFR 中的对应元素设置为真。首个故障加载将 FFR 中的对应元素和其余元素设置为假或 0。
</code></pre><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_Vector-partioning-for-software-managed-speculation-example.webp alt=Vector-partioning-for-software-managed-speculation-example-2024-08-13 width=auto loading=lazy><figcaption><h4>用于软件管理推测的向量分区示例</h4></figcaption></figure><ul><li>扩展的浮点和水平规约</li></ul><p>为了允许在向量中进行高效的归约操作，并满足对精度的不同要求，SVE 增强了浮点和水平归约操作。这些指令可能具有顺序（从低到高）或基于树（成对）的浮点归约顺序，其中操作顺序可能会导致不同的舍入结果。这些操作需要在可重复性和性能之间进行权衡。例如：</p><pre><code class=language-armasm>FADDA D0, P0/M, D1, Z2.D // 从源头向量的低位到高位元素进行浮点加严格顺序归约，将结果累积到 SIMD&amp;FP 标量寄存器中。该示例指令将 D1 与 Z2.D 的所有活动元素相加，并将结果存储到标量寄存器 D0 中。向量元素按从低到高的顺序严格处理，标量源 D1 提供初始值。源向量中的非活动元素将被忽略。而 FADDV 将执行递归成对归约，并将结果存储到标量寄存器中。
</code></pre><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_Extended_Floating-poing-and-horizontal-reductions-example.webp alt=Extended_Floating-poing-and-horizontal-reductions-example-2024-08-13 width=auto loading=lazy><figcaption><h4>扩展的浮点和水平规约示例</h4></figcaption></figure><h2 id=3-sve2-新增特性><a href=#3-sve2-%e6%96%b0%e5%a2%9e%e7%89%b9%e6%80%a7 class=header-anchor>#</a>
3. SVE2 新增特性</h2><p>本节介绍 SVE2 为 Arm AArch64 架构新增的特性。为了实现可伸缩的性能，SVE2 基于 SVE 构建，允许向量实现高达 2048 位。</p><p>在 SVE2 中，添加了许多复制 Neon 中现有指令的指令，包括：</p><ul><li>转换后的 Neon 整数运算，例如，带符号绝对差累加 (SAB) 和带符号减半加法 (SHADD)。</li><li>转换后的 Neon 扩展、缩小和成对运算，例如，无符号长加法 - 底部 (UADDLB) 和无符号长加法 - 顶部 (UADDLT)。</li></ul><p>元素处理顺序发生了变化。SVE2 对交错的偶数和奇数元素进行处理，而 Neon 对窄或宽操作的低半部分和高半部分元素进行处理。下图说明了 Neon 和 SVE2 处理之间的区别：</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_transformed_neon_widen_narraow_pairwise_operations.webp alt=transformed_neon_widen_narraow_pairwise_operations-2024-08-13 width=auto loading=lazy><figcaption><h4>转换后的 Neon 窄或宽操作对比</h4></figcaption></figure><ul><li>复数操作，例如带旋转的复整数乘加 (CMLA)。</li><li>多精度运算，用于大整数运算和密码学，例如，带进位长加法 - 底部 (ADCLB)、带进位长加法 - 顶部 (ADCLT) 以及 SM4 加密和解密 (SM4E)。</li></ul><p>为了向后兼容，最新架构中需要 Neon 和 VFP。虽然 SVE2 包含 SVE 和 Neon 的一些功能，但 SVE2 并不排除 Neon 在芯片上的存在。</p><p>SVE2 支持针对 HPC 市场以外的新兴应用进行优化，例如，在机器学习 (ML)（UDOT 指令）、计算机视觉（TBL 和 TBX 指令）、基带网络（CADD 和 CMLA 指令）、基因组学（BDEP 和 BEXT 指令）和服务器（MATCH 和 NMATCH 指令）中。</p><p>SVE2 增强了通用处理器大量数据操作的整体性能，而无需其他片外加速器。</p><h2 id=4-使用-sve-编程><a href=#4-%e4%bd%bf%e7%94%a8-sve-%e7%bc%96%e7%a8%8b class=header-anchor>#</a>
4. 使用 SVE 编程</h2><p>本节介绍支持 SVE2 应用程序开发的软件工具和库。本节还介绍了如何为支持 SVE2 的目标开发应用程序，在支持 SVE2 的硬件上运行该应用程序，以及在任何 Armv8-A 硬件上模拟该应用程序。</p><h3 id=41-软件和库支持><a href=#41-%e8%bd%af%e4%bb%b6%e5%92%8c%e5%ba%93%e6%94%af%e6%8c%81 class=header-anchor>#</a>
4.1 软件和库支持</h3><p>要构建 SVE 或 SVE2 应用程序，你必须选择支持 SVE 和 SVE2 功能的编译器。</p><ul><li>GNU 工具 8.0+ 版本支持 SVE。</li><li><a class=link href=https://developer.arm.com/tools-and-software/server-and-hpc/compile/arm-compiler-for-linux target=_blank rel=noopener>Arm Compiler for Linux
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span>
</a>18.0+ 版本支持 SVE，20.0+ 版本支持 SVE 和 SVE2。</li><li>GNU 和 Arm Compiler for Linux 编译器都支持优化 C/C++/Fortran 代码。</li><li>LLVM（开源 Clang）5 及更高版本包括对 SVE 的支持，9 及更高版本包括对 SVE2 的支持。要了解 LLVM 工具的每个版本支持哪些 SVE 或 SVE2 功能，请参阅 <a class=link href=https://developer.arm.com/tools-and-software/open-source-software/developer-tools/llvm-toolchain/sve-support target=_blank rel=noopener>LLVM 工具链 SVE 支持页面
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span>
</a>。</li></ul><p><a class=link href=https://developer.arm.com/Tools%20and%20Software/Arm%20Performance%20Libraries target=_blank rel=noopener>Arm Performance Libraries
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span>
</a>针对数学例程进行了高度优化，可以链接到你的应用程序。Arm Performance Libraries 19.3+ 版本支持 SVE 的数学库。</p><p>Arm Compiler for Linux 是 Arm Allinea Studio 的一部分，包含 Arm C/C++ 编译器、Arm Fortran 编译器和 Arm Performance Libraries。</p><h3 id=42-如何使用-sve2-编程><a href=#42-%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-sve2-%e7%bc%96%e7%a8%8b class=header-anchor>#</a>
4.2 如何使用 SVE2 编程</h3><p>编写或生成 SVE 和 SVE2 代码的方法有多种。在本小节中，我们将探讨其中的一些方法。</p><p>要编写或生成 SVE 和 SVE2 代码，你可以：</p><ul><li>编写 SVE 汇编代码</li><li>使用 SVE 内部函数编程</li><li>自动向量化</li><li>使用 SVE 优化库</li></ul><p>让我们更详细地了解这四种选择。</p><h4 id=421-编写-sve-汇编代码><a href=#421-%e7%bc%96%e5%86%99-sve-%e6%b1%87%e7%bc%96%e4%bb%a3%e7%a0%81 class=header-anchor>#</a>
4.2.1 编写 SVE 汇编代码</h4><p>你可以将 SVE 指令作为内联汇编编写到 C/C++ 代码中，或者作为完整的函数编写到汇编源代码中。例如：</p><pre><code class=language-armasm>    .globl subtract_arrays // -- Begin function
    .p2align 2
    .type subtract_arrays, @function
    subtract_arrays: // @subtract_arrays
    .cfi_startproc
// %bb.0:
    orr w9, wzr, #0x400
    mov x8, xzr
    whilelo p0.s, xzr, x9
.LBB0_1: // =&gt;This Inner Loop Header: Depth=1
    ld1w { z0.s }, p0/z, [x1, x8, lsl #2]
    ld1w { z1.s }, p0/z, [x2, x8, lsl #2]
    sub z0.s, z0.s, z1.s
    st1w { z0.s }, p0, [x0, x8, lsl #2]
    incw x8
    whilelo p0.s, x8, x9
    b.mi .LBB0_1
// %bb.2:
    ret
.Lfunc_end0:
    .size subtract_arrays, .Lfunc_end0-subtract_arrays
    .cfi_endproc
</code></pre><p>如果你混合使用高级语言和汇编语言编写的函数，则必须熟悉针对 SVE 更新的<a class=link href=https://developer.arm.com/documentation/ihi0036/latest/ target=_blank rel=noopener>应用程序二进制接口 (ABI)
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span>
</a>标准。<a class=link href=https://developer.arm.com/documentation/ihi0055/latest target=_blank rel=noopener>Arm 架构过程调用标准 (AAPCS)
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span>
</a>指定了数据类型和寄存器分配，并且与汇编编程最相关。AAPCS 要求：</p><ul><li><code>Z0-Z7</code> 和 <code>P0-P3 </code>用于传递可伸缩向量参数和结果。</li><li><code>Z8-Z15</code> 和 <code>P4-P15</code> 是被调用者保存的。</li><li>所有其他向量寄存器（<code>Z16-Z31</code>）都可能被被调用函数破坏，调用函数负责在需要时备份和恢复它们。</li></ul><h4 id=422-使用-sve-instruction-函数intrinsics><a href=#422-%e4%bd%bf%e7%94%a8-sve-instruction-%e5%87%bd%e6%95%b0intrinsics class=header-anchor>#</a>
4.2.2 使用 SVE instruction 函数（Intrinsics）</h4><p>SVE 内部函数是由编译器支持的函数，可以替换为相应的指令。程序员可以直接在 C 和 C++ 等高级语言中调用指令函数。SVE 的 ACLE（Arm C 语言扩展）定义了哪些 SVE 指令函数可用、它们的参数以及它们的功能。支持 ACLE 的编译器可以在编译期间将内部函数替换为映射的 SVE 指令。要使用 ACLE 内部函数，你必须包含头文件 <code>arm_sve.h</code>，其中包含可在 C/C++ 中使用的向量类型和指令函数（针对 SVE）列表。每种数据类型都描述了向量中元素的大小和数据类型：</p><ul><li><code>svint8_t svuint8_t</code></li><li><code>svint16_t svuint16_t svfloat16_t</code></li><li><code>svint32_t svuint32_t svfloat32_t</code></li><li><code>svint64_t svuint64_t svfloat64_t</code></li></ul><p>例如，<code>svint64_t</code> 表示 64 位有符号整数向量，<code>svfloat16_t</code> 表示半精度浮点数向量。</p><p>以下示例 C 代码已使用 SVE 内部函数进行了手动优化：</p><pre><code class=language-c>// intrinsic_example.c
#include &lt;arm_sve.h&gt;
svuint64_t uaddlb_array(svuint32_t Zs1, svuint32_t Zs2)
{
    // widening add of even elements
    svuint64_t result = svaddlb(Zs1, Zs2);
    return result;
}
</code></pre><p>包含 <code>arm_sve.h</code> 头文件的源代码可以使用 SVE 向量类型，就像数据类型可以用于变量声明和函数参数一样。要使用 Arm C/C++ 编译器编译代码并以支持 SVE 的 Armv8-A 架构为目标，请使用：</p><pre><code class=language-bash>armclang -O3 -S -march=armv8-a+sve2 -o intrinsic_example.s intrinsic_example.c
</code></pre><p>此命令生成以下汇编代码：</p><pre><code class=language-armasm>// instrinsic_example.s
uaddlb_array:         // @uaddlb_array
    .cfi_startproc
// %bb.0:
    uaddlb z0.d, z0.s, z1.s
    ret
</code></pre><h4 id=423-自动向量化><a href=#423-%e8%87%aa%e5%8a%a8%e5%90%91%e9%87%8f%e5%8c%96 class=header-anchor>#</a>
4.2.3 自动向量化</h4><p>C/C++/Fortran 编译器（例如，适用于 Arm 平台的原生 <a class=link href=https://developer.arm.com/tools-and-software/server-and-hpc/compile/arm-compiler-for-linux target=_blank rel=noopener>Arm Compiler for Linux
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span>
</a>和 GNU 编译器）支持使用 SVE 或 SVE2 指令对 C、C++ 和 Fortran 循环进行向量化。要生成 SVE 或 SVE2 代码，请选择适当的编译器选项。例如，使用 armclang 启用 SVE2 优化的一个选项是 <code>-march=armv8-a+sve2</code> 。如果要使用 SVE 版本的库，请将 <code>-march=armv8-a+sve2</code> 与 <code>-armpl=sve</code> 结合使用。</p><h4 id=424-使用-svesve2-优化库><a href=#424-%e4%bd%bf%e7%94%a8-svesve2-%e4%bc%98%e5%8c%96%e5%ba%93 class=header-anchor>#</a>
4.2.4 使用 SVE/SVE2 优化库</h4><p>使用针对 SVE/SVE2 高度优化的库，例如 <a class=link href=https://developer.arm.com/Tools%20and%20Software/Arm%20Performance%20Libraries target=_blank rel=noopener>Arm Performance Libraries
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span>
</a>和 Arm Compute Libraries。Arm Performance Libraries 包含针对 BLAS、LAPACK、FFT、稀疏线性代数和 libamath 优化的数学函数的高度优化实现。要能够链接任何 Arm Performance Libraries 函数，您必须安装 Arm Allinea Studio 并在代码中包含 armpl.h。要使用 Arm Compiler for Linux 和 Arm Performance Libraries 构建应用程序，您必须在命令行中指定 <code>-armpl=&lt;arg></code> 。如果您使用 GNU 工具，则必须使用 <code>-L&lt;armpl_install_dir>/lib</code> 将 Arm Performance Libraries 安装路径包含在链接器命令行中，并指定与 Arm Compiler for Linux <code>-armpl=&lt;arg></code> 选项等效的 GNU 选项，即 <code>-larmpl_lp64</code> 。有关更多信息，请参阅 Arm Performance Libraries 入门指南。</p><h3 id=43-如何运行-svesve2-程序><a href=#43-%e5%a6%82%e4%bd%95%e8%bf%90%e8%a1%8c-svesve2-%e7%a8%8b%e5%ba%8f class=header-anchor>#</a>
4.3 如何运行 SVE/SVE2 程序</h3><p>如果您无法访问 SVE 硬件，则可以使用模型或仿真器来运行代码。你可以选择以下几种模型和仿真器：</p><ul><li><strong>QEMU</strong>： 交叉编译和原生模型，支持在具有 SVE 的 Arm AArch64 平台上进行建模。</li><li><strong>Fast Models</strong>： 跨平台模型，支持在基于 x86 的主机上运行的具有 SVE 的 Arm AArch64 平台进行建模。支持 SVE2 的 架构包络模型 AEM 只对主要合作伙伴可用。</li><li><strong>Arm Instruction Emulator (ArmIE)</strong>： 直接在 Arm 平台上运行。支持 SVE，并从 19.2+ 版本开始支持 SVE2。</li></ul><h2 id=5-acle-intrinsics><a href=#5-acle-intrinsics class=header-anchor>#</a>
5. ACLE Intrinsics</h2><h3 id=51-acle-简介><a href=#51-acle-%e7%ae%80%e4%bb%8b class=header-anchor>#</a>
5.1 ACLE 简介</h3><p>ACLE (Arm C 语言扩展) 是在 C 和 C++ 代码中利用内部函数和其他特性来支持 Arm 的功能。</p><ul><li>ACLE (ARM C 语言扩展) 通过特定于 Arm 的特性扩展了 C/C++ 语言。<ul><li>预定义宏：<code>__ARM_ARCH_ISA_A64</code> 、 <code>__ARM_BIG_ENDIAN</code> 等。</li><li>内部函数：<code>__clz(uint32_t x)</code> 、 <code>__cls(uint32_t x)</code> 等。</li><li>数据类型：SVE、NEON 和 FP16 数据类型。</li></ul></li><li>用于 SVE 的 ACLE 支持使用 ACLE 进行可变长度向量 (VLA) 编程。<ul><li>几乎每个 SVE 指令都有一个对应的内部函数。</li><li>数据类型用于表示 SVE 内部函数所使用的无大小向量。</li></ul></li><li>适用于以下用户的场景：<ul><li>希望手动调整 SVE 代码的用户。</li><li>希望适配或手动优化应用程序和库的用户。</li><li>需要对 Arm 目标进行底层访问的用户。</li></ul></li></ul><h3 id=52-如何使用-acle><a href=#52-%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-acle class=header-anchor>#</a>
5.2 如何使用 ACLE</h3><ul><li>引入头文件<ul><li><code>arm_acle.h</code> ：核心 ACLE</li><li><code>arm_fp16.h</code> ：添加 FP16 数据类型。<ul><li>目标平台需支持 FP16，即 <code>march=armv8-a+fp16</code>。</li></ul></li><li><code>arm_neon.h</code> ：添加 NEON Intrinsics 和数据类型。<ul><li>目标平台需支持 NEON，即 <code>march=armv8-a+simd</code>。</li></ul></li><li><code>arm_sve.h</code> ：添加 SVE Intrinsics 和数据类型。<ul><li>目标平台需支持 SVE，即 <code>march=armv8-a+sve</code>。</li></ul></li></ul></li></ul><h3 id=53-sve-acle><a href=#53-sve-acle class=header-anchor>#</a>
5.3 SVE ACLE</h3><ul><li>首先需要做的是引入头文件</li></ul><pre><code class=language-c>#include &lt;arm_sve.h&gt;
</code></pre><ul><li>VLA 数据类型<ul><li><code>svfloat64_t</code>, <code>svfloat16_t</code>, <code>svuint32_t</code> 等。</li><li>命名规则：<code>sv&lt;datatype>&lt;datasize>_t</code></li></ul></li><li>Predication<ul><li>合并：<code>_m</code></li><li>置零：<code>_z</code></li><li>不确定：<code>_x</code></li><li>P 寄存器的数据类型：<code>svbool_t</code></li></ul></li><li>使用泛型做函数重载，比如函数 <code>svadd</code> 会根据参数类型自动选择对应的函数。</li><li>函数命名规则：<code>svbase[disambiguator][type0][type1]...[predication]</code><ul><li>base 指的是基本操作，比如 <code>add</code>、<code>mul</code>、<code>sub</code> 等。</li><li>disambiguator 用于区分相同基本操作的不同变体。</li><li>typeN 指定了向量和 P 寄存器的类型。</li><li>predication 指定了非活动元素的处理方式。</li><li>例如： <code>svfloat64_t svld1_f64</code>, <code>svbool_t svwhilelt_b8</code>, <code>svuint32_t svmla_u32_z</code>, <code>svuint32_t svmla_u32_m</code></li></ul></li></ul><h3 id=54-sve-常用-intrinsics><a href=#54-sve-%e5%b8%b8%e7%94%a8-intrinsics class=header-anchor>#</a>
5.4 SVE 常用 Intrinsics</h3><ul><li>Predicate<ul><li>Predicate 是一个 bool 类型的向量，用于控制计算过程中向量中对应位置是否参与运算</li><li><code>svbool_t pg = svwhilelt_b32(i, num)</code> 产生 (i, i + 1, i + 2, &mldr;, i + vl - 1) &lt; num 的 predicate</li><li><code>svbool_t pg = svptrue_b32()</code> 产生一个全为 true 的 predicate</li><li>其中，b32 对应处理 32 位数据（int/float），此外还有 b8, b16, b64 对应的 intrinsic</li></ul></li><li>内存数据存取<ul><li><code>svld1(pg, *base)</code>： 从地址 base 中加载连续向量。</li><li><code>svst1(pg, *base, vec)</code>： 将向量 vec 存储到地址 base 中。</li><li><code>svld1_gather_index(pg, *base, vec_index)</code>： 从地址 base 中加载向量索引对应的数据。</li><li><code>svst1_scatter_index(pg, *base, vec_index, vec)</code>： 将向量 vec 中数据存储到向量索引对应的位置。</li></ul></li><li>基础计算<ul><li><code>svadd_z(pg, sv_vec1, sv_vec2)</code></li><li><code>svadd_m(pg, sv_vec1, sv_vec2)</code></li><li><code>svadd_x(pg, sv_vec1, sv_vec2)</code></li><li><code>svadd_x(pg, sv_vec1, x)</code></li><li>其中，<code>_z</code> 表示将 pg 为 false 的位置置零，<code>_m</code> 表示保留原值，<code>_x</code> 表示不确定（什么值都有可能）。</li><li>第二个操作数可以为标量数据。</li><li><code>svmul</code>, <code>svsub</code>, <code>svsubr</code>, <code>svdiv</code>, <code>svdivr</code>：其中，<code>svsubr</code> 相比 <code>svsub</code> 交换了减数与被减数的位置。</li></ul></li><li>其它<ul><li><code>svdup_f64(double x)</code>： 生成一个所有元素都为 x 的向量。</li><li><code>svcntd()</code>：返回 64-bit 数据的向量长度：<code>svcntb</code> 对应 8 位， <code>svcnth</code> 对应 16 位，<code>svcntw</code> 对应 32 位。</li></ul></li></ul><h3 id=55-sve-结构体-intrinsics><a href=#55-sve-%e7%bb%93%e6%9e%84%e4%bd%93-intrinsics class=header-anchor>#</a>
5.5 SVE 结构体 Intrinsics</h3><p>对应结构体数据，SVE 提供了一些特殊的 Intrinsics，比如：<code>svld3</code>, <code>svget3</code>, <code>svset3</code>, <code>svst3</code> 等。这些 Intrinsics 用于处理结构体数据。</p><p>例如，对于粒子结构体：</p><pre><code class=language-c>typedef struct {
    float x;
    float y;
    float z;
} Particle;
</code></pre><p>可以使用 <code>svld3</code> 加载结构体中全部的数据为 3 个向量的组，然后使用 <code>svget3</code> 从 3 个向量的组中提取一个向量, index 的值为 0, 1, 2 分别对应 x, y, z。</p><pre><code class=language-c>Particle *ps;
float factor = 2.2;
// 初始化部分省略
for (int i = 0; i &lt; num; i += svcntw()) {
    svbool_t pg = svwhilelt_b32(i, num);
    svfloat32x3_t sv_ps = svld3(pg, (float32_t *)&amp;ps[i]);
    svfloat32_t sv_ps_x = svget3(sv_ps, 0);
    svfloat32_t sv_ps_y = svget3(sv_ps, 1);

    // 执行计算
    sv_ps_x = svmul_x(pg, sv_ps_x, factor);
    sv_ps_y = svmul_x(pg, sv_ps_y, factor);

    //保存结果
    sv_ps = svset3(sv_ps, 0, sv_ps_x);
    sv_ps = svset3(sv_ps, 1, sv_ps_y);
    svst3(pg, (float32_t *)&amp;ps[i], sv_ps);
}
</code></pre><ul><li><code>svld3(pg, *base)</code>： 加载结构体中全部的数据为 3 个向量的组；其中，base 是 3 个元素结构体数组的地址。</li><li><code>svget3(tuple, index)</code>： 从 3 个向量的组中提取一个向量；index 的值为 0、1 或 2。</li><li><code>svset3(tuple, index, vec)</code>： 设置 3 个向量的组中的一个向量；index 的值为 0、1 或 2。</li><li><code>svst3(pg, *base, vec)</code>： 将 3 个向量的组存储到结构体中；其中，base 是 3 个元素结构体数组的地址。</li></ul><h3 id=56-sve-条件选择><a href=#56-sve-%e6%9d%a1%e4%bb%b6%e9%80%89%e6%8b%a9 class=header-anchor>#</a>
5.6 SVE 条件选择</h3><p>SVE 中提供了 <code>svcmplt</code>、<code>svcompact</code>、<code>svcntp_b32</code> 等方法，可以根据条件选择保留向量中的元素。</p><p>例如，对于无向量化的代码：</p><pre><code class=language-c>for (int i = 0; i &lt; num; i++) {
    float tmp = provided[i];
    if (tmp &lt; mark) {
        selected[count++] = tmp;
        if (count &gt;= maxSize) {
            break;
        }
    }
}
</code></pre><p>该代码的作用是从 provided 数组中选择小于 mark 的元素，存储到 selected 数组中，直到 selected 数组满。</p><p>用 SVE Intrinsic 改写：</p><pre><code class=language-c>for (int i = 0; i &lt; num; i += svcntw()) {
    svbool_t pg = svwhilelt_b32(i, num);
    svfloat32_t sv_tmp = svld1(pg, &amp;provided[i]);
    svbool_t pg_sel = svcmplt(pg, sv_tmp, mark);
    sv_tmp = svcompact(pg_sel, sv_tmp);
    svst1(pg, &amp;selected[count], sv_tmp);
    count += svcntp_b32(pg, pg_sel);
    if (count &gt;= maxSize) {
        break;
    }
}
</code></pre><ul><li><code>svcmplt(pg, vec1, vec2)</code> ：比较两个向量的大小，返回一个 predicate，表示 vec1 中小于 vec2 的位置。</li><li><code>svcompact(pg, sv_tmp)</code> ：压缩向量，将 pg 为 active 的数据按序移动到向量低位，其余位置置零。</li><li><code>svcntp_b32(pg, pg2)</code> ：返回 pg2 中 active 的元素个数</li><li>这段代码先将 provided 数组中的数据加载到 sv_tmp 中，然后使用 <code>svcmplt</code> 生成一个 predicate，表示小于 mark 的位置。接着使用 <code>svcompact</code> 压缩 sv_tmp，得到小于 mark 的数据，再通过 <code>svst1</code> 存储到 selected 数组中。最后，使用 <code>svcntp_b32</code> 统计 active 的元素个数，更新 count。</li></ul><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_compact.webp alt=compact-2024-08-13 width=auto loading=lazy><figcaption><h4>svcompact 示意图（256-bit 向量）</h4></figcaption></figure><p>由于进行了 compact 操作，所以 selected 数组从 count 位置连续存储新的小于 mark 的数据，剩下的位置被置零。</p><figure><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-13_svst1.webp alt=svst1-2024-08-13 width=auto loading=lazy><figcaption><h4>svst1 示意图（256-bit 向量）</h4></figcaption></figure><h3 id=57-sve-向量化循环交织><a href=#57-sve-%e5%90%91%e9%87%8f%e5%8c%96%e5%be%aa%e7%8e%af%e4%ba%a4%e7%bb%87 class=header-anchor>#</a>
5.7 SVE 向量化循环交织</h3><p>SVE Intrinsic 实现的向量化循环交织，相比编译器自动向量化能大大减少读取向量的次数。</p><p>例如，对于无向量化的代码：</p><pre><code class=language-c>for (int j = offset; j &lt; outerLen - offset; j++) {
    int m2index = (j - offset) * innerLen;
    int m1index = m2index + innerLen;
    int m0index = m1index + innerLen;
    int p1index = m0index + innerLen;
    int p2index = p1index + innerLen;
    for (int i = 0; i &lt; innerLen; i++) {
        res[m0index + i] = m2factor * field[m2index + i] +
                           m1factor * field[m1index + i] +
                           m0factor * field[m0index + i] +
                           p1factor * field[p1index + i] +
                           p2factor * field[p2index + i];
    }
}
</code></pre><p>编译器对该代码进行自动向量化后，每次迭代需读取五次不同向量的数据，效率较低。</p><p>用 SVE Intrinsic 改写：</p><pre><code class=language-c>for (int i = 0; i &lt; innerLen; i += svcntd()) {
    svbool_t pg = svwhilelt_b32(i, innerLen);
    int dataIndex = i;
    svfloat64_t jm2Field = svld1(pg, &amp;field[dataIndex]);
    dataIndex += innerLen;
    svfloat64_t jm1Field = svld1(pg, &amp;field[dataIndex]);
    dataIndex += innerLen;
    svfloat64_t jm0Field = svld1(pg, &amp;field[dataIndex]);
    dataIndex += innerLen;
    svfloat64_t jp1Field = svld1(pg, &amp;field[dataIndex]);

    for (int j = offset; j &lt; outerLen - offset; j += 1) {
        svfloat64_t jp2Field = svld1(pg, &amp;field[(j + offset) * innerLen + i]);
        svfloat64_t svRes = svmul_x(pg, jm2Field, m2factor);
        svRes = svmad_x(pg, jm1Field, m1factor, svRes);
        svRes = svmad_x(pg, jm0Field, m0factor, svRes);
        svRes = svmad_x(pg, jp1Field, p1factor, svRes);
        svRes = svmad_x(pg, jp2Field, p2factor, svRes);
        svst1(pg, &amp;res[j * innerLen + 1], svRes);
        jm2Field = jm1Field;
        jm1Field = jm0Field;
        jm0Field = jp1Field;
        jp1Field = jp2Field;
    }
}
</code></pre><ul><li><code>svmad_x(pg, vec1, vec2, vec3)</code> ：计算 vec1 * vec2 + vec3，返回一个向量。</li><li>这段代码每次迭代只需读取一个向量，大大减少向量读取的次数。</li></ul><h2 id=参考文献><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae class=header-anchor>#</a>
参考文献</h2><ol><li><a class=link href="https://developer.arm.com/-/media/Arm%20Developer%20Community/PDF/102340_0001_02_en_introduction-to-sve2.pdf?revision=b208e56b-6569-4ae2-b6f3-cd7d5d1ecac3" target=_blank rel=noopener>Introduction to SVE2
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></li><li><a class=link href=https://www.stonybrook.edu/commcms/ookami/support/_docs/5%20-%20Advanced%20SVE.pdf target=_blank rel=noopener>SVE Deep Dive
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></li><li><a class=link href=https://arm-software.github.io/acle/main/acle.html target=_blank rel=noopener>Arm C Language Extensions
<span style=white-space:nowrap><svg width=".8em" height=".8em" viewBox="0 0 21 21"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></li></ol></section><footer class=article-footer><section class=article-tags><a href=/tags/simd/>SIMD</a>
<a href=/tags/vectorized-programming/>向量化编程</a>
<a href=/tags/parallel-computing/>并行计算</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><script type=text/javascript src=/js/prism.js async></script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/arm-sme-for-performance/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-14_117622407_p0_master1200.webp loading=lazy data-key=arm-sme-for-performance data-hash=https://cuterwrite-1302252842.file.myqcloud.com/img/2024-08-14_117622407_p0_master1200.webp></div><div class=article-details><h2 class=article-title>Arm 矩阵加速：可伸缩矩阵扩展 SME</h2></div></a></article><article class=has-image><a href=/p/simd/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/blog/173b9c0b3728e5e9e05d12a4f6dda9a2a7560722.jpg@1256w_1776h_!web-article-pic.webp loading=lazy data-key=simd data-hash=https://cuterwrite-1302252842.file.myqcloud.com/blog/173b9c0b3728e5e9e05d12a4f6dda9a2a7560722.jpg@1256w_1776h_!web-article-pic.webp></div><div class=article-details><h2 class=article-title>SSE 与 AVE 向量化编程</h2></div></a></article><article class=has-image><a href=/p/openmp-intro/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/c17b7451a44c1d4370d5ba2b966298ea195413_crop-2024-02-19.webp loading=lazy data-key=openmp-intro data-hash=https://cuterwrite-1302252842.file.myqcloud.com/img/c17b7451a44c1d4370d5ba2b966298ea195413_crop-2024-02-19.webp></div><div class=article-details><h2 class=article-title>OpenMP 简介</h2></div></a></article><article class=has-image><a href=/p/openmpi-with-ucx/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/img/cropped_2024010204-2024-02-03.webp loading=lazy data-key=openmpi-with-ucx data-hash=https://cuterwrite-1302252842.file.myqcloud.com/img/cropped_2024010204-2024-02-03.webp></div><div class=article-details><h2 class=article-title>编译安装 UCX 1.15.0 与 OpenMPI 5.0.0：详尽指南</h2></div></a></article><article class=has-image><a href=/p/false-sharing/><div class=article-image><img src=https://cuterwrite-1302252842.file.myqcloud.com/blog/6c3f8961290e41f894f5a1cbb768aba9-2023-12-02.webp loading=lazy data-key=false-sharing data-hash=https://cuterwrite-1302252842.file.myqcloud.com/blog/6c3f8961290e41f894f5a1cbb768aba9-2023-12-02.webp></div><div class=article-details><h2 class=article-title>性能刺客之伪共享</h2></div></a></article></div></div></aside><script src=https://unpkg.com/twikoo@1.6.39/dist/twikoo.all.min.js></script><div id=tcomment></div><style>.twikoo{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}:root[data-scheme=dark]{--twikoo-body-text-color-main:rgba(255, 255, 255, 0.9);--twikoo-body-text-color:rgba(255, 255, 255, 0.7)}.twikoo .el-input-group__prepend,.twikoo .tk-action-icon,.twikoo .tk-time,.twikoo .tk-comments-count{color:var(--twikoo-body-text-color)}.twikoo .el-input__inner,.twikoo .el-textarea__inner,.twikoo .tk-preview-container,.twikoo .tk-content,.twikoo .tk-nick,.twikoo .tk-send{color:var(--twikoo-body-text-color-main)}.twikoo .el-button{color:var(--twikoo-body-text-color)!important}.OwO .OwO-body{background-color:var(--body-background)!important;color:var(--body-text-color)!important}</style><script>twikoo.init({envId:"https://comment.cuterwrite.top",el:"#tcomment",lang:"zh-CN"})</script><footer class=site-footer><section class=copyright>&copy;
2021 -
2024 cuterwrite</section><section class=running-time>本博客已稳定运行
<span id=runningdays class=running-days></span></section><section class=totalcount>发表了73篇文章 ·
总计323.12k字</section><section class=powerby>Welcome to cuterwrite's blog!<br>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.27.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计<br><span>基于 <a href=https://github.com/CaiJimmy/hugo-theme-stack/tree/v3.27.0 target=_blank rel=noopener><b style=color:#9e8f9f>v3.27.0</b></a> 分支版本修改</span><br></section></footer><script>let s1="2021-4-17";s1=new Date(s1.replace(/-/g,"/"));let s2=new Date,timeDifference=s2.getTime()-s1.getTime(),days=Math.floor(timeDifference/(1e3*60*60*24)),hours=Math.floor(timeDifference%(1e3*60*60*24)/(1e3*60*60)),minutes=Math.floor(timeDifference%(1e3*60*60)/(1e3*60)),result=days+"天"+hours+"小时"+minutes+"分钟";document.getElementById("runningdays").innerHTML=result</script><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://libs.jshub.com/photoswipe/4.1.3/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://libs.jshub.com/photoswipe/4.1.3/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://libs.jshub.com/photoswipe/4.1.3/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://libs.jshub.com/photoswipe/4.1.3/photoswipe.min.css crossorigin=anonymous></main></div><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.font.im/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><meta name=apple-mobile-web-app-capable content="yes"><meta name=theme-color content="#ffffff"><script>"serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("/sw.js").then(e=>{console.log("Service worker registered with scope: ",e.scope)},e=>{console.log("Service worker registration failed: ",e)})})</script></body></html>