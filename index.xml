<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>cuterwrite</title>
        <link>https://cuterwrite.top/</link>
        <description>Recent content on cuterwrite</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>cuterwrite</copyright>
        <lastBuildDate>Mon, 25 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://cuterwrite.top/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>使用 Pillow &#43; Plugin 处理 AVIF 和 HEIC 图片</title>
        <link>https://cuterwrite.top/p/processing-avif-heic-images-pillow-plugins/</link>
        <pubDate>Thu, 21 Dec 2023 11:45:14 +0000</pubDate>
        
        <guid>https://cuterwrite.top/p/processing-avif-heic-images-pillow-plugins/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/4674616682ccadfd81f2dc86c6241f23195413.jpg@1256w_704h_!web-article-pic-2023-12-22.png" alt="Featured image of post 使用 Pillow &#43; Plugin 处理 AVIF 和 HEIC 图片" /&gt;&lt;h2 id=&#34;一引言&#34;&gt;一、引言&lt;/h2&gt;
&lt;p&gt;随着图片格式的不断发展，AVIF和HEIC这两种高效的图片格式逐渐受到了开发者的关注。AVIF（AV1 Image File Format）是一种基于 AV1 视频编码的图像格式，具有高压缩率和高质量的特点。HEIC（High Efficiency Image Format）是一种基于 HEVC（High Efficiency Video Coding）编码的图像格式，同样具有高压缩率和高质量的优势。为了方便处理这两种格式的图片，我们可以使用 Pillow-AVIF-Plugin 和 Pillow-HEIC 库。&lt;/p&gt;
&lt;h2 id=&#34;二安装&#34;&gt;二、安装&lt;/h2&gt;
&lt;p&gt;首先，我们需要安装 Pillow 库，它是一个强大的 Python 图像处理库。使用以下命令安装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pip install pillow
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;接下来，安装 Pillow-AVIF-Plugin 和 Pillow-HEIC 库：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pip install pillow-avif-plugin
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pip install pillow-heic
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;三使用方法&#34;&gt;三、使用方法&lt;/h2&gt;
&lt;h3 id=&#34;1-处理avif图片&#34;&gt;1. 处理AVIF图片&lt;/h3&gt;
&lt;p&gt;使用 Pillow-AVIF-Plugin 处理 AVIF 图片非常简单。首先，导入所需的库：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;PIL&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Image&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;pillow_avif&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后，使用 &lt;code&gt;Image.open()&lt;/code&gt; 方法打开AVIF图片：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;image&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Image&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;example.avif&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;接下来，可以对图片进行各种操作，例如调整大小、旋转等。也可以使用以下方法将图片保存为其他格式（例如 PNG ）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;with&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Image&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;im&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;png_file_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;splitext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;.png&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;im&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;save&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;png_file_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;format&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;PNG&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;2-处理heic图片&#34;&gt;2. 处理HEIC图片&lt;/h3&gt;
&lt;p&gt;处理 HEIC 图片的方法与处理 AVIF 图片类似。首先，导入所需的库：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;PIL&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Image&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;pillow_heif&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;register_heif_opener&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;register_heif_opener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后，使用 &lt;code&gt;Image.open()&lt;/code&gt; 方法打开 HEIC 图片：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;image&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Image&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;example.heic&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;接下来，可以对图片进行各种操作，例如调整大小、旋转等。也可以使用以下方法将图片保存为其他格式（例如 PNG ）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;with&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Image&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;im&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;png_file_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;splitext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;.png&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;im&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;save&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;png_file_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;format&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;PNG&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;四结论&#34;&gt;四、结论&lt;/h2&gt;
&lt;p&gt;通过使用 Pillow-AVIF-Plugin 和 Pillow-HEIC 库，我们可以轻松地处理 AVIF 和 HEIC 格式的图片。这两个库为开发者提供了简单易用的接口，使得在实际项目中处理这些高效的图片格式变得更加方便。希望本文能对你有所帮助。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Ring buffer详解</title>
        <link>https://cuterwrite.top/p/ring-buffer/</link>
        <pubDate>Sat, 02 Dec 2023 02:00:00 +0000</pubDate>
        
        <guid>https://cuterwrite.top/p/ring-buffer/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/9fd865ce11924381a127462463ae2234-2023-12-02.jpg" alt="Featured image of post Ring buffer详解" /&gt;&lt;h1 id=&#34;ring-buffer详解&#34;&gt;Ring buffer详解&lt;/h1&gt;
&lt;h2 id=&#34;一概述&#34;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ring buffer&lt;/code&gt; 称作 &lt;strong&gt;环形缓冲区&lt;/strong&gt; ，也称作环形队列（circular queue），是一种用于表示一个固定尺寸、头尾相连的缓冲区的数据结构，适合缓存数据流。如下为 &lt;strong&gt;环形缓冲区（ring buffer）&lt;/strong&gt; 的概念示意图。&lt;/p&gt;
&lt;p&gt;在任务间的通信、串口数据收发、log缓存、网卡处理网络数据包、音频/视频流处理中均有 &lt;strong&gt;环形缓冲区（ring buffer）&lt;/strong&gt; 的应用。在 &lt;strong&gt;RT-Thread&lt;/strong&gt; 的 &lt;code&gt;ringbuffer.c&lt;/code&gt; 和 &lt;code&gt;ringbuffer.h&lt;/code&gt; 文件中，Linux 内核文件 &lt;code&gt;kfifo.h&lt;/code&gt; 和 &lt;code&gt;kfifo.c&lt;/code&gt; 中也有 &lt;strong&gt;环形缓冲区（ring buffer）&lt;/strong&gt; 的代码实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20231202213555-2023-12-02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20231202213555-2023-12-02&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;环形缓冲区的一些使用特点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一个数据元素被读取出后，其余数据元素不需要移动其存储位置；&lt;/li&gt;
&lt;li&gt;适合于事先明确了缓冲区的最大容量的情形。缓冲区的容量（长度）一般固定，可以用一个静态数组来充当缓冲区，无需重复申请内存；&lt;/li&gt;
&lt;li&gt;如果缓冲区的大小需要经常调整，就不适合用环形缓冲区，因为在扩展缓冲区大小时，需要搬移其中的数据，这种场合使用链表更加合适；&lt;/li&gt;
&lt;li&gt;因为缓冲区成头尾相连的环形，写操作可能会覆盖未及时读取的数据，有的场景允许这种情况发生，有的场景又严格限制这种情况发生。选择何种策略和具体应用场景相关。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二原理&#34;&gt;二、原理&lt;/h2&gt;
&lt;p&gt;由于计算机内存是线性地址空间，因此 &lt;strong&gt;环形缓冲区（ring buffer）&lt;/strong&gt; 需要特别的算法设计才可以从逻辑上实现。&lt;/p&gt;
&lt;h3 id=&#34;1-一个简单例子&#34;&gt;1. 一个简单例子&lt;/h3&gt;
&lt;p&gt;先不要想 &lt;strong&gt;环形缓冲区（ring buffer）&lt;/strong&gt; 的具体实现细节，来看一个简单的例子。如下是一个空间大小为 7 的环形缓冲区，其中底部的单线箭头表示头尾相连形成一个环形地址空间：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/375px-Circular_buffer_-_empty.svg-2023-12-02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;375px-Circular_buffer_-_empty.svg-2023-12-02&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;假设 &lt;code&gt;1&lt;/code&gt; 被写入圆形缓冲区的中心（在环形缓冲区中，最初的写入位置在哪里是无关紧要的）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/375px-Circular_buffer_-_XX1XXXX.svg-2023-12-02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;375px-Circular_buffer_-_XX1XXXX.svg-2023-12-02&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;再 &lt;strong&gt;写入两个&lt;/strong&gt; 元素，分别是 &lt;code&gt;2&lt;/code&gt; 和 &lt;code&gt;3&lt;/code&gt; ，这两个元素被追加到 &lt;code&gt;1&lt;/code&gt; 之后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/375px-Circular_buffer_-_XX123XX.svg-2023-12-02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;375px-Circular_buffer_-_XX123XX.svg-2023-12-02&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如果 &lt;strong&gt;读出两个&lt;/strong&gt; 元素，那么环形缓冲区中最老的两个元素将被读出（先进先出原则）。在本例中 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;2&lt;/code&gt; 被读出，缓冲区中剩下 &lt;code&gt;3&lt;/code&gt; ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/375px-Circular_buffer_-_XXXX3XX.svg-2023-12-02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;375px-Circular_buffer_-_XXXX3XX.svg-2023-12-02&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;紧接着，向缓冲区中 &lt;strong&gt;写入六个&lt;/strong&gt; 元素 &lt;code&gt;4、5、6、7、8、9&lt;/code&gt; ，这时缓冲区会被装满：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/375px-Circular_buffer_-_6789345.svg-2023-12-02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;375px-Circular_buffer_-_6789345.svg-2023-12-02&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如果缓冲区是满的，又要写入新的数据，这时有两种策略：一种是覆盖掉最老的数据，也就是将老数据丢掉；另一种是返回错误码或者抛出异常。来看策略一，例如，这时写入两个元素 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; ，就会覆盖掉 &lt;code&gt;3&lt;/code&gt; 和 &lt;code&gt;4&lt;/code&gt; ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/375px-Circular_buffer_-_6789AB5.svg-2023-12-02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;375px-Circular_buffer_-_6789AB5.svg-2023-12-02&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;再看，这时如果读出两个元素，就不是 &lt;code&gt;3&lt;/code&gt; 和 &lt;code&gt;4&lt;/code&gt; 而是 &lt;code&gt;5&lt;/code&gt; 和 &lt;code&gt;6&lt;/code&gt;（ &lt;code&gt;5&lt;/code&gt; 和 &lt;code&gt;6&lt;/code&gt; 这时最老），&lt;code&gt;3&lt;/code&gt; 和 &lt;code&gt;4&lt;/code&gt; 已经被 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 覆盖掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/375px-Circular_buffer_-_X789ABX.svg-2023-12-02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;375px-Circular_buffer_-_X789ABX.svg-2023-12-02&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;通过这个简单的例子，可以总结出要实现 &lt;strong&gt;环形缓冲区（ring buffer）&lt;/strong&gt; 需要注意到几个问题点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在缓冲区满的时候写数据，有两种策略可以使用：第一覆盖掉老数据；第二抛出异常；&lt;/li&gt;
&lt;li&gt;读数据时，一定要读出缓冲区中最老的数据（缓冲区中数据满足FIFO特性）；&lt;/li&gt;
&lt;li&gt;怎样来判断缓冲区是满的；&lt;/li&gt;
&lt;li&gt;如何实现一个线性地址空间的循环读写。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-具体操作&#34;&gt;2. 具体操作&lt;/h3&gt;
&lt;p&gt;一般的，对一个环形缓冲区进行读写操作，最少需要 &lt;code&gt;4&lt;/code&gt; 个信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在内存中的实际 &lt;strong&gt;开始位置&lt;/strong&gt; （例如：一片内存的头指针，数组的第一个元素指针）；&lt;/li&gt;
&lt;li&gt;在内存中的实际 &lt;strong&gt;结束位置&lt;/strong&gt; （也可以是缓冲区实际空间大小，结合开始位置，可以算出结束位置）；&lt;/li&gt;
&lt;li&gt;在缓冲区中进行写操作时的 &lt;strong&gt;写索引&lt;/strong&gt; 值；&lt;/li&gt;
&lt;li&gt;在缓冲区中进行读操作时的 &lt;strong&gt;读索引&lt;/strong&gt; 值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缓冲区开始位置&lt;/strong&gt; 和 &lt;strong&gt;缓冲区结束位置（或空间大小）&lt;/strong&gt; 实际上定义了环形缓冲区的实际逻辑空间和大小。 &lt;strong&gt;读索引&lt;/strong&gt; 和 &lt;strong&gt;写索引&lt;/strong&gt; 标记了缓冲区进行读操作和写操作时的具体位置。&lt;/p&gt;
&lt;p&gt;具体来说，读写逻辑如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当环形缓冲区为空时，读索引和写索引指向相同的位置（因为是环形缓冲区，可以出现在任何位置）；&lt;/li&gt;
&lt;li&gt;当向缓冲区写入一个元素时，元素被写入 &lt;strong&gt;写索引&lt;/strong&gt; 当前所指向位置，然后写索引加1，指向下一个位置；&lt;/li&gt;
&lt;li&gt;当从缓冲区读出一个元素时，在 &lt;strong&gt;读索引&lt;/strong&gt; 当前所指向位置的元素被读出，然后读索引加1，指向下一个位置；&lt;/li&gt;
&lt;li&gt;当缓冲区满时，写索引和读索引指向相同的位置（和缓冲区为空时一样）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;21-在缓冲区满的时候写数据有两种策略可以使用&#34;&gt;2.1 在缓冲区满的时候写数据，有两种策略可以使用&lt;/h4&gt;
&lt;p&gt;缓冲区变满在 &lt;strong&gt;环形缓冲区（ring buffer）&lt;/strong&gt; 中会实际发生，一般会有两种处理策略，第一覆盖掉老数据；第二抛出“异常”。这两种策略该如何选择要结合具体的应用场景。如音/视频流中，丢掉一些数据不要紧，可以选择第一种策略；在任务间通信的时候，要严格保证数据正确传输，这个时候就要选择第二种策略。&lt;/p&gt;
&lt;h4 id=&#34;22-读数据时一定要读出缓冲区中最老的数据&#34;&gt;2.2 读数据时，一定要读出缓冲区中最老的数据&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;环形缓冲区（ring buffer）&lt;/strong&gt; 也是 &lt;code&gt;FIFO&lt;/code&gt; 类型的数据结构，需要满足先进先出的原则。写就相当于进，读就相当于出。所以读数据时，一定要保证读最老的数据。一般的情况下不会有问题，但有一种场景需要小心： &lt;strong&gt;当缓冲区是满的时候，继续写入元素（覆盖），除了写索引要变，读索引也要跟着变，保证读索引一定是指向缓冲区中最老的元素&lt;/strong&gt; 。&lt;/p&gt;
&lt;h4 id=&#34;23-怎样来判断缓冲区是满的&#34;&gt;2.3 怎样来判断缓冲区是满的&lt;/h4&gt;
&lt;p&gt;判断缓冲区是满还是空，在环形缓冲区（ring buffer）中是一个重点问题，在&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Circular_buffer&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;维基百科&lt;/a&gt;中，讲解了五种判断方法，感兴趣可以看一下。在平衡各方优缺点后，本节重点讲解 &lt;strong&gt;镜像指示位&lt;/strong&gt; 方法，在 &lt;code&gt;linux&lt;/code&gt; 和 &lt;code&gt;RT-Thread&lt;/code&gt; 实现的环形缓冲区中，也都是用的该策略（或者说是该策略的扩展）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;镜像指示位：缓冲区的长度如果是 n ，逻辑地址空间则为 0 至 n-1 ；那么，规定 n 至 2n-1 为镜像逻辑地址空间。本策略规定读写指针的地址空间为 0 至 2n-1 ，其中低半部分对应于常规的逻辑地址空间，高半部分对应于镜像逻辑地址空间。当指针值大于等于 2n 时，使其折返（wrapped）到ptr-2n。使用一位表示写指针或读指针是否进入了虚拟的镜像存储区：置位表示进入，不置位表示没进入还在基本存储区。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在读写指针的值相同情况下，如果二者的指示位相同，说明缓冲区为空；如果二者的指示位不同，说明缓冲区为满。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这种方法优点是测试缓冲区满/空很简单；不需要做取余数操作；读写线程可以分别设计专用算法策略，能实现精致的并发控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点是读写指针各需要额外的一位作为指示位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果缓冲区长度是 &lt;code&gt;2&lt;/code&gt; 的幂，则本方法可以省略镜像指示位。如果读写指针的值相等，则缓冲区为空；如果读写指针相差 &lt;code&gt;n&lt;/code&gt; ，则缓冲区为满，这可以用条件表达式（写指针 == (读指针 异或 缓冲区长度)）来判断。—— 维基百科&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/v2-22cba7a9b8ff0746184d752a63621981_1440w-2023-12-02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;v2-22cba7a9b8ff0746184d752a63621981_1440w-2023-12-02&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上面是维基百科中对 &lt;strong&gt;镜像指示位&lt;/strong&gt; 的整体描述，但是单凭上面这一个描述，去理解 &lt;strong&gt;镜像指示位&lt;/strong&gt; 方法还是有一定困难，下面来进行一些讨论。&lt;/p&gt;
&lt;p&gt;上面描述中提到了 &lt;strong&gt;读/写指针&lt;/strong&gt; 的概念，注意这个读/写指针和上文提到的 &lt;strong&gt;读索引&lt;/strong&gt; 和 &lt;strong&gt;写索引&lt;/strong&gt; 不是一回事。读写指针的范围是 $[0, 2n-1]$ ，而 &lt;strong&gt;读索引&lt;/strong&gt; 和 &lt;strong&gt;写索引&lt;/strong&gt; 的范围是 $[0, n - 1]$ ，其必须和缓冲区的实际逻辑空间一致。但是 &lt;strong&gt;读/写指针&lt;/strong&gt; 和 &lt;strong&gt;读索引&lt;/strong&gt; 和 &lt;strong&gt;写索引&lt;/strong&gt; 有一个转换关系：&lt;/p&gt;
&lt;p&gt;$$
读索引 = 读指针 \bmod 缓冲区长度 \\
写索引 = 写指针 \bmod 缓冲区长度
$$&lt;/p&gt;
&lt;p&gt;但是如果缓冲区长度是 &lt;code&gt;2&lt;/code&gt; 的幂，那么求余运算可以等价的转换为如下的 &lt;strong&gt;按位与&lt;/strong&gt; 运算：&lt;/p&gt;
&lt;p&gt;$$
读索引 = 读指针 \&amp;amp; (缓冲区长度 - 1) \\
写索引 = 写指针 \&amp;amp; (缓冲区长度 - 1)
$$&lt;/p&gt;
&lt;p&gt;按位与的运算效率要比求余运算高的多，在 &lt;code&gt;linux&lt;/code&gt; 内核中将缓冲区长度扩展为 &lt;code&gt;2&lt;/code&gt; 的幂长度随处可见，都是为了用按位与操作代替求余操作。为了判断缓冲区是否为空或者满，镜像指示位策略引入了两个布尔变量（指示位），来分别标记读指针或写指针是否进入了镜像区间 $[n, 2n-1]$ ，在读写指针的值相同情况下，如果二者的指示位相同，说明缓冲区 &lt;strong&gt;为空&lt;/strong&gt; ；如果二者的指示位不同，说明缓冲区 &lt;strong&gt;为满&lt;/strong&gt; 。但如果缓冲区的长度是 &lt;code&gt;2&lt;/code&gt; 的幂，则可以省略镜像指示位。如果读写指针的值相等，则缓冲区为空；如果读写指针相差 &lt;code&gt;n&lt;/code&gt; ，则缓冲区为满。&lt;/p&gt;
&lt;h4 id=&#34;24-如何实现一个线性地址空间的循环读写&#34;&gt;2.4 如何实现一个线性地址空间的循环读写&lt;/h4&gt;
&lt;p&gt;理解了2.3节的描述，再来理解用一个线性地址空间来实现循环读写就比较容易。如一个环形缓冲区的长度为 &lt;strong&gt;七&lt;/strong&gt; ，则其读写索引的区间为 $[0, 6]$ 。当写索引的值为 &lt;code&gt;6&lt;/code&gt; ，再向缓冲区中写入一个元素时，写索引应该要回到缓冲区的起始索引位置 &lt;code&gt;0&lt;/code&gt; ，读索引在碰到这种情况也是类似处理。总结为一句话就是，当写索引或读索引已经到了环形缓冲区的结束位置时，进行下一步操作时，其应该要回到环形缓冲区的开始位置。&lt;/p&gt;
&lt;h2 id=&#34;三实现&#34;&gt;三、实现&lt;/h2&gt;
&lt;p&gt;对于环形缓冲区的代码实现，本文会分析 &lt;strong&gt;RT-Thread&lt;/strong&gt; 的 &lt;code&gt;ringbuffer.c&lt;/code&gt; 和 &lt;code&gt;ringbuffer.h&lt;/code&gt; 文件，&lt;strong&gt;Linux&lt;/strong&gt; 内核中的 &lt;code&gt;kfifo.h&lt;/code&gt; 和 &lt;code&gt;kfifo.c&lt;/code&gt; 文件。&lt;/p&gt;
&lt;h3 id=&#34;1-rt-thread-中实现的-ring-buffer&#34;&gt;1. RT-Thread 中实现的 ring buffer&lt;/h3&gt;
&lt;p&gt;下面分析 &lt;strong&gt;RT-Thread&lt;/strong&gt; 的 &lt;strong&gt;ring buffer&lt;/strong&gt; 实现，主要会讨论 &lt;strong&gt;环形缓冲区结构体&lt;/strong&gt; 、 &lt;strong&gt;缓冲区初始化操作&lt;/strong&gt; 、&lt;strong&gt;写操作&lt;/strong&gt; 、 &lt;strong&gt;读操作&lt;/strong&gt; 、&lt;strong&gt;判断缓冲区是否为空或满&lt;/strong&gt; 。&lt;/p&gt;
&lt;h4 id=&#34;11-环形缓冲区结构体&#34;&gt;1.1 环形缓冲区结构体&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;RT-Thread&lt;/code&gt; 中定义了结构体 &lt;code&gt;rt_ringbuffer&lt;/code&gt; ，其中 &lt;code&gt;buffer_ptr&lt;/code&gt; 、 &lt;code&gt;buffer_size&lt;/code&gt; 、 &lt;code&gt;read_index&lt;/code&gt; 、 &lt;code&gt;write_index&lt;/code&gt; 和之前介绍的 4 个信息是完全对应的。为了判断缓冲区是空还是满，还定义了两个布尔型变量 &lt;code&gt;read_mirror&lt;/code&gt; 和 &lt;code&gt;write_mirror&lt;/code&gt; ，其是通过位域的定义方式来实现。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rt_ringbuffer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;rt_uint8_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;rt_uint16_t&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;read_mirror&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;rt_uint16_t&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;read_index&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;rt_uint16_t&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;write_mirror&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;rt_uint16_t&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;write_index&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;rt_int16_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;12-缓冲区初始化操作&#34;&gt;1.2 缓冲区初始化操作&lt;/h4&gt;
&lt;p&gt;初始化操作 &lt;code&gt;rt_ringbuffer_init&lt;/code&gt; 很容易理解，就是将申请好的内存地址赋值给环形缓冲区，缓冲区实际逻辑大小也传入进去。&lt;code&gt;read_index&lt;/code&gt; 、&lt;code&gt;write_index&lt;/code&gt; 、&lt;code&gt;read_mirror&lt;/code&gt; 和 &lt;code&gt;write_mirror&lt;/code&gt; 全部初始化为零。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rt_ringbuffer_init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rt_ringbuffer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                        &lt;span class=&#34;kt&#34;&gt;rt_uint8_t&lt;/span&gt;           &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                        &lt;span class=&#34;kt&#34;&gt;rt_int16_t&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;RT_ASSERT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RT_NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;RT_ASSERT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;cm&#34;&gt;/* initialize read and write index */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_mirror&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_mirror&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;cm&#34;&gt;/* set buffer pool and size */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_ptr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;RT_ALIGN_DOWN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RT_ALIGN_SIZE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;13-写操作和读操作&#34;&gt;1.3 写操作和读操作&lt;/h4&gt;
&lt;p&gt;写操作有两个接口 &lt;code&gt;rt_ringbuffer_put&lt;/code&gt; 和 &lt;code&gt;rt_ringbuffer_put_force&lt;/code&gt; ，当缓冲区满的时候，前一个不会写入，后一个会强制写入（覆盖）；读操作有一个接口 &lt;code&gt;rt_ringbuffer_get&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这里先说明一下， &lt;strong&gt;RT-Thread&lt;/strong&gt; 的 &lt;strong&gt;ring buffer&lt;/strong&gt; 实现虽然借鉴了上一章讲的 &lt;strong&gt;镜像指示位&lt;/strong&gt; 策略，但其并没有使用读写指针，而是直接用的 &lt;strong&gt;写索引&lt;/strong&gt; 和 &lt;strong&gt;读索引&lt;/strong&gt; ，也就是说结构体中的 &lt;code&gt;read_index&lt;/code&gt; 和 &lt;code&gt;write_index&lt;/code&gt; 就是写索引和读索引，无需进行转换，直接可以用来操作缓冲区。这一点和 &lt;code&gt;linux&lt;/code&gt; 的实现方式不同，在下面的 &lt;code&gt;linux&lt;/code&gt; 章节中会看到。但 &lt;code&gt;read_mirror&lt;/code&gt; 和 &lt;code&gt;write_mirror&lt;/code&gt; 是和 &lt;strong&gt;镜像指示位策略&lt;/strong&gt; 中讲的一样，用来标记是否进入了镜像区间。&lt;/p&gt;
&lt;p&gt;先来看 &lt;code&gt;rt_ringbuffer_put&lt;/code&gt; 的实现，该函数的返回值是实际写入大小，就是如果传入的 &lt;code&gt;length&lt;/code&gt; 大于缓冲区的剩余空间，则 &lt;code&gt;length&lt;/code&gt; 只有部分会被写入缓冲区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;if (rb-&amp;gt;buffer_size - rb-&amp;gt;write_index &amp;gt; length)&lt;/code&gt; 为真时，就是说从 &lt;strong&gt;写索引&lt;/strong&gt; 到缓冲区结束位置这一段空间能容纳全部所写入数据。写索引无需回环。对应的代码就是 &lt;code&gt;rt_memcpy(&amp;amp;rb-&amp;gt;buffer_ptr[rb-&amp;gt;write_index], ptr, length);&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;if (rb-&amp;gt;buffer_size - rb-&amp;gt;write_index &amp;gt; length)&lt;/code&gt; 为假时，就是说从 &lt;strong&gt;写索引&lt;/strong&gt; 到缓冲区结束位置这一段空间无法全部容纳所写入数据，写索引需要回环到缓冲区开头，写入剩下的数据。对应代码就是 &lt;code&gt;rt_memcpy(&amp;amp;rb-&amp;gt;buffer_ptr[rb-&amp;gt;write_index],&amp;amp;ptr[0],rb-&amp;gt;buffer_size - rb-&amp;gt;write_index);&lt;/code&gt; 和 &lt;code&gt;rt_memcpy(&amp;amp;rb-&amp;gt;buffer_ptr[0],&amp;amp;ptr[rb-&amp;gt;buffer_size - rb-&amp;gt;write_index],length - (rb-&amp;gt;buffer_size - rb-&amp;gt;write_index));&lt;/code&gt; 。因为写索引已经回环了，所以要将 &lt;code&gt;write_mirror&lt;/code&gt; 做一下取反操作：&lt;code&gt;rb-&amp;gt;write_mirror = ~rb-&amp;gt;write_mirror;&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;写操作接口 &lt;code&gt;rt_ringbuffer_put_force&lt;/code&gt; 和上面介绍的基本一样，其实就是多了当传入的 &lt;code&gt;length&lt;/code&gt; 大于缓冲区的剩余空间时，会将已有的元素覆盖掉。如果发生了元素覆盖，那缓冲区一定会变满，&lt;code&gt;read_index&lt;/code&gt; 和 &lt;code&gt;write_index&lt;/code&gt; 会相等，对应语句 &lt;code&gt;if (length &amp;gt; space_length) rb-&amp;gt;read_index = rb-&amp;gt;write_index;&lt;/code&gt; 。因为会操作 &lt;code&gt;read_index&lt;/code&gt; 元素，也要考虑其是否发生了回环，发生了回环后 &lt;code&gt;read_mirror&lt;/code&gt; 需要取反，对应语句 &lt;code&gt;rb-&amp;gt;read_mirror = ~rb-&amp;gt;read_mirror;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;读接口 &lt;code&gt;rt_ringbuffer_get&lt;/code&gt; 和写接口的操作逻辑基本一致，也是通过条件 &lt;code&gt;if (rb-&amp;gt;buffer_size - rb-&amp;gt;write_index &amp;gt; length)&lt;/code&gt; 将读操作分成了两种情形，过程和写操作接口 &lt;code&gt;rt_ringbuffer_put&lt;/code&gt; 没有差异。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;  1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 95
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 96
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 97
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 98
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 99
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;100
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;101
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;102
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;103
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;104
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;105
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;106
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;107
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;108
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;109
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;110
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;111
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;112
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;113
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;114
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;115
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;116
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;117
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;118
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;119
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;120
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;121
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;122
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;123
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;124
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;125
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;126
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;127
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;128
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;129
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;130
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;131
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;132
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;133
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;134
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;135
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;136
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;137
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;138
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;139
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;140
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;141
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;142
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;143
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;144
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;145
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;146
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;147
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;148
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;149
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;150
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;151
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;152
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;153
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;154
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;155
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;156
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;157
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;158
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;159
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;160
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;161
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;162
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;163
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;164
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;165
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;166
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * @brief Put a block of data into the ring buffer. If the capacity of ring buffer is insufficient, it will discard out-of-range data.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * @param rb            A pointer to the ring buffer object.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * @param ptr           A pointer to the data buffer.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * @param length        The size of data in bytes.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * @return Return the data size we put into the ring buffer.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;rt_size_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rt_ringbuffer_put&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rt_ringbuffer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                            &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;rt_uint8_t&lt;/span&gt;     &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                            &lt;span class=&#34;kt&#34;&gt;rt_uint16_t&lt;/span&gt;           &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;rt_uint16_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;RT_ASSERT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RT_NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;cm&#34;&gt;/* whether has enough space */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rt_ringbuffer_space_len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;cm&#34;&gt;/* no space */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;cm&#34;&gt;/* drop some data */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;cm&#34;&gt;/* read_index - write_index = empty space */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;rt_memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;cm&#34;&gt;/* this should not cause overflow because there is enough space for
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * length of data in current mirror */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;rt_memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;rt_memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;cm&#34;&gt;/* we are going into the other side of the mirror */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_mirror&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;~&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_mirror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;RTM_EXPORT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rt_ringbuffer_put&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * @brief Put a block of data into the ring buffer. If the capacity of ring buffer is insufficient, it will overwrite the existing data in the ring buffer.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * @param rb            A pointer to the ring buffer object.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * @param ptr           A pointer to the data buffer.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * @param length        The size of data in bytes.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * @return Return the data size we put into the ring buffer.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;rt_size_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rt_ringbuffer_put_force&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rt_ringbuffer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                            &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;rt_uint8_t&lt;/span&gt;     &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                            &lt;span class=&#34;kt&#34;&gt;rt_uint16_t&lt;/span&gt;           &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;rt_uint16_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;space_length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;RT_ASSERT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RT_NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;space_length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rt_ringbuffer_space_len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;cm&#34;&gt;/* read_index - write_index = empty space */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;rt_memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;cm&#34;&gt;/* this should not cause overflow because there is enough space for
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * length of data in current mirror */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;space_length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;rt_memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;rt_memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;cm&#34;&gt;/* we are going into the other side of the mirror */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_mirror&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;~&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_mirror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;space_length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_mirror&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;~&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_mirror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;RTM_EXPORT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rt_ringbuffer_put_force&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * @brief Get data from the ring buffer.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * @param rb            A pointer to the ring buffer.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * @param ptr           A pointer to the data buffer.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * @param length        The size of the data we want to read from the ring buffer.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * @return Return the data size we read from the ring buffer.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;rt_size_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rt_ringbuffer_get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rt_ringbuffer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                            &lt;span class=&#34;kt&#34;&gt;rt_uint8_t&lt;/span&gt;           &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                            &lt;span class=&#34;kt&#34;&gt;rt_uint16_t&lt;/span&gt;           &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;rt_size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;RT_ASSERT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RT_NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;cm&#34;&gt;/* whether has enough data  */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rt_ringbuffer_data_len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;cm&#34;&gt;/* no data */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;cm&#34;&gt;/* less data */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;cm&#34;&gt;/* copy all of data */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;rt_memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;cm&#34;&gt;/* this should not cause overflow because there is enough space for
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * length of data in current mirror */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;rt_memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;rt_memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;cm&#34;&gt;/* we are going into the other side of the mirror */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_mirror&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;~&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_mirror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;RTM_EXPORT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rt_ringbuffer_get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;14-判断缓冲区是否为空或满&#34;&gt;1.4 判断缓冲区是否为空或满&lt;/h4&gt;
&lt;p&gt;判断缓冲区是否为空或满，通过函数 &lt;code&gt;rt_ringbuffer_status&lt;/code&gt; 来实现。其逻辑是：在读写指针的值相同情况下，如果二者的指示位相同，说明缓冲区 &lt;strong&gt;为空&lt;/strong&gt; ；如果二者的指示位不同，说明缓冲区 &lt;strong&gt;为满&lt;/strong&gt; 。注意这里的读写指针已经在读写( &lt;code&gt;rt_ringbuffer_get&lt;/code&gt; 和 &lt;code&gt;rt_ringbuffer_put&lt;/code&gt; )过程中转换为了读写索引。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;rt_inline&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rt_ringbuffer_state&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rt_ringbuffer_status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rt_ringbuffer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_mirror&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write_mirror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RT_RINGBUFFER_EMPTY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RT_RINGBUFFER_FULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RT_RINGBUFFER_HALFFULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;小结&#34;&gt;小结&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在多线程中，对同一个环形缓冲区进行读写操作时，需要加上锁，不然存在访问不安全问题；&lt;/li&gt;
&lt;li&gt;当只有一个读线程和一个写线程（单生产者单消费者模型）时，用 &lt;code&gt;rt_ringbuffer_put&lt;/code&gt; 和 &lt;code&gt;rt_ringbuffer_get&lt;/code&gt; 进行读写操作缓冲区是线程安全的，无需加锁；但是 &lt;code&gt;rt_ringbuffer_put_force&lt;/code&gt; 不行，因为其可能对 &lt;strong&gt;读写索引&lt;/strong&gt; 都进行操作的场景，这个时候再进行 &lt;code&gt;rt_ringbuffer_get&lt;/code&gt; 读操作，就是不安全访问；&lt;/li&gt;
&lt;li&gt;读写指针已经在读写( &lt;code&gt;rt_ringbuffer_get&lt;/code&gt; 和 &lt;code&gt;rt_ringbuffer_put&lt;/code&gt; )过程中转换为了读写索引。所以 &lt;code&gt;read_index&lt;/code&gt;(读索引)和 &lt;code&gt;write_index&lt;/code&gt; (写索引)可以直接用来操作缓冲区，无需转换；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read_index&lt;/code&gt; 和 &lt;code&gt;write_index&lt;/code&gt; 的大小区间为$[0, n-1]$ ， $n$ 为缓冲区大小；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RT-Thread&lt;/strong&gt; 的环形缓冲区不需要 &lt;code&gt;buffer&lt;/code&gt; 大小为 &lt;strong&gt;2的幂&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-linux-中实现的-ring-buffer&#34;&gt;2. Linux 中实现的 ring buffer&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;linux&lt;/code&gt; 内核中， &lt;code&gt;kfifo&lt;/code&gt; 就是 &lt;strong&gt;ring buffer&lt;/strong&gt; 的经典实现方式，本文将介绍 &lt;code&gt;linux 2.6&lt;/code&gt; 版本中的 &lt;strong&gt;ring buffer&lt;/strong&gt; 实现方式，主要介绍 &lt;strong&gt;缓冲区结构体&lt;/strong&gt; 、 &lt;strong&gt;缓冲区初始化&lt;/strong&gt; 、 &lt;strong&gt;读操作&lt;/strong&gt; 、 &lt;strong&gt;写操作&lt;/strong&gt; 、 &lt;strong&gt;判断缓冲区是否为空或满&lt;/strong&gt; 。&lt;/p&gt;
&lt;h4 id=&#34;21-缓冲区结构体&#34;&gt;2.1 缓冲区结构体&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;kfifo&lt;/code&gt; 的 &lt;strong&gt;ring buffer&lt;/strong&gt; 结构体定义如下，其中 &lt;code&gt;buffer、size、in、out&lt;/code&gt; 环形缓冲区4个信息是一一对应的。但其中 &lt;code&gt;in&lt;/code&gt; 、 &lt;code&gt;out&lt;/code&gt; 分别是 &lt;strong&gt;写指针&lt;/strong&gt; 和 &lt;strong&gt;读指针&lt;/strong&gt; ，而不是 &lt;strong&gt;写索引&lt;/strong&gt; 和 &lt;strong&gt;读索引&lt;/strong&gt; 。参数 &lt;code&gt;lock&lt;/code&gt; 是自旋锁，在多进程/线程对同一个环形缓冲区进行读写操作时，需要进行锁保护。和 &lt;strong&gt;RT-Thread&lt;/strong&gt; 对比，可以看到其并没有读写的 &lt;strong&gt;镜像指示位&lt;/strong&gt; 。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kfifo&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* the buffer holding the data */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* the size of the allocated buffer */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* data is added at offset (in % size) */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* data is extracted from off. (out % size) */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;kt&#34;&gt;spinlock_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* protects concurrent modifications */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;22-缓冲区初始化&#34;&gt;2.2 缓冲区初始化&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;kfifo&lt;/code&gt; 的初始化 &lt;code&gt;kfifo_init&lt;/code&gt; 中可以看出，其会对所传入的 &lt;code&gt;size&lt;/code&gt; 大小进行扩展，使其满足 &lt;code&gt;size&lt;/code&gt; 为 &lt;strong&gt;2的幂&lt;/strong&gt; 。这样就可以使用性质： &lt;strong&gt;如果缓冲区的长度是 2 的幂 ，则可以省略镜像指示位。如果读写指针的值相等，则缓冲区为空；如果读写指针相差n(缓冲区大小)，则缓冲区为满&lt;/strong&gt; 。所以在传入 &lt;code&gt;buffer&lt;/code&gt; 的 &lt;code&gt;size&lt;/code&gt; 大小时，最好开始就将其确定为 &lt;strong&gt;2的幂&lt;/strong&gt; 。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kfifo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;kfifo_init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gfp_mask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;spinlock_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kfifo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;cm&#34;&gt;/* size must be a power of 2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nf&#34;&gt;BUG_ON&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;kmalloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kfifo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gfp_mask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ERR_PTR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ENOMEM&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;23-读操作和写操作&#34;&gt;2.3 读操作和写操作&lt;/h4&gt;
&lt;p&gt;可以看到 &lt;code&gt;kfifo&lt;/code&gt; 对读操作和写操作的实现非常简洁。在进行读操作和写操作时，其充分利用了无符号整型的性质。在 &lt;code&gt;__kfifo_put&lt;/code&gt; (写操作)和 &lt;code&gt;__kfifo_get&lt;/code&gt; (读操作)时， &lt;code&gt;in&lt;/code&gt; (写指针)和 &lt;code&gt;out&lt;/code&gt; (读指针)都是正向增加的，当达到最大值时，产生溢出，使得从 &lt;code&gt;0&lt;/code&gt; 开始，进行循环使用。 &lt;strong&gt;in(写指针)&lt;/strong&gt;  和 &lt;strong&gt;out(读指针)&lt;/strong&gt;  会恒定的保持如下关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读指针 + 缓冲区已存储数据长度 = 写指针&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中读指针是 &lt;code&gt;out&lt;/code&gt; ，写指针是 &lt;code&gt;in&lt;/code&gt; 。 &lt;strong&gt;out(读指针)&lt;/strong&gt; 永远不会超过 &lt;strong&gt;in(写指针)&lt;/strong&gt; 的大小，最多两者相等，相等就是缓冲区为空的时候。&lt;/p&gt;
&lt;p&gt;先看 &lt;code&gt;__kfifo_put&lt;/code&gt; 的源码。 &lt;code&gt;len = min(len, fifo-&amp;gt;size - fifo-&amp;gt;in + fifo-&amp;gt;out);&lt;/code&gt; 中表达的意思就是实际写入的长度一定要小于缓冲区的可用空间大小，防止发生覆盖已有元素的场景。来看这一句 &lt;code&gt;l = min(len, fifo-&amp;gt;size - (fifo-&amp;gt;in &amp;amp; (fifo-&amp;gt;size - 1)));&lt;/code&gt; ，其中 &lt;code&gt;(fifo-&amp;gt;in &amp;amp; (fifo-&amp;gt;size - 1))&lt;/code&gt; 就是将 &lt;strong&gt;in(写指针)&lt;/strong&gt; 转换为写索引，整体表达的意思是从 &lt;strong&gt;写索引&lt;/strong&gt; 到缓冲区结束位置这一段所能写入数据的大小，这一段写入操作的代码为 &lt;code&gt;memcpy(fifo-&amp;gt;buffer + (fifo-&amp;gt;in &amp;amp; (fifo-&amp;gt;size - 1)), buffer, l);&lt;/code&gt; 。如果这一段还不够，需要折返到缓冲区的开始位置，将剩下的部分写入到缓冲区中，其代码为 &lt;code&gt;memcpy(fifo-&amp;gt;buffer, buffer + l, len - l);&lt;/code&gt; 。而且 $len &amp;gt;= l$, 当 $len=l$ 就说明第一段已经可以容纳所写入大小，缓冲区无需折返，第二个 &lt;code&gt;memcpy&lt;/code&gt; 拷贝了零个字节，相当于什么也没有发生。&lt;/p&gt;
&lt;p&gt;再看 &lt;code&gt;__kfifo_get&lt;/code&gt; 的源码。其思路基本和 &lt;code&gt;__kfifo_put&lt;/code&gt; 一致，了解了上面的转换关系，就比较好理解：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * __kfifo_put - puts some data into the FIFO, no locking version
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * @fifo: the fifo to be used.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * @buffer: the data to be added.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * @len: the length of the data to be added.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * This function copies at most &amp;#39;len&amp;#39; bytes from the &amp;#39;buffer&amp;#39; into
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * the FIFO depending on the free space, and returns the number of
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * bytes copied.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * Note that with only one concurrent reader and one concurrent
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * writer, you don&amp;#39;t need extra locking to use these functions.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;__kfifo_put&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kfifo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;cm&#34;&gt;/* first put the data starting from fifo-&amp;gt;in to buffer end */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nf&#34;&gt;memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;cm&#34;&gt;/* then put the rest (if any) at the beginning of the buffer */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nf&#34;&gt;memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;EXPORT_SYMBOL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;__kfifo_put&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;__kfifo_get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kfifo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;cm&#34;&gt;/* first get the data from fifo-&amp;gt;out until the end of the buffer */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nf&#34;&gt;memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;cm&#34;&gt;/* then get the rest (if any) from the beginning of the buffer */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nf&#34;&gt;memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;EXPORT_SYMBOL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;__kfifo_get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;24-判断缓冲区是否为空或满&#34;&gt;2.4 判断缓冲区是否为空或满&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;kfifo&lt;/code&gt; 中没有专门的函数判断缓冲区是否为空或满，但可以通过 &lt;code&gt;__kfifo_len&lt;/code&gt; 函数获取 &lt;strong&gt;缓冲区已存储数据长度&lt;/strong&gt; 。如果其值等于零就说明缓冲区为空，如果其值等于缓冲区大小，就说明缓冲区满。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;inline&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;__kfifo_len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kfifo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fifo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;小结-1&#34;&gt;小结&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;linux&lt;/code&gt; 中环形缓冲区（ring buffer）的实现，其实是对 &lt;strong&gt;镜像指示位&lt;/strong&gt; 策略的扩展，读指针和写指针区间范围不再局限在镜像区间 $[0, 2n-1]$ ，而是整个unsigned int大小的空间，对于32位机器，读指针和写指针的区间范围是 $[0, 2^32 - 1]$ ;&lt;/li&gt;
&lt;li&gt;进行扩展后，还能维持如下的关系，是因为缓冲区大小 &lt;code&gt;n&lt;/code&gt; 会被扩展为 &lt;strong&gt;2的幂&lt;/strong&gt; ，那么 $2^32$ 肯定是 $n$ 扩展后的整数倍，所以还是能够满足如下关系；
&lt;ul&gt;
&lt;li&gt;读索引 = 读指针 &amp;amp; (缓冲区长度 - 1)&lt;/li&gt;
&lt;li&gt;写索引 = 写指针 &amp;amp; (缓冲区长度 - 1)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读索引和写索引的区间范围仍然是 $[0, n-1]$ ， $n$ 为缓冲区大小；&lt;/li&gt;
&lt;li&gt;在多进程/线程中，对同一个环形缓冲区进行读写操作时，需要加上锁，不然存在访问不安全问题；&lt;/li&gt;
&lt;li&gt;当只有一个读进程/线程和一个写进程/线程时，无需加锁，也能保证访问安全。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-517版本的linux中实现的-ring-buffer&#34;&gt;3. 5.17+版本的Linux中实现的 ring buffer&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;linux5.17+&lt;/code&gt; 版本中的 &lt;code&gt;kfifo.c&lt;/code&gt; 和 &lt;code&gt;kfifo.h&lt;/code&gt; 中，其源码实现已经和 &lt;code&gt;linux 2.6&lt;/code&gt; 版本有很大的不同，但是最新版本的 &lt;strong&gt;ring buffer&lt;/strong&gt; 核心思想和 &lt;code&gt;linux 2.6&lt;/code&gt; 版本并没有不同。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kfifo.h&lt;/code&gt; 文件中定义的 ring buffer 结构体，其中 &lt;code&gt;in&lt;/code&gt; 、 &lt;code&gt;out&lt;/code&gt; 依然是 &lt;strong&gt;写指针&lt;/strong&gt; 和 &lt;strong&gt;读指针&lt;/strong&gt; ，&lt;code&gt;mask&lt;/code&gt; 是缓冲区大小减1（做&amp;amp;操作，更方便的将读写指针转换为 &lt;strong&gt;读写索引&lt;/strong&gt; ）， &lt;code&gt;esize&lt;/code&gt; 缓冲区单个存储元素的字节大小(在 &lt;code&gt;linux 2.6&lt;/code&gt; 版本中，一个元素就是一个字节大小，最新版本将其进行了扩展)， &lt;code&gt;data&lt;/code&gt; 缓冲区的逻辑起始地址（指针类型不再是字节）。其它的 &lt;strong&gt;初始化接口&lt;/strong&gt; 、 &lt;strong&gt;读接口&lt;/strong&gt; 、 &lt;strong&gt;写接口&lt;/strong&gt; 、 &lt;strong&gt;判断缓冲区是否为空或满接口逻辑&lt;/strong&gt; 和 &lt;code&gt;linux 2.6&lt;/code&gt; 大致差不多，可以对照源码看一下。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__kfifo&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;esize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;四总结&#34;&gt;四、总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;环形缓冲区（ring buffer）适合于事先明确了缓冲区的最大容量的情形。缓冲区的容量（长度）一般固定，可以用一个静态数组来充当缓冲区，无需重复申请内存；&lt;/li&gt;
&lt;li&gt;如果缓冲区的大小需要经常调整，就不适合用环形缓存区，因为在扩展缓冲区大小时，需要搬移其中的数据，这种场合使用链表更加合适；&lt;/li&gt;
&lt;li&gt;因为缓冲区成头尾相连的环形，写操作可能会覆盖未及时读取的数据，有的场景允许这种情况发生，有的场景又严格限制这种情况发生。选择何种策略和具体应用场景相关；&lt;/li&gt;
&lt;li&gt;环形缓冲区（ring buffer）特别适合于通信双方循环发送数据的场景；&lt;/li&gt;
&lt;li&gt;镜像指示位是一种高效判断缓冲区是否为空或满的策略，在 &lt;strong&gt;RT-Thread&lt;/strong&gt; 和 &lt;strong&gt;linux&lt;/strong&gt; 中都使用了该策略（或者是该策略的扩展），其能够保证在只有一个读线程（或进程）和一个写线程（或进程）中无需锁也能做到线程安全；&lt;/li&gt;
&lt;li&gt;注意区分写指针和写索引，读指针和读索引，最终对缓冲区进行操作还是需要写索引和读索引；&lt;/li&gt;
&lt;li&gt;如果自己嵌入式项目中需要使用环形缓冲区（ring buffer），可以借鉴 &lt;code&gt;linux 2.6&lt;/code&gt; 版本的 &lt;code&gt;kfifo&lt;/code&gt; 实现，很容易改写，而且非常高效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;五参考资料&#34;&gt;五、参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Circular_buffer&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;环形缓冲区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/534098236&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ring buffer，一篇文章讲透它？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>性能刺客之伪共享</title>
        <link>https://cuterwrite.top/p/false-sharing/</link>
        <pubDate>Sat, 02 Dec 2023 00:00:00 +0000</pubDate>
        
        <guid>https://cuterwrite.top/p/false-sharing/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/6c3f8961290e41f894f5a1cbb768aba9-2023-12-02.png" alt="Featured image of post 性能刺客之伪共享" /&gt;&lt;h1 id=&#34;性能刺客之伪共享&#34;&gt;性能刺客之伪共享&lt;/h1&gt;
&lt;h2 id=&#34;一前言&#34;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;在多核并发编程中，如果将互斥锁的争用比作 &lt;strong&gt;性能杀手&lt;/strong&gt; 的话，那么伪共享则相当于 &lt;strong&gt;性能刺客&lt;/strong&gt;。&lt;strong&gt;杀手&lt;/strong&gt; 与 &lt;strong&gt;刺客&lt;/strong&gt; 的区别在于杀手是可见的，遇到杀手时我们可以选择战斗、逃跑、绕路、求饶等多种手段去应付，但 &lt;strong&gt;刺客&lt;/strong&gt; 却不同， &lt;strong&gt;刺客&lt;/strong&gt; 永远隐藏在暗处，伺机给你致命一击，防不胜防。具体到我们的并发编程中，遇到锁争用影响并发性能情况时，我们可以采取多种措施（如缩短临界区，原子操作等等）去提高程序性能，但是伪共享却是我们从所写代码中看不出任何蛛丝马迹的，发现不了问题也就无法解决问题，从而导致伪共享在暗处严重拖累程序的并发性能，但我们却束手无策。&lt;/p&gt;
&lt;h2 id=&#34;二缓存行&#34;&gt;二、缓存行&lt;/h2&gt;
&lt;p&gt;为了进行下面的讨论，我们需要首先熟悉缓存行的概念，学过操作系统课程存储结构这部分内容的同学应该对存储器层次结构的金字塔模型印象深刻，金字塔从上往下代表存储介质的成本降低、容量变大，从下往上则代表存取速度的提高。位于金字塔模型最上层的是 CPU 中的寄存器，其次是 CPU缓存（L1，L2，L3），再往下是内存，最底层是磁盘，操作系统采用这种存储层次模型主要是为了解决 CPU 的高速与内存磁盘低速之间的矛盾，CPU将最近使用的数据预先读取到Cache中，下次再访问同样数据的时候，可以直接从速度比较快的CPU缓存中读取，避免从内存或磁盘读取拖慢整体速度。&lt;/p&gt;
&lt;p&gt;CPU缓存的最小单位就是缓存行，缓存行大小依据架构不同有不同大小，最常见的有 &lt;code&gt;64Byte&lt;/code&gt; 和 &lt;code&gt;32Byte&lt;/code&gt; ，CPU缓存从内存取数据时以缓存行为单位进行，每一次都取需要读取数据所在的整个缓存行，即使相邻的数据没有被用到也会被缓存到 CPU 缓存中。&lt;/p&gt;
&lt;h2 id=&#34;三缓存一致性&#34;&gt;三、缓存一致性&lt;/h2&gt;
&lt;p&gt;在单核CPU情况下，上述方法可以正常工作，可以确保缓存到CPU缓存中的数据永远是 &lt;strong&gt;干净&lt;/strong&gt; 的，因为不会有其他 CPU 去更改内存中的数据，但是在多核 CPU 下，情况就变得更加复杂一些。多 CPU 中，每个 CPU 都有自己的私有缓存（可能共享 L3 缓存），当一个 CPU1 对 Cache 中缓存数据进行操作时，如果 CPU2 在此之前更改了该数据，则 CPU1 中的数据就不再是 &lt;strong&gt;干净&lt;/strong&gt; 的，即应该是失效数据，缓存一致性就是为了保证多 CPU 之间的缓存一致。&lt;/p&gt;
&lt;p&gt;Linux系统中采用 &lt;code&gt;MESI&lt;/code&gt; 协议处理缓存一致性，所谓 &lt;code&gt;MESI&lt;/code&gt; 即是指 CPU 缓存的四种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;M（修改，Modified）：本地处理器已经修改缓存行，即是脏行，它的内容与内存中的内容不一样，并且此 cache 只有本地一个拷贝(专有)；&lt;/li&gt;
&lt;li&gt;E（专有，Exclusive）：缓存行内容和内存中的一样，而且其它处理器都没有这行数据；&lt;/li&gt;
&lt;li&gt;S（共享，Shared）：缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝；&lt;/li&gt;
&lt;li&gt;I（无效，Invalid）：缓存行失效, 不能使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20231202205445-2023-12-02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20231202205445-2023-12-02&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;每个 CPU 缓存行都在四个状态之间互相转换，以此决定 CPU 缓存是否失效，比如 CPU1 对一个缓存行执行了写入操作，则此操作会导致其他 CPU 的该缓存行进入 Invalid 无效状态， CPU 需要使用该缓存行的时候需要从内存中重新读取。由此就解决了多 CPU 之间的缓存一致性问题。&lt;/p&gt;
&lt;h2 id=&#34;四伪共享&#34;&gt;四、伪共享&lt;/h2&gt;
&lt;p&gt;何谓伪共享？上面我们提过 CPU 的缓存是 &lt;strong&gt;以缓存行为单位&lt;/strong&gt; 进行的，即除了本身所需读写的数据之外还会缓存与该数据在同一缓存行的数据，假设缓存行大小是 32 字节，内存中有 &lt;code&gt;abcdefgh&lt;/code&gt; 八个int型数据，当 CPU 读取 &lt;code&gt;d&lt;/code&gt; 这个数据时， CPU 会将 &lt;code&gt;abcdefgh&lt;/code&gt; 八个 int 数据组成一个缓存行加入到 CPU 缓存中。假设计算机有两个 CPU：CPU1 和 CPU2 ， CPU1 只对 &lt;code&gt;a&lt;/code&gt; 这个数据进行频繁读写， CPU2 只对 &lt;code&gt;b&lt;/code&gt; 这个数据进行频繁读写，按理说这两个 CPU 读写数据没有任何关联，也就不会产生任何竞争，不会有性能问题，但是由于 CPU 缓存是以缓存行为单位进行存取的，也是以缓存行为单位失效的，即使 CPU1 只更改了缓存行中 &lt;code&gt;a&lt;/code&gt; 数据，也会导致 CPU2 中该缓存行完全失效，同理，CPU2 对&lt;code&gt; b&lt;/code&gt; 的改动也会导致 CPU1 中该缓存行失效，由此引发了该缓存行在两个CPU之间 &lt;strong&gt;乒乓&lt;/strong&gt; ，缓存行频繁失效，最终导致程序性能下降，这就是伪共享。&lt;/p&gt;
&lt;p&gt;下面是维基百科的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In computer science, &lt;strong&gt;false sharing&lt;/strong&gt; is a performance-degrading usage pattern that can arise in systems with distributed, coherent caches at the size of the smallest resource block managed by the caching mechanism. When a system participant attempts to periodically access data that is not being altered by another party, but that data shares a cache block with data that is being altered, the caching protocol may force the first participant to reload the whole cache block despite a lack of logical necessity. The caching system is unaware of activity within this block and forces the first participant to bear the caching system overhead required by true shared access of a resource.&lt;/p&gt;
&lt;p&gt;在计算机科学中，伪共享是一种性能降低的使用模式，可能出现在具有分布式、一致性缓存的系统中，缓存大小为缓存机制管理的最小资源块。当一个系统参与者试图定期访问未被其他方修改的数据，但该数据与正在被修改的数据共享一个缓存块时，缓存协议可能会强制第一个参与者重新加载整个缓存块，尽管在逻辑上没有必要。 缓存系统无法感知这个块内的活动，并强制第一个参与者承担由真正共享资源访问所需的缓存系统开销。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;五如何避免伪共享&#34;&gt;五、如何避免伪共享&lt;/h2&gt;
&lt;p&gt;避免伪共享主要有以下两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存行填充（Padding）：为了避免伪共享就需要将可能造成伪共享的多个变量处于不同的缓存行中，可以采用在变量后面填充字节的方式达到该目的。&lt;/li&gt;
&lt;li&gt;使用某些语言或编译器中强制变量对齐，将变量都对齐到缓存行大小，避免伪共享发生。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;六获取缓存行大小&#34;&gt;六、获取缓存行大小&lt;/h2&gt;
&lt;p&gt;在 C++11 中，可以使用 &lt;code&gt;std::hardware_destructive_interference_size&lt;/code&gt; 和 &lt;code&gt;std::hardware_constructive_interference_size&lt;/code&gt; 获取缓存行大小，前者获取的是缓存行大小，后者获取的是缓存行大小的两倍，即 &lt;code&gt;2 * std::hardware_destructive_interference_size&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在 C语言中，可以读取 &lt;code&gt;coherency_line_size&lt;/code&gt; 文件获取缓存行大小，该文件位于 &lt;code&gt;/sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size&lt;/code&gt; ，该文件中存储的是缓存行大小的字节数，可以使用 &lt;code&gt;cat&lt;/code&gt; 命令查看。也可以通过 &lt;code&gt;long cache_line_size = sysconf(_SC_LEVEL1_DCACHE_LINESIZE)&lt;/code&gt; 的方式获取。&lt;/p&gt;
&lt;h2 id=&#34;七通过对齐解决伪共享&#34;&gt;七、通过对齐解决伪共享&lt;/h2&gt;
&lt;p&gt;C语言中可以使用 &lt;code&gt;posix_memalign&lt;/code&gt; 函数来实现对齐，该函数的声明如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;posix_memalign&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;memptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;alignment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;一般伪共享都很隐蔽，很难被发现，当伪共享真正构成性能瓶颈的时候，我们有必要去努力找到并解决它，但是在大部分对性能追求没有那么高的应用中，伪共享的存在对程序的危害很小，有时并不值得耗费精力和额外的内存空间（缓存行填充）去查找系统存在的伪共享。还是那句我们一直以来应该遵循的原则 &lt;strong&gt;“不要过度优化，不要提前优化。”&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/37069591&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;C++性能榨汁机之伪共享&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>离子通道与 Hudgkin-Huxley 模型</title>
        <link>https://cuterwrite.top/p/ion-channels-and-hudgkin-huxley/</link>
        <pubDate>Thu, 02 Nov 2023 00:55:55 +0000</pubDate>
        
        <guid>https://cuterwrite.top/p/ion-channels-and-hudgkin-huxley/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20231102162211-2023-11-02.png" alt="Featured image of post 离子通道与 Hudgkin-Huxley 模型" /&gt;&lt;h1 id=&#34;离子通道与-hudgkin-huxley-模型&#34;&gt;离子通道与 Hudgkin-Huxley 模型&lt;/h1&gt;
&lt;p&gt;从生物物理学的角度来看，动作电位是通过细胞膜中离子通道的电流的结果。在对乌贼的巨型轴突进行的一系列广泛实验中，霍奇金和胡克斯利成功地测量了这些电流，并以微分方程的方式描述了它们的动力学。在转向 Hudgkin-Huxley 方程之前，我们需要补充一些关于离子通道平衡电位的额外知识。&lt;/p&gt;
&lt;h2 id=&#34;一平衡电位equilibrium-potential&#34;&gt;一、平衡电位（Equilibrium Potential）&lt;/h2&gt;
&lt;p&gt;神经元和其他细胞一样，被一个膜所包围，该膜将细胞的内部与细胞外空间分开。细胞内的离子浓度与周围液体中的离子浓度不同。浓度的差异产生了一个电位，在神经元动力学中起着重要作用。该小节将对平衡电位给出一个直观的解释。&lt;/p&gt;
&lt;h3 id=&#34;1-nernst-电位nernst-potential&#34;&gt;1. Nernst 电位（Nernst Potential）&lt;/h3&gt;
&lt;p&gt;根据热力学理论，分子处于能量状态的概率与 Boltzmann 因子成正比，即 $p \propto \exp \left( -E/kT \right )$，其中 $E$ 是分子的能量，$k$ 是 Boltzmann 常数，$T$ 是温度。现在考虑带有电荷 $q$ 的正离子在静电场中。它们在位置 $x$ 的能量为 $E=q u(x)$，其中 $u(x)$ 是 $x$ 处的电势。因此，正离子在位置 $x$ 附近的概率为 $p(x) \propto \exp \left[ -q u(x)/kT \right ] $。对于带有正电荷 $q&amp;gt;0$ 的离子，离子密度在电位低的区域更高。我们用 $n(x)$ 表示点 $x$ 处的离子密度。则点 $x_1$ 处和点 $x_2$ 处的密度之间的关系为：&lt;/p&gt;
&lt;p&gt;$$
\frac{n(x_1)}{n(x_2)} = \exp \left [ -\frac{qu(x_1)-qu(x_2)}{kT} \right ] \tag{1.1}
$$&lt;/p&gt;
&lt;p&gt;因此，电位差 $\Delta u = u(x_1) − u(x_2)$ 引起了离子密度的差异。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20231102170347-2023-11-02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20231102170347-2023-11-02&#34;
	
	
&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;图1.1： (a)在热平衡状态下，电场中的正离子分布为：高能态的离子较少，低能态的离子较多。因此，电压差会产生浓度梯度。(b) 类似地，离子浓度的差异会产生电势差。神经元内部的浓度与周围的浓度不同。由此产生的电位称为 &lt;strong&gt;Nernst 电位&lt;/strong&gt; 。实线表示细胞膜。离子可以通过间隙传递。&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;由于这是关于平衡状态的陈述，反过来也是成立的。离子密度的差异会产生电势差 $\Delta u$ 。我们考虑两个离子浓度分别为 $n_1$ 和 $n_2$ 的区域；参见图1.1(b)。通过求解公式 (1.1) 得到 $\Delta u$，我们发现，在平衡状态下，浓度差异会产生一个电压。&lt;/p&gt;
&lt;p&gt;$$
\Delta u = \frac{kT}{q} \ln \frac{n_1}{n_2} \tag{1.2}
$$&lt;/p&gt;
&lt;p&gt;该电压又被称为 Nernst 电位（Hille, 2001）。&lt;/p&gt;
&lt;h3 id=&#34;2-反转电位reversal-potential&#34;&gt;2. 反转电位（Reversal Potential）&lt;/h3&gt;
&lt;p&gt;细胞膜由一层薄的脂质双层组成，几乎是一个完美的电绝缘体。然而，在细胞膜中嵌入了特定的蛋白质，它们作为离子门控通道。第一种类型的门控通道是离子泵，第二种是离子通道。离子泵能够主动地将离子从一侧运输到另一侧。因此，细胞内液体中的离子浓度与周围环境不同。例如，哺乳动物神经元内的钠浓度（约为 $10 mM$ ）低于细胞外液体中的钠浓度（约为 $145 mM$ ）。另一方面，细胞内的钾浓度（约为 $140 mM$ ）高于周围环境中的钾浓度（约为 $5 mM$ ）。对于霍奇金和哈克斯利研究的鱿鱼巨大轴突，这些数字略有不同，但基本思想是相同的：细胞外的钠离子比细胞内多，而钾离子则相反。&lt;/p&gt;
&lt;p&gt;让我们暂时专注于钠离子。在平衡状态下，浓度差引起了约为 $+67 mV$ 的 Nernst 电位 $E_{Na}$ 。也就是说，在平衡状态下，细胞内部相对于周围环境具有正电势。细胞内部和周围液体通过离子通道相互联系，钠离子可以从膜的一侧通过到另一侧。如果电压差 $\Delta u$ 小于 Nernst电势 $E_{Na^{+}}$ 的值，更多的 $Na^+$ 离子会流入细胞，以减小浓度差异。如果电压大于 Nernst 电势，离子会从细胞流出。因此，当电压 $\Delta u$ 通过 $E_{Na}$ 时，电流的方向会反转。因此，$E_{Na}$ 被称为反转电位。&lt;/p&gt;
&lt;p&gt;继续看钾离子，正如上面提到的，钾离子在细胞内的浓度（约为 $140 mM$ ）比细胞外液体（约为 $5 mM$ ）高。钾离子具有单个正电荷 $q = 1.6 × 10^{-19} C$ 。应用 Nernst 公式（1.2），其中玻尔兹曼常数 $k = 1.4 × 10^{-23} J/K$ ，在室温下得到 $E_K ≈ -83 mV$ 。因此，钾离子 $K^{+} 的反转电势是负的。&lt;/p&gt;
&lt;p&gt;到目前为止，我们考虑了钠或钾的存在。在真实的细胞中，这些和其他离子类型同时存在，并对跨膜电压做出贡献。实验发现，细胞膜的静息电位约为 $u_{rest} ≈ 65 mV$ 。由于 $E_K &amp;lt; u_{rest} &amp;lt; E_{Na}$ ，钾离子在静息电位下从细胞流出，而钠离子则流入细胞。在稳态下，主动离子泵平衡这种流动，并通过通道运输与通过通道的离子数量相同的离子返回。$u_{rest}$ 的值由通道中离子流动（膜的渗透性）和主动离子转运（维持浓度差的离子泵的效率）之间的动态平衡决定。&lt;/p&gt;
&lt;h2 id=&#34;二hudgkin-huxley-模型&#34;&gt;二、Hudgkin-Huxley 模型&lt;/h2&gt;
&lt;p&gt;霍奇金和哈克斯利（1952）对乌贼的巨型轴突进行了实验，发现了三种不同类型的离子电流，即钠、钾和主要由氯离子组成的泄漏电流。特定的电压依赖性离子通道，一个用于钠，另一个用于钾，控制这些离子通过细胞膜的流动。泄漏电流负责其他未明确描述的通道类型。&lt;/p&gt;
&lt;h3 id=&#34;1-模型定义model-definition&#34;&gt;1. 模型定义（Model Definition）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20231102175050-2023-11-02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20231102175050-2023-11-02&#34;
	
	
&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;图2.1： Hodgkin-Huxley模型示意图。&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;Hodgkin-Huxley模型可以通过图 2.1 来理解。半透膜细胞膜将细胞内部与细胞外液体隔开，并起到电容器的作用。如果将输入电流 $I(t)$ 注入细胞，它可能会在电容器上增加进一步的电荷，或者通过细胞膜中的通道泄漏。&lt;/p&gt;
&lt;p&gt;图 2.1 中的每种通道类型都由一个电阻器表示。非特异通道具有泄漏电阻 $R$ ，钠通道具有电阻 $R_{Na}$ ，钾通道具有电阻 $R_K$ 。电阻器图中的对角箭头表示电阻值不固定，而是根据离子通道是否打开或关闭而变化。&lt;/p&gt;
&lt;p&gt;由于通过细胞膜的主动离子转运，细胞内的离子浓度与细胞外液体不同。由离子浓度差产生的 Nernst 电位在图 2.1 中由电池表示。由于每种离子类型的 Nernst 电位不同，分别为钠、钾和非特异第三通道设置了单独的电池，其电池电压分别为 $E_{Na}$ 、$E_K$ 和 $E_L$ 。&lt;/p&gt;
&lt;p&gt;现在让我们将上述电路图转化为数学方程。膜上电荷的守恒意味着施加的电流 $I(t)$ 可以分为充电电流 $I_C$ ，用于充电电容器 $C$ ，以及通过离子通道的其他电流 $I_k$ 。因此，可以写成以下方程：&lt;/p&gt;
&lt;p&gt;$$
I(t) = I_C(t) + \sum_{k} I_k(t) \tag{2.1}
$$&lt;/p&gt;
&lt;p&gt;在标准的 Hodgkin-Huxley 模型中，只有三种类型的通道：一个带有 $Na$ 索引的钠通道，一个带有 $K$ 索引的钾通道，以及一个具有电阻 $R$ 的非特异泄漏通道。根据电容的定义 $C = q / u$ ，可以得到充电电流 $I_C = C\frac{du}{dt}$ 。因此，方程 (2.1) 可以写成：&lt;/p&gt;
&lt;p&gt;$$
C \frac{du}{dt} = I(t) - \sum_{k} I_k(t) \tag{2.2}
$$&lt;/p&gt;
&lt;p&gt;在生物学术语中，$u$ 是膜上的电压，$\sum_{k} I_k(t)$ 是通过细胞膜的离子电流之和。&lt;/p&gt;
&lt;p&gt;如上所述，Hodgkin-Huxley 模型描述了三种类型的通道。所有通道可以通过它们的电阻或等效地通过它们的电导来表征。泄漏通道由电压无关的电导 $g_L=1/R$ 来描述。由于 $u$ 是细胞膜上的总电压，$E_L$ 是电池的电压，在图 2.1 中泄漏电阻器的电压为 $u - E_L$ 。根据欧姆定律，我们得到泄漏电流 $I_L = g_L (u - E_L)$ 。&lt;/p&gt;
&lt;p&gt;其他离子通道的数学模型类似，只是它们的电导是电压和时间依赖的。如果所有通道都打开，它们分别以最大电导率 $g_{Na}$ 或 $g_K$ 发射电流。然而，通常情况下，一些通道被阻断。霍奇金和哈克斯利的突破是，他们成功地测量了通道的有效电阻如何随着时间和电压的变化而变化。此外，他们还提出了对其观察结果的数学描述。具体来说，他们引入了额外的门控变量 $m$ , $n$ 和 $h$ 来模拟模拟通道在给定时间点开放的概率。例如，钠通道的有效电导被建模为 $1 / R_{Na} = g_{Na} \cdot m^3 h$ ，其中 $m$ 描述通道的激活（开放），$h$ 描述通道的失活（阻塞）。钾的电导率为 $1 / R_K = g_K \cdot n^4$ ，其中 $n$ 描述通道的激活。&lt;/p&gt;
&lt;p&gt;总的来说，霍奇金和哈克斯利将公式 (2.2) 右边的三个离子电流写成：&lt;/p&gt;
&lt;p&gt;$$
\sum_{k} I_k(t) = g_{Na} \cdot m^3 h \cdot (u - E_{Na}) + g_K \cdot n^4 \cdot (u - E_K) + g_L \cdot (u - E_L) \tag{2.3}
$$&lt;/p&gt;
&lt;p&gt;其中参数 $E_{Na}$ , $E_K$ , 和 $E_L$ 是反转电位。&lt;/p&gt;
&lt;p&gt;三个门控变量 $m$ , $n$ 和 $h$ 根据以下形式的微分方程变化：&lt;/p&gt;
&lt;p&gt;$$
\dot{x}=-\frac{1}{\tau_x (u)}\left [ x-x_0(u)\right ] \tag{2.4}
$$&lt;/p&gt;
&lt;p&gt;其中，$\dot{x} = \frac{dx}{dt}$ ，其中 $x$ 表示 $m$, $n$ 或者 $h$ 。公式 （2.4） 的解释很简单：对于一个固定的电压 $u$ ，变量 $x$ 以时间常数 $\tau_x(u)$ 逼近目标值 $x_0(u)$ 。目标值 $x_0(u)$ 和时间常数 $\tau_x(u)$ 对电压的依赖关系分别如图 2.2 (a), (b) 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20231102185532-2023-11-02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20231102185532-2023-11-02&#34;
	
	
&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;图 2.2 ： Hodgkin-Huxley 模型。(a) 门控变量 $m$, $n$, $h$ 的平衡函数。(b)与电压有关的时间常数，静息电位为 $u=-65mV$ （箭头），参数由表 2.1 给出。&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20231102185758-2023-11-02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20231102185758-2023-11-02&#34;
	
	
&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;表 2.1 ：在大脑皮层上的锥体神经元上拟合的 Hodgkin-Huxley 方程的参数。$n$ 和 $m$ 的参数由Zach Mainen（Mainen et al., 1995）根据Huguenard等人（1988）报告的实验进行拟合，$h$ 的参数由 Richard Naud 根据 Hamill 等人（1991）报告的实验进行拟合。电压以 $mV$ 为单位，膜电容为 $C = 1 \mu F/ cm^2$ 。&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;图 2.2 中绘制的函数形式，以及公式（2.3）中的最大电导和反转电位，是霍奇金和哈克斯利根据经验推导出来的。&lt;/p&gt;
&lt;p&gt;实验者通过向细胞注入适当的电流来保持细胞膜上的电压在所需的值上。在实验中，假设实验者在 $t&amp;lt;t_0$ 时将细胞保持在静息电位 $u_0 =-65mV$ ，并且在 $t=t_0$ 时将电压切换到一个新值 $u_1$ 。对于 $t &amp;gt; t_0$ ，通过对微分方程（2.4）进行积分，可以得到以下动力学方程：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
&amp;amp; m(t)=m_0(u_1) + [m_0(u_0)-m_0(u_1)] \exp \left[ -\frac{t-t_0}{\tau_m(u_1)} \right ] ,\\
&amp;amp; h(t)=h_0(u_1) + [h_0(u_0)-h_0(u_1)] \exp \left[ -\frac{t-t_0}{\tau_h(u_1)} \right ] ,
\end{aligned}
\tag{2.5}
$$&lt;/p&gt;
&lt;p&gt;其中 $m(t)$ 和 $h(t)$ 分别表示钠通道和钾通道的激活和失活状态。基于给定的函数 $m_0(u)$ 、$h_0(u)$ 、$\tau_m(u)$ 和 $\tau_h(u)$ 的模型，可以预测在 $t &amp;gt; t_0$ 时电压变化引起的钠电流 $I_{Na}(t)=g_{Na} [m(t)^3] h(t)  (u_1 - E_{Na})$ 和钾电流 $I_K(t)=g_K [n(t)^4] (u_1 - E_K)$ 。&lt;/p&gt;
&lt;p&gt;而 $n(t)$ 的表达式为：&lt;/p&gt;
&lt;p&gt;$$
n(t)=n_0(u_1) + [n_0(u_0)-n_0(u_1)] \exp \left[ -\frac{t-t_0}{\tau_n(u_1)} \right ] \tag{2.6}
$$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20231102222844-2023-11-02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20231102222844-2023-11-02&#34;
	
	
&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;图 2.3 ：Hodgkin 和 Huxley 绘制的钾离子电导率变化原始测量曲线和公式拟合曲线。施加 $25 mV$ 的电压切换后，回到静息电位后，钾的电导率（圆圈）的测量时间过程。拟合实线是基于公式（2.6）的。&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;霍奇金和哈克斯利使用方程（2.4）和（2.5）反过来进行研究。他们在使用适当的药物阻断钠通道后，施加电压变化并测量钾电流的时间变化。将记录的电流除以驱动电位 $(u_1 - E_K)$ 可以得到时间相关的电导率 $g_K [ n(t)^4]$ (图 2.3 ）。使用方程（2.6），霍奇金和哈克斯利推导出了钾通道的 $n_0(u_1)$ 和 $τ_n(u_1)$ 的值，以及 $n^4(t)$ 中的指数 4。通过对不同的 $u_1$ 值重复实验，可以得到 $n_0(u)$ 和 $τ_n(u)$ 的实验曲线。&lt;/p&gt;
&lt;p&gt;变量 $m$ 被称为激活变量。为了理解这个术语，我们注意到从图 2.2 可以看出，在神经元的静息电位 $u = -65 mV$ 时，$m_0(u)$ 的值接近于零。因此，在静息状态下，通过通道的钠电流 $I_{Na} = g_{Na} m^3 h(u - E_{Na})$ 为零。换句话说，钠通道是关闭的。&lt;/p&gt;
&lt;p&gt;当膜电位显著增加超过静息电位时，门控变量 $m$ 增加到其新值 $m_0(u)$ 。只要 $h$ 不变，钠电流就会增加，门打开。因此，变量 $m$ “激活”了通道。如果在电压恢复到静息状态后，$m$ 衰减回零，就被称为“去激活”。类似地，关于失活变量 $h$ 的术语也是类似的。在静息状态下，$h$ 有一个较大的正值。如果电压增加到超过 $-40 mV$ 的值，$h$ 接近一个接近静息状态的新值 $h_0(u)$ 。因此，通道通过一个由 $\tau_h(u)$ 给出的时间常数“失活”（阻塞）。如果电压返回到零，$h$ 增加，使得通道经历“去失活”。这听起来像是一种棘手的词汇，但事实证明，将一个去激活的通道（$m$ 接近零，$h$ 接近1）与一个失活的通道（$h$ 接近零）区分开来是有用的。&lt;/p&gt;
&lt;h3 id=&#34;2-随机通道的打开stochastic-channel-opening&#34;&gt;2. 随机通道的打开（Stochastic Channel Opening）&lt;/h3&gt;
&lt;p&gt;首先，离子通道的数量在一个细胞膜上是有限的，而且每个离子通道的开启和关闭是随机的。因此，当实验者记录通过细胞膜的电流时，他不会发现测量变量随时间平滑可靠地演变，而是会发现电流高度波动，每次重复实验时看起来都不同。这就是离子通道的随机性（如图 2.4 所示）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20231102224048-2023-11-02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20231102224048-2023-11-02&#34;
	
	
&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;图 2.4 ： 随机通道激活现象。在实验中，当施加一个电压阶跃到细胞膜上时，通过细胞膜的电流会呈现阶梯状变化，并且在每次试验中都有所不同（如顶部的连续轨迹所示）。对多次试验进行平均后，得到的结果是底部的轨迹。&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;然而，Hodgkin-Huxley 模型是用确定性方程描述离子通道的开启和关闭的。这些方程涉及的变量包括 $m$ ，$h$ 和 $n$ ，它们对应的是通过一个假设的、包含无限数量离子通道的极大细胞膜的电流密度，或者说是通过一小片细胞膜的电流，但是这个电流是在多次重复同一实验后得到的平均值。这就是 $Hodgkin-Huxley$ 模型的局限性，因为它忽略了离子通道的随机性。不过可以通过向模型中添加适当的噪声来包含随机性。这种噪声可以模拟离子通道开启和关闭的随机性，从而使模型更准确地描述神经元的动力学行为。&lt;/p&gt;
&lt;p&gt;使用以电压为自变量的转换速率 $\alpha$ 和 $\beta$ 来描述每种通道类型的激活和失活动力学，公式如下：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
\dot{m}= &amp;amp;\alpha_m (u) (1-m) - \beta_m (u) m ,\\
\dot{n}= &amp;amp;\alpha_n (u) (1-n) - \beta_n (u) n ,\\
\dot{h}= &amp;amp;\alpha_h (u) (1-h) - \beta_h (u) h , \\
\end{aligned}
\tag{2.7}
$$&lt;/p&gt;
&lt;p&gt;公式 （2.4）和 （2.7）是等价的。逼近值 $x_0(u)$ 和时间常数 $\tau_x(u)$ 由变换 $x_0(u)=\alpha_x(u)/[\alpha_x(u)+\beta_x(u)]$ 和 $\tau_x(u)=1/[\alpha_x(u)+\beta_x(u)]$ 给出。表 2.1 中的第二个表格给出了各种以 $u$ 为自变量的经验拟合函数 $\alpha$ 和 $\beta$ ，用于生成图 2.2 中的曲线。&lt;/p&gt;
&lt;p&gt;方程（2.7）是化学中常用的方程，用于描述具有速率常数 $α$ 和 $β$ 的激活过程的随机动力学。我们可以将这个过程解释为具有电压依赖的转换速率的两个状态之间的分子开关。例如，激活变量 $n$ 可以解释为找到一个开放的钾通道的概率。因此，在一个具有 $K$ 个离子通道的细胞膜中，预计有 $k \approx (1 - n)K$ 个通道是关闭的。我们可以将 $\alpha_n(u) \Delta t$ 解释为在短时间区间 $\Delta t$ 内，暂时关闭的通道中有一个切换到开放状态的概率。&lt;/p&gt;
&lt;h3 id=&#34;3-hudgkin-huxley-模型的动力学dynamics-of-hudgkin-huxley-model&#34;&gt;3. Hudgkin-Huxley 模型的动力学（Dynamics of Hudgkin-Huxley Model）&lt;/h3&gt;
&lt;p&gt;不同类型的输入被依次考虑，包括脉冲输入、恒定输入、阶跃电流输入和时间依赖输入。选择这些输入场景是为了直观理解 Hodgkin-Huxley 模型的动力学特性。Hodgkin-Huxley 模型最重要的特性是能够产生动作电位。在图 2.5(a) 中，一个持续 $1ms$ 的短脉冲电流在 $t=1ms$ 时施加，引发了一个动作电位。这个脉冲的幅度接近 $100mV$ ，半峰宽约为 $2.5ms$ 。在动作电位之后，膜电位下降到静息电位以下，再慢慢回到静息电位值 $-65mV$ 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20231102225930-2023-11-02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20231102225930-2023-11-02&#34;
	
	
&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;图 2.5 ： (a)动作电位。Hodgkin-Huxley 模型受到 $t=1ms$ 和 $t=2ms$ 之间的短而强的电流脉冲的刺激。对于 $t&amp;gt;2ms$ 的膜电位 $u(t)$ 的时间变化显示了动作电位（正峰值），随后是相对不应期，此时电位低于静息电位 $u_rest$（虚线）。右侧面板显示了 $t=2ms$ 和 $t=5ms$ 之间动作电位的放大视图。（b）门控变量 $m，h，n$ 的变化揭示了动作电位是如何通过钠通道和钾通道介导的。（c）钠电流 $I_{Na}$ 取决于变量 $m$ 和 $h$ ，在动作电位的上升阶段有一个脉冲。钾电流 $I_K$ 受变量 $n$ 控制，并与 $I_{Na}$ 相比有一定的延迟开始。&lt;/p&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脉冲产生过程中离子通道的动力学（Ion channel dynamics during spike generation）
为了理解动作电位生成的生物物理学基础，我们回到图 2.2(a) 。我们发现 $m_0$ 和 $n_0$ 随着 $u$ 的增加而增加，而 $h_0$ 则减少。因此，如果某些外部输入导致膜电压上升，由于 $m$ 的增加，钠通道的电导增加。结果，正钠离子流入细胞，进一步提高膜电位。如果这种正反馈足够大，就会引发动作电位。当膜电位接近钠电流的反转电位 $E_{Na}$ 时，这种爆发性增加自然停止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在高 $u$ 值下，由于因子 $h$ 的作用，钠电导缓慢关闭。如图 2.2(b) 所示，时间常数 $\tau_h$ 始终大于 $\tau_m$ 。因此，使通道失活的变量 $h$ 对电压增加的反应比激活通道的变量 $m$ 慢。在类似的较慢时间尺度上，钾电流在图 2.5(c) 中开始。由于它是向外的电流，它降低了电位。钠和钾电流的整体效应是一个短暂的动作电位，随后是负超调；(负超调，又被称为超极化脉冲后电位，是由于 $h$ 变量引起的钠通道的缓慢去失活过程所导致）。&lt;/p&gt;
&lt;p&gt;Hudgkin-Huxley 模型的动力学覆盖的知识比较多，主要概念如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平均发射率与增益函数（Mean Firing Rate and Gain Function）&lt;/li&gt;
&lt;li&gt;时间依赖的输入刺激 （Stimulations by Time-Dependent Input）&lt;/li&gt;
&lt;li&gt;发射阈值（Firing Threshold）&lt;/li&gt;
&lt;li&gt;不应性（Refractoriness）&lt;/li&gt;
&lt;li&gt;阻尼振荡与瞬时脉冲（Damped Oscillations and transient spiking）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里就不继续介绍了，有兴趣的可以参考原文。&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;[1] Gerstner, Wulfram, Werner M. Kistler, Richard Naud, and Liam Paninski. Neuronal dynamics: from single neurons to networks and models of cognition. Cambridge university press, 2014.&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>脉冲神经网络入门：神经元与数学</title>
        <link>https://cuterwrite.top/p/introduction-neuron-math/</link>
        <pubDate>Wed, 01 Nov 2023 00:55:55 +0000</pubDate>
        
        <guid>https://cuterwrite.top/p/introduction-neuron-math/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/2bb88c98-90f9-4308-abcf-493b7e507baa-2023-09-12.jpg" alt="Featured image of post 脉冲神经网络入门：神经元与数学" /&gt;&lt;h1 id=&#34;脉冲神经网络入门神经元与数学&#34;&gt;脉冲神经网络入门：神经元与数学&lt;/h1&gt;
&lt;h2 id=&#34;一神经元系统的结构&#34;&gt;一、神经元系统的结构&lt;/h2&gt;
&lt;p&gt;生物神经元是一种高度特化的细胞，其结构和功能包含很多因素，其中神经元的几何形态特征和电学物理特性是两个重要方面。几何形态特征主要指神经元的空间结构，而电学物理特性包含神经元不同的动作点位发放模式。生物神经系统内有两类细胞：神经元细胞和神经胶质细胞，前者担负着信息处理的主要任务，而后者对前者起支持作用。神经元细胞的几何形态结构和电学物理特性是生物神经系统进行信息处理的基础。所谓的神经胶质细胞，它们是脑组织能量供应和结构稳定所需要的。由于胶质细胞不直接参与信息处理，本文将不再进一步讨论它们。本文还将忽略一些罕见的神经元亚型，如哺乳动物视网膜上的非脉冲神经元。本文只专注于脉冲神经元。&lt;/p&gt;
&lt;h3 id=&#34;1-理想的脉冲神经元-ideal-spike-neuron&#34;&gt;1. 理想的脉冲神经元 (ideal spike neuron)&lt;/h3&gt;
&lt;p&gt;一个典型的神经元可以分为三个功能不同的部分，称为树突（dendrite）、细胞体（soma）和轴突（axon）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230912222755-2023-09-12.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230912222755-2023-09-12&#34;
	
	
&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;图 1.1：(a) Ramón y Cajal 于 1899 年绘制的神经元示意图。树突、体细胞和轴突可以被清楚地区分出来。图片显示了一个神经元动作电位的例子。动作电位是一个持续时间为 $1ms$ 的短电压脉冲，振幅约为 $100mv$ 。(b) 从突触前神经元 $j$ 到突触后神经元 $i$ 的信号传输。突触由虚线圈标记。右下端的轴突通向其它神经元。&lt;/p&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;树突：指从神经元细胞体内向外伸出的许多较短的分支，它们充当着神经元的&lt;strong&gt;输入端&lt;/strong&gt;，接收来自其它神经元的神经冲动并传递给细胞体；&lt;/li&gt;
&lt;li&gt;细胞体：神经元的核心，由细胞核、细胞质和细胞膜等组成，&lt;strong&gt;负责处理接收到的信号&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;轴突：指由神经元细胞体向外伸出的一条最长的分支，它是管状纤维组织，充当神经元的&lt;strong&gt;输出端&lt;/strong&gt;，再轴突末端有很多神经末梢，它们向外发出神经冲动。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;神经元的轴突末梢经过多次分支，最后每一个小支的末端膨大呈杯状或球状，称为突触小体。这些突触小体可以与多个神经元的细胞体或树突相接触，形成神经元之间连接的突触（synapse）。通常把发送神经元成为突触前神经元（presynaptic neuron），把接收神经元称为突触后神经元（postsynaptic neuron）。&lt;/p&gt;
&lt;h3 id=&#34;2-脉冲序列-spike-train&#34;&gt;2. 脉冲序列 (spike train)&lt;/h3&gt;
&lt;p&gt;生物神经系统在内外刺激作用下，使得神经元按照一定的时间间隔产生一系列的活动电位，称为脉冲序列 (spike train)。神经元信号由短的电脉冲组成，可以通过在神经元的体部或靠近体部或轴突的位置放置一个精细的电极来观察，如下图所示，脉冲（或活动电位），其振幅为 100 毫伏，通常持续时间为 1~2 ms。脉冲的形式不会因为活动电位沿轴突传播而改变。神经元发送的单个活动电位或脉冲是信号传递的基本单元，因为所有脉冲的波形都是相似的，所以活动电位的形状不会携带任何信息，而传递有用神经信息的是&lt;strong&gt;脉冲的发放时间和频率&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230912224451-2023-09-12.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230912224451-2023-09-12&#34;
	
	
&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;图 1.2：动作电位是刻板事件。在最大电压时间内排列的膜电位记录显示动作电位形状的变化很小。&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;脉冲序列中的活动电位通常是很好地分开的。即使有非常强的输入，也不可能在第一次脉冲期间紧接着激发第二次脉冲。两个脉冲之间的最小距离定义了神经元的绝对不应期（absolute refractory period）—— 大致在活动电位的复极化阶段（repolarization phase），无论用任何强的刺激都不能再引起活动电位。&lt;/p&gt;
&lt;h3 id=&#34;3-突触-synapse&#34;&gt;3. 突触 (synapse)&lt;/h3&gt;
&lt;p&gt;突触前神经元的轴突与突触后细胞的树突（或体细胞）接触的部位是突触。脊椎动物大脑中最常见的突触类型是化学突触。在化学突触处，轴突终端非常接近突触后神经元，在突触前和突触后细胞膜之间只留下一个微小的间隙。这就是所谓的突触间隙（synaptic cleft）。当一个活动电位到达突触时，它触发了一个复杂的生化处理步骤链，导致神经递质从突触前末端释放到突触间隙中。一旦递质分子到达突触后一侧，它们将被突触后细胞膜上的专门受体检测到，并导致（直接或通过生化信号链）打开特定通道，导致细胞外液体中的离子流入细胞。离子的涌入反过来又改变了突触后部位的膜电位，因此，最后，化学信号被转化为电反应。从突触前神经元传入的脉冲信号引起突触后神经元膜电位发生的变化称为突触后电位（postsynaptic potential）。&lt;/p&gt;
&lt;p&gt;除了化学突触之外，神经元还可以通过电突触连接，称为间隙连接（gap junctions）。特化膜蛋白在两个神经元之间形成直接的电连接。关于间隙连接的功能方面当前所知不多，但它们被认为参与了神经元的同步。&lt;/p&gt;
&lt;h2 id=&#34;二神经动力学的要素&#34;&gt;二、神经动力学的要素&lt;/h2&gt;
&lt;p&gt;脉冲对突触后神经元的影响可以用细胞内电极来记录，该电极测量细胞内部和其周围环境之间的电位差 $u(t)$ 。这个电位差被称为膜电位。在没有任何输入的情况下，神经元处于静息状态，对应一个恒定的膜电位 $u_{rest}$，称为静息电位（resting potential），一般在 $-80\sim -40mV$ （当以细胞外的电位为 0 ）。当神经元受到外界刺激，突触后电位的总和超过某一阈值时，神经元产生一个不衰减的沿神经纤维传递的神经冲动，即活动电位或脉冲。活动电位的动态变化过程包含一个迅速的去极化正向电位变化和缓慢的复极化负向电位变化。活动电位的另一特征是电位的极性在峰电位顶端倒转，细胞内由静息时的负电位变为正电位，这一过程称为超射。神经元活动电位的产生会导致局部的兴奋性发生一系列的变化。大致在活动电位的复极化阶段（repolarization phase），无论用任何强的刺激都不能再引起活动电位，这个阶段称为绝对不应期（absolute refractory period）；在随后的短时间内，活动电位进入超极化阶段（hyperpolarization phase），用比原来强的刺激方能引起活动电位，而且反应幅度还会小一些，这个阶段称为相对不应期（relative refractory period）。神经元对信号的传递方式在很大程度上与神经元的电学特性有关。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230913004838-2023-09-13.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230913004838-2023-09-13&#34;
	
	
&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;图 2.1：膜电位在绝对不应期和相对不应期的变化。在绝对不应期，神经元不能再次激发。在相对不应期，神经元可以激发，但需要更强的刺激。&lt;/p&gt;&lt;/div&gt;

&lt;h3 id=&#34;1-突触后电位postsynaptic-potential&#34;&gt;1. 突触后电位（postsynaptic potential）&lt;/h3&gt;
&lt;p&gt;从突触前神经元传入的脉冲信号引起突触后神经元膜电位发生的变化称为突触后电位（postsynaptic potential），具有局部电位的性质。一个神经元通常有许多突触，其中有些是兴奋性的，有些是抑制性的。对于从突触前神经元传来的多个脉冲，由于突触类型的不同，突触后电位可分为兴奋性和抑制性两类。兴奋性突触使突触后神经元的膜去极化，产生正的突触后电位，称为兴奋性突触后电位（excitatory postsynaptic potential，EPSP）。EPSP 在传入脉冲到达突触后神经元 $0.3\sim 0.5ms$ 之后产生，它有一个较快的上升过程和缓慢的指数衰减过程，电位总共持续  $10\sim 20ms$ 。抑制性突触使突触后神经元的膜超极化，产生负的突触后电位，称为抑制性突触后电位（inhibitory postsynapticpotential，IPSP），IPSP 到达峰值时间和 EPSP 相似。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230913005342-2023-09-13.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230913005342-2023-09-13&#34;
	
	
&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;图 2.2：(a)兴奋性突触后电位（EPSP）; (b)抑制性突触后电位（IPSP）。&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;用数学术语规范化，那么研究神经元 $i$ 的膜电位随时间变化的函数 $u_i(t)$ 。在输入脉冲到达之前，有 $u_i(t)=u_{rest}\ (t=0)$ 。对于 $t&amp;gt;0$ ，在电极上看到神经元 $i$ 的反应如下：&lt;/p&gt;
&lt;p&gt;$$
u_i(t)-u_{rest}=: \varepsilon_{ij}(t) \tag{2.1}
$$&lt;/p&gt;
&lt;h3 id=&#34;2-发射阈值与活动电位firing-threshold-and-action-potential&#34;&gt;2. 发射阈值与活动电位（firing threshold and action potential）&lt;/h3&gt;
&lt;p&gt;考虑两个突触前神经元 $j=1,2$ ，它们都向突触后神经元 $i$ 发送脉冲。神经元 $j=1$ 在时刻 $t_1^{(1)}, t_2^{(2)}, \cdots$ 发送脉冲，神经元 $j=2$ 也在时刻 $t_1^{(1)}, t_2^{(2)}, \cdots$ 发送脉冲。每个脉冲分别引起一个突触后电位 $\varepsilon_{i1}$ 或 $\varepsilon_{i2}$ 。只要只有少数的输入脉冲，电位的总变化大小约是各个 PSP 的总和：&lt;/p&gt;
&lt;p&gt;$$
u_i(t)=\sum_{j}\sum_{f} \varepsilon_{ij}(t-t_j^{f}) + u_{rest} \tag{2.2}
$$&lt;/p&gt;
&lt;p&gt;即，膜电位对输入脉冲的反应是线性的。&lt;/p&gt;
&lt;p&gt;另一方面，如果在很短的时间间隔内有太多的输入脉冲到达，线性就会被打破。一旦膜电位达到一个临界值 $\vartheta$ ，它的曲线就会显示出与 PSP 的简单求和完全不同的行为：膜电位表现出类似脉冲的偏移，振幅约为 $100 mV$ 。这个短电压脉冲将沿着神经元轴突与其他神经元的突触传播。在脉冲之后，膜电位并不直接回到静止电位，而是在许多神经元类型中通过低于静止值的超极化阶段。&lt;/p&gt;
&lt;p&gt;单个 EPSP 的振幅在 $1 mV$ 的范围内。脉冲初始临界值比静息电位高约 $20$ 至 $30 mV$ 。因此在大多数神经元中，如下图所示的四个脉冲是不足以触发一个活动电位的。相反地，需要大约 $20\sim 50$ 个突触前脉冲在很短的时间窗口内到达才能触发一个突触后活动电位。这个时间窗口称为发射阈值（firing threshold），它是神经元的一个重要参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230913012304-2023-09-13.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230913012304-2023-09-13&#34;
	
	
&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;图 2.3：来自第二个突触前神经元 $j=2$ 的输入脉冲在来自神经元 $j=1$ 的尖峰后不久到达，导致第二个突触后电位增加到了第一个上。&lt;/p&gt;&lt;/div&gt;

&lt;h2 id=&#34;三integrade-and-fire-模型&#34;&gt;三、Integrade-and-fire 模型&lt;/h2&gt;
&lt;p&gt;神经元动力学可以被视为一个整合的过程，与出发活动电位超过某个临界电压的机制相结合。事实上，在实验中，发射时间通常被定义为膜电位从下往上达到某个阈值的时刻。为了建立一个神经元动力学的现实模型，我们通过阈值 $\vartheta$ 来描述神经元的发射阈值。如果电压 $u_i(t)$ （包含所有输入的总效应）从下往上到达 $\vartheta$ ，我们就说神经元会发射一个脉冲。跨越阈值的时刻定义了发射时间 $t_i^f$ 。&lt;/p&gt;
&lt;p&gt;该模型利用了一个事实，即一个而给定的神经元的活动电位总是具有大致相同的形式。如果一个活动电位的形状总是相同的，那么这个形状就不能用来传递信息；相反，信息包含在脉冲的存在或不存在中。因此活动电位被简化为“发生在一个精确的时刻的事件”。&lt;/p&gt;
&lt;p&gt;将活动电位描述为事件的神经元模型被称为 Intergrate-and-fire 模型。该模型没有尝试描述活动电位的形状。Integrade-and-fire 模型有两个独立的组成部分，都是定义其动力学所必须的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;描述膜电位 $u_i(t)$ 变化的方程；&lt;/li&gt;
&lt;li&gt;产生脉冲的机制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在下文中将介绍最简单的 Intergrade-and-fire 类模型：Leaky Integrade-and-fire 模型，该模型有两个独立的组成部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;描述膜电位变化的线性微分方程；&lt;/li&gt;
&lt;li&gt;脉冲发射的阈值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-输入的整合input-integration&#34;&gt;1. 输入的整合（input integration）&lt;/h3&gt;
&lt;p&gt;变量 $u_i$ 描述了神经元 $i$ 的膜电位的瞬时值。在没有任何输入的情况下，电位处于静息值 $u_{rest}$ 。如果实验者向神经元 $i$ 注入电流 $I(t)$ ，或神经元 $i$ 接收其它神经元的突触输入，电位 $u_i$ 将被偏离其静止值。&lt;/p&gt;
&lt;p&gt;为了得到一个将瞬时电压 $u_i(t) - u_{rest}$ 与输入电流 $I(t)$ 联系起来的方程，我们使用电学理论中的基本定律。一个神经元被细胞膜所包围，这是一个相当好的绝缘体。如果一个短的电流脉冲 $I(t)$ 被注入到神经元中，额外的电荷 $q=\int I(t&amp;rsquo;)\ dt&amp;rsquo;$ 必须去到某个地方：给细胞膜充电（如下图所示）。因此，细胞膜的作用就相当于一个容量为 $C$ 的电容器。因为绝缘体并不完美，电荷会随着时间的推移慢慢通过细胞膜泄露。因此，细胞膜可以用一个有限的泄露电阻 $R$ 表示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230914213909-2023-09-14.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230914213909-2023-09-14&#34;
	
	
&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;图 3.1：神经元的电学特性：被动膜。(a)由细胞膜（大圈）包围的神经元接收一个（正）输入电流 $I(t)$ ，增加细胞内的电荷。细胞膜的作用就像一个与电阻并联的电容器，与电位为 $u_{rest}$ 的电池并联。(b)细胞膜对具有平滑电压轨迹的阶梯电流的反应。&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;代表 Leaky Integrate-and-fire 模型的基本电路由一个电容 $C$ 和一个由电流 $I(t)$ 驱动的电阻 $R$ 并联组成。如果驱动电流 $I(t)$ 为零，则电容器两端的电压由电池电压 $u_{rest}$ 给出。&lt;/p&gt;
&lt;p&gt;为了分析电路，我们使用电流守恒定律，将驱动电流分成两部分。&lt;/p&gt;
&lt;p&gt;$$
I(t) = I_{R} + I_{C}. \tag{3.1}
$$&lt;/p&gt;
&lt;p&gt;第一个是通过线性电阻 $R$ 的阻性电流 $I_R$ ，根据欧姆定律可以计算出 $I_R=\frac{u_R}{R}$，其中 $u_R=u-u_{rest}$ 是电阻两端的电压。第二个分量 $I_C$ 给电容器 $C$ 充电。根据电容的定义 $C=\frac{q}{u}$ ，其中 $q$ 为电荷，$u$ 为电压，我们可以得出电容电流 $I_C=\frac{dq}{dt}=C \frac{du}{dt}$ ，即：&lt;/p&gt;
&lt;p&gt;$$
I(t)=\frac{u(t)-u_{rest}}{R}+C \frac{du}{dt}. \tag{3.2}
$$&lt;/p&gt;
&lt;p&gt;等式两边乘以 $R$ ，并引入时间常数 $\tau_{m}=RC$ ， 则标准形式为：&lt;/p&gt;
&lt;p&gt;$$
\tau_m \frac{du}{dt} = -[u(t)-u_{rest}]+RI(t). \tag{3.3}
$$&lt;/p&gt;
&lt;p&gt;其中，$u$ 是膜电位，$\tau_m$ 是神经元的膜时间常数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20231031161758-2023-10-31.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20231031161758-2023-10-31&#34;
	
	
&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;图3.2：被动膜上的短脉冲和总充电量。由短电流脉冲 $I(t)$ 驱动的漏电整合器的电压响应振幅（底部）（顶部）只取决于总电荷 $q = \int I(t) \ dt$ ，而不取决于电流脉冲的高度。&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;从数学的角度来看，公式 (3.3) 是一个线性微分方程。从电气工程师的角度来看，它是一个漏电整合器或 $RC$ 电路的方程，其中电阻 $R$ 和电容 $C$ 是平行排列的。从神经科学家的角度来看，它被称为被动膜的方程。&lt;/p&gt;
&lt;p&gt;方程 (3.3) 的解是什么？我们假设，无论出于什么原因，在时刻 $t=0$ 时，膜电位的值为 $u_{rest} + \Delta u$ 。在 $t&amp;gt;0$ 时，输入电流 $I(t)$ 将消失变为零。直观地讲，我们期望，如果我们等待足够长的时间，膜电位会放松到静息电位 $u_{rest}$ 。事实上，具有初始条件 $u(t_0)=u_{rest} + \Delta u$ 的方程 (3.3) 的解是：&lt;/p&gt;
&lt;p&gt;$$
u(t)-u_{rest}=\Delta u \exp \left ( -\frac{t-t_0}{\tau_m} \right)\ \mathrm{for}\ t&amp;gt;0. \tag{3.4}
$$&lt;/p&gt;
&lt;p&gt;因此，在没有输入的情况下，膜电位以指数形式衰减静息电位。膜时间常数 $\tau_m=RC$ 是衰减的特征时间。对于一个典型的神经元来说，它在 $10ms$ 的范围内，因此与 $1ms$ 数量级的脉冲持续时间相比相当长。解 (3.4) 的有效性可以通过在方程两边取导数来检查。由于它是没有输入时的解，它又被称为自由解（free solution）。&lt;/p&gt;
&lt;h3 id=&#34;2-脉冲输入pulse-input&#34;&gt;2. 脉冲输入（pulse input）&lt;/h3&gt;
&lt;p&gt;在我们继续定义 Intergrate-and-Fire 模型及其变体之前，让我们研究一下由公式 (3.3) 定义的被动膜的动力学。假设被动膜受到恒定输入电流 $I(t)=I_0$ 的刺激。该电流从 $t=0$ 开始，持续到 $t=Delta$ 。为了简单起见，我们假设 $t=0$ 时，膜电位为 $u_{rest}$ 。&lt;/p&gt;
&lt;p&gt;第一步，我们计算一下膜电位的时间过程。膜电位的轨迹可以通过整合方程 (3.3) 和初始条件 $u(t_0)=u_{rest}$ 得到，即 $0 &amp;lt; t &amp;lt; \Delta$ 时的解为：&lt;/p&gt;
&lt;p&gt;$$
u(t) = u_{rest} + RI_0 \left [ 1 - \exp \left ( -\frac{t}{\tau_m} \right ) \right ]. \tag{3.5}
$$&lt;/p&gt;
&lt;p&gt;如果输入电流从未停止，膜电位 (3.5) 将在 $t\rightarrow \infty$ 时接近渐进值 $u(\infty)=u_{rest}+RI_0$ 。一旦达到稳定状态，电容器上的电荷就不再变化。然后，所有的输入电流必须流经电阻。因此，电阻处的稳态电压是 $RI_0$ ，所哟膜的总电压是 $u_{rest}+RI_0$ 。&lt;/p&gt;
&lt;h3 id=&#34;3-脉冲发射阈值spike-firing-threshold&#34;&gt;3. 脉冲发射阈值（spike firing threshold）&lt;/h3&gt;
&lt;p&gt;发射时间指的是一个给定的神经元发射动作电位 $t^f$ 的时刻。Leaky Integrate-and-Fire(LIF) 模型中的发射时间 $t^f$ 是由一个阈值标准定义的：&lt;/p&gt;
&lt;p&gt;$$
t^f\ : \quad u(t^f) = \vartheta. \tag{3.6}
$$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20231031165128-2023-10-31.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20231031165128-2023-10-31&#34;
	
	
&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;图3.3：Integrate-and-Fire 模型。(a)由恒定输入电流 $I_0=1.5$ 驱动的 Integrate-and-fire 神经元的膜电位的事件过程。电压 $\Delta u(t)=u-u_{rest}$ 被阈值 $\vartheta$ 归一化。输入电流的单位将被选择，以便 $I_0=1$ 能对应达到 $t\rightarrow \infty$ 的阈值曲线。在一个脉冲过后，电位被重置为 $u_{\tau} = u_{rest}$ 。(b)对随时间变化的输入电流的电压反应。&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;虽然脉冲的形式没有被明确描述。然而注意到，在发射时间 $t^f$ 之后，电位立即被重置为一个新的值 $u_r &amp;lt; \vartheta$。&lt;/p&gt;
&lt;p&gt;$$
\lim_{\delta \rightarrow 0; \delta &amp;gt; 0} u(t^f + \delta) = u_r. \tag{3.7}
$$&lt;/p&gt;
&lt;p&gt;对于 $t&amp;gt;t^f$，动力学再次由 (3.3) 给出，直到发生下一个阈值跨越。联立 (3.3) 和 (3.7)，我们可以定义 Leak Integrate-and-Fire(LIF) 模型（Stein, 1967）。图 3.3 显示了由恒定电流 $I_0$ 驱动的 LIF 模型的电压曲线。&lt;/p&gt;
&lt;p&gt;对于神经元 $i$ 的发射时间，我们定义 $t_i^f$ ，其中 $f=1,2,\cdots $ 是脉冲的标签。从形式上看，我们可以将神经元的脉冲序列表示为发射时间的序列：&lt;/p&gt;
&lt;p&gt;$$
S_i(t) = \sum_{f} \delta (t-t_i^f). \tag{3.8}
$$&lt;/p&gt;
&lt;p&gt;其中，$\delta(x)$ 是 Dirac $\delta$ 函数：&lt;/p&gt;
&lt;p&gt;$$
\delta(x)=\begin{cases}
0,&amp;amp;x = 0 \\
\int_{-\infty}^{\infty} \delta(x) dx = 1,&amp;amp; x \neq 0
\end{cases} \tag{3.9}
$$&lt;/p&gt;
&lt;h2 id=&#34;四lif-模型的局限性&#34;&gt;四、LIF 模型的局限性&lt;/h2&gt;
&lt;p&gt;LIF 模型是高度简化的，忽略了神经元动力学的许多细节。尤其是，可能来自突触前神经元或者电流注入的输入被线性整合，与突触后神经元的状态无关：&lt;/p&gt;
&lt;p&gt;$$
\tau_m \frac{du}{dt} = -[u(t)-u_{rest}]+RI(t). \tag{4.1}
$$&lt;/p&gt;
&lt;p&gt;其中，$I(t)$ 是输入电流。此外，在每个输出脉冲之后，膜电位被重置。&lt;/p&gt;
&lt;p&gt;$$
\mathrm{if}\ u(t)=\vartheta \quad\mathrm{then} \ \lim_{\delta \rightarrow 0; \delta &amp;gt; 0} u(t+\delta) = u_r. \tag{4.2}
$$&lt;/p&gt;
&lt;p&gt;这样就不会保留对以前脉冲的记忆。现在，让我们列出到目前位置讨论的简化模型的主要局限性。&lt;/p&gt;
&lt;h3 id=&#34;1-适应爆发和抑制性反弹adaptation-bursting-and-inhibitory-rebound&#34;&gt;1. 适应、爆发和抑制性反弹（adaptation, bursting and inhibitory rebound）&lt;/h3&gt;
&lt;p&gt;通过细胞内电极注入电流。在一个标准的实验方案中，我们可以施加一个刺激电流，在时间 $t_0$ 从一个电流值 $I_1$ 切换到一个新的电流值 $I_2$ 。假设 $I_1=0$ ，这样神经元在 $t&amp;lt;t_0$ 时是静息状态的。如果电流 $I_2$ 足够大，它将引起 $t&amp;gt;t_0$ 的脉冲。大多数神经元会对当前阶跃做出反应，产生一列脉冲，脉冲之间的间隔会连续增加，直到达到周期性发射的稳定状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20231031210458-2023-10-31.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20231031210458-2023-10-31&#34;
	
	
&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;图4.1：对当前阶跃的反应。在(a)(c)中，电流在 $t=t_0$ 时从 $I_1=0$ 切换到 $I_2&amp;gt;0$ 。fast-spiking neuron(a)在没有适应的情况下具有较短的脉冲间隔，而 regularly firing neuron(c)表现出适应性，可以看到脉冲间隔时间的增加。(b)中显示了一个 stuttering neuron(指发生语言或运动障碍的神经元，这种神经元在传递信号时可能会出现中断、重复或不协调的行为，导致口吃或肌肉抽动等症状)的例子。许多神经元在抑制性电流 $I_1 &amp;lt;0$ 被关闭后发出一个抑制性反弹脉冲(d)。&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;图4.1(c)中这种具有适应性的神经元被称为 regularly firing neuron。适应是一个缓慢的过程，在几个脉冲上积累起来。由于标准的 LIF 模型在每次脉冲后将电位重置位相同的值并重新启动整合过程，因此在最近的脉冲之后不会保留任何记忆。因此，LIF 神经元不具有适应性。&lt;/p&gt;
&lt;p&gt;第二类神经元为 fast-spiking neuron。这些神经元不显示适应性，因此可以用 LIF 模型来近似。许多抑制性神经元是 fast-spiking neuron。&lt;/p&gt;
&lt;p&gt;除了 regularly firing neuron 和 fast-spiking neuron 外，还有 bursting neuron 和 stuttering neuron。这些神经元对恒定刺激的反应是一连串的脉冲，这些脉冲周期性地爆发或非周期性地被相当长的间隔打断。&lt;/p&gt;
&lt;p&gt;另一个经常观察到的行为是抑制后的反弹。考虑到一个 $I_1&amp;lt;0$ 和 $I_2=0$ 的阶梯电流，即：在一个时间 $t_0$ 从一个抑制性电流 $I_1$ 切换到零电流。在这种情况下，许多神经元会在 $t&amp;gt;t_0$ 时发出一个或多个抑制性反弹脉冲，甚至抑制的释放也能出发动作电位。这种行为在图 4.1(d) 中显示。&lt;/p&gt;
&lt;h3 id=&#34;2-分流抑制和反转电位shunting-inhibition-and-reversal-potential&#34;&gt;2. 分流抑制和反转电位（shunting inhibition and reversal potential）&lt;/h3&gt;
&lt;p&gt;在显示中，神经元被嵌入在一个大型网络中，并接受来自许多其它神经元的输入。假设一个来自突触前神经元 $j$ 的脉冲在时间 $t_j^f$ 被发送到突触后神经元 $i$ 的突触。突触后电位是脉冲到达突触后产生的，其形状和振幅不取决于突触后神经元 $i$ 的状态。这当然是一种简化，现实中的情况要复杂一些。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20231031231444-2023-10-31.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20231031231444-2023-10-31&#34;
	
	
&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;图4.2：突触后电位的形状取决于去极化的瞬间水平。(a)当神经元处于静息状态时，在时间 $t^f$ 到达的抑制性突触的突触前脉冲对膜电位几乎没有影响，但如果膜电位 $u$ 高于静息电位，则影响很大。如果膜在抑制性突触的反转电位以下超极化，对突触前输入的反应就会改变符号。(b)兴奋性突触的脉冲引起突触后电位，其振幅仅略微取决于瞬间电压 $u$ 。对于大的去极化，振幅会饱和并且变小。&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;在图 4.2 中示意性地勾勒了一个实验，其中神经元由恒定电流 $I_0$ 驱动。假设 $I_0$ 太弱，无法引起发射，因此，在一定的静息时间后，膜电位会稳定在一个恒定值 $u_0$ 。在 $t=t^f$ 时，其中一个突触前神经元发出一个脉冲，这样，不久之后动作电位就会到达突触，并且提供突触后神经元的额外刺激。更精确的说，脉冲在突触后神经元产生一个电流脉冲（突触后电流，PSC），其振幅为：&lt;/p&gt;
&lt;p&gt;$$
PSC \propto [u_0-E_{syn}] \tag{4.3}
$$&lt;/p&gt;
&lt;p&gt;其中，$u_0$ 是膜电位，$E_{syn}$ 是突触的反转电位。由于电流输入的振幅取决于 $u_0$ ，突触后电位的反应也是如此。&lt;/p&gt;
&lt;p&gt;突触后反应对神经元瞬间状态的依赖性在抑制性突触中最为明显。抑制性突触 $E_{syn}$ 的反转电位更低，但通常接近静息电位。因此，如果神经元处于精细状态，输入脉冲对膜电位几乎没有任何影响。然而，如果膜是去极化的，同样的输入脉冲会引起更大的抑制性突触后电位；如果膜已经超极化，输入脉冲甚至可以产生去极化的效果。&lt;/p&gt;
&lt;p&gt;虽然抑制性输入通常对膜电位只有很小的影响，但细胞膜的局部电导率可以大大增加。突触通常位于树突树的体部或轴上。由于它们的策略位置，少数抑制性输入脉冲可以“冲刷”树突树从从数百个兴奋性突触收集的整合输入。这种现象被称为分流抑制（shunting inhibition）。&lt;/p&gt;
&lt;p&gt;兴奋性突触的反转电位通常明显高于静息电位。如果膜去极化， $u_0 \gg u_rest$ ，兴奋性突触后电位的振幅就会降低，但其效果并不像抑制那样明显。对于非常高的去极化水平，可以观察到 EPSPs 的饱和。&lt;/p&gt;
&lt;h3 id=&#34;3-脉冲后的电导率变化conductance-changes-after-spikes&#34;&gt;3. 脉冲后的电导率变化（conductance changes after spikes）&lt;/h3&gt;
&lt;p&gt;突触后电位的形状不仅取决于去极化的程度，而且更广泛地取决于神经元的内部状态，例如，相对于以前动作电位的时间。假设在时间 $t^f_i$ 产生了动作电位，突触前的脉冲在突触 $j$ 的时间 $t^f_j &amp;gt; t^f_i$ 到达。如果突触前脉冲在突触后动作电位期间或之后不久到达，它的影响不大，因为参与发射动作电位的一些离子通道依然是开放的。如果输入脉冲到达地更晚，它就会产生一个通常大小的突触后电位。&lt;/p&gt;
&lt;h3 id=&#34;4-空间结构spatial-structure&#34;&gt;4. 空间结构（spatial structure）&lt;/h3&gt;
&lt;p&gt;突触后电位的形式也取决于突触在树突树上的位置。位于远离体细胞的突触引起的突触后电位通常比位于体细胞附近的突触引起的突触后电位小。如果几个输入在几毫秒内出现在同一个树突分支上，第一个输入将引起膜电位的局部变化，影响对稍晚到达的输入脉冲的反应幅度。这可能会导致饱和，或者在所谓的“活性”电流的情况下，导致反应的增强。而在 LIF 模型中，不同突触前脉冲之间这种非线性相互作用被忽略了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20231101212827-2023-11-01.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20231101212827-2023-11-01&#34;
	
	
&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;图4.3：突触后电位的形状（虚线）取决于自神经元 $i$ 的最后一次输出脉冲以来所经过的时间 $t-t^f_i$。 突触后的尖峰在时间 $t^f_i$ 被触发。突触前的脉冲在突触后神经元的尖峰后不久到达 $t^f_j$ ，其振幅比后来到达的脉冲小得多。&lt;/p&gt;&lt;/div&gt;

&lt;h2 id=&#34;五lif-模型的启示&#34;&gt;五、LIF 模型的启示&lt;/h2&gt;
&lt;p&gt;LIF 模型是一个极其简化的神经元模型。它忽略了神经科学家在研究活脑或脑组织切片中的神经元时观察到的许多特征。因此，问题出现了：我们应该从这样一个模型中期待什么？显然，我们不能指望它能解释神经元的完整生物化学和生物物理学。我们也不期望它能解释由树突树上某些 &amp;ldquo;热点 &amp;ldquo;的活性电流引起的高度非线性的相互作用。然而，当涉及到产生脉冲时，即在时间上精确计时的事件时，LIF 模型是十分精确的。因此，它有可能成为神经元中脉冲产生的有效模型，或者更准确地说，能成为细胞体中脉冲产生的有效模型。&lt;/p&gt;
&lt;p&gt;从脉冲生成模型中预测真实神经元脉冲的时间趋势是合理的。实验者使用第一个电极将随时间变化的输入电流 $I(t)$ 注入皮质神经元的细胞体中。通过一个独立的第二电极，实验者测量神经元体部的电压。毫不奇怪，电压轨迹不时地包含尖锐的电脉冲。这些是动作电位或脉冲。&lt;/p&gt;
&lt;p&gt;数学神经科学家现在把实验者使用的输入电流的时间过程 $I(t)$ 与神经元膜电位的时间过程一起，调整一个 LIF 模型的参数，使该模型在输入电流相同的情况下，在时间上产生与真实神经元大致相同的脉冲。这需要一些参数调整，但似乎是可行的。然而，更难解决的相关问题是，神经元模型现在是否可以用来预测真实神经元在新的随时间变化的输入电流下的发射时间，而这种新的输入电流在参数优化过程中并未使用。&lt;/p&gt;
&lt;p&gt;如上所述，神经元不仅在每次放电后表现出不稳定，而且还表现出在数百毫秒内积累起来的适应能力。简单的 LIF 模型并不能很好地预测真实神经元的脉冲时间。然而，如果在神经元模型中加入适应性(和不稳定因素)，预测结果就会出奇地好。增加适应性的一种直接方法是使神经元模型的放电阈值动态：在每个脉冲之后，将阈值 $\vartheta$ 增加一个增量 $\theta$ ，使得静息期间，阈值接近其固定值 $θ_0$ 。我们可以使用 Dirac $\delta$ 函数来表示这种动态阈值：&lt;/p&gt;
&lt;p&gt;$$
\tau_{adapt} \frac{d\vartheta}{dt} = -[\vartheta(t)-\vartheta_0] + \theta \sum_{f} \delta(t-t_i^f). \tag{5.1}
$$&lt;/p&gt;
&lt;p&gt;其中，$\tau_{adapt}$ 为适应时间常数（~几百毫秒），$t^f=t^{(1)}, t^{(2)}, t^{(3)}, \cdots$ 是神经元的发射时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20231101214530-2023-11-01.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20231101214530-2023-11-01&#34;
	
	
&gt;&lt;/p&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;图5.1： 广义 LIF 模型与真实实验测量的对比。由波动电流驱动的真实神经元中记录的电压曲线（粗黑线）被叠加在由相同电流驱动的广义 LIF 模型（细线）上。除了少数额外或遗漏的脉冲（箭头），平均脉冲时间也得到了很好的预测。&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;从图 5.1 中可以看出，具有动态阈值的 LIF 模型的预测结果与真实神经元的电压曲线非常吻合。&lt;/p&gt;
&lt;p&gt;一旦我们确定了好的候选神经元模型，我们将可以尝试用这些模型构建大的神经元网络，并进一步尝试理解神经元网络所使用的动态和计算原理以及潜在的神经编码。虽然这并不意味着理解了整个大脑，但经过良好测试的简化神经元模型中理解大量神经元群体的原理是朝着这个方向迈出的第一步，也是重要的一步。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;神经元信号由短电压脉冲组成，称为动作电位或者脉冲。这些脉冲沿着轴突行进，并被分配到几个突触后神经元，在那里它们又引起突触后电位。如果一个突触后神经元在一个短时间窗口内从多个突触前神经元那收集到足够多的脉冲，它的膜电位可能会达到一个临界值，然后发射出一个脉冲。我们说，神经元已经“发射”了一个脉冲。这个脉冲是神经元的输出信号，反过来又被传输到其它神经元。&lt;/p&gt;
&lt;p&gt;一个比较简单的脉冲神经元模型是 LIF 模型。该模型用一个线性微分方程描述了输入电流如何被整合并转化为膜电位 $u(t)$ 。这里的输入可以是实验者注入孤立神经元的输入电流，也可以是由大型高度连接网络中其它神经元到达的脉冲引起的突触输入电流。其次，如果膜电位到达阈值 $\vartheta$ ，LIF 神经元会产生一个输出脉冲。最后，在脉冲发射后，线性整合过程被重置，膜电位被重置为一个新的值 $u_r$ 。这个过程被称为膜电位的重置。&lt;/p&gt;
&lt;p&gt;LIF 模型并没有考虑持久的适应性，然而，如果 LIF 模型的电压动态地通过适应机制得到增强，那么它可以成为准确预测皮层神经元脉冲时间的有力工具。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>NEST on HPC 安装教程</title>
        <link>https://cuterwrite.top/p/nest-on-hpe-install/</link>
        <pubDate>Mon, 30 Oct 2023 00:00:00 +0000</pubDate>
        
        <guid>https://cuterwrite.top/p/nest-on-hpe-install/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20231031002508-2023-10-31.png" alt="Featured image of post NEST on HPC 安装教程" /&gt;&lt;h1 id=&#34;nest-on-hpc-安装教程&#34;&gt;NEST on HPC 安装教程&lt;/h1&gt;
&lt;h2 id=&#34;1-安装-miniconda3&#34;&gt;1. 安装 MiniConda3&lt;/h2&gt;
&lt;p&gt;从 &lt;a class=&#34;link&#34; href=&#34;https://repo.anaconda.com/miniconda/Miniconda3-py39_23.5.2-0-Linux-x86_64.sh&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Miniconda3 官方网站&lt;/a&gt; 下载 Miniconda3_py39_23.5.2 。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wget https://repo.anaconda.com/miniconda/Miniconda3-py39_23.5.2-0-Linux-x86_64.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;执行 Miniconda3-py39_23.5.2-0-Linux-x86_64.sh ，按照提示安装 Miniconda3。（安装在 &lt;code&gt;$HOME/software/miniconda3/23.5.2&lt;/code&gt; 目录下）&lt;/p&gt;
&lt;p&gt;然后，设置 Miniconda3 环境变量。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;PATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/software/miniconda3/23.5.2/bin:&lt;span class=&#34;nv&#34;&gt;$PATH&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;2-安装-boost&#34;&gt;2. 安装 Boost&lt;/h2&gt;
&lt;p&gt;从 &lt;a class=&#34;link&#34; href=&#34;https://boostorg.jfrog.io/artifactory/main/release/1.77.0/source/boost_1_77_0.tar.gz&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Boost 官方网站&lt;/a&gt; 下载 Boost。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wget https://boostorg.jfrog.io/artifactory/main/release/1.77.0/source/boost_1_77_0.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tar -zxvf boost_1_77_0.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; boost_1_77_0
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在 Boost 根目录下执行以下命令安装 Boost：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;module load gcc/8.4.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./bootstrap.sh --prefix&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/software/boost/1.77.0-gcc-8.4.0 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CC&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;gcc &lt;span class=&#34;nv&#34;&gt;CXX&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;g++ &lt;span class=&#34;nv&#34;&gt;FC&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;gfortran &lt;span class=&#34;nv&#34;&gt;CFLAGS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;-O3&amp;#39;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;CXXFLAGS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;-O3&amp;#39;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;FCFLAGS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;-O3&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;配置环境变量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;BOOST_ROOT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/software/boost/1.77.0-gcc-8.4.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LD_LIBRARY_PATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$BOOST_ROOT&lt;/span&gt;/lib:&lt;span class=&#34;nv&#34;&gt;$LD_LIBRARY_PATH&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LIBRARY_PATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$BOOST_ROOT&lt;/span&gt;/lib:&lt;span class=&#34;nv&#34;&gt;$LIBRARY_PATH&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;CMAKE_PREFIX_PATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$BOOST_ROOT&lt;/span&gt;/lib/cmake:&lt;span class=&#34;nv&#34;&gt;$CMAKE_PREFIX_PATH&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;CPATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$BOOST_ROOT&lt;/span&gt;/include:&lt;span class=&#34;nv&#34;&gt;$CPATH&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LD_RUN_PATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$BOOST_ROOT&lt;/span&gt;/lib:&lt;span class=&#34;nv&#34;&gt;$LD_RUN_PATH&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;3-安装-gnu-scientific-library&#34;&gt;3. 安装 GNU Scientific Library&lt;/h2&gt;
&lt;p&gt;从 &lt;a class=&#34;link&#34; href=&#34;https://mirror.ibcp.fr/pub/gnu/gsl/gsl-latest.tar.gzz&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GNU Scientific Library 镜像站&lt;/a&gt; 下载 GSL。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wget https://mirror.ibcp.fr/pub/gnu/gsl/gsl-latest.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tar -zxvf gsl-latest.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在 GSL 根目录执行以下命令安装 GSL：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;module load gcc/8.4.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./configure --prefix&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/software/gsl/2.7.1-gcc-8.4.0 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CC&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;gcc &lt;span class=&#34;nv&#34;&gt;CXX&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;g++ &lt;span class=&#34;nv&#34;&gt;FC&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;gfortran &lt;span class=&#34;nv&#34;&gt;CFLAGS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;-O3&amp;#39;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;CXXFLAGS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;-O3&amp;#39;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;FCFLAGS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;-O3&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;配置环境变量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;GSL_ROOT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/software/gsl/2.7.1-gcc-8.4.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LD_LIBRARY_PATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$GSL_ROOT&lt;/span&gt;/lib:&lt;span class=&#34;nv&#34;&gt;$LD_LIBRARY_PATH&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;PATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$GSL_ROOT&lt;/span&gt;/bin:&lt;span class=&#34;nv&#34;&gt;$PATH&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;CPATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$GSL_ROOT&lt;/span&gt;/include:&lt;span class=&#34;nv&#34;&gt;$CPATH&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LIBRARY_PATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$GSL_ROOT&lt;/span&gt;/lib:&lt;span class=&#34;nv&#34;&gt;$LIBRARY_PATH&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LD_RUN_PATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$GSL_ROOT&lt;/span&gt;/lib:&lt;span class=&#34;nv&#34;&gt;$LD_RUN_PATH&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;4-安装-nest&#34;&gt;4. 安装 NEST&lt;/h2&gt;
&lt;p&gt;使用 Miniconda3 创建一个虚拟环境。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; activate
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;conda create -n nest &lt;span class=&#34;nv&#34;&gt;python&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;3.9
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;conda activate nest
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用 pip 安装 numpy, scipy, cython==0.29.36&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pip install numpy scipy &lt;span class=&#34;nv&#34;&gt;cython&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;0.29.36
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;从 &lt;a class=&#34;link&#34; href=&#34;https://github.com/nest/nest-simulator/archive/refs/tags/v3.4.tar.gz&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;NEST github仓库&lt;/a&gt; 下载 NEST 3.4。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wget https://github.com/nest/nest-simulator/archive/refs/tags/v3.4.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tar -zxvf v3.4.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在 nest-simulator-3.4 目录下执行:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;module load gcc/8.4.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;module load mvaapich2/2.3.7-gcc-8.4.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cmake -DCMAKE_C_COMPILER&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;mpicc &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;      -DCMAKE_CXX_COMPILER&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;mpicxx &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;      -Dwith-mpi&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;which mpiexec&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;      -DCMAKE_C_FLAGS&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;-O3 -fPIC&amp;#39;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;      -DCMAKE_CXX_FLAGS&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;-O3&amp;#39;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;      -Dwith-boost&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/software/boost/1.77.0-gcc-8.4.0 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;      -DGSL_INCLUDE_DIR&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/software/gsl/2.7.1-gcc-8.4.0/include &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;      -DGSL_LIBRARY&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/software/gsl/2.7.1-gcc-8.4.0/lib/libgsl.a &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;      -DGSL_CBLAS_LIBRARY&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/software/gsl/2.7.1-gcc-8.4.0/lib/libgslcblas.a &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;      -DCMAKE_INSTALL_PREFIX:PATH&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/software/nest-simulator/3.4-gcc-8.4.0 .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;配置环境变量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NEST_ROOT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/software/nest-simulator/3.4-gcc-8.4.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LIBRARY_PATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$NEST_ROOT&lt;/span&gt;/lib:&lt;span class=&#34;nv&#34;&gt;$LIBRARY_PATH&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LD_LIBRARY_PATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$NEST_ROOT&lt;/span&gt;/lib:&lt;span class=&#34;nv&#34;&gt;$LD_LIBRARY_PATH&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;5-运行-hpc_benchmark-测试&#34;&gt;5. 运行 hpc_benchmark 测试&lt;/h2&gt;
&lt;p&gt;运行 NEST 前需要配置nest环境：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/software/nest-simulator/3.4-gcc-8.4.0/bin/nest_vars.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;接着找到 &lt;code&gt;hpc_benchmark.py&lt;/code&gt; 目录，该文件位于 &lt;code&gt;$HOME/software/nest-simulator/3.4-gcc-8.4.0/share/doc/nest/examples/hpc_benchmark.py&lt;/code&gt;。修改其中的 params 以并行运行更大的模型。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改 nvp 为所需 MPI 进程数 × 每进程线程数，如 2 MPI进程 × 14 线程 = 28&lt;/li&gt;
&lt;li&gt;设置合适的 scale ，如 10 。更大的需要更多 nvp 。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;params&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s1&#34;&gt;&amp;#39;nvp&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;28&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;               &lt;span class=&#34;c1&#34;&gt;# total number of virtual processes&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s1&#34;&gt;&amp;#39;scale&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;10.&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;# scaling factor of the network size&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# others...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在 &lt;code&gt;hpc_benchmark.py&lt;/code&gt; 目录下执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;OMP_NUM_THREADS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;14&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mpiexec -N &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; -n &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; -p &amp;lt;partition_name&amp;gt; --export&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;all python3 hpc_benchmark.py
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中 -N 指定节点数，-n 指定 MPI 进程数，-p 指定分区名，如 &lt;code&gt;compute&lt;/code&gt;，&amp;ndash;export=all 用于将环境变量导出到 MPI 进程中。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文介绍了在高性能计算机上安装 NEST-3.4 的方法。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://nest-simulator.readthedocs.io/en/latest/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;NEST 官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>CUDA基础：内存访问模式</title>
        <link>https://cuterwrite.top/p/cuda-base-memory-access-mode/</link>
        <pubDate>Mon, 04 Sep 2023 00:55:55 +0000</pubDate>
        
        <guid>https://cuterwrite.top/p/cuda-base-memory-access-mode/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/14ce26d6f495200cea2cfa76fefadf88eaab94e5.jpg@1256w_754h_!web-article-pic-2023-09-04.webp" alt="Featured image of post CUDA基础：内存访问模式" /&gt;&lt;h1 id=&#34;cuda基础内存访问模式&#34;&gt;CUDA基础：内存访问模式&lt;/h1&gt;
&lt;p&gt;大多数设备端数据访问都是从全局内存开始的，并且多数 GPU 应用程序容易受内存带宽的限制。因此，最大限度地利用全局内存带宽是调控核函数性能的基本。如果不能正确地调控全局内存的使用，其他优化方案很可能也收效甚微。&lt;/p&gt;
&lt;p&gt;为了在读写数据时达到最佳的性能，内存访问操作必须满足一定的条件。CUDA 执行模型的显著特征之一就是指令必须以线程束为单位进行发布和执行。存储操作也是同样。在执行内存指令时，线程束中的每个线程都提供了一个正在加载或存储的内存地址。在线程束的 32 个线程中，每个线程都提出了一个包含请求地址的单一内存访问请求，它并由一个或多个设备内存传输提供服务。根据线程束中内存地址的分布，内存访问可以被分成不同的模式。&lt;/p&gt;
&lt;h2 id=&#34;一对齐与合并访问&#34;&gt;一、对齐与合并访问&lt;/h2&gt;
&lt;p&gt;全局内存通过缓存实现加载和存储的过程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230904151729-2023-09-04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230904151729-2023-09-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;全局内存是一个逻辑内存空间，用户可以通过核函数访问它。所有应用程序数据最初存在于 DRAM 上，即物理设备内存中。核函数的内存请求通常是在 DRAM 设备和片上内存间以 128 字节或 32 字节内存事务来实现。&lt;/p&gt;
&lt;p&gt;所有对全局内存的访问都会通过二级缓存，也有许多访问会通过一级缓存，这取决于访问类型和 GPU 架构。如果这两级缓存都被用到，那么内存访问是由一个 128 字节的内存事务实现的。如果只使用二级缓存，那么这个内存访问是由一个 32 字节的内存事务来实现的。对全局内存缓存其架构，如果允许使用一级缓存，那么可以在编译时选择启用或禁用一级缓存。&lt;/p&gt;
&lt;p&gt;一行一级缓存是 128 字节，它映射到设备内存中一个 128 字节 的对齐段。如果线程束中的每个线程请求一个 4 字节的值，那么每次请求就会获取 128 字节的数据，这恰好与缓存行和设备内存段的大小相契合。&lt;/p&gt;
&lt;p&gt;因此在优化应用程序时，需要注意设备内存访问的两个特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对齐内存访问&lt;/li&gt;
&lt;li&gt;合并内存访问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们把一次内存请求：也就是从核函数发起请求，到硬件响应返回数据这个过程称为一个内存事务（加载和存储都行）。&lt;/p&gt;
&lt;p&gt;当一个内存事务的首个访问地址是缓存粒度（32或128字节）的偶数倍的时候：比如二级缓存32字节的偶数倍 64，128 字节的偶数倍 256 的时候，这个时候被称为对齐内存访问，非对齐访问就是除上述的其他情况，&lt;strong&gt;非对齐的内存访问会造成带宽浪费&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当一个线程束内的线程访问的内存都在一个内存块里的时候，就会出现合并访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对齐合并访问的状态是理想化的，也是最高速的访问方式&lt;/strong&gt;，当线程束内的所有线程访问的数据在一个内存块，并且数据是从内存块的首地址开始被需要的，那么对齐合并访问出现了。为了最大化全局内存访问的理想状态，尽量将线程束访问内存组织成对齐合并的方式，这样的效率是最高的。下面看一个例子。&lt;/p&gt;
&lt;p&gt;一个线程束加载数据，使用一级缓存，并且这个事务所请求的所有数据在一个 128 字节的对齐的地址段上，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230904152703-2023-09-04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230904152703-2023-09-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上面蓝色表示全局内存，下面橙色是线程束要的数据，绿色就是对齐的地址段。&lt;/p&gt;
&lt;p&gt;而如果一个事务加载的数据分布在不一个对齐的地址段上，就会有以下两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;连续的，但是不在一个对齐的段上，比如，请求访问的数据分布在内存地址 1~128 ，那么 0~127 和 128~255 这两段数据要传递两次到 SM 。&lt;/li&gt;
&lt;li&gt;不连续的，也不在一个对齐的段上，比如，请求访问的数据分布在内存地址 0~63 和 128~191 上，明显这也需要两次加载。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230904152901-2023-09-04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230904152901-2023-09-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上图就是典型的一个线程束，数据分散开了，thread 0 的请求在 128 之前，后面还有请求在 256 之后，所以需要三个内存事务，而利用率，也就是从主存取回来的数据被使用到的比例，只有 $\frac{128}{128 \times 3}$ 的比例。这个比例低会造成带宽的浪费，最极端的表现，就是如果每个线程的请求都在不同的段，也就是一个 128 字节的事务只有 1 个字节是有用的，那么利用率只有 $\frac{1}{128}$ 。&lt;/p&gt;
&lt;p&gt;这里总结一下内存事务的优化关键：&lt;strong&gt;用最少的事务次数满足最多的内存请求&lt;/strong&gt;。事务数量和吞吐量的需求随设备的计算能力变化。&lt;/p&gt;
&lt;h2 id=&#34;二全局内存读取&#34;&gt;二、全局内存读取&lt;/h2&gt;
&lt;p&gt;在 SM 中，数据通过以下 3 种缓存 / 缓冲路径进行传输，具体使用何种方式取决于引用了哪种类型的设备内存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一级和二级缓存&lt;/li&gt;
&lt;li&gt;常量缓存&lt;/li&gt;
&lt;li&gt;只读缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一 / 二级缓存是默认路径。想要通过其它两种路径传输数据需要&lt;strong&gt;应用程序显式说明&lt;/strong&gt;，但想要提升性能还要取决于使用地访问模式。全局内存加载操作是否会通过一级缓存取决于两个因素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设备的计算能力：比较老的设备可能没有一级缓存&lt;/li&gt;
&lt;li&gt;编译器选项&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Fermi GPU 和 Kepler K40 及以后的 GPU （计算能力为 3.5 及以上）中，可以通过编译器标志启用或禁用全局内存负载的一级缓存。默认情况下，在 Fermi 设备上对于全局内存加载可以使用一级缓存，在 K40 及以上 GPU 中禁用。以下标志通知编译器禁用一级缓存：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-Xptxas -dlcm=cg
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果一级缓存被禁用，所有对全局内存的加载请求将直接进入到二级缓存；如果二级缓存缺失，则由 DRAM 完成请求。每一次内存事务可由一个、两个或四个部分执行，每个部分有 32 个字节。一级缓存也可以使用下列标识符直接启用:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-Xptxas -dlcm=ca
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;设置这个标志后，全局内存加载请求首先尝试通过一级缓存。如果一级缓存缺失，该请求转向二级缓存。如果二级缓存缺失，则请求由 DRAM 完成。在这种模式下，一个内存加载请求由一个 128 字节的设备内存事务实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230904164822-2023-09-04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230904164822-2023-09-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在 Kepler K10、K20 和 K20X GPU 中一级缓存不用来缓存全局内存加载。一级缓存专门用于&lt;strong&gt;缓存寄存器溢出到本地内存中的数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;内存加载可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存加载&lt;/li&gt;
&lt;li&gt;没有缓存的加载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内存访问有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否使用缓存：一级缓存是否介入加载过程&lt;/li&gt;
&lt;li&gt;对齐与非对齐的：如果访问的第一个地址是 32 的倍数&lt;/li&gt;
&lt;li&gt;合并与非合并，访问连续数据块则是合并的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-缓存加载&#34;&gt;1. 缓存加载&lt;/h3&gt;
&lt;p&gt;下面是使用一级缓存的加载过程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对齐合并的访问，总线利用率 $100\%$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230904165226-2023-09-04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230904165226-2023-09-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;对齐的，但是不是连续的，每个线程访问的数据都在一个块内，但是位置是交叉的，总线利用率 $100\%$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230904165245-2023-09-04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230904165245-2023-09-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;连续非对齐的，线程束请求一个连续的非对齐的，32 个 4 字节数据，那么会出现，数据横跨两个块，但是没有对齐，当启用一级缓存的时候，就要两个 128 字节的事务来完成，总线利用率为 $50\%$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230904165306-2023-09-04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230904165306-2023-09-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;线程束所有线程请求同一个地址，那么肯定落在一个缓存行范围内，那么如果按照请求的是 4 字节数据来说，总线利用率是 $\frac{4}{128}=3.125\% $&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230904165516-2023-09-04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230904165516-2023-09-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;比较坏的情况，前面提到过最坏的，就是每个线程束内的线程请求的都是不同的缓存行内，这里比较坏的情况就是，所有数据分布在 $N$ 个缓存行，其中 $1\leq N \leq 32$ ，那么请求 32 个 4 字节的数据，就需要 $N$ 个事务来完成，总线利用率也是 $\frac{1}{N}$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230904165524-2023-09-04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230904165524-2023-09-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;CPU 和 GPU 的一级缓存有显著的差异， GPU 的一级缓存可以通过编译选项等控制，CPU 不可以，而且 CPU 的一级缓存是的替换算法是有使用频率和时间局部性的， GPU 则没有。&lt;/p&gt;
&lt;h3 id=&#34;2-没有缓存的加载&#34;&gt;2. 没有缓存的加载&lt;/h3&gt;
&lt;p&gt;没有缓存的加载是指的没有通过一级缓存，二级缓存则是不得不经过的。&lt;/p&gt;
&lt;p&gt;当不使用一级缓存的时候，&lt;strong&gt;内存事务的粒度变为 32 字节&lt;/strong&gt;，更细粒度的加载可以为非对齐或非合并的内存访问带来更好的总线利用率。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对齐合并访问 128 字节，不用说，还是最理想的情况，使用 4 个段，总线利用率 $100\%$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230904170430-2023-09-04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230904170430-2023-09-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;对齐不连续访问 128 字节，都在四个段内，且互不相同，这样的总线利用率也是 $100\%$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230904170454-2023-09-04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230904170454-2023-09-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;连续不对齐，一个段 32 字节，所以，一个连续的 128 字节的请求，即使不对齐，最多也不会超过五个段，总线利用率至少为 $\frac{4}{5}=80\%$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230904170542-2023-09-04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230904170542-2023-09-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;所有线程访问一个 4 字节的数据，那么此时的总线利用率是 $\frac{4}{32} = 12.5\%$ ，在这种情况下，非缓存加载性能也是优于缓存加载的性能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230904170609-2023-09-04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230904170609-2023-09-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;最坏的情况：所有目标数据分散在内存的各个角落，那么需要 $N$ 个内存段，由于请求的 128 个字节最多落在 $N$ 个 32 字节的内存分段内而不是 $N$ 个 128 字节的缓存行内，所以相比于缓存加载，即便是最坏的情况也有所改善。需要注意这里比较的前提是$N$ 不变，然而在实际情况下，当使用大粒度的缓存行时，$N$ 有可能会减少。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230904170847-2023-09-04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230904170847-2023-09-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-只读缓存&#34;&gt;3. 只读缓存&lt;/h3&gt;
&lt;p&gt;只读缓存最初是预留给纹理内存加载用的。对计算能力为 3.5 及以上的 GPU 来说，只读缓存也支持使用全局内存加载代替一级缓存。&lt;/p&gt;
&lt;p&gt;只读缓存的加载粒度是 32 个字节。通常，对分散读取来说，这些更细粒度的加载要优于一级缓存。&lt;/p&gt;
&lt;p&gt;有两种方式可以指导内存通过只读缓存进行读取:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用函数 __ldg&lt;/li&gt;
&lt;li&gt;在间接引用的指针上使用修饰符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;__global__&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;copyKernel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;blockDim&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;blockIdx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;threadIdx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;__ldg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后就能强制使用只读缓存了。&lt;/p&gt;
&lt;p&gt;也可以将常量 restrict 修饰符应用到指针上。这些修饰符帮助 nvcc 编译器识别无别名指针(即专门用来访问特定数组的指针)。nvcc将自动通过只读缓存指导无别名指针的加载。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;__global__&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;copyKernel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__restrict__&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__restrict__&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;blockDim&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;blockIdx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;threadIdx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;三全局内存写入&#34;&gt;三、全局内存写入&lt;/h2&gt;
&lt;p&gt;内存的存储操作相对简单。一级缓存不能用在 Fermi 或 Kepler GPU 上进行存储操作，在发送到设备内存之间存储操作&lt;strong&gt;只通过二级缓存&lt;/strong&gt;。存储操作在 &lt;strong&gt;32 个字节段&lt;/strong&gt;的粒度上被执行。内存事务可以同时被分为一段、两段或四段。例如，如果两个地址同属于一个 128 字节区域，但是不属于一个对齐的 64 字节区域，则会执行一个四段事务（也就是说，执行一个四段事务比执行两个一段事务效果更好）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对齐的，访问一个连续的 128 字节范围。存储操作使用一个四段事务完成：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230904172018-2023-09-04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230904172018-2023-09-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;分散在一个 192 字节的范围内，不连续，使用 3 个一段事务完成：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230904172036-2023-09-04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230904172036-2023-09-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;对齐的，在一个 64 字节的范围内，使用一个两段事务完成：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230904172052-2023-09-04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230904172052-2023-09-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;非对齐写入示例与读取情况类似，且更简单，因为始终不经过一级缓存，这里就略过了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;四结构体数组与数组结构体&#34;&gt;四、结构体数组与数组结构体&lt;/h2&gt;
&lt;p&gt;数组结构体（AoS）和结构体数组（SoA）是C语言中常见的两种数组组织方式。当存储结构化数据集时，它们代表了可以采用的两种强大的数据组织方式（结构体和数组）。&lt;/p&gt;
&lt;p&gt;下面是存储成对的浮点数据数据集的例子。首先，考虑这些成对数据元素集如何使用 AoS 方法进行存储。如下定义一个结构体，命名为 innerStruct ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;innerStruct&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后，按照下面的方法定义这些结构体数组。这是利用 AoS 方式来组织数据的。它存储的是空间上相邻的数据，这在 CPU 上会有良好的缓存局部性。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;innerStruct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;myAoS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;接下来，考虑使用 SoA 方法来存储数据：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;innerArray&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这里，在原结构体中每个字段的所有值都被分到各自的数组中。这不仅能将相邻数据点紧密存储起来，也能将跨数组的独立数据点存储起来。可以使用如下结构体定义一个变量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;innerArray&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mySoA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;下图说明了 AoS 和 SoA 方法的内存布局。用 AoS 模式在 GPU 上存储示例数据并执行一个只有 $x$ 字段的应用程序，将导致 $50\%$ 的带宽损失，因为 $y$ 值在每 32 个字节段或 128 个字节缓存行上隐式地被加载。 AoS格式也在不需要的 $y$ 值上浪费了二级缓存空间。&lt;/p&gt;
&lt;p&gt;用 SoA 模式存储数据充分利用了 GPU 的内存带宽。由于没有相同字段元素的交叉存取， GPU 上的 SoA 布局提供了合并内存访问，并且可以对全局内存实现更高效的利用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230904173436-2023-09-04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;20230904173436-2023-09-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;当 32 个线程同时访问的时候， SoA 的访问就是连续的，而 AoS 则是不连续的。&lt;/p&gt;
&lt;p&gt;对比 AoS 和 SoA 的内存布局，我们能得到下面结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并行编程范式，尤其是 SIMD（单指令多数据）对 SoA 更友好。 CUDA 中普遍倾向于 SoA 因为这种内存访问可以有效地合并。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;五性能调整&#34;&gt;五、性能调整&lt;/h2&gt;
&lt;p&gt;优化设备内存带宽利用率有两个目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对齐及合并内存访问，以减少带宽的浪费&lt;/li&gt;
&lt;li&gt;足够的并发内存操作，以隐藏内存延迟&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实现并发内存访问量最大化是通过以下方式得到的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;增加每个线程中执行独立内存操作的数量&lt;/li&gt;
&lt;li&gt;对核函数启动的执行配置进行试验，已充分体现每个 SM 的并行性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;按照这个思路对程序进行优化，则有两种方法：展开技术和增大并行性。&lt;/p&gt;
&lt;h3 id=&#34;1-展开技术&#34;&gt;1. 展开技术&lt;/h3&gt;
&lt;p&gt;包含了内存操作的展开循环增加了更独立的内存操作。考虑如下 readOffsetUnroll4 核函数，每个线程都执行 4 个独立的内存操作。因为每个加载过程都是独立的，所以可以调用更多的并发内存访问：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;__global__&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;readOffsetUnroll4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;blockIdx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;blockDim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;threadIdx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;blockDim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;blockDim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;blockDim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;blockDim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;blockDim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;blockDim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;blockDim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;blockDim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;blockDim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;blockDim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;启用一级缓存编译选项：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;nvcc -O3 readSegmentUnroll.cu -o readSegmentUnroll -Xptxas -dlcm&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ca
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;结果表明，展开技术对性能有非常好的影响，甚至比地址对齐还要好。对于 I/O 密集型的核函数，充分说明内存访问并行有很高的优先级。&lt;/p&gt;
&lt;h3 id=&#34;2-增大并行性&#34;&gt;2. 增大并行性&lt;/h3&gt;
&lt;p&gt;可以通过调整块的大小来实现并行性调整：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程块最内层维度的大小对性能起着关键的作用&lt;/li&gt;
&lt;li&gt;在所有其它情况下，线程块的数量越多，一般性能越高。因此，增大并行性仍然是性能优化的一个重要因素。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1] CUDA C编程权威指南，机械工业出版社，（美）程润伟（John Cheng） 等著&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>