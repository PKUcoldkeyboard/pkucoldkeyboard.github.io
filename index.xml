<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>cuterwrite (Pang S.Z)</title>
        <link>https://cuterwrite.top/</link>
        <description>Recent content on cuterwrite (Pang S.Z)</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 18 Jul 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://cuterwrite.top/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>MPI与并行计算（一）：并行环境及编程模型</title>
        <link>https://cuterwrite.top/p/mpi-tutorial/1/</link>
        <pubDate>Tue, 18 Jul 2023 00:00:00 +0000</pubDate>
        
        <guid>https://cuterwrite.top/p/mpi-tutorial/1/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20230719012753.png" alt="Featured image of post MPI与并行计算（一）：并行环境及编程模型" /&gt;&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;  &lt;em&gt;generated with &lt;a class=&#34;link&#34; href=&#34;https://github.com/thlorenz/doctoc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;DocToc&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#mpi%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E4%B8%80%E5%B9%B6%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%8F%8A%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B&#34; &gt;MPI与并行计算（一）：并行环境及编程模型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#1-%E4%BB%80%E4%B9%88%E6%98%AFmpi&#34; &gt;1. 什么是MPI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#2-mpi%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B&#34; &gt;2. MPI的发展过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8mpi&#34; &gt;3. 为什么要用MPI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#4-%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F&#34; &gt;4. 并行编程模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#5-mpi%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F&#34; &gt;5. MPI的工作模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#6-mpi%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5&#34; &gt;6. MPI消息传递通信的基本概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#7-mpi%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C&#34; &gt;7. MPI程序编译、运行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#8-mpi%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%8F%A3&#34; &gt;8. MPI的四个基本接口&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;mpi与并行计算一并行环境及编程模型&#34;&gt;MPI与并行计算（一）：并行环境及编程模型&lt;/h1&gt;
&lt;h2 id=&#34;1-什么是mpi&#34;&gt;1. 什么是MPI&lt;/h2&gt;
&lt;p&gt;Massage Passing Interface：是消息传递函数库的标准规范，由MPI论坛开发，支持Fortran和C。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一种新的库描述，不是一种语言。共有上百个函数调用接口，在Fortran和C语言中可以直接对这些函数进行调用。&lt;/li&gt;
&lt;li&gt;MPI是一种标准或规范的代表，而不是特指某一个对它的具体实现。迄今为止所有的并行计算机制造商都提供对MPI的支持。
&lt;ul&gt;
&lt;li&gt;Intel MPI&lt;/li&gt;
&lt;li&gt;OpenMPI&lt;/li&gt;
&lt;li&gt;mpich&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MPI是一种消息传递编程模型，并成为这种编程模型的代表和事实上的标准。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-mpi的发展过程&#34;&gt;2. MPI的发展过程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MPI 1.1：1995
&lt;ul&gt;
&lt;li&gt;MPICH:是MPI最流行的非专利实现,由Argonne国家实验室和密西西比州立大学联合开发,具有更好的可移植性.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MPI 1.2~2.0：动态进程, 并行 I/O, 支持F90和C++(1997)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-为什么要用mpi&#34;&gt;3. 为什么要用MPI&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;高可移植性：MPI已在IBM PC机上、 MS Windows上、所有主要的Unix工作站上和所有主流的并行机上得到实现。使用MPI作消息传递的C或Fortran并行程序可不加改变地运行在IBMPC、 MS Windows、 Unix工作站、以及各种并行机上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-并行编程模式&#34;&gt;4. 并行编程模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;隐式并行：借助编译器和运行时环境的支持发掘程序的并行性，对串行程序进行并行化。&lt;/li&gt;
&lt;li&gt;数据并行：数据并行依靠所处理的数据集合无关性，借助数据划分来驱动程序之间的并行执行。&lt;/li&gt;
&lt;li&gt;消息传递：消息传递模型可以通过如下的几个概念加以定义：
&lt;ul&gt;
&lt;li&gt;一组仅有本地内存空间的进程&lt;/li&gt;
&lt;li&gt;进程之间通过发送和接收消息进行通信&lt;/li&gt;
&lt;li&gt;进程之间需要使用协同操作完成数据传递，如发送操作必须要求有与之配对的接收操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共享变量：并行代码分别驻留在不同的处理器上，通过读写公共存储器中的共享变量进行同步和通信，一般适合在多核系统，SMP系统上运行。分布式存储系统可以在运行时库支持下通过自定义机制以共享变量的方式运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-mpi的工作模式&#34;&gt;5. MPI的工作模式&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;运行方式：以串行方式编写，运行时分别执行不同的块。&lt;/li&gt;
&lt;li&gt;资源分配：所有程序元素只要没有进行显示区分，无论是代码、函数、全局变量还是局部变量，都默认的由全部进程共同拥有，所有进程看到的虽然是相同的名字，但在“物理”上却彼此无关。&lt;/li&gt;
&lt;li&gt;显示区分：就是指程序员需在程序设计阶段通过显示的条件判断来指定在不同进程上运行不同的代码块。这正是MPI程序的特点，也恰好是难点之一。&lt;/li&gt;
&lt;/ol&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;一个典型的MPI程序代码模式如下：&lt;/p&gt;&lt;/div&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Inititalization code block
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rank&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;process1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// define works to be carried out by process1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rank&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;process2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// define works to be carried out by process2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rank&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;process3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// define works to be carried out by process3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rank&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;process4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// define works to be carried out by process4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}...&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rank&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;processn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// define works to be carried out by processn
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// define works to be carried out by all processes
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;6-mpi消息传递通信的基本概念&#34;&gt;6. MPI消息传递通信的基本概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;消息：一个消息可以比做一个封信。需要定义消息的内容以及消息的发送与接收者。前者称为消息的缓冲(Message Buffer)，后者称为消息信封(Message Envelop)。在MPI中，消息缓冲由三元组&amp;lt;起始地址，数据个数，数据类型&amp;gt;来标识，而消息信封则是由三元组&amp;lt;源/目标进程，消息标签，通讯域&amp;gt;来标识。如下为&lt;code&gt;MPI_Send&lt;/code&gt;的消息缓冲和消息信封。
&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230718183355.png&#34; alt=&#34;20230718183355&#34;  /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓冲区：MPI环境定义了3种缓冲区：应用缓冲区，系统缓冲区和用户向系统注册的缓冲区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用缓冲区：保存将要发送或接收的消息内容即上述的消息缓冲。&lt;/li&gt;
&lt;li&gt;系统缓冲区：MPI环境为通信所准备的存储空间。&lt;/li&gt;
&lt;li&gt;用户缓冲区：指用户向系统注册的缓冲区，用户使用某些API(如&lt;code&gt;MPI_Bsend&lt;/code&gt;)时，在程序中显示申请的存储空间，然后注册到MPI环境中供通信所用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通信子：MPI环境管理进程及通信的基本设施。&lt;code&gt;MPI_COMM_WORLD&lt;/code&gt;就是MPI环境启动时默认创建的通信子。对某个进程的操作必须放在通信子内方可有效。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程号：进程号即进程的&lt;code&gt;rank&lt;/code&gt;，指在某个通信子内某个进程号rank为num。在一个通信子内，每一个进程都有它&lt;!-- raw HTML omitted --&gt;唯一&lt;!-- raw HTML omitted --&gt;的num，这个标识号是在进程初始化时由系统分配，从0开始编号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程组：定义一个通信子，也就指定了一组共享该空间的进程，这些进程组成了该通信子的进程组(group)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通信协议：MPI环境依据实现的策略不同，可能采用如下一种或几种协议。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;立即通信协议，总是假定目标进程具有保存消息数据的能力。&lt;/li&gt;
&lt;li&gt;集中通信协议，在目标准备好之后，才可以执行发送动作。&lt;/li&gt;
&lt;li&gt;短消息协议，消息数据与信封封装在一起发送。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;7-mpi程序编译运行&#34;&gt;7. MPI程序编译、运行&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MPI环境安装：
&lt;ul&gt;
&lt;li&gt;更新apt源：&lt;code&gt;sudo apt-get update&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;安装build-essential：&lt;code&gt;sudo apt-get install -y build-essential&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;安装mpich: &lt;code&gt;sudo apt-get install -y mpich&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MPI程序编译：mpicc
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Intel MPI&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Mpich/OpenMPI&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Fortran&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;mpiifort&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;mpi90&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;C&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;mpiicc&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;mpicc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;C++&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;mpiicpc&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;mpicxx&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;mpicc编译示例&lt;/p&gt;&lt;/div&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mpicc -o mpi mpi.c
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;MPI程序运行：mpirun
&lt;ul&gt;
&lt;li&gt;使用mpirun来运行mpi程序（intel mpi、mpich、openmpi等）&lt;/li&gt;
&lt;li&gt;用法：mpirun -n 进程数 可执行文件名&lt;/li&gt;
&lt;li&gt;示例：&lt;code&gt;mpirun -n 2 ./example&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;第一个MPI程序示例 - Hello World&lt;/p&gt;&lt;/div&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// mpi.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;mpi.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;MPI_Init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Hello World!&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;MPI_Finalize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;编译与运行mpi.c&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mpicc -o mpi mpi.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mpirun -n &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; ./mpi
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&#34;notice notice-warning&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 576 512&#34;&gt;&lt;path d=&#34;M570 440c18 32-5 72-42 72H48c-37 0-60-40-42-72L246 24c19-32 65-32 84 0l240 416zm-282-86a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;注意： root用户运行mpirun时，需要加上&amp;ndash;allow-run-as-root参数，否则会报错。&lt;/p&gt;&lt;/div&gt;

&lt;h2 id=&#34;8-mpi的四个基本接口&#34;&gt;8. MPI的四个基本接口&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;接口名&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;MPI_Init(&amp;amp;argc, &amp;amp;argv)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;初始化MPI环境，MPI系统将通过argc, argv得到命令行参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;MPI_Comm_rank(MPI_COMM_WORLD, &amp;amp;myrank)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;缺省的通信子为MPI_COMMON_WORLD，获得进程所在缺省通信子的编号，赋值给myrank&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;MPI_Comm_size(MPI_COMM_WORLD, &amp;amp;nprocs)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;获得缺省通信子中进程的个数，赋值给nprocs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;MPI_Finalize()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一般放在程序最后一行，如果没有此行，MPI程序将不会终止&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;MPI初始化：MPI_Init
&lt;ul&gt;
&lt;li&gt;int MPI_Init(int *argc, char ***argv)&lt;/li&gt;
&lt;li&gt;MPI_Init是MPI程序的第一个调用，它完成MPI程序的所有初始化工作。所有的MPI程序的第一条可执行语句都是这条语句。&lt;/li&gt;
&lt;li&gt;启动MPI环境,标志并行代码的开始.&lt;/li&gt;
&lt;li&gt;要求main必须带参数运行,否则出错&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MPI结束：MPI_Finalize
&lt;ul&gt;
&lt;li&gt;int MPI_Finalize(void)&lt;/li&gt;
&lt;li&gt;MPI_FINALIZE是MPI程序的最后一个调用，它结束MPI程序的运行，它是MPI程序的最后一条可执行语句，否则程序的运行结果是不可预知的。&lt;/li&gt;
&lt;li&gt;标志并行代码的结束,结束除主进程外其它进程。&lt;/li&gt;
&lt;li&gt;之后串行代码仍可在主进程(rank = 0)上运行(如果必须)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程号：MPI_Comm_rank
&lt;ul&gt;
&lt;li&gt;int MPI_Comm_rank(MPI_Comm comm, int *rank)&lt;/li&gt;
&lt;li&gt;MPI_COMM_RANK是MPI程序中的一个重要函数，它返回调用进程在通信子中的进程号，即rank。&lt;/li&gt;
&lt;li&gt;通信子：MPI_COMM_WORLD&lt;/li&gt;
&lt;li&gt;进程号：rank&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程数：MPI_Comm_size
&lt;ul&gt;
&lt;li&gt;int MPI_Comm_size(MPI_Comm comm, int *size)&lt;/li&gt;
&lt;li&gt;MPI_COMM_SIZE是MPI程序中的一个重要函数，它返回通信子中的进程数，即size。&lt;/li&gt;
&lt;li&gt;通信子：MPI_COMM_WORLD&lt;/li&gt;
&lt;li&gt;进程数：size&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;



&lt;div class=&#34;notice notice-note&#34; &gt;
    &lt;div class=&#34;notice-title&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon notice-icon&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&lt;p&gt;示例2：打印进程ID和进程数&lt;/p&gt;&lt;/div&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// mpi.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;mpi.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;myrank&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nprocs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;MPI_Init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;MPI_Comm_rank&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MPI_COMM_WORLD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myrank&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;MPI_Comm_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MPI_COMM_WORLD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nprocs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Hello World! I&amp;#39;m %d of %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;myrank&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nprocs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;MPI_Finalize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;结果：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;root@ubuntu:~# mpicc -o mpi mpi.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;root@ubuntu:~# mpirun -n 2 ./mpi
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Hello World! I&amp;#39;m 0 of 2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Hello World! I&amp;#39;m 1 of 2
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>CUDA编程：从基础到应用</title>
        <link>https://cuterwrite.top/p/cuda-tutorial/</link>
        <pubDate>Tue, 11 Jul 2023 00:00:00 +0000</pubDate>
        
        <guid>https://cuterwrite.top/p/cuda-tutorial/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/ba25bc69cbefbfac1287056fee570cee2b6458ff.jpg@1256w_880h_!web-article-pic.avif" alt="Featured image of post CUDA编程：从基础到应用" /&gt;&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;  &lt;em&gt;generated with &lt;a class=&#34;link&#34; href=&#34;https://github.com/thlorenz/doctoc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;DocToc&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#cuda%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%BA%94%E7%94%A8&#34; &gt;CUDA编程：从基础到应用&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%E4%B8%80%E4%BB%80%E4%B9%88%E6%98%AFcuda&#34; &gt;一、什么是CUDA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%E4%BA%8Ccpu-vs-gpu&#34; &gt;二、CPU vs. GPU&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%E4%B8%89%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97&#34; &gt;三、异构计算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%E5%9B%9Bcuda%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B&#34; &gt;四、CUDA编程模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%E4%BA%94cuda%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B&#34; &gt;五、CUDA线程执行模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%E5%85%ADcuda%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C&#34; &gt;六、CUDA原子操作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;cuda编程从基础到应用&#34;&gt;CUDA编程：从基础到应用&lt;/h1&gt;
&lt;h2 id=&#34;一什么是cuda&#34;&gt;一、什么是CUDA&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CUDA是NVIDIA推出的一种通用并行计算平台和编程模型，可以利用GPU的强大计算能力来加速各种应用程序。&lt;/li&gt;
&lt;li&gt;CUDA的优势在于：
&lt;ul&gt;
&lt;li&gt;提供了一套简单易用的编程接口，支持C/C++/Fortran/Python等多种语言。&lt;/li&gt;
&lt;li&gt;兼容各种操作系统，如Windows/Linux/MacOS等。&lt;/li&gt;
&lt;li&gt;支持多种GPU架构，如Tesla/Fermi/Kepler/Maxwell/Pascal/Volta/Turing/Ampere等。&lt;/li&gt;
&lt;li&gt;支持多种并行编程模式，如数据并行/任务并行/流并行等。&lt;/li&gt;
&lt;li&gt;支持多种优化技术，如共享内存/纹理内存/常量内存/原子操作/同步机制等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Why CUDA?
&lt;ul&gt;
&lt;li&gt;串行速度提升已经结束
&lt;ul&gt;
&lt;li&gt;无法继续提升频率&lt;/li&gt;
&lt;li&gt;难以继续降低功耗&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当前计算机性能提升趋势
&lt;ul&gt;
&lt;li&gt;计算机没有变得更快，而是变得更宽
&lt;ul&gt;
&lt;li&gt;多核CPU、GPU、超级计算机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据级别并行
&lt;ul&gt;
&lt;li&gt;同样的指令作用于多个数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程级别的并行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二cpu-vs-gpu&#34;&gt;二、CPU vs. GPU&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CPU和GPU都是计算机中的重要组件，但它们有着不同的设计目标和特点。&lt;/li&gt;
&lt;li&gt;CPU的特点是：
&lt;ul&gt;
&lt;li&gt;拥有较少的核心数，但每个核心都有较高的时钟频率和较强的运算能力。&lt;/li&gt;
&lt;li&gt;拥有较大的缓存和复杂的控制流机制，可以有效地降低延迟和提高串行代码的性能。&lt;/li&gt;
&lt;li&gt;更适合于处理复杂的单任务或少量的多任务，如操作系统/数据库/编译器等。&lt;/li&gt;
&lt;li&gt;类比于摩托车，可以灵活地在城市中穿梭。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GPU的特点是：
&lt;ul&gt;
&lt;li&gt;拥有较多的核心数，但每个核心都有较低的时钟频率和较弱的运算能力。&lt;/li&gt;
&lt;li&gt;拥有较小的缓存和简单的控制流机制，可以有效地提高吞吐量和利用大规模并行架构。&lt;/li&gt;
&lt;li&gt;更适合于处理大量相似或简单的任务，如图形渲染/科学计算/机器学习等。&lt;/li&gt;
&lt;li&gt;类比于大巴车，可以承载更多的乘客。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;CPU&lt;/th&gt;
&lt;th&gt;GPU&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;缓存&lt;/td&gt;
&lt;td&gt;大缓存：掩盖较长的存储器延迟&lt;/td&gt;
&lt;td&gt;小缓存：但通过更快的存储提高吞吐量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;运算器&lt;/td&gt;
&lt;td&gt;强大的运算器：降低运算延迟&lt;/td&gt;
&lt;td&gt;更节能的运算器：延迟大但总吞吐量大&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;控制机制&lt;/td&gt;
&lt;td&gt;复杂的控制机制：分支预测等&lt;/td&gt;
&lt;td&gt;简单的控制流机制：无分支预测&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;线程&lt;/td&gt;
&lt;td&gt;线程高度轻量级：大量并发&lt;/td&gt;
&lt;td&gt;线程高度轻量级：大量并发&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;三异构计算&#34;&gt;三、异构计算&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;异构计算是指利用不同类型的处理器协同工作来完成一个任务，如CPU+GPU、CPU+FPGA、CPU+ASIC等。&lt;/li&gt;
&lt;li&gt;异构计算的优势在于：
&lt;ul&gt;
&lt;li&gt;可以充分发挥每种处理器的特长，提高性能和效率。&lt;/li&gt;
&lt;li&gt;可以降低功耗和成本，延长设备寿命和节约资源。&lt;/li&gt;
&lt;li&gt;可以增加灵活性和可扩展性，适应不同场景和需求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;异构计算的挑战在于：
&lt;ul&gt;
&lt;li&gt;需要设计合适的编程模型和接口，实现不同处理器之间的协调和通信。&lt;/li&gt;
&lt;li&gt;需要考虑不同处理器之间的负载均衡和数据一致性，避免性能瓶颈和错误发生。&lt;/li&gt;
&lt;li&gt;需要优化不同处理器之间的数据传输和转换，减少开销和延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CPU+GPU
&lt;ul&gt;
&lt;li&gt;利用CPU处理复杂控制流&lt;/li&gt;
&lt;li&gt;利用GPU处理大规模运算&lt;/li&gt;
&lt;li&gt;CPU与GPU之间通过PCIe总线通信
&lt;ul&gt;
&lt;li&gt;新显卡支持NVLink连接（5-12倍PCIe3.0)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四cuda编程模型&#34;&gt;四、CUDA编程模型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CUDA编程模型是基于数据并行思想设计的一种分层抽象模型，可以将一个复杂的问题分解为多个简单的子问题，并将其映射到GPU上执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CUDA编程模型包括以下几个层次：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程（thread）：线程是CUDA中最基本的执行单元，每个线程都有自己独立的寄存器、指令指针、栈空间等。&lt;/li&gt;
&lt;li&gt;块（block）：块是由多个线程组成的一维或二维的逻辑分组，每个块都有自己独立的共享内存、同步机制等。&lt;/li&gt;
&lt;li&gt;网格（grid）：网格是由多个块组成的一维或二维的逻辑分组，每个网格都有自己独立的全局内存、常量内存、纹理内存等。&lt;/li&gt;
&lt;li&gt;设备（device）：设备是指GPU本身，包括多个流式处理器（SM）、多个CUDA核心（core）、多个缓存、总线等。&lt;/li&gt;
&lt;li&gt;主机（host）：主机是指CPU本身，包括内存、硬盘、键盘、鼠标等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CUDA编程模型的执行流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在主机端编写并行代码，称为核函数（kernel），并使用&lt;code&gt;__global__&lt;/code&gt;修饰符标记。&lt;/li&gt;
&lt;li&gt;在主机端调用核函数，并使用&lt;code&gt;&amp;lt;&amp;lt;&amp;lt; grid,block &amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;语法指定网格和块的维度，称为执行配置。&lt;/li&gt;
&lt;li&gt;在设备端执行核函数，每个块被分配到一个SM上，每个线程被分配到一个core上。&lt;/li&gt;
&lt;li&gt;在设备端完成核函数后，返回主机端继续执行后续代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2级架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个GPU拥有多个Streaming Multiprocessor(SM)
&lt;ul&gt;
&lt;li&gt;具体数目及设计因产品而异&lt;/li&gt;
&lt;li&gt;SM共用显存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个SM拥有多个CUDA core
&lt;ul&gt;
&lt;li&gt;数目因产品而异&lt;/li&gt;
&lt;li&gt;Core共用调度器和指令缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2级架构下的执行模型：线程束（warp）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CUDA线程以32个为一组在GPU上执行
&lt;ul&gt;
&lt;li&gt;线程束以单指令多线程的方式运行（SIMT）
&lt;ul&gt;
&lt;li&gt;所有线程在不同数据上执行相同的指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SMIT、SIMD、SMT
&lt;ul&gt;
&lt;li&gt;灵活度：SIMD &amp;lt; SIMT &amp;lt; SMT&lt;/li&gt;
&lt;li&gt;性能： SIMD &amp;gt; SIMT &amp;gt; SMT&lt;/li&gt;
&lt;li&gt;SIMT与SIMD相比：多个状态寄存器，多个地址，独立的执行路径&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SM负责调度并执行线程束
&lt;ul&gt;
&lt;li&gt;线程束调度时会产生上下文切换&lt;/li&gt;
&lt;li&gt;调度方式因架构而异&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Host与device&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Host（CPU）相关：运行在CPU上的代码及主机内存&lt;/li&gt;
&lt;li&gt;Device（GPU）相关：运行在GPU上的代码及显存（设备内存）&lt;/li&gt;
&lt;li&gt;通过在主机上调用核函数（kernel）执行并行代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指明host与device代码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__host__&lt;/code&gt;从主机端调用，在主机端执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__global__&lt;/code&gt;从主机端调用，在设备端执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__device__&lt;/code&gt;从设备端调用，在设备端执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__host__&lt;/code&gt;和&lt;code&gt;__device__&lt;/code&gt;可以一起使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt; 1,4 &amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;：执行配置
&lt;ul&gt;
&lt;li&gt;指明网格中有1个块&lt;/li&gt;
&lt;li&gt;每块中有4个线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cudaDeviceSynchronize()
&lt;ul&gt;
&lt;li&gt;与OpenMP不同，CUDA核函数为异步执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;核函数限制条件（&lt;code&gt;__global__&lt;/code&gt;函数）
&lt;ul&gt;
&lt;li&gt;只能访问设备内存&lt;/li&gt;
&lt;li&gt;必须返回void&lt;/li&gt;
&lt;li&gt;不支持可变数量的参数&lt;/li&gt;
&lt;li&gt;参数不可为引用类型&lt;/li&gt;
&lt;li&gt;不支持静态变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指明网格及块的维度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;形式为&lt;code&gt;&amp;lt;&amp;lt;&amp;lt; grid,block &amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;grid与block为dim3类型&lt;/li&gt;
&lt;li&gt;grid与block的大小受到计算能力的限制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/grid-of-thread-blocks.png&#34; alt=&#34;grid-of-thread-blocks&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GPU架构与线程执行
&lt;ul&gt;
&lt;li&gt;一个CUDA core执行一个线程&lt;/li&gt;
&lt;li&gt;一个SM执行一个block中的线程&lt;/li&gt;
&lt;li&gt;GPU中执行grid中的所有线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;确定线程编号
&lt;ul&gt;
&lt;li&gt;使用内置变量threadIdx、blockIdx、blockDim&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CUDA编程例子：向量加法
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;__global__&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;VecAdd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;blockIdx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Kernel invocation with N threads
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;VecAdd&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GPU内存管理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建：cudaMalloc&lt;/li&gt;
&lt;li&gt;拷贝：cudaMemcpy
&lt;ul&gt;
&lt;li&gt;使用cudaMemcpyHostToDevice与cudaMemcpyDeviceToHost指明拷贝方向&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;释放：cudaFree&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理错误&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用宏定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;block中最大线程限制：n必须不大于1024&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一个block只在一个SM上执行：没有充分利用GPU计算资源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;思路：使用多个block&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个block使用m个thread（如m=32）&lt;/li&gt;
&lt;li&gt;grid,block设置：&lt;code&gt;&amp;lt;&amp;lt;&amp;lt; n/m, m &amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;n无法被m整除？&lt;/li&gt;
&lt;li&gt;需对n/m向上取整&lt;/li&gt;
&lt;li&gt;需判断tid是否会超过范围&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;确定thread的全局编号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;五cuda线程执行模型&#34;&gt;五、CUDA线程执行模型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;逻辑视图
&lt;ul&gt;
&lt;li&gt;每个线程块由一个SM执行&lt;/li&gt;
&lt;li&gt;由硬件调度&lt;/li&gt;
&lt;li&gt;无法控制线程块的执行顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;硬件视图
&lt;ul&gt;
&lt;li&gt;所有线程块在硬件上都是一维的&lt;/li&gt;
&lt;li&gt;三维线程将沿x-&amp;gt;y-&amp;gt;z的顺序展开到一维&lt;/li&gt;
&lt;li&gt;展开后的一维线程每32个形成一个线程束
&lt;ul&gt;
&lt;li&gt;最后不足32的部分也将创建线程
&lt;ul&gt;
&lt;li&gt;不活跃&lt;/li&gt;
&lt;li&gt;仍将消耗SM资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程束调度
&lt;ul&gt;
&lt;li&gt;线程束切换开销为0
&lt;ul&gt;
&lt;li&gt;SM保存每个线程束的执行上下文&lt;/li&gt;
&lt;li&gt;在整个线程束的生命周期中保存于芯片内&lt;/li&gt;
&lt;li&gt;上下文切换没有损失&lt;/li&gt;
&lt;li&gt;可切换同一SM上不同线程块的线程束&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SM中常驻线程块数量受可用资源限制
&lt;ul&gt;
&lt;li&gt;资源：程序计数器、寄存器、共享内存&lt;/li&gt;
&lt;li&gt;活跃线程束：具备计算资源的线程束
&lt;ul&gt;
&lt;li&gt;Kepler上最大为64&lt;/li&gt;
&lt;li&gt;选定的线程束：被调度到执行单元的线程束（Kepler上最大为4）&lt;/li&gt;
&lt;li&gt;符合条件的线程束：准备执行但尚未执行&lt;/li&gt;
&lt;li&gt;阻塞的线程束：没做好执行准备（指令参数未就绪，无可用CUDA core）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;活跃线程束于延迟隐藏
&lt;ul&gt;
&lt;li&gt;满载：线程调度器在每个时钟周期都有符合条件的线程束&lt;/li&gt;
&lt;li&gt;通过调度符合条件的线程束，可以有效的掩盖指令延迟
&lt;ul&gt;
&lt;li&gt;算数指令：算数操作从开始到产生输出（10~20时钟周期）&lt;/li&gt;
&lt;li&gt;内存指令：发出加载/存储操作到数据到达目的地（全局内存~800时钟周期）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应适当增加活跃线程束
&lt;ul&gt;
&lt;li&gt;Little&amp;rsquo;s law&lt;/li&gt;
&lt;li&gt;线程数不宜过少（每个线程处理的任务数与线程数需要平衡）&lt;/li&gt;
&lt;li&gt;线程块资源不易过多（如，共享内存的大小与活跃线程块数量需要平衡）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程束执行
&lt;ul&gt;
&lt;li&gt;每个线程束以SIMD方式在SM上执行
&lt;ul&gt;
&lt;li&gt;线程束内同时执行同样语句&lt;/li&gt;
&lt;li&gt;线程束外的视角看来为SIMT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分支分化
&lt;ul&gt;
&lt;li&gt;线程束出现不同的控制流&lt;/li&gt;
&lt;li&gt;性能优化：避免分支分化，因为线程束只能执行相同的逻辑，在执行某一个路径的线程时会禁用另一路径的线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;busy waiting vs signal
&lt;ul&gt;
&lt;li&gt;busy waiting：如，使用while循环不断检查条件是否满足&lt;/li&gt;
&lt;li&gt;signal：当条件满足由系统发送指令
&lt;ul&gt;
&lt;li&gt;__syncthreads()：只能在线程块内同步，不能在不同的线程块同步&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;busy waiting的问题：死锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;减少分支分化的影响
&lt;ul&gt;
&lt;li&gt;减少if语句
&lt;ul&gt;
&lt;li&gt;尤其是减少基于threadIdx的if语句&lt;/li&gt;
&lt;li&gt;使用条件赋值代替条件语句&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;平衡分支执行时间
&lt;ul&gt;
&lt;li&gt;避免出现执行时间过长的分支&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;六cuda原子操作&#34;&gt;六、CUDA原子操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;原子指令
&lt;ul&gt;
&lt;li&gt;执行过程不能分解为更小的部分：不被中断&lt;/li&gt;
&lt;li&gt;避免竞争条件出现&lt;/li&gt;
&lt;li&gt;竞争条件
&lt;ul&gt;
&lt;li&gt;程序运行结果依赖于不可控的执行顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CUDA原子操作：
&lt;ul&gt;
&lt;li&gt;基本操作：atomicCAS
&lt;ul&gt;
&lt;li&gt;其它所有原子操作均可由atomicCAS()实现&lt;/li&gt;
&lt;li&gt;CAS：compare and swap
&lt;ul&gt;
&lt;li&gt;读取目标位置(address)并与预期值(old_val)进行比较
&lt;ul&gt;
&lt;li&gt;相等则将new_val写入目标位置&lt;/li&gt;
&lt;li&gt;不相等则不发生变化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;返回目标位置中原值：可用来检查CAS操作是否成功&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;原子指令与并发控制：原子指令在并发控制中起着重要的作用。在多线程或多进程的环境中，当多个线程或进程尝试同时访问和修改共享数据时，如果没有适当的控制机制，可能会导致数据的不一致性。原子指令通过确保某些操作在执行过程中不会被其他线程或进程中断，来避免这种情况。&lt;/li&gt;
&lt;li&gt;竞争条件与死锁：竞争条件是并发编程中的一个主要问题，它发生在两个或更多的线程或进程在无序或未同步的情况下访问和修改共享数据，导致结果不可预测。原子指令是解决竞争条件的一种方法，但也可能引入另一个问题 - 死锁。死锁是指两个或更多的进程或线程互相等待对方释放资源，导致所有进程或线程都无法继续执行。&lt;/li&gt;
&lt;li&gt;CUDA原子操作与GPU编程：在GPU编程中，由于大量的线程并行执行，可能会有多个线程同时访问和修改同一块内存。CUDA的原子操作提供了一种机制，使得在这种情况下仍能保证数据的一致性。然而，过度依赖原子操作可能会导致性能下降，因为它们违反了GPU编程的基本原则——并行执行。因此，在设计GPU算法时，应尽量减少原子操作的使用，或者寻找可以避免使用原子操作的算法。&lt;/li&gt;
&lt;li&gt;CUDA原子操作的应用：在某些情况下，CUDA原子操作是必要的。例如，在统计或计数问题中，需要多个线程共享一个计数器，并且每个线程都可能需要增加计数器的值。在这种情况下，使用CUDA原子操作可以保证计数器的正确性。另一个例子是图形处理，其中可能需要多个线程同时更新像素的值。使用CUDA原子操作可以避免同时更新导致的数据不一致问题。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>SVD与NMF：矩阵分解的两种方法</title>
        <link>https://cuterwrite.top/p/matrix-factorization/</link>
        <pubDate>Tue, 11 Jul 2023 00:00:00 +0000</pubDate>
        
        <guid>https://cuterwrite.top/p/matrix-factorization/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/65cf6588fa725014c7cd617ccbeb997f27742e49.jpg@1256w_1880h_!web-article-pic.jpg" alt="Featured image of post SVD与NMF：矩阵分解的两种方法" /&gt;&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;  &lt;em&gt;generated with &lt;a class=&#34;link&#34; href=&#34;https://github.com/thlorenz/doctoc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;DocToc&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#svd%E4%B8%8Enmf%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95&#34; &gt;SVD与NMF：矩阵分解的两种方法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%E4%B8%80%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3svd&#34; &gt;一、奇异值分解（SVD）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%E4%BA%8C%E9%9D%9E%E8%B4%9F%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3nmf&#34; &gt;二、非负矩阵分解（NMF）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%E4%B8%89svd%E4%B8%8Enmf%E7%9A%84%E6%AF%94%E8%BE%83&#34; &gt;三、SVD与NMF的比较&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%E5%9B%9B%E5%AE%9E%E6%88%98%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9&#34; &gt;四、实战：图像压缩&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%E4%BA%94%E7%BB%93%E8%AE%BA&#34; &gt;五、结论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99&#34; &gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;svd与nmf矩阵分解的两种方法&#34;&gt;SVD与NMF：矩阵分解的两种方法&lt;/h1&gt;
&lt;p&gt;在数据科学中，矩阵分解技术是一种强大的工具，可以用于各种应用，如推荐系统、图像处理和自然语言处理。在这篇文章中，我们将深入探讨两种流行的矩阵分解技术：奇异值分解（SVD）和非负矩阵分解（NMF）。我们将详细解析它们的理论基础，以及如何在实际问题中应用它们。&lt;/p&gt;
&lt;h2 id=&#34;一奇异值分解svd&#34;&gt;一、奇异值分解（SVD）&lt;/h2&gt;
&lt;p&gt;奇异值分解是一种在线性代数中常用的矩阵分解方法。对于给定的 $m\times n$ 矩阵A，我们可以将其分解为三个矩阵的乘积：&lt;/p&gt;
&lt;p&gt;$$
A = U\Sigma V^T
$$&lt;/p&gt;
&lt;p&gt;这里，$U$ 是一个 $m\times m$ 的正交矩阵，$V$ 是一个 $n\times n$ 的正交矩阵，$\Sigma$ 是一个 $m\times n$ 的对角矩阵。对角线上的元素称为奇异值，它们是 $A^T A$ 的特征值的平方根。它们是按降序排列的，代表了原始矩阵中的“能量”或信息量。。我们可以将奇异值分解看作是一种特征值分解，其中 $U$ 和 $V$ 是特征向量，$\Sigma$ 是特征值的对角矩阵。&lt;/p&gt;
&lt;p&gt;计算SVD的基本步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;构造矩阵A的Gram矩阵&lt;!-- raw HTML omitted --&gt;：对于给定的 $m\times n$ 矩阵A，我们可以构造一个 $n\times n$ 的矩阵 $A^T A$，称为A的Gram矩阵。Gram矩阵是一个对称半正定矩阵，因此它的特征值都是非负的。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;计算Gram矩阵的特征值和特征向量&lt;!-- raw HTML omitted --&gt;：我们可以使用任何标准的特征值分解算法来计算Gram矩阵的特征值和特征向量。这些特征值就是A的奇异值的平方，特征向量则构成了右奇异向量和左奇异向量。我们将特征值按降序排列，将特征向量按相同的顺序排列。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;构造奇异值矩阵 $\Sigma$ &lt;!-- raw HTML omitted --&gt;：我将特征值的平方根按照从大到小的顺序排列在对角线上，构成 $m\times n $ 的对角矩阵 $\Sigma$ 。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;构造左奇异向量矩阵 $U$ 和右奇异向量矩阵 $V$ &lt;!-- raw HTML omitted --&gt;：将对应于特征值的特征向量按照特征值的顺序排列，构成 $n\times n$ 的矩阵 $V$ 和 $m\times m$ 的矩阵 $U$ 。这些特征向量是标准化的，即它们的长度为1，并且互相正交。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样，我们就得到了A的奇异值分解。在Python中，我们可以使用NumPy的&lt;code&gt;np.linalg.svd&lt;/code&gt;函数来计算SVD，这个函数会自动执行上述步骤，并返回 $ U, \Sigma, V^T $ 。如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;numpy&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;np&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;linalg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;svd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要注意的是，虽然理论上SVD总是存在的，但在实际计算中可能会遇到数值稳定性的问题。此外，对于非常大的矩阵，计算SVD可能会非常耗时。在这些情况下，我们可能需要使用一些更高效的算法或者近似方法，如随机SVD。&lt;/p&gt;
&lt;p&gt;SVD的一个重要应用是在推荐系统中进行矩阵补全。在推荐系统中，我们通常有一个用户-商品评分矩阵，但这个矩阵通常是非常稀疏的，因为大多数用户只评价了少数商品。SVD可以用于预测用户对未评价商品的评分，从而提供个性化的推荐。&lt;/p&gt;
&lt;h2 id=&#34;二非负矩阵分解nmf&#34;&gt;二、非负矩阵分解（NMF）&lt;/h2&gt;
&lt;p&gt;由于维度的复杂性和维度诅咒，直接处理高维数据需要大量的计算资源。非负矩阵分解（NMF）作为一种降维技术被提出，在图像处理中得到了重要的应用。通过采用NMF，非负的高维矩阵可以被分解成两个非负的低维矩阵，其中一个包括列向量，可以被视为数据空间中的基向量，另一个则包含缩放这些基向量的系数行。此外，NMF也可用于文本数据处理。我们可以检查系数矩阵中的每一列，并确定具有最大系数的行号，其中行号表示原始矩阵中各列的聚类ID。这种聚类特性意味着NMF可以用于数据聚类。&lt;/p&gt;
&lt;p&gt;NMF对矩阵的元素有一个额外的非负约束。对于给定的 $K\times N$ 非负矩阵 $M\in R^{K\times N}$ ，我们可以找到两个非负矩阵 $W$ 和 $H$ ，使得 $M\approx WH$ 。其中 $W\in R^{K\times r}$ 和 $H\in R^{r\times N}$ 是两个非负矩阵，即 $W\geq 0$ 和 $H\geq 0$ 。矩阵 $W$ 代表捕捉数据特征的基向量，而矩阵 $H$ 是表示每个基向量对重建原始数据的贡献的权重。NMF中的非负约束允许学习整体数据的部分表征，而这种约束在SVD中是不允许的。为了找到 $M\approx WH$的近似解，定义基于欧氏距离的成本函数来量化近似的质量，即:&lt;/p&gt;
&lt;p&gt;$$
Q=\Vert M-WH\Vert^2_F=\sum_{i,j}(M_{ij}-(WH)_{ij})^2
$$&lt;/p&gt;
&lt;p&gt;由于成本函数 $Q$ 在 $W$ 和 $H$ 中都是非凸的，所以在求解 $Q$ 的最小值过程中找到全局最小值是不现实的。一些数值优化技术，如梯度下降和共轭梯度，可以被用来寻找局部最小值。然而，梯度下降的收敛速度很慢，共轭梯度的实现很复杂。此外，基于梯度的方法对步长的参数设置很敏感，这对现实应用来说并不方便。为此，可以利用 $W$ 和 $H$ 的multiplicative update rules，作为收敛速度和实现复杂性之间的折中方案，具体如下:&lt;/p&gt;
&lt;p&gt;$$
H_{aj} \leftarrow H_{aj} \frac{W^T M_{aj}}{W^T W H_{aj}}, W_{ia} \leftarrow W_{ia} \frac{M H^T_{ia}}{W H H^T_{ia}}
$$&lt;/p&gt;
&lt;p&gt;其中，矩阵 $W$ 和 $H$ 可以被随机初始化，然后通过迭代更新来优化 $Q$ 。这些更新规则可以保证 $Q$ 在每次迭代中都会减少，因此可以保证收敛到局部最小值。&lt;/p&gt;
&lt;p&gt;在Python中，我们可以使用&lt;code&gt;sklearn.decomposition.NMF&lt;/code&gt;类来计算NMF。如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sklearn.decomposition&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NMF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;model&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NMF&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n_components&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;random&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;random_state&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;W&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;model&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fit_transform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;H&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;model&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;components_&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;三svd与nmf的比较&#34;&gt;三、SVD与NMF的比较&lt;/h2&gt;
&lt;p&gt;虽然SVD和NMF都是矩阵分解技术，但它们有一些重要的区别。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;数据类型和约束&lt;!-- raw HTML omitted --&gt;：SVD可以应用于任何矩阵，而NMF只能应用于非负矩阵。其次，SVD提供了一种最优的低秩近似，而NMF则没有这种保证。然而，NMF的非负约束使得它的分解更具解释性，这在许多应用中是非常有用的。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;分解的解释性&lt;!-- raw HTML omitted --&gt;：虽然SVD和NMF都可以将原始矩阵分解为一些基本的“构成元素”，但NMF的分解通常更具解释性。这是因为NMF的非负约束使得分解的结果更容易解释和理解。在许多应用中，如主题模型或社区发现，NMF的分解可以直接解释为数据的一些基本模式或特征。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;优化和稳定性&lt;!-- raw HTML omitted --&gt;：SVD的优化问题有闭式解，这意味着我们可以直接计算出最优解。而NMF的优化问题通常需要使用迭代方法来求解，如梯度下降或坐标下降。这使得NMF的计算过程可能更复杂，而且可能需要更多的时间。而且SVD的结果是唯一的（除了奇异向量的符号），而NMF的结果可能依赖于初始化和优化算法。这意味着对同一个数据集，NMF可能会给出不同的结果。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;近似质量&lt;!-- raw HTML omitted --&gt;：SVD提供了一种最优的低秩近似，即它可以找到最接近原始矩阵的低秩矩阵。而NMF则没有这种保证，它的近似质量可能会比SVD差。然而，NMF的非负约束使得它的近似可能更符合实际的需求，尤其是在那些原始数据是非负的情况下。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;计算复杂性&lt;!-- raw HTML omitted --&gt;：SVD和NMF的计算复杂性也有所不同。对于一个 $m\times n$ 的矩阵，SVD的计算复杂性大约为 $\mathbf{O}(\min {m^2n, mn^2})$ ，而NMF的计算复杂性则取决于迭代次数和所选的优化算法。在实践中，NMF通常比SVD更慢，但也有一些高效的NMF算法可以缩短计算时间。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总的来说，SVD和NMF各有优势，选择使用哪一种技术取决于具体的应用和需求。&lt;/p&gt;
&lt;h2 id=&#34;四实战图像压缩&#34;&gt;四、实战：图像压缩&lt;/h2&gt;
&lt;p&gt;让我们通过一个实战演示来看看如何使用SVD和NMF进行图像压缩。我们将使用Python的NumPy和scikit-learn库来执行这些任务。&lt;/p&gt;
&lt;p&gt;首先，我们需要导入必要的库，并加载一张图像：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;numpy&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;np&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sklearn.decomposition&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NMF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;PIL&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Image&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 加载图像&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Image&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;image.jpg&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;height&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;img&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;array&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;img&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;img&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;img&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;img_matrix&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;img_matrix&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;extend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flatten&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flatten&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flatten&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;M&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;array&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;img_matrix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后，我们可以使用NumPy的&lt;code&gt;np.linalg.svd&lt;/code&gt;函数来进行SVD，得到 $U, S, V^T$ ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 执行SVD&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;linalg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;svd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;full_matrices&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;False&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以选择前 $r$ 个奇异值和对应的 $U$ 和 $V^T$ 的列来进行低秩近似：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;U_d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;s_d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Vt_d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;M_d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;U_d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;@&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;diag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s_d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;@&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vt_d&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;M_d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;M_d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;M_d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dstack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reshape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;255&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;255&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Image&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fromarray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uint8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;RGB&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同样，我们也可以使用scikit-learn的NMF类来进行NMF：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 执行NMF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;model&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NMF&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n_components&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;random&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;random_state&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;W&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;model&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fit_transform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;H&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;model&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;components_&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;M_d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;W&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;@&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;H&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;M_d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;M_d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;M_d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dstack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reshape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;255&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;255&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Image&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fromarray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uint8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;RGB&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;img&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，我们可以比较原始图像和重构图像的差异，以及SVD和NMF的压缩效果。这种压缩方法的优点是可以大大减少存储和传输图像所需的数据量，而且如果选择的秩r足够大，压缩后的图像的质量也可以接受。&lt;/p&gt;
&lt;h2 id=&#34;五结论&#34;&gt;五、结论&lt;/h2&gt;
&lt;p&gt;总的来说，SVD和NMF都是强大的矩阵分解技术，它们在许多数据科学应用中都有广泛的用途。虽然SVD提供了一种最优的低秩近似，但NMF的非负约束使得它的分解更具解释性。在选择使用哪一种技术时，我们需要考虑我们的具体需求，以及我们的数据是否满足这些技术的要求。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1] Lee, Daniel, and H. Sebastian Seung. &amp;ldquo;Unsupervised learning by convex and conic coding. &amp;quot; Advances in neural information processing systems 9 (1996).&lt;/p&gt;
&lt;p&gt;[2] Lee, Daniel D., and H. Sebastian Seung. &amp;ldquo;Learning the parts of objects by non-negative matrix factorization.&amp;rdquo; Nature 401.6755 (1999): 788-791.&lt;/p&gt;
&lt;p&gt;[3] Lee, Daniel, and H. Sebastian Seung. &amp;ldquo;Algorithms for non-negative matrix factorization. &amp;quot; Advances in neural information processing systems 13 (2000).&lt;/p&gt;
</description>
        </item>
        <item>
        <title>最小反馈弧集合问题</title>
        <link>https://cuterwrite.top/p/fas/</link>
        <pubDate>Tue, 11 Jul 2023 00:00:00 +0000</pubDate>
        
        <guid>https://cuterwrite.top/p/fas/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/20230711173143.png" alt="Featured image of post 最小反馈弧集合问题" /&gt;&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;  &lt;em&gt;generated with &lt;a class=&#34;link&#34; href=&#34;https://github.com/thlorenz/doctoc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;DocToc&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%E6%9C%80%E5%B0%8F%E5%8F%8D%E9%A6%88%E5%BC%A7%E9%9B%86%E5%90%88%E9%97%AE%E9%A2%98&#34; &gt;最小反馈弧集合问题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%E4%B8%80%E5%BC%95%E8%A8%80&#34; &gt;一、引言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%E4%BA%8C%E9%97%AE%E9%A2%98%E5%AE%9A%E4%B9%89&#34; &gt;二、问题定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%E4%B8%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&#34; &gt;三、解决方案&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#1-greedyfas&#34; &gt;1. GreedyFAS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#2-sortfas&#34; &gt;2. SortFAS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#3-pagerankfas&#34; &gt;3. PageRankFAS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%E5%9B%9B%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8&#34; &gt;四、实际应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;最小反馈弧集合问题&#34;&gt;最小反馈弧集合问题&lt;/h1&gt;
&lt;h2 id=&#34;一引言&#34;&gt;一、引言&lt;/h2&gt;
&lt;p&gt;在复杂网络分析、社会学、生物信息学等领域，我们经常需要处理的一个问题是如何从一个有向图中移除最少的边，使得图中不再存在环。这个问题被称为最小反馈弧集问题（Minimum Feedback Arc Set，简称MinFAS）。在本文中，我们将详细介绍这个问题的定义、性质，以及一些常见的解决算法。我们还将讨论这个问题在实际应用中的一些例子。&lt;/p&gt;
&lt;h2 id=&#34;二问题定义&#34;&gt;二、问题定义&lt;/h2&gt;
&lt;p&gt;首先，我们来详细定义一下最小反馈弧集问题。给定一个有向图G=(V, E)，其中V是顶点集，E是边集。给定有向图G(V,E)，集合F是E的一个子集，若G的生成子图G′(V,E−F)中不包含环，则称F是G的一个反馈弧集合。容易推出：若有向图G包含环，则其每个环至少有一条边在F中。我们将基数最小的反馈弧集合称为最小反馈弧集合。最小反馈弧集合问题就是在给定有向图G的情况下，求解最小反馈弧集合F。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230711173938.png&#34; alt=&#34;20230711173938&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如：$ F={(1, 2), (4, 5)} $&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230711174006.png&#34; alt=&#34;20230711174006&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;在这个问题中，我们的目标是找到最小的反馈弧集，也就是说，我们希望找到尽可能少的边，使得去掉这些边后图中不再有环。这个问题在许多实际应用中都有重要的意义。例如，在社会网络分析中，我们可以通过这个问题来找出社区内的关键人物；在生物信息学中，我们可以通过这个问题来找出基因调控网络中的关键基因。&lt;/p&gt;
&lt;p&gt;最小反馈弧集问题已经被证明是一个NP难问题。这意味着，我们无法在多项式时间内找到这个问题的精确解（除非P=NP）。然而，尽管这个问题很难，但是我们仍然可以通过一些方法来找到它的近似解。在理论计算机科学中，有一类算法被称为近似算法，它们可以在多项式时间内找到问题的近似解。对于最小反馈弧集问题，我们也可以使用这类算法来求解。在接下来的部分中，我们将介绍一些常见的近似算法。&lt;/p&gt;
&lt;h2 id=&#34;三解决方案&#34;&gt;三、解决方案&lt;/h2&gt;
&lt;p&gt;对于最小反馈弧集问题，我们有多种解决方案，其中包括贪心算法（GreedyFAS）、排序算法（SortFAS）和基于PageRank的算法（PageRankFAS）。&lt;/p&gt;
&lt;h3 id=&#34;1-greedyfas&#34;&gt;1. GreedyFAS&lt;/h3&gt;
&lt;p&gt;GreedyFAS算法的核心思想在于用贪心法生成一个线性排列，将该线性排列中的后向边集作为结果返回。该算法的伪代码如下图所示：
&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/20230711172920.png&#34; alt=&#34;20230711172920&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;对任一有向图G，GreedyFAS算法使用的贪心策略为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查找源头点（入度为0的点）。若查到源头点则排在序列 $s_1$ 末尾并移除该点，重复直到 $G$ 无源头点。&lt;/li&gt;
&lt;li&gt;查找汇集点（出度为0的点）。若查到汇集点则排在序列 $s_2$ 首部并移除该点，重复直到 $G$ 无汇集点。&lt;/li&gt;
&lt;li&gt;计算剩余点的 $\delta$ 值（出度与入度的差值），将 $\delta$ 值最大的点排在 $s_1$ 末尾并移除该点。&lt;/li&gt;
&lt;li&gt;重复上述过程直到 $G$ 不存在任何点。&lt;/li&gt;
&lt;li&gt;返回序列 $s_1 s_2$ 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-sortfas&#34;&gt;2. SortFAS&lt;/h3&gt;
&lt;p&gt;SortFAS算法的基本思想是该算法根据序号的自然顺序生成初始最小线性排列问题（LA），不断调整LA使后向边的数量尽可能少。该算法的伪代码如下图所示：
&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/SortFAS.png&#34; alt=&#34;SortFAS&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;对任一有向图G，SortFAS算法的步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成初始最小线性排列问题（LA）。&lt;/li&gt;
&lt;li&gt;对于LA中的每个序号v，记录全局变量val，初始化为0，表示调整后新增的后向边数。记录v的位置loc。记录最小值min=0
&lt;ul&gt;
&lt;li&gt;从序号loc-1开始，向前遍历LA得到序号w，若v-&amp;gt;w存在则val&amp;ndash;，否则val++。&lt;/li&gt;
&lt;li&gt;如果val小于等于min，则赋值min=val，记录位置loc=w&lt;/li&gt;
&lt;li&gt;在位置loc插入序号v&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-pagerankfas&#34;&gt;3. PageRankFAS&lt;/h3&gt;
&lt;p&gt;PageRankFAS算法的核心思想在于将原始图的强连通分量转换为线图，然后用PageRank算法评估线图中节点的重要性，然后依次删除线图中PageRank值最高的节点对应的边。该算法的伪代码如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/PageRankFAS.png&#34; alt=&#34;PageRankFAS&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;对任一有向图G，PageRankFAS的算法步骤如下：&lt;/p&gt;
&lt;p&gt;检测图是否有环，如果存在环，执行以下循环：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;识别有向图中的强连接分量 $s_i, i=0,1,\cdots$&lt;/li&gt;
&lt;li&gt;遍历强连通分量 $s_i$ ，对于每个强连通分量 $s_i$ ，执行：
&lt;ul&gt;
&lt;li&gt;如果 $s-i$ 的大小小于等于1，跳过该强连通分量的处理。&lt;/li&gt;
&lt;li&gt;选择 $s_i$ 中的一个随机节点 $v$ ，从 $v$ 开始遍历创建 $s_i$ 的线图 $L(s_i)$&lt;/li&gt;
&lt;li&gt;计算 $L(s_i)$ 的PageRank值。&lt;/li&gt;
&lt;li&gt;选择 $L(s_i)$ 中PageRank值最大的节点，找到 $s_i$ 中对应的边 $e$ ，添加到最小反馈弧集。&lt;/li&gt;
&lt;li&gt;在 $G$ 中删除边 $e$ 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果仍有环，重复执行1和2，直到图不存在环为止。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;四实际应用&#34;&gt;四、实际应用&lt;/h2&gt;
&lt;p&gt;最小反馈弧集问题在许多领域都有广泛的应用。例如，在生物信息学中，我们可以通过求解最小反馈弧集问题，来找出基因调控网络中的关键基因。在这种情况下，我们通常将基因调控网络表示为一个有向图，其中的顶点代表基因，边代表基因之间的调控关系。然后，我们可以通过求解最小反馈弧集问题，来找出那些对整个网络有重要影响的基因。&lt;/p&gt;
&lt;p&gt;在社会网络分析中，我们可以通过求解最小反馈弧集问题，来检测社区内的关键人物。在这种情况下，我们通常将社区表示为一个有向图，其中的顶点代表人，边代表人之间的关系。然后，我们可以通过求解最小反馈弧集问题，来找出那些对整个社区有重要影响的人。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>RDMA：Soft-RoCE环境搭建实验</title>
        <link>https://cuterwrite.top/p/soft-roce/</link>
        <pubDate>Sat, 11 Feb 2023 00:00:00 +0000</pubDate>
        
        <guid>https://cuterwrite.top/p/soft-roce/</guid>
        <description>&lt;img src="https://cuterwrite-1302252842.file.myqcloud.com/img/86.png" alt="Featured image of post RDMA：Soft-RoCE环境搭建实验" /&gt;&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;  &lt;em&gt;generated with &lt;a class=&#34;link&#34; href=&#34;https://github.com/thlorenz/doctoc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;DocToc&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#rdma-soft-roce%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%AE%9E%E9%AA%8C&#34; &gt;RDMA: Soft-RoCE环境搭建实验&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#1-roce%E7%AE%80%E4%BB%8B&#34; &gt;1. RoCE简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#2-roce%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%B1%82%E6%AC%A1&#34; &gt;2. RoCE的协议层次&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#3-roce%E7%9A%84%E4%BC%98%E5%8A%BF&#34; &gt;3. RoCE的优势&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#4-soft-roce&#34; &gt;4. Soft-RoCE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#5-%E9%83%A8%E7%BD%B2%E5%AE%9E%E9%AA%8C&#34; &gt;5. 部署实验&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#51-%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83&#34; &gt;5.1. 实验环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#52-%E9%83%A8%E7%BD%B2rdma%E8%BD%AF%E4%BB%B6%E6%A0%88&#34; &gt;5.2. 部署RDMA软件栈&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#521-%E7%A1%AE%E8%AE%A4%E5%BD%93%E5%89%8D%E5%86%85%E6%A0%B8%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81rxe&#34; &gt;5.2.1. 确认当前内核是否支持RXE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#522-%E5%AE%89%E8%A3%85%E7%94%A8%E6%88%B7%E6%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93&#34; &gt;5.2.2. 安装用户态动态链接库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#523-%E5%AE%89%E8%A3%85iproute2%E5%92%8Cperftest&#34; &gt;5.2.3. 安装iproute2和perftest&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#53-%E9%85%8D%E7%BD%AErxe%E7%BD%91%E5%8D%A1&#34; &gt;5.3. 配置RXE网卡&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#54-%E6%89%A7%E8%A1%8Cperftest%E6%B5%8B%E8%AF%95&#34; &gt;5.4. 执行perftest测试&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;rdma-soft-roce环境搭建实验&#34;&gt;RDMA: Soft-RoCE环境搭建实验&lt;/h1&gt;
&lt;h2 id=&#34;1-roce简介&#34;&gt;1. RoCE简介&lt;/h2&gt;
&lt;p&gt;RoCE是三大RDMA协议之一，全称为RDMA Over Converged Ethernet，即基于融合以太网的RDMA。它是一种基于传统以太网的部分下层协议，在其基础上实现InfiniBand的部分上层协议。&lt;/p&gt;
&lt;p&gt;RoCE的发展历史如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1999年，由Compaq, Dell, HP, IBM, Intel, Microsoft和Sun公司组成了IBTA组织。愿景是&lt;strong&gt;设计一种更高速的新的互联协议规范标准，来应对传统以太网在面对未来计算机行业的发展时可能遇到的瓶颈&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2000年，IBTA组织设计并发布了Infiniband Architecture Specification 1.0（IB规范）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2007年，IETF发布了iWARP（Internet Wide Area RDMA Protocol）的一系列RFC。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2010年，IBTA发布了RoCE v1规范。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2014年，IBTA发布了RoCE v2规范。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-roce的协议层次&#34;&gt;2. RoCE的协议层次&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/v2-106078a152d4926ac8234022bd629c79_1440w.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/v2-17e04efb14c550ad0be456b7b71209b4_1440w.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;首先是二层的以太网链路帧，然后是IP报文头和UDP报文头，最后是各层级协议的校验。而Infiniband传输层报文实际上是UDP层的负载，也就是深蓝色背景的部分。UDP报文头中有一个字段Destination Port Number（目的端口号），对于RoCE v2来说固定是4791，当对端网卡收到报文后，会根据该字段识别是普通的以太网数据包，还是RoCE数据包，或者是其他协议的数据包，然后再进行解析。深蓝色背景的IB传输层部分又分成了IB报头，实际的用户数据（Payload）以及校验部分。&lt;/p&gt;
&lt;h2 id=&#34;3-roce的优势&#34;&gt;3. RoCE的优势&lt;/h2&gt;
&lt;p&gt;为什么我们有了Infiniband协议之后，还要设计RoCE协议呢？最主要的原因还是成本问题：由于Infiniband协议本身定义了一套全新的层次架构，从链路层到传输层，都无法与现有的以太网设备兼容。也就是说，如果某个数据中心因为性能瓶颈，想要把数据交换方式从以太网切换到Infiniband技术，那么需要购买全套的Infiniband设备，包括网卡、线缆、交换机和路由器等等。商用级设备由于对可靠性有比较高的要求，所以这一套下来是非常昂贵的。&lt;/p&gt;
&lt;p&gt;而RoCE协议的出现解决了这一问题，如果用户想要从以太网切换到RoCE，那么只需要购买支持RoCE的网卡就可以了，线缆、交换机和路由器（RoCE v1不支持以太网路由器）等网络设备都是兼容的——因为我们只是在以太网传输层基础上又定义了一套协议而已。&lt;/p&gt;
&lt;p&gt;所以RoCE相比于Infiniband，主要还是省钱，当然性能上相比Infiniband还是有一些损失，毕竟人家是全套重新设计的。&lt;/p&gt;
&lt;p&gt;至于iWARP，相比于RoCE协议栈更复杂，并且由于TCP的限制，只能支持可靠传输，即无法支持UD等传输类型。所以目前iWARP的发展并不如RoCE和Infiniband。&lt;/p&gt;
&lt;h2 id=&#34;4-soft-roce&#34;&gt;4. Soft-RoCE&lt;/h2&gt;
&lt;p&gt;虽然RoCE相比Infiniband具有兼容性优势，价格也便宜，但是&lt;strong&gt;实际应用&lt;/strong&gt;的时候&lt;strong&gt;依然需要专用的网卡支持&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;RoCE本身确实可以由软件实现，也就是本节即将介绍的Soft-RoCE，但是商用的时候，几乎不会有人用软件实现的RoCE。RDMA技术本身的一大特点就是“硬件卸载”，即把本来软件（CPU）做的事情放到硬件中实现以达到加速的目的。CPU主要是用来计算的，让它去处理协议封包和解析以及搬运数据，这是对计算资源的浪费。所以RoCE网卡会把TCP/IP协议栈放到硬件中实现以解放CPU，让它去做更重要的事。&lt;/p&gt;
&lt;p&gt;我们说回Soft-RoCE，它由IBM和Mellanox牵头的IBTA RoCE工作组实现。本身的设计初衷有几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;降低RoCE部署成本：Soft-RoCE可以使不具备RoCE能力的硬件和支持RoCE的硬件间进行基于IB语义的交流，这样可以免于替换网络中的一些非关键节点的旧型号网卡。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相比TCP提升性能：虽然软件实现IB传输层带来了一定的开销，但是相比基于Socket-TCP/IP的传统通信方式，Soft-RoCE因为减少了系统调用（只在软件通知硬件下发了新SQ WQE时才会使用系统调用），发送端的零拷贝以及接收端的只需要单次拷贝等原因，仍然带来了性能上的提升。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;便于开发和测试RDMA程序：有了Soft-RoCE，我们基于Verbs API编写的程序，就可以不依赖于硬件执行起来，可以很方便地运行程序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Soft-RoCE就是把本来应该卸载到硬件的封包和解析工作，又拿到软件来做。其本身是基于Linux内核的TCP/IP协议栈实现的，网卡本身并不感知收发的数据包是RoCE报文，其驱动程序按照IB规范中的报文格式将用户数据封装成IB传输层报文，然后把报文整体当做数据填入Socket Buffer当中，由网卡进行下一步收发包处理。&lt;/p&gt;
&lt;h2 id=&#34;5-部署实验&#34;&gt;5. 部署实验&lt;/h2&gt;
&lt;h3 id=&#34;51-实验环境&#34;&gt;5.1. 实验环境&lt;/h3&gt;
&lt;p&gt;本实验主要使用Ubuntu 20.04 64位作为系统环境，采用2台2核4GB云服务器作为Soft-RoCE的部署环境，&lt;/p&gt;
&lt;h3 id=&#34;52-部署rdma软件栈&#34;&gt;5.2. 部署RDMA软件栈&lt;/h3&gt;
&lt;h4 id=&#34;521-确认当前内核是否支持rxe&#34;&gt;5.2.1. 确认当前内核是否支持RXE&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cat /boot/config-&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;uname -r&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep RXE
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果CONFIG_RDMA_RXE的值为y或者m，表示当前的操作系统可以使用RXE。&lt;/p&gt;
&lt;h4 id=&#34;522-安装用户态动态链接库&#34;&gt;5.2.2. 安装用户态动态链接库&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install libibverbs1 ibverbs-utils librdmacm1 libibumad3 ibverbs-providers rdma-core
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这几个软件包的作用如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;软件包名&lt;/th&gt;
&lt;th&gt;主要功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;libibverbs1&lt;/td&gt;
&lt;td&gt;ibverbs动态链接库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ibverbs-utils&lt;/td&gt;
&lt;td&gt;ibverbs示例程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;librdmacm1&lt;/td&gt;
&lt;td&gt;rdmacm动态链接库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;libibumad3&lt;/td&gt;
&lt;td&gt;ibumad动态链接库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ibverbs-providers&lt;/td&gt;
&lt;td&gt;ibverbs各厂商用户态驱动（包括RXE）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rdma-core&lt;/td&gt;
&lt;td&gt;文档及用户态配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;安装完上述软件之后，可以执行ibv_devices看看有没有报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/ibv_devices.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;这是个基于verbs接口编写的小程序，用来获取并打印出当前系统中的RDMA设备列表。&lt;/p&gt;
&lt;p&gt;查看安装的版本：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;dpkg -L libibverbs1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-02-11%20125822.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;可以看到安装的版本是28.0&lt;/p&gt;
&lt;h4 id=&#34;523-安装iproute2和perftest&#34;&gt;5.2.3. 安装iproute2和perftest&lt;/h4&gt;
&lt;p&gt;iproute2是用来替代net-tools软件包的，是一组开源的网络工具集合，比如用更强大ip命令替换了以前常用的ifconfig。我们需要其中的rdma工具来对RXE进行配置。一般的操作系统都已经包含了，安装也很简单：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install iproute2
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;perftest是一个基于Verbs接口开发的开源RDMA性能测试工具，可以对支持RDMA技术的节点进行带宽和时延测试。相比于rdma-core自带的示例程序 ，功能更加强大，当然也更复杂。使用如下命令安装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install perftest
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;53-配置rxe网卡&#34;&gt;5.3. 配置RXE网卡&lt;/h3&gt;
&lt;p&gt;首先我们需要加载内核驱动，modprobe会自动加载依赖的其他驱动。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo modprobe rdma_rxe
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后进行用户态配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo rdma link add rxe_0 &lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt; rxe netdev eth0
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中rxe_0是你希望的RDMA的设备名，可任意取名。eth0为Soft-RoCE设备所绑定的网络设备名，也就是ifconfig中看到的网卡名。&lt;/p&gt;
&lt;p&gt;接着我们用rdma工具查看是否添加成功：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;rdma link
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/rdma_link.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;再次运行&lt;code&gt;ibv_devices&lt;/code&gt;程序，可以看到RXE网卡已经出现在设备列表里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/ibv_devices_new.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;也可以运行&lt;code&gt;ibv_devinfo -d rxe_0&lt;/code&gt;命令查看虚拟RDMA设备的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/ibv_devinfo.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;h3 id=&#34;54-执行perftest测试&#34;&gt;5.4. 执行perftest测试&lt;/h3&gt;
&lt;p&gt;分别在两端执行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ib_send_bw -d rxe_0
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以及：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ib_send_bw -d rxe_0 192.168.1.5
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ib_send_bw是用来测试SEND操作的带宽的程序（infiniband_send&lt;em&gt;bandwidth），其中&lt;/em&gt;&amp;lt;server_ip&amp;gt;表示对端的IP&lt;/p&gt;
&lt;p&gt;两端的结果如下，Server端：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/ib_server.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Client端：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cuterwrite-1302252842.file.myqcloud.com/img/ibv_client.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;可以看到两端都打印出了一些测试信息以及最后的测试结果，也就是带宽信息。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
